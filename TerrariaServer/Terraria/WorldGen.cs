using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
using ReLogic.Utilities;
using Terraria.Audio;
using Terraria.Chat;
using Terraria.DataStructures;
using Terraria.Enums;
using Terraria.GameContent;
using Terraria.GameContent.Achievements;
using Terraria.GameContent.Biomes;
using Terraria.GameContent.Biomes.CaveHouse;
using Terraria.GameContent.Creative;
using Terraria.GameContent.Events;
using Terraria.GameContent.Generation;
using Terraria.GameContent.Generation.Dungeon;
using Terraria.GameContent.Prefixes;
using Terraria.GameContent.Tile_Entities;
using Terraria.GameContent.UI.States;
using Terraria.Graphics.Capture;
using Terraria.ID;
using Terraria.IO;
using Terraria.Localization;
using Terraria.Map;
using Terraria.ObjectData;
using Terraria.Testing;
using Terraria.UI;
using Terraria.Utilities;
using Terraria.WorldBuilding;

namespace Terraria;

public class WorldGen
{
	public class SecretSeed
	{
		public static class Variations
		{
			public static bool paintEverythingGrayJustTheSurface
			{
				get
				{
					if (paintEverythingGray.Enabled && !paintEverythingGrayJustTreasure)
					{
						if (!paintEverythingNegative.Enabled && !coatEverythingEcho.Enabled)
						{
							return coatEverythingIlluminant.Enabled;
						}
						return true;
					}
					return false;
				}
			}

			public static bool paintEverythingGrayJustTreasure
			{
				get
				{
					if (paintEverythingGray.Enabled)
					{
						return activeSecretSeedCount >= 4;
					}
					return false;
				}
			}

			public static bool paintEverythingGrayUseWhite
			{
				get
				{
					if (paintEverythingGray.Enabled)
					{
						return worldIsFrozen.Enabled;
					}
					return false;
				}
			}

			public static bool paintEverythingNegativeJustUnderground
			{
				get
				{
					if (paintEverythingNegative.Enabled && !paintEverythingNegativeJustSomeThings)
					{
						if (!paintEverythingGray.Enabled && !coatEverythingEcho.Enabled)
						{
							return coatEverythingIlluminant.Enabled;
						}
						return true;
					}
					return false;
				}
			}

			public static bool paintEverythingNegativeJustSomeThings
			{
				get
				{
					if (paintEverythingNegative.Enabled)
					{
						return activeSecretSeedCount >= 4;
					}
					return false;
				}
			}

			public static bool coatEverythingJustInnerBlocks
			{
				get
				{
					if (coatEverythingEcho.Enabled && !coatEverythingEchoJustSomeThings)
					{
						if (!paintEverythingGray.Enabled && !paintEverythingNegative.Enabled)
						{
							return activeSecretSeedCount >= 3;
						}
						return true;
					}
					return false;
				}
			}

			public static bool coatEverythingEchoJustSomeThings
			{
				get
				{
					if (coatEverythingEcho.Enabled)
					{
						return activeSecretSeedCount >= 4;
					}
					return false;
				}
			}

			public static bool coatEverythingIlluminantJustRandomSpots
			{
				get
				{
					if (!coatEverythingIlluminantJustSomeThings)
					{
						return coatEverythingEcho.Enabled;
					}
					return false;
				}
			}

			public static bool coatEverythingIlluminantJustSomeThings
			{
				get
				{
					if (coatEverythingEcho.Enabled)
					{
						if (activeSecretSeedCount < 3 && !paintEverythingGray.Enabled)
						{
							return paintEverythingNegative.Enabled;
						}
						return true;
					}
					return false;
				}
			}

			public static bool noSurfaceNoFloatingIslands
			{
				get
				{
					if (noSurface.Enabled && !errorWorld.Enabled)
					{
						return !extraFloatingIslands.Enabled;
					}
					return false;
				}
			}

			public static bool noSurfaceNoLivingTrees
			{
				get
				{
					if (noSurface.Enabled && !errorWorld.Enabled)
					{
						return !extraLivingTrees.Enabled;
					}
					return false;
				}
			}

			public static bool noSurfaceNoPyramids
			{
				get
				{
					if (noSurface.Enabled)
					{
						return !errorWorld.Enabled;
					}
					return false;
				}
			}

			public static bool noSurfaceNoSwordShrines
			{
				get
				{
					if (noSurface.Enabled)
					{
						return !errorWorld.Enabled;
					}
					return false;
				}
			}

			public static bool extraLivingTreesReducedAmount
			{
				get
				{
					if (extraLivingTrees.Enabled)
					{
						if (activeSecretSeedCount < 6)
						{
							return noSurface.Enabled;
						}
						return true;
					}
					return false;
				}
			}

			public static bool extraFloatingIslandsNormalAmount
			{
				get
				{
					if (extraFloatingIslands.Enabled)
					{
						return Main.skyblockWorld;
					}
					return false;
				}
			}

			public static bool extraFloatingIslandsReducedAmount
			{
				get
				{
					if (!extraFloatingIslands.Enabled || activeSecretSeedCount < 6)
					{
						return noSurface.Enabled;
					}
					return true;
				}
			}

			public static bool errorWorldBalancedChests
			{
				get
				{
					if (errorWorld.Enabled)
					{
						return activeSecretSeedCount >= 6;
					}
					return false;
				}
			}

			public static bool noSpiderCavesActuallyNoSpiderCaves
			{
				get
				{
					if (noSpiderCaves.Enabled)
					{
						return activeSecretSeedCount < 4;
					}
					return false;
				}
			}

			public static bool noSpiderCavesILiedMoreSpiderCaves
			{
				get
				{
					if (noSpiderCaves.Enabled)
					{
						return activeSecretSeedCount >= 4;
					}
					return false;
				}
			}

			public static bool actuallyNoTrapsForRealIMeanIt
			{
				get
				{
					if (actuallyNoTraps.Enabled)
					{
						return activeSecretSeedCount < 4;
					}
					return false;
				}
			}

			public static bool surfaceIsDesertNormalFunction
			{
				get
				{
					if (surfaceIsDesert.Enabled)
					{
						return !surfaceIsDesertSwapDesertAndSnowBiomes;
					}
					return false;
				}
			}

			public static bool surfaceIsDesertSwapDesertAndSnowBiomes
			{
				get
				{
					if (surfaceIsDesert.Enabled)
					{
						return noSurface.Enabled;
					}
					return false;
				}
			}

			public static int errorWorldAdjustment(double value)
			{
				if (activeSecretSeedCount < 1)
				{
					return 4;
				}
				return (int)(value * (double)((activeSecretSeedCount + 3) / 4));
			}
		}

		public static List<SecretSeed> AllSecretSeeds = new List<SecretSeed>();

		public static SecretSeed paintEverythingGray = Register(SoundID.MenuAccept, "2htOIVagY/7JFx7acMpyUR6D3qJDr/u+");

		public static SecretSeed paintEverythingNegative = Register(SoundID.MenuAccept, "YJayFFSdWEl66+rlFoWJRNvBHJi8gHnx");

		public static SecretSeed coatEverythingEcho = Register(SoundID.MenuAccept, "5Czr2vSNyB9hJd1yob+TYo0qqH/5U2P9");

		public static SecretSeed coatEverythingIlluminant = Register(SoundID.MenuAccept, "5YXhKErRZovhjJkrP9fptrVHbNc1oSSn");

		public static SecretSeed noSurface = Register(SoundID.MenuAccept, "cptECrPRxYeNTULJULs4gVoKdRsf3c3n");

		public static SecretSeed extraLivingTrees = Register(SoundID.MenuAccept, "QQN1FbxlHeUCXPZc51GYvn8G5GXOJcny");

		public static SecretSeed extraFloatingIslands = Register(SoundID.MenuAccept, "0ebq4RCzI3PVaUPOT0f6/+vkXEaoLz2U");

		public static SecretSeed errorWorld = Register(SoundID.MenuAccept, "GkviuS3QN0pyESRJdjIs6oC8s8hOhUXw");

		public static SecretSeed graveyardBloodmoonStart = Register(SoundID.MenuAccept, "N8G20sWOkIa7ZP0rS/jopLpe9180N6Tx");

		public static SecretSeed surfaceIsInSpace = Register(SoundID.MenuAccept, "io2s6kMi4L7ZCDYZGP1Hc8nEWuYW4gp5");

		public static SecretSeed rainsForAYear = Register(SoundID.MenuAccept, "xYBNU5Soje9VhQHNQXETDKbwlc+7XZau");

		public static SecretSeed biggerAbandonedHouses = Register(SoundID.MenuAccept, "vWb/t7nNF+tnjgr5VgY2hi0HcT1j3kvC");

		public static SecretSeed randomSpawn = Register(SoundID.MenuAccept, "zSwnCH9E121+S6VQdB0k20E7IPdtobls");

		public static SecretSeed addTeleporters = Register(SoundID.MenuAccept, "+URq9gxzcyHxAXVqdwl1fz8wgPYYu0Wx");

		public static SecretSeed startInHardmode = Register(SoundID.MenuAccept, "6kX2PJe0FWt3i0fp0tVBh5jt84ozLXBo");

		public static SecretSeed noInfection = Register(SoundID.MenuAccept, "m1gQVuUnIRW083pnfFdnN3DPsg1qFYHZ");

		public static SecretSeed hallowOnTheSurface = Register(SoundID.MenuAccept, "KYvKIk2LK0oyNY86m+uPhKQ7QbzFmDsR");

		public static SecretSeed worldIsInfected = Register(SoundID.MenuAccept, "kbxnychxHNDcoyFHhxM9OJHRxis6mFF/");

		public static SecretSeed surfaceIsMushrooms = Register(SoundID.MenuAccept, "e48+tRi5DqzRkBPk3yq9udBG/kaYOQaB");

		public static SecretSeed surfaceIsDesert = Register(SoundID.MenuAccept, "eyGmBQhQ9QnE7UsIib1QmnNRVBNmQtMi");

		public static SecretSeed pooEverywhere = Register(SoundID.MenuAccept, "Iubz1XcBvsfPjSZucIJ3hCDFFEpjG57w");

		public static SecretSeed noSpiderCaves = Register(SoundID.MenuAccept, "SPlOdka0fv8wUovao6u3VB7ZS+IbcPDu");

		public static SecretSeed actuallyNoTraps = Register(SoundID.MenuAccept, "AoEz0g1XX0V/nJwcaN2RWwUf/6ghr9pT");

		public static SecretSeed rainbowStuff = Register(SoundID.MenuAccept, "6lK0Tn4t2UlklesGiJ94617yKvk01ICB");

		public static SecretSeed digExtraHoles = Register(SoundID.MenuAccept, "MucLvCERZix3rfcwUH68HDtuFYukiTv9");

		public static SecretSeed roundLandmasses = Register(SoundID.MenuAccept, "VSN8nV180t6PgabWDl4Uf55I1vu97JRD");

		public static SecretSeed extraLiquid = Register(SoundID.MenuAccept, "ZYO3rUjSeCaaBrCE8Bv0FBtkjigLMz90");

		public static SecretSeed portalGunInChests = Register(SoundID.MenuAccept, "ALdQZ+bxQA4VdfjVfdhO/sm9q3sZD9dJ");

		public static SecretSeed worldIsFrozen = Register(SoundID.MenuAccept, "eH2IYQwQyOud0hyoTPaeVsqYlAP7MvbS");

		public static SecretSeed halloweenGen = Register(SoundID.MenuAccept, "Z4Odmvd5lScy/KGXHUO2nvqA9l3KRvm8");

		public static SecretSeed endlessHalloween = Register(SoundID.MenuAccept, "KNSxbK83ZXH41aUhWLti9OFMxoMrCV1s");

		public static SecretSeed endlessChristmas = Register(SoundID.MenuAccept, "gkN386qfe3u1qqQDpGsUu3DsRkEBpD1R");

		public static SecretSeed vampirism = Register(SoundID.MenuAccept, "4eijvDtfcSl66CDifYSVP3WBZm9OLBoW");

		public static SecretSeed teamBasedSpawns = Register(SoundID.MenuAccept, "HnTdmrZ5OT1ldA3r0w3dCgrdLnJBtBSD");

		public static SecretSeed dualDungeons = Register(SoundID.MenuAccept, "ypBuvKpqKay//OvhG2COriSpGT7f4YY3");

		private readonly string _code;

		private readonly LegacySoundStyle _sound;

		private string _plaintext;

		private static int activeSecretSeedCount = 0;

		private bool _enabled;

		public static bool anySecretSeedIsActive => activeSecretSeedCount > 0;

		public bool Enabled => _enabled;

		public static bool GenerateBiggerAbandonedHouses
		{
			get
			{
				if (!biggerAbandonedHouses.Enabled)
				{
					if (errorWorld.Enabled)
					{
						return genRand.Next(3) == 0;
					}
					return false;
				}
				return true;
			}
		}

		public static bool GenerateRainbowGlowsticks
		{
			get
			{
				if (!rainbowStuff.Enabled)
				{
					return Main.tenthAnniversaryWorld;
				}
				return true;
			}
		}

		private SecretSeed(LegacySoundStyle sound, string code)
		{
			_sound = sound;
			_code = code;
		}

		public static SecretSeed Register(LegacySoundStyle sound, string code)
		{
			SecretSeed secretSeed = new SecretSeed(sound, code);
			AllSecretSeeds.Add(secretSeed);
			return secretSeed;
		}

		public static void ClearAllSeeds()
		{
			foreach (SecretSeed allSecretSeed in AllSecretSeeds)
			{
				Disable(allSecretSeed);
			}
		}

		public static bool CheckInputForSecretSeed(string worldSeed, out SecretSeed secretSeed)
		{
			secretSeed = null;
			if (string.IsNullOrWhiteSpace(worldSeed))
			{
				return false;
			}
			worldSeed = Regex.Replace(worldSeed.ToLower(), "[^a-z0-9]+", "");
			if (string.IsNullOrWhiteSpace(worldSeed))
			{
				return false;
			}
			secretSeed = AllSecretSeeds.FirstOrDefault((SecretSeed s) => s._plaintext == worldSeed);
			if (secretSeed == null)
			{
				string code = Secrets.ToSecret(worldSeed);
				secretSeed = AllSecretSeeds.FirstOrDefault((SecretSeed s) => s._code == code);
			}
			if (secretSeed == null)
			{
				return false;
			}
			secretSeed._plaintext = worldSeed;
			return true;
		}

		public static void Enable(SecretSeed seed, bool playSound = true)
		{
			if (!seed.Enabled)
			{
				activeSecretSeedCount++;
				seed._enabled = true;
				if (playSound)
				{
					SoundEngine.PlaySound(seed._sound);
				}
			}
		}

		public static void Disable(SecretSeed seed)
		{
			if (seed.Enabled)
			{
				activeSecretSeedCount--;
				seed._enabled = false;
			}
		}

		public static void InitializeSecretSeeds()
		{
			if (vampirism.Enabled)
			{
				Main.vampireSeed = true;
			}
			if (worldIsInfected.Enabled)
			{
				Main.infectedSeed = true;
			}
			if (teamBasedSpawns.Enabled)
			{
				Main.teamBasedSpawnsSeed = true;
			}
			if (dualDungeons.Enabled)
			{
				Main.dualDungeonsSeed = true;
			}
			if (endlessHalloween.Enabled)
			{
				Main.forceHalloweenForever = true;
			}
			if (endlessChristmas.Enabled)
			{
				Main.forceXMasForever = true;
			}
			if (!skyblockWorldGen && endlessChristmas.Enabled)
			{
				Main.forceXMasForToday = true;
			}
		}

		public static void FinalizeSecretSeeds()
		{
			if (surfaceIsDesert.Enabled)
			{
				DoSurfaceIsDesertFinish();
			}
			if (extraLiquid.Enabled)
			{
				DoExtraLiquidFinish();
			}
			if (surfaceIsInSpace.Enabled)
			{
				DoSurfaceIsInSpace();
			}
			if (actuallyNoTraps.Enabled)
			{
				DoActuallyNoTraps();
			}
			if (surfaceIsMushrooms.Enabled)
			{
				if (!noSurface.Enabled)
				{
					DoSurfaceIsMushrooms();
				}
				DoSurfaceIsMushrooms();
			}
			if (worldIsFrozen.Enabled)
			{
				DoWorldIsFrozen();
			}
			if (noInfection.Enabled)
			{
				DoNoInfection();
			}
			if (hallowOnTheSurface.Enabled)
			{
				DoHallowOnSurface();
			}
			if (worldIsInfected.Enabled)
			{
				DoWorldIsInfected();
			}
			if (startInHardmode.Enabled)
			{
				DoStartInHardmode();
			}
			if (noSurface.Enabled)
			{
				DoNoSurface();
			}
			if (coatEverythingEcho.Enabled)
			{
				DoCoatEverythingEcho();
			}
			if (coatEverythingIlluminant.Enabled)
			{
				DoCoatEverythingIlluminant();
			}
			if (paintEverythingGray.Enabled)
			{
				DoPaintEverythingGray();
			}
			if (paintEverythingNegative.Enabled)
			{
				DoPaintEverythingNegative();
			}
			if (randomSpawn.Enabled)
			{
				DoRandomSpawn();
			}
			if (rainbowStuff.Enabled)
			{
				DoRainbowStuff();
			}
			if (portalGunInChests.Enabled)
			{
				DoPortalGunInChests();
			}
			if (worldIsFrozen.Enabled)
			{
				DoWorldIsFrozenFinish();
			}
			if (errorWorld.Enabled)
			{
				DoErrorWorldFinish();
			}
			if (teamBasedSpawns.Enabled)
			{
				ExtraSpawnPointManager.settings = new ExtraSpawnSettings
				{
					spawnType = ExtraSpawnType.TeamBased,
					surface = (!GenVars.worldSpawnHasBeenRandomized && Main.isThereAWorldSurface),
					remix = Main.remixWorld,
					roundLandmass = roundLandmasses.Enabled,
					skyblock = Main.skyblockWorld,
					extraLiquid = extraLiquid.Enabled
				};
				ExtraSpawnPointManager.GenerateExtraSpawns();
			}
			if (Variations.noSpiderCavesActuallyNoSpiderCaves)
			{
				NPC.savedStylist = true;
			}
		}

		public static void DoPaintEverythingGray()
		{
			byte b = 27;
			double num = Main.maxTilesY;
			if (Variations.paintEverythingGrayUseWhite)
			{
				b = 26;
			}
			bool paintEverythingGrayJustTheSurface = Variations.paintEverythingGrayJustTheSurface;
			bool paintEverythingGrayJustTreasure = Variations.paintEverythingGrayJustTreasure;
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				if (paintEverythingGrayJustTheSurface)
				{
					num = Main.worldSurface + (double)genRand.Next(3);
				}
				for (int j = 0; (double)j < num; j++)
				{
					if (paintEverythingGrayJustTreasure)
					{
						if (TileID.Sets.Ore[Main.tile[i, j].type] || TileID.Sets.Gems[Main.tile[i, j].type] || Main.tile[i, j].type == 178)
						{
							Main.tile[i, j].color(b);
						}
					}
					else
					{
						Main.tile[i, j].color(b);
						Main.tile[i, j].wallColor(b);
					}
				}
			}
		}

		public static void DoPaintEverythingNegative()
		{
			bool paintEverythingNegativeJustUnderground = Variations.paintEverythingNegativeJustUnderground;
			bool paintEverythingNegativeJustSomeThings = Variations.paintEverythingNegativeJustSomeThings;
			int num = 0;
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				if (paintEverythingNegativeJustUnderground)
				{
					num = (int)Main.worldSurface - genRand.Next(3);
				}
				for (int j = num; j < Main.maxTilesY - 30; j++)
				{
					if (paintEverythingNegativeJustSomeThings)
					{
						if (Main.tileDungeon[Main.tile[i, j].type])
						{
							Main.tile[i, j].color(30);
						}
						if (TileID.Sets.CrackedBricks[Main.tile[i, j].type])
						{
							Main.tile[i, j].color(30);
						}
						if (Main.wallDungeon[Main.tile[i, j].wall])
						{
							Main.tile[i, j].wallColor(30);
							if (Main.tile[i, j].type == 19)
							{
								Main.tile[i, j].color(30);
							}
						}
						if (TileID.Sets.Clouds[Main.tile[i, j].type])
						{
							Main.tile[i, j].color(30);
						}
						if (Main.tile[i, j].wall == 73)
						{
							Main.tile[i, j].wallColor(30);
						}
						if (Main.tile[i, j].type == 192 || Main.tile[i, j].type == 384)
						{
							Main.tile[i, j].color(30);
							if (Main.tile[i, j + 1].type == 52 || Main.tile[i, j + 1].type == 382 || Main.tile[i, j + 1].type == 62)
							{
								for (int k = j + 1; k < Main.maxTilesY && Main.tile[i, k].active() && (Main.tile[i, k].type == 52 || Main.tile[i, k].type == 382 || Main.tile[i, k].type == 62); k++)
								{
									Main.tile[i, k].color(30);
								}
							}
							if (Main.tile[i, j - 1].type == 186 || Main.tile[i, j - 1].type == 187)
							{
								Main.tile[i, j - 1].color(30);
								if (Main.tile[i, j - 2].type == 186 || Main.tile[i, j - 2].type == 187)
								{
									Main.tile[i, j - 2].color(30);
								}
							}
						}
						if (Main.tile[i, j].wall == 60)
						{
							Main.tile[i, j].wallColor(30);
						}
					}
					else
					{
						Main.tile[i, j].color(30);
						Main.tile[i, j].wallColor(30);
					}
				}
			}
		}

		public static void DoCoatEverythingEcho()
		{
			bool coatEverythingEchoJustSomeThings = Variations.coatEverythingEchoJustSomeThings;
			bool coatEverythingJustInnerBlocks = Variations.coatEverythingJustInnerBlocks;
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				for (int j = 0; j < Main.maxTilesY; j++)
				{
					if (coatEverythingEchoJustSomeThings)
					{
						if (Main.tile[i, j].type == 48 || Main.tile[i, j].type == 232 || Main.tile[i, j].type == 137 || (TileID.Sets.Boulders[Main.tile[i, j].type] && Main.tile[i, j].type != 665 && Main.tile[i, j].type != 711) || Main.tile[i, j].type == 141 || Main.tile[i, j].type == 135 || Main.tile[i, j].type == 443)
						{
							Main.tile[i, j].invisibleBlock(invisibleBlock: true);
						}
					}
					else if (coatEverythingJustInnerBlocks)
					{
						bool flag = true;
						for (int k = i - 1; k <= i + 1; k++)
						{
							for (int l = j - 1; l <= j + 1; l++)
							{
								if (!SolidTile3(k, l))
								{
									flag = false;
								}
							}
						}
						if (flag)
						{
							Main.tile[i, j].invisibleBlock(invisibleBlock: true);
							Main.tile[i, j].invisibleWall(invisibleWall: true);
						}
						if (!errorWorld.Enabled)
						{
							Main.tile[i, j].invisibleWall(invisibleWall: true);
						}
					}
					else
					{
						Main.tile[i, j].invisibleBlock(invisibleBlock: true);
						Main.tile[i, j].invisibleWall(invisibleWall: true);
					}
				}
			}
			if (coatEverythingJustInnerBlocks && errorWorld.Enabled)
			{
				for (int m = 0; m < Main.maxTilesX; m++)
				{
					for (int n = 0; n < Main.maxTilesY; n++)
					{
						if (Main.tile[m, n].invisibleBlock())
						{
							Main.tile[m, n].active(active: false);
						}
						if (Main.tile[m, n].invisibleWall())
						{
							Main.tile[m, n].wall = 0;
						}
						if (SolidTile3(m, n))
						{
							Main.tile[m, n].wall = 0;
						}
					}
				}
			}
			for (int num = 0; num < 8000; num++)
			{
				Chest chest = Main.chest[num];
				if (chest == null)
				{
					break;
				}
				if (genRand.Next(25) != 0 || chest.item[1].stack == 0)
				{
					continue;
				}
				for (int num2 = 1; num2 < chest.maxItems; num2++)
				{
					if (chest.item[num2].stack == 0)
					{
						chest.item[num2].SetDefaults(4409);
						break;
					}
				}
			}
		}

		public static void DoCoatEverythingIlluminant()
		{
			bool coatEverythingIlluminantJustSomeThings = Variations.coatEverythingIlluminantJustSomeThings;
			bool coatEverythingIlluminantJustRandomSpots = Variations.coatEverythingIlluminantJustRandomSpots;
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				for (int j = 0; j < Main.maxTilesY; j++)
				{
					if (coatEverythingIlluminantJustSomeThings)
					{
						if (Main.tile[i, j].type == 12 || Main.tile[i, j].type == 665 || Main.tile[i, j].type == 639)
						{
							Main.tile[i, j].fullbrightBlock(fullbrightBlock: true);
						}
					}
					else if (coatEverythingIlluminantJustRandomSpots)
					{
						if (genRand.Next(2) == 0)
						{
							Main.tile[i, j].fullbrightBlock(fullbrightBlock: true);
							Main.tile[i, j].fullbrightWall(fullbrightWall: true);
							Main.tile[i, j].invisibleBlock(invisibleBlock: false);
							Main.tile[i, j].invisibleWall(invisibleWall: false);
						}
					}
					else
					{
						Main.tile[i, j].fullbrightBlock(fullbrightBlock: true);
						Main.tile[i, j].fullbrightWall(fullbrightWall: true);
					}
				}
			}
		}

		public static void DoNoSurface()
		{
			if (!skyblockWorldGen)
			{
				double num = (double)Main.maxTilesX / 4200.0;
				int num2 = (int)(4.0 * num);
				for (int i = 0; i < num2; i++)
				{
					dropMeteor(spawnUnderGround: true);
				}
				if (!remixWorldGen && !GenVars.worldSpawnHasBeenRandomized)
				{
					RandomizeWorldSpawn();
					PlaceTorchesAroundSpawn();
				}
			}
		}

		public static void DoNoSurfaceFillTheTop()
		{
			if (skyblockWorldGen)
			{
				return;
			}
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				for (int j = 0; j < 100 + genRand.Next(2); j++)
				{
					if (!Main.wallDungeon[Main.tile[i, j].wall])
					{
						if (!Main.tileDungeon[Main.tile[i, j].type])
						{
							Main.tile[i, j].active(active: true);
						}
						if (Main.tile[i, j].type == 60)
						{
							Main.tile[i, j].type = 59;
						}
						if (Main.tile[i, j].type == 70)
						{
							Main.tile[i, j].type = 59;
						}
					}
				}
			}
		}

		public static ushort DoErrorWorldGetRandomBlock()
		{
			int num = genRand.Next(TileID.Count);
			while (!Main.tileSolid[num] || Main.tileSolidTop[num] || Main.tileFrameImportant[num] || Main.tileDungeon[num] || num == 58 || num == 226 || num == 404)
			{
				num = genRand.Next(TileID.Count);
			}
			return (ushort)num;
		}

		public static void DoErrorWorldShuffleBlocks()
		{
			int num = 30;
			int num2 = 50;
			int num3 = Main.maxTilesX * 10 / Variations.errorWorldAdjustment(1.0);
			if (skyblockWorldGen)
			{
				num3 /= 2;
			}
			for (int i = 0; i < num3; i++)
			{
				int num4 = genRand.Next(num, Main.maxTilesX - num);
				int num5 = genRand.Next(num + num2, Main.maxTilesY - num);
				while (!Main.tileSolid[Main.tile[num4, num5].type] || Main.tileSolidTop[Main.tile[num4, num5].type] || Main.tileFrameImportant[Main.tile[num4, num5].type])
				{
					num4 = genRand.Next(num, Main.maxTilesX - num);
					num5 = genRand.Next(num + num2, Main.maxTilesY - num);
				}
				Main.tile[num4, num5].type = DoErrorWorldGetRandomBlock();
				if (skyblockWorldGen)
				{
					Main.tile[num4, num5].active(active: true);
				}
			}
			num3 = Main.maxTilesX / 2 / Variations.errorWorldAdjustment(1.0);
			for (int j = 0; j < num3; j++)
			{
				int num6 = genRand.Next(num, Main.maxTilesX - num);
				int num7 = genRand.Next(num + num2, Main.maxTilesY - num);
				while (Main.tile[num6, num7].anyShimmer() || !Main.tileSolid[Main.tile[num6, num7].type] || Main.tileSolidTop[Main.tile[num6, num7].type] || Main.tileFrameImportant[Main.tile[num6, num7].type] || Main.tileFrameImportant[Main.tile[num6, num7 - 1].type] || Main.tileFrameImportant[Main.tile[num6, num7 + 1].type])
				{
					num6 = genRand.Next(num, Main.maxTilesX - num);
					num7 = genRand.Next(num + num2, Main.maxTilesY - num);
				}
				int num8 = genRand.Next(num, Main.maxTilesX - num);
				int num9 = genRand.Next(num + num2, Main.maxTilesY - num);
				while (Main.tile[num8, num9].anyShimmer() || !Main.tileSolid[Main.tile[num8, num9].type] || Main.tileSolidTop[Main.tile[num8, num9].type] || Main.tileFrameImportant[Main.tile[num8, num9].type] || Main.tileFrameImportant[Main.tile[num8, num9 - 1].type] || Main.tileFrameImportant[Main.tile[num8, num9 + 1].type])
				{
					num8 = genRand.Next(num, Main.maxTilesX - num);
					num9 = genRand.Next(num + num2, Main.maxTilesY - num);
				}
				if (remixWorldGen)
				{
					if ((num6 > Main.maxTilesX / 2 - 30 && num6 < Main.maxTilesX / 2 + 30 && num7 > Main.UnderworldLayer) || (num8 > Main.maxTilesX / 2 - 30 && num8 < Main.maxTilesX / 2 + 30 && num9 > Main.UnderworldLayer))
					{
						continue;
					}
				}
				else if ((num6 > Main.maxTilesX / 2 - 30 && num6 < Main.maxTilesX / 2 + 30 && (double)num7 < Main.worldSurface) || (num8 > Main.maxTilesX / 2 - 30 && num8 < Main.maxTilesX / 2 + 30 && (double)num9 < Main.worldSurface))
				{
					continue;
				}
				Tile tile = new Tile(Main.tile[num6, num7]);
				Tile tile2 = new Tile(Main.tile[num8, num9]);
				Main.tile[num6, num7].active(tile2.active());
				Main.tile[num6, num7].type = tile2.type;
				Main.tile[num6, num7].color(tile2.color());
				Main.tile[num6, num7].fullbrightBlock(tile2.fullbrightBlock());
				Main.tile[num6, num7].invisibleBlock(tile2.invisibleBlock());
				Main.tile[num8, num9].active(tile.active());
				Main.tile[num8, num9].type = tile.type;
				Main.tile[num8, num9].color(tile.color());
				Main.tile[num8, num9].fullbrightBlock(tile.fullbrightBlock());
				Main.tile[num8, num9].invisibleBlock(tile.invisibleBlock());
			}
			num3 = Main.maxTilesX / 2 / Variations.errorWorldAdjustment(1.0);
			for (int k = 0; k < num3; k++)
			{
				int num10 = 1;
				int num11 = 1;
				if (genRand.Next(2) == 0)
				{
					num10 = genRand.Next(5, 21);
					num11 = genRand.Next(1, 4);
				}
				else
				{
					num10 = genRand.Next(1, 4);
					num11 = genRand.Next(5, 21);
				}
				int num12 = genRand.Next(num, Main.maxTilesX - num);
				int num13 = genRand.Next(num + num2, Main.maxTilesY - num);
				bool flag = false;
				for (int l = num12; l < num12 + num10; l++)
				{
					for (int m = num13; m < num13 + num11; m++)
					{
						if (Main.tile[l, m].anyShimmer() || !Main.tileSolid[Main.tile[l, m].type] || Main.tileSolidTop[Main.tile[l, m].type] || Main.tileFrameImportant[Main.tile[l, m].type] || Main.tileFrameImportant[Main.tile[l, m - 1].type] || Main.tileFrameImportant[Main.tile[l, m + 1].type])
						{
							flag = true;
							break;
						}
					}
					if (flag)
					{
						break;
					}
				}
				if (flag)
				{
					continue;
				}
				int num14 = genRand.Next(num, Main.maxTilesX - num);
				int num15 = genRand.Next(num + num2, Main.maxTilesY - num);
				flag = false;
				for (int n = num14; n < num14 + num10; n++)
				{
					for (int num16 = num15; num16 < num15 + num11; num16++)
					{
						if (Main.tile[n, num16].anyShimmer() || !Main.tileSolid[Main.tile[n, num16].type] || Main.tileSolidTop[Main.tile[n, num16].type] || Main.tileFrameImportant[Main.tile[n, num16].type] || Main.tileFrameImportant[Main.tile[n, num16 - 1].type] || Main.tileFrameImportant[Main.tile[n, num16 + 1].type])
						{
							flag = true;
							break;
						}
					}
					if (flag)
					{
						break;
					}
				}
				if (flag)
				{
					continue;
				}
				if (remixWorldGen)
				{
					if ((num12 + num10 / 2 > Main.maxTilesX / 2 - 50 && num12 < Main.maxTilesX / 2 + 50 && num13 > Main.UnderworldLayer) || (num14 + num10 / 2 > Main.maxTilesX / 2 - 50 && num14 < Main.maxTilesX / 2 + 50 && num15 > Main.UnderworldLayer))
					{
						continue;
					}
				}
				else if ((num12 + num10 / 2 > Main.maxTilesX / 2 - 50 && num12 < Main.maxTilesX / 2 + 50 && (double)num13 < Main.worldSurface) || (num14 + num10 / 2 > Main.maxTilesX / 2 - 50 && num14 < Main.maxTilesX / 2 + 50 && (double)num15 < Main.worldSurface))
				{
					continue;
				}
				for (int num17 = 0; num17 < num10; num17++)
				{
					for (int num18 = 0; num18 < num11; num18++)
					{
						Tile tile3 = new Tile(Main.tile[num12 + num17, num13 + num18]);
						Tile tile4 = new Tile(Main.tile[num14 + num17, num15 + num18]);
						Main.tile[num12 + num17, num13 + num18].active(tile4.active());
						Main.tile[num12 + num17, num13 + num18].type = tile4.type;
						Main.tile[num12 + num17, num13 + num18].color(tile4.color());
						Main.tile[num12 + num17, num13 + num18].fullbrightBlock(tile4.fullbrightBlock());
						Main.tile[num12 + num17, num13 + num18].invisibleBlock(tile4.invisibleBlock());
						Main.tile[num14 + num17, num15 + num18].active(tile3.active());
						Main.tile[num14 + num17, num15 + num18].type = tile3.type;
						Main.tile[num14 + num17, num15 + num18].color(tile3.color());
						Main.tile[num14 + num17, num15 + num18].fullbrightBlock(tile3.fullbrightBlock());
						Main.tile[num14 + num17, num15 + num18].invisibleBlock(tile3.invisibleBlock());
					}
				}
			}
			num3 = Main.maxTilesX * 10 / Variations.errorWorldAdjustment(1.0);
			for (int num19 = 0; num19 < num3; num19++)
			{
				int num20 = genRand.Next(num, Main.maxTilesX - num);
				int num21 = genRand.Next(num + num2, Main.maxTilesY - num);
				while (!Main.tileSolid[Main.tile[num20, num21].type] || Main.tileSolidTop[Main.tile[num20, num21].type] || Main.tileFrameImportant[Main.tile[num20, num21].type] || Main.tileDungeon[Main.tile[num20, num21].type])
				{
					num20 = genRand.Next(num, Main.maxTilesX - num);
					num21 = genRand.Next(num + num2, Main.maxTilesY - num);
				}
				Vector2D vector2D = default(Vector2D);
				if (genRand.Next(2) == 0)
				{
					if (genRand.Next(2) == 0)
					{
						vector2D.X = -1.0;
					}
					else
					{
						vector2D.X = 1.0;
					}
				}
				else if (genRand.Next(2) == 0)
				{
					vector2D.Y = -1.0;
				}
				else
				{
					vector2D.Y = 1.0;
				}
				int num22 = genRand.Next(5, 21);
				int num23 = num20;
				int num24 = num21;
				Tile tile5 = new Tile(Main.tile[num20, num21]);
				for (int num25 = 0; num25 < num22; num25++)
				{
					num23 += (int)vector2D.X;
					num24 += (int)vector2D.Y;
					if (Main.tile[num23, num24].active())
					{
						break;
					}
					Main.tile[num20, num21].slope(0);
					Main.tile[num20, num21].halfBrick(halfBrick: false);
					Main.tile[num23, num24].active(tile5.active());
					Main.tile[num23, num24].type = tile5.type;
					Main.tile[num23, num24].color(tile5.color());
					Main.tile[num23, num24].fullbrightBlock(tile5.fullbrightBlock());
					Main.tile[num23, num24].invisibleBlock(tile5.invisibleBlock());
				}
			}
		}

		public static void DoErrorWorldFinish()
		{
			int num = Main.maxTilesX * 2;
			for (int i = 0; i < num; i++)
			{
				int num2 = genRand.Next(8000);
				int num3 = 100000;
				while (Main.chest[num2] == null || Main.chest[num2].item[0].type == 0)
				{
					num2 = genRand.Next(8000);
					if (num3-- <= 0)
					{
						return;
					}
				}
				int num4 = genRand.Next(Main.chest[num2].item.Length);
				num3 = 100000;
				while (ItemID.Sets.ErrorWorldChestSwapImmunity[Main.chest[num2].item[num4].type])
				{
					num4 = genRand.Next(Main.chest[num2].item.Length);
					if (num3-- <= 0)
					{
						return;
					}
				}
				int num5 = genRand.Next(8000);
				while (Main.chest[num5] == null || Main.chest[num5].item[0].type == 0)
				{
					num5 = genRand.Next(8000);
				}
				int num6 = genRand.Next(Main.chest[num5].item.Length);
				while (ItemID.Sets.ErrorWorldChestSwapImmunity[Main.chest[num5].item[num6].type])
				{
					num6 = genRand.Next(Main.chest[num5].item.Length);
				}
				if (!Variations.errorWorldBalancedChests || Main.chest[num2].item[num4].rare == Main.chest[num5].item[num6].rare)
				{
					Item item = Main.chest[num2].item[num4].Clone();
					Item item2 = Main.chest[num5].item[num6].Clone();
					Main.chest[num2].item[num4] = item2;
					Main.chest[num5].item[num6] = item;
				}
			}
			int num7 = 20;
			for (int j = num7; j < Main.maxTilesX - num7; j++)
			{
				for (int k = num7; k < Main.maxTilesY - num7; k++)
				{
					if (TileID.Sets.CrackedBricks[Main.tile[j, k].type])
					{
						Main.tile[j, k].invisibleBlock(invisibleBlock: true);
					}
					if (TileID.Sets.Conversion.Moss[Main.tile[j, k].type] && Main.tile[j, k].type != 381 && genRand.Next(Variations.errorWorldAdjustment(5.0)) == 0)
					{
						Main.tile[j, k].type = genRand.NextFromList(new ushort[5] { 539, 536, 534, 625, 627 });
					}
					if ((double)k > Main.worldSurface && Main.tile[j, k].wall == 73)
					{
						Main.tile[j, k].wall = 0;
					}
					if (Main.tile[j, k].type == 501)
					{
						if (!CanKillTile(j, k))
						{
							Main.tile[j, k].invisibleBlock(invisibleBlock: true);
						}
						else
						{
							Main.tile[j, k].active(active: false);
						}
					}
					if (Main.tile[j, k].wall == 238)
					{
						Main.tile[j, k].wall = 0;
					}
					if (Main.tile[j, k].type == 137 && !Main.tile[j, k].wire())
					{
						Main.tile[j, k].frameX = (short)(genRand.Next(6) * 18);
					}
					if (Main.tile[j, k].type == 28 && genRand.Next(5) == 0)
					{
						Main.tile[j, k].active(active: false);
					}
					if (genRand.Next(Variations.errorWorldAdjustment(7.0)) == 0 && (Main.tile[j, k].type == 48 || Main.tile[j, k].type == 232 || Main.tile[j, k].type == 21 || Main.tile[j, k].type == 467 || Main.tile[j, k].type == 28 || Main.tile[j, k].type == 639 || Main.tile[j, k].type == 12 || Main.tile[j, k].type == 484))
					{
						Main.tile[j, k].invisibleBlock(invisibleBlock: true);
					}
					if (genRand.Next(Variations.errorWorldAdjustment(15.0)) == 0 && SolidTile3(j, k) && !Main.tileFrameImportant[Main.tile[j, k].type] && Main.tile[j, k - 1].active() && !SolidTile3(j, k - 1) && Main.tile[j, k - 1].type != 237 && Main.tile[j, k - 1].type != 231 && Main.tile[j, k - 1].type != 355 && Main.tile[j, k - 1].type != 354 && Main.tile[j, k - 1].type != 26 && Main.tile[j, k - 1].type != 77 && Main.tile[j, k - 1].type != 642 && Main.tile[j, k - 1].type != 506 && Main.tile[j, k - 1].type != 377)
					{
						if (CanKillTile(j, k))
						{
							Main.tile[j, k].active(active: false);
						}
						else
						{
							Main.tile[j, k].invisibleBlock(invisibleBlock: true);
						}
					}
					if (genRand.Next(Variations.errorWorldAdjustment(10000.0)) == 0)
					{
						Main.tile[j, k].color(30);
					}
					if (genRand.Next(Variations.errorWorldAdjustment(10000.0)) == 0)
					{
						Main.tile[j, k].wallColor(30);
					}
					if (genRand.Next(Variations.errorWorldAdjustment(50000.0)) == 0)
					{
						Main.tile[j, k].fullbrightBlock(fullbrightBlock: true);
					}
					if (genRand.Next(Variations.errorWorldAdjustment(50000.0)) == 0)
					{
						Main.tile[j, k].fullbrightWall(fullbrightWall: true);
					}
					if (genRand.Next(Variations.errorWorldAdjustment(250000.0)) == 0)
					{
						Main.tile[j, k].invisibleBlock(invisibleBlock: true);
					}
				}
			}
			for (int l = num7; l < Main.maxTilesX - num7; l++)
			{
				for (int m = num7; m < Main.maxTilesY - num7; m++)
				{
					if (!Main.tile[l, m].active() || Main.tile[l, m].type != 137 || Main.tile[l, m].wire())
					{
						continue;
					}
					bool flag = false;
					for (int n = 1; n < 50; n++)
					{
						if (flag)
						{
							break;
						}
						for (int num8 = l - n; num8 <= l + n; num8++)
						{
							if (flag)
							{
								break;
							}
							for (int num9 = m - n; num9 <= m + n; num9++)
							{
								if (flag)
								{
									break;
								}
								if (!InWorld(num8, num9) || !Main.tile[num8, num9].wire())
								{
									continue;
								}
								flag = true;
								int num10 = num8;
								int num11 = num9;
								if (Math.Abs(num10 - l) < Math.Abs(num11 - m))
								{
									while (num10 < l)
									{
										num10++;
										Main.tile[num10, num11].wire(wire: true);
									}
									while (num10 > l)
									{
										num10--;
										Main.tile[num10, num11].wire(wire: true);
									}
									while (num11 < m)
									{
										num11++;
										Main.tile[num10, num11].wire(wire: true);
									}
									while (num11 > m)
									{
										num11--;
										Main.tile[num10, num11].wire(wire: true);
									}
								}
								else
								{
									while (num11 < m)
									{
										num11++;
										Main.tile[num10, num11].wire(wire: true);
									}
									while (num11 > m)
									{
										num11--;
										Main.tile[num10, num11].wire(wire: true);
									}
									while (num10 < l)
									{
										num10++;
										Main.tile[num10, num11].wire(wire: true);
									}
									while (num10 > l)
									{
										num10--;
										Main.tile[num10, num11].wire(wire: true);
									}
								}
							}
						}
					}
				}
			}
			num = Main.maxTilesX / 3 / Variations.errorWorldAdjustment(1.0);
			for (int num12 = 0; num12 < num; num12++)
			{
				int num13 = genRand.Next(50, Main.maxTilesX - 50);
				int num14 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 50);
				if (Main.tile[num13, num14].active() || Main.tile[num13, num14].liquid != 0 || Main.tile[num13 + 1, num14].active() || Main.tile[num13 + 1, num14].liquid != 0 || Main.tile[num13, num14 + 1].active() || Main.tile[num13, num14 + 1].liquid != 0 || Main.tile[num13 + 1, num14 + 1].active() || Main.tile[num13 + 1, num14 + 1].liquid != 0)
				{
					continue;
				}
				int num15 = genRand.Next(4);
				for (int num16 = num13; num16 <= num13 + 1; num16++)
				{
					for (int num17 = num14; num17 <= num14 + 1; num17++)
					{
						Main.tile[num16, num17].active(active: true);
						Main.tile[num16, num17].type = 379;
						Main.tile[num16, num17].liquid = byte.MaxValue;
						Main.tile[num16, num17].liquidType(num15);
						switch (num15)
						{
						case 0:
							Main.tile[num16, num17].color(9);
							break;
						case 1:
							Main.tile[num16, num17].color(1);
							break;
						case 2:
							Main.tile[num16, num17].color(2);
							break;
						case 3:
							Main.tile[num16, num17].color(10);
							break;
						}
					}
				}
			}
			if (worldIsInfected.Enabled || vampirism.Enabled)
			{
				return;
			}
			for (int num18 = 0; num18 < Main.maxNPCs; num18++)
			{
				if (Main.npc[num18].active && Main.npc[num18].townNPC && Main.npc[num18].type != 37)
				{
					int num19 = NPC.NewNPC(new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 37);
					Main.npc[num19].homeTileX = Main.spawnTileX;
					Main.npc[num19].homeTileY = Main.spawnTileY;
					Main.npc[num19].direction = 1;
					Main.npc[num19].homeless = true;
					Main.npc[num19].position = Main.npc[num18].position;
					Main.npc[num18].active = false;
				}
			}
		}

		public static int DoErrorWorldFindChestItem()
		{
			if (Variations.errorWorldBalancedChests)
			{
				return -1;
			}
			return genRand.Next(32) switch
			{
				0 => 4008, 
				1 => 238, 
				2 => 2275, 
				3 => 3352, 
				4 => 3262, 
				5 => 3334, 
				6 => 4818, 
				7 => 1325, 
				8 => 4144, 
				9 => 3350, 
				10 => 4347, 
				11 => 1309, 
				12 => 1863, 
				13 => 485, 
				14 => 748, 
				15 => 1825, 
				16 => 1321, 
				17 => 5451, 
				18 => 3385, 
				19 => 3386, 
				20 => 3387, 
				21 => 3388, 
				22 => 4951, 
				24 => 3043, 
				25 => 2341, 
				26 => 2342, 
				27 => 2800, 
				28 => 3623, 
				29 => 4980, 
				30 => 4273, 
				31 => 4711, 
				_ => 4420, 
			};
		}

		public static void DoExtraLiquidAddLiquid()
		{
			if (skyblockWorldGen)
			{
				return;
			}
			int num = 40;
			for (int i = num; i < Main.maxTilesX - num; i++)
			{
				for (int j = num; j < Main.maxTilesY - num; j++)
				{
					if (Main.tile[i, j].active())
					{
						continue;
					}
					if (Main.tile[i, j].wall == 0 && (double)j < Main.worldSurface)
					{
						if (genRand.Next(3) == 0)
						{
							Main.tile[i, j].liquid = byte.MaxValue;
						}
					}
					else if (j > Main.UnderworldLayer)
					{
						if (!remixWorldGen && genRand.Next(4) == 0)
						{
							Main.tile[i, j].liquid = byte.MaxValue;
						}
					}
					else if (Main.tile[i, j].wall == 216 || Main.tile[i, j].wall == 187)
					{
						if (genRand.Next(3) == 0)
						{
							Main.tile[i, j].liquid = byte.MaxValue;
						}
					}
					else if (genRand.Next(3) != 0)
					{
						if (Main.tile[i, j].liquid == 0 && Main.tile[i, j].wall == 86)
						{
							Main.tile[i, j].honey(honey: true);
						}
						Main.tile[i, j].liquid = byte.MaxValue;
					}
				}
			}
		}

		public static void DoExtraLiquidAddBubbleBlocks()
		{
			if (skyblockWorldGen)
			{
				return;
			}
			bool flag = Main.tileSolid[225];
			Main.tileSolid[225] = true;
			Liquid.QuickWater(-2);
			if (remixWorldGen)
			{
				bool flag2 = true;
				while (flag2)
				{
					int num = (int)((double)Main.maxTilesX * 0.38);
					int num2 = (int)((double)Main.maxTilesX * 0.62);
					int num3 = Main.maxTilesY - 135;
					for (int i = num; i < num2 + 15; i++)
					{
						for (int j = Main.maxTilesY - 200; j < num3 + 10; j++)
						{
							Main.tile[i, j].liquid = 0;
						}
					}
					Liquid.QuickWater(-2);
					flag2 = false;
					int num4 = Main.maxTilesX / 2;
					int num5 = Main.maxTilesY - 10;
					while (SolidTile(num4, num5))
					{
						num5--;
					}
					int num6 = num5 + 1;
					for (int k = num4 - 40; k <= num4 + 40; k++)
					{
						for (int l = num6 - 10; l <= num6 + 10; l++)
						{
							if (Main.tile[k, l].liquid > 0)
							{
								flag2 = true;
								break;
							}
						}
						if (flag2)
						{
							break;
						}
					}
				}
			}
			Main.tileSolid[225] = flag;
			int num7 = Main.maxTilesX * 20;
			int num8 = 10;
			int num9 = 30;
			int minValue = num8;
			int num10 = num9;
			int num11 = 15;
			if (teamBasedSpawns.Enabled)
			{
				minValue = 20;
				num10 = 30;
			}
			for (int m = 0; m < num7; m++)
			{
				bool flag3 = false;
				int num12 = genRand.Next(100, Main.maxTilesX - 100);
				int num13 = genRand.Next(100, Main.maxTilesY - 100);
				int num14 = 0;
				num14 = ((!IsConsideredTheSpawnArea(num12, num13)) ? genRand.Next(num8, num9 + 1) : genRand.Next(minValue, num10 + 1));
				if (Vector2D.Distance(new Vector2D(num12, num13), GenVars.shimmerPosition) < 100.0)
				{
					continue;
				}
				if (m > num7 / 2)
				{
					num14 /= 2;
				}
				if (IsTileNearby(num12, num13, 379, num14 + num11))
				{
					continue;
				}
				float num15 = 0f;
				int num16 = 0;
				for (int n = num12 - num14; n <= num12 + num14; n++)
				{
					for (int num17 = num13 - num14; num17 <= num13 + num14; num17++)
					{
						if (n == num12 - num14 || n == num12 + num14 || num17 == num13 - num14 || num17 == num13 + num14)
						{
							if (SolidTile(n, num17))
							{
								num16++;
							}
							if (Main.tile[n, num17].active() && (!SolidTile(n, num17) || Main.tile[n, num17].type == 10 || Main.tile[n, num17].type == 192 || Main.tile[n, num17].type == 384 || Main.tile[n, num17].type == 189 || Main.tile[n, num17].type == 196 || Main.tile[n, num17].type == 460 || Main.tile[n, num17].type == 48 || Main.tile[n, num17].type == 232 || (Main.tile[n, num17].type >= 0 && TileID.Sets.Boulders[Main.tile[n, num17].type])))
							{
								flag3 = true;
							}
						}
						if (SolidTile(n, num17))
						{
							num15 += 0.334f;
						}
						else if (Main.tile[n, num17].liquid > 0)
						{
							num15 += 1f;
						}
						if (Main.tile[n, num17].wall == 86 || Main.tile[n, num17].wall == 62)
						{
							flag3 = true;
						}
						if (flag3)
						{
							break;
						}
					}
					if (flag3)
					{
						break;
					}
				}
				if (flag3 || num15 < (float)((num14 * 2 + 1) * (num14 * 2 + 1) / 2) || num16 < (num14 * 2 + 1) / 3)
				{
					continue;
				}
				for (int num18 = num12 - num14; num18 <= num12 + num14; num18++)
				{
					for (int num19 = num13 - num14; num19 <= num13 + num14; num19++)
					{
						if (num18 == num12 - num14 || num18 == num12 + num14 || num19 == num13 - num14 || num19 == num13 + num14)
						{
							if (!Main.tile[num18, num19].active())
							{
								PlaceTile(num18, num19, 379);
							}
							Main.tile[num18, num19].slope(0);
							Main.tile[num18, num19].halfBrick(halfBrick: false);
						}
						Main.tile[num18, num19].liquid = 0;
						Main.tile[num18, num19].fullbrightBlock(fullbrightBlock: true);
					}
				}
				LandmassData item = new LandmassData
				{
					DataType = LandmassDataType.ExtraLiquidBubbleSquare,
					Position = new Vector2(num12, num13),
					RadiusOrHalfSize = num14
				};
				GenVars.landmassData.Add(item);
			}
			for (int num20 = num11; num20 < Main.maxTilesX - num11; num20++)
			{
				for (int num21 = num11; num21 < Main.maxTilesY - num11; num21++)
				{
					if (SolidTile(num20, num21))
					{
						Main.tile[num20, num21].liquid = 0;
					}
				}
			}
		}

		public static bool IsConsideredTheSpawnArea(int x, int y)
		{
			if (Main.remixWorld)
			{
				if (y > GenVars.remixSurfaceLayerLow)
				{
					return y < GenVars.remixSurfaceLayerHigh;
				}
				return false;
			}
			if (GenVars.worldSpawnHasBeenRandomized || !Main.isThereAWorldSurface)
			{
				if ((double)y > Main.worldSurface)
				{
					return y < Main.UnderworldLayer;
				}
				return false;
			}
			return (double)y < Main.worldSurface;
		}

		public static void DoExtraLiquidFinish()
		{
			if (skyblockWorldGen)
			{
				return;
			}
			bool flag = Main.tileSolid[225];
			Main.tileSolid[225] = true;
			Liquid.QuickWater(-2);
			Main.tileSolid[225] = flag;
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				for (int j = 0; j < Main.maxTilesY; j++)
				{
					if (Main.tile[i, j].type == 518)
					{
						SquareTileFrame(i, j);
					}
					if (Main.tile[i, j].fullbrightBlock())
					{
						Main.tile[i, j].liquid = 0;
						Main.tile[i, j].fullbrightBlock(fullbrightBlock: false);
						if (Main.tile[i, j].type == 375 || Main.tile[i, j].type == 373 || Main.tile[i, j].type == 374 || Main.tile[i, j].type == 709)
						{
							Main.tile[i, j].active(active: false);
						}
					}
					if (j >= Main.UnderworldLayer)
					{
						if (Main.tile[i, j].liquid > 0)
						{
							Main.tile[i, j].lava(lava: true);
						}
						if (Main.tile[i, j].type == 56 || Main.tile[i, j].type == 230 || Main.tile[i, j].type == 659)
						{
							Main.tile[i, j].active(active: false);
						}
					}
				}
			}
		}

		public static void DoRainsForAYear()
		{
			Main.rainTime = 1892160000;
			Main.raining = true;
			Main.ChangeRain(instant: true);
			Main.numClouds = 200;
		}

		public static void DoRandomSpawn()
		{
			if (!GenVars.worldSpawnHasBeenRandomized)
			{
				RandomizeWorldSpawn();
				PlaceTorchesAroundSpawn();
			}
		}

		public static void DoAddTeleporters()
		{
			double num = Main.maxTilesX / 4200;
			int num2 = 0;
			int num3 = 10;
			int num4 = (int)(40000.0 * num);
			int num5 = 1;
			num3 = (int)((double)num3 * num);
			for (int i = 0; i < num4; i++)
			{
				if (num2 >= num3)
				{
					break;
				}
				bool flag = i > num4 / 2;
				int num6 = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
				int num7 = 0;
				num7 = ((!skyblockWorldGen) ? genRand.Next((int)Main.worldSurface, Main.UnderworldLayer - 100) : ((num2 != 0) ? genRand.Next(50, Main.UnderworldLayer - 100) : 50));
				if (Main.tile[num6, num7].active())
				{
					continue;
				}
				while (!Main.tile[num6, num7].active())
				{
					num7++;
					if (num7 > Main.UnderworldLayer)
					{
						break;
					}
				}
				if (!DoAddTeleporters_CanPutTeleporterHere(num6, num7, flag))
				{
					continue;
				}
				int num8 = 0;
				int num9 = 0;
				int num10 = 500;
				while (num10 > 0)
				{
					num10--;
					num8 = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
					num9 = 0;
					num9 = ((!skyblockWorldGen) ? genRand.Next((int)Main.worldSurface, Main.UnderworldLayer - 100) : ((num2 != 0) ? genRand.Next(50, Main.UnderworldLayer - 100) : 50));
					if (Main.tile[num8, num9].active())
					{
						continue;
					}
					while (!Main.tile[num8, num9].active())
					{
						num9++;
						if (num9 > Main.UnderworldLayer)
						{
							break;
						}
					}
					if (DoAddTeleporters_CanPutTeleporterHere(num8, num9, flag))
					{
						break;
					}
				}
				if (flag)
				{
					DoAddTeleporters_ClearArea(num6, num7);
					DoAddTeleporters_ClearArea(num8, num9);
				}
				PlaceTile(num6, num7, 235);
				if (!Main.tile[num6, num7].active() || Main.tile[num6, num7].type != 235)
				{
					continue;
				}
				PlaceTile(num8, num9, 235);
				if (Main.tile[num8, num9].active() && Main.tile[num8, num9].type == 235)
				{
					num2++;
					PlaceTile(num6, num7 - 1, 135, mute: true, forced: false, -1, 4);
					AddWire(num6, num7 - 1, num5);
					AddWire(num6, num7, num5);
					PlaceTile(num8, num9 - 1, 135, mute: true, forced: false, -1, 4);
					AddWire(num8, num9 - 1, num5);
					AddWire(num8, num9, num5);
					AddWireFromPointToPoint(num6, num7, num8, num9, num5);
					num5++;
					if (num5 > 3)
					{
						num5 = 1;
					}
				}
			}
		}

		public static bool DoAddTeleporters_CanPutTeleporterHere(int x1, int y1, bool moreForcefulPlacement)
		{
			if (!moreForcefulPlacement && (!SolidTile(x1 - 1, y1) || !SolidTile(x1, y1) || !SolidTile(x1 + 1, y1)))
			{
				return false;
			}
			y1--;
			if (Main.wallDungeon[Main.tile[x1, y1].wall] || Main.tile[x1, y1].wall == 112 || Main.tile[x1, y1].wall == 86 || TileID.Sets.Clouds[Main.tile[x1, y1 + 1].type])
			{
				return false;
			}
			if (dualDungeons.Enabled && DungeonUtils.InAnyPotentialDungeonBounds(x1, y1))
			{
				return false;
			}
			for (int i = x1 - 1; i <= x1 + 1; i++)
			{
				for (int j = y1 - 3; j <= y1; j++)
				{
					if (Main.tile[i, y1].active() || Main.tile[i, y1].liquid > 0)
					{
						return false;
					}
				}
			}
			if (Math.Abs(x1 - Main.spawnTileX) + Math.Abs(y1 - Main.spawnTileY) < 20)
			{
				return false;
			}
			if (IsTileNearby(x1, y1, 235, moreForcefulPlacement ? 150 : 300))
			{
				return false;
			}
			return true;
		}

		public static void DoAddTeleporters_ClearArea(int tileX, int tileY)
		{
			Tile tile = Main.tile[tileX - 1, tileY];
			Tile tile2 = Main.tile[tileX, tileY];
			Tile tile3 = Main.tile[tileX + 1, tileY];
			if (tile.active() && CanKillTile(tileX - 1, tileY))
			{
				tile.ClearTile();
				tile.ClearBlockPaintAndCoating();
			}
			if (tile2.active() && CanKillTile(tileX, tileY))
			{
				tile2.ClearTile();
				tile2.ClearBlockPaintAndCoating();
			}
			if (tile3.active() && CanKillTile(tileX + 1, tileY))
			{
				tile3.ClearTile();
				tile3.ClearBlockPaintAndCoating();
			}
			ushort type = Main.tile[tileX, tileY + 1].type;
			Tile tile4 = Main.tile[tileX - 1, tileY + 1];
			Tile tile5 = Main.tile[tileX, tileY + 1];
			Tile tile6 = Main.tile[tileX + 1, tileY + 1];
			if (!tile4.active() || tile4.slope() != 0 || tile4.halfBrick())
			{
				if (!tile4.active())
				{
					tile4.type = type;
					tile4.active(active: true);
				}
				tile4.slope(0);
				tile4.halfBrick(halfBrick: false);
			}
			if (!tile5.active() || tile5.slope() != 0 || tile5.halfBrick())
			{
				if (!tile5.active())
				{
					tile5.type = type;
					tile5.active(active: true);
				}
				tile5.slope(0);
				tile5.halfBrick(halfBrick: false);
			}
			if (!tile6.active() || tile6.slope() != 0 || tile6.halfBrick())
			{
				if (!tile6.active())
				{
					tile6.type = type;
					tile6.active(active: true);
				}
				tile6.slope(0);
				tile6.halfBrick(halfBrick: false);
			}
		}

		public static void DoStartInHardmode()
		{
			Main.hardMode = true;
			initializeHardMode();
		}

		public static void DoNoInfection()
		{
			if (skyblockWorldGen)
			{
				return;
			}
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				for (int j = 0; j < Main.maxTilesY; j++)
				{
					bool flag = Main.tile[i, j].type != 70;
					bool flag2 = Main.tile[i, j].wall != 80;
					if (worldIsInfected.Enabled)
					{
						if (flag)
						{
							if (Main.tile[i, j].type == 203)
							{
								flag = false;
							}
							if (Main.tile[i, j].type == 25)
							{
								flag = false;
							}
						}
						if (flag2)
						{
							if (Main.tile[i, j].wall == 83)
							{
								flag2 = false;
							}
							if (Main.tile[i, j].wall == 3)
							{
								flag2 = false;
							}
						}
					}
					if (flag || flag2)
					{
						Convert(i, j, 0, 0, flag, flag2);
					}
				}
			}
		}

		public static void DoHallowOnSurface()
		{
			if (skyblockWorldGen)
			{
				return;
			}
			int num = (int)Main.worldSurface;
			if (noSurface.Enabled)
			{
				num = ((!worldIsInfected.Enabled || !noInfection.Enabled) ? ((int)Main.rockLayer) : ((int)Main.rockLayer / 2));
			}
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				for (int j = 0; j < num + genRand.Next(3); j++)
				{
					if (Main.tile[i, j].type == 2)
					{
						Convert(i, j, 2, 0, tiles: true, walls: false);
					}
					if (Main.tile[i, j].type == 161)
					{
						Convert(i, j, 2, 0, tiles: true, walls: false);
					}
					if (noSurface.Enabled && Main.tile[i, j].type == 1)
					{
						Convert(i, j, 2, 0, tiles: true, walls: false);
					}
					if (Main.tile[i, j].type == 53)
					{
						Convert(i, j, 2, 0, tiles: true, walls: false);
					}
					if (Main.tile[i, j].type == 396)
					{
						Convert(i, j, 2, 0, tiles: true, walls: false);
					}
					if (Main.tile[i, j].type == 397)
					{
						Convert(i, j, 2, 0, tiles: true, walls: false);
					}
					if (Main.tile[i, j].wall == 187)
					{
						Convert(i, j, 2, 0, tiles: false);
					}
					if (Main.tile[i, j].wall == 216)
					{
						Convert(i, j, 2, 0, tiles: false);
					}
					if (Main.tile[i, j].wall == 63)
					{
						Convert(i, j, 2, 0, tiles: false);
					}
					if (Main.tile[i, j].wall == 65)
					{
						Convert(i, j, 2, 0, tiles: false);
					}
					if (Main.tile[i, j].wall == 66)
					{
						Convert(i, j, 2, 0, tiles: false);
					}
					if (Main.tile[i, j].wall == 68)
					{
						Convert(i, j, 2, 0, tiles: false);
					}
				}
			}
		}

		public static void DoWorldIsInfected()
		{
			if (skyblockWorldGen)
			{
				return;
			}
			int num = 0;
			if (noInfection.Enabled)
			{
				if (noSurface.Enabled)
				{
					num = (int)(Main.rockLayer + (double)Main.UnderworldLayer) / 2;
				}
				else
				{
					num = (int)Main.worldSurface + 10;
					if (hallowOnTheSurface.Enabled)
					{
						num = (int)(Main.rockLayer + (double)Main.UnderworldLayer) / 2;
					}
				}
			}
			else if (hallowOnTheSurface.Enabled)
			{
				num = (int)Main.worldSurface - 3;
			}
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				int conversionType = 1;
				if (drunkWorldGen)
				{
					if (GenVars.crimsonLeft && i < Main.maxTilesX / 2)
					{
						conversionType = 4;
					}
					if (!GenVars.crimsonLeft && i > Main.maxTilesX / 2)
					{
						conversionType = 4;
					}
				}
				else if (crimson)
				{
					conversionType = 4;
				}
				for (int j = num + genRand.Next(3); j < Main.maxTilesY; j++)
				{
					Tile tile = Main.tile[i, j];
					bool tiles = tile.type != 60 && tile.type != 109 && tile.type != 117 && tile.type != 164 && tile.type != 116 && tile.type != 403 && tile.type != 402;
					bool walls = tile.wall != 64 && tile.wall != 204 && tile.wall != 205 && tile.wall != 206 && tile.wall != 207 && tile.wall != 70 && tile.wall != 265 && tile.wall != 28 && tile.wall != 219 && tile.wall != 222;
					Convert(i, j, conversionType, 0, tiles, walls);
				}
			}
		}

		public static void DoSurfaceIsInSpace()
		{
			if (skyblockWorldGen)
			{
				return;
			}
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				for (int j = 0; (double)j < Main.worldSurface; j++)
				{
					if (Main.tile[i, j].wall == 73 && (!Main.tile[i, j].active() || Main.tile[i, j].type == 53))
					{
						Main.tile[i, j].wall = 0;
					}
				}
			}
		}

		public static void DoSurfaceIsMushrooms()
		{
			if (skyblockWorldGen)
			{
				return;
			}
			if (noSurface.Enabled)
			{
				for (int i = 0; i < Main.maxTilesX; i++)
				{
					for (int j = 0; j < Main.maxTilesY; j++)
					{
						if (Main.tile[i, j].active() && Main.tile[i, j].type == 60)
						{
							Convert(i, j, 3, 0);
						}
						else if (Main.tile[i, j].wall == 64 || Main.tile[i, j].wall == 204 || Main.tile[i, j].wall == 205 || Main.tile[i, j].wall == 206 || Main.tile[i, j].wall == 207)
						{
							Main.tile[i, j].wall = 80;
						}
						else if (Main.tile[i, j].active() && Main.tile[i, j].type == 70)
						{
							Convert(i, j, 0, 0);
						}
						else if (Main.tile[i, j].wall == 80)
						{
							Convert(i, j, 0, 0);
						}
					}
				}
				return;
			}
			for (int k = 0; k < Main.maxTilesX; k++)
			{
				for (int l = 0; (double)l < Main.worldSurface + (double)genRand.Next(3); l++)
				{
					if (Main.tile[k, l].type == 60)
					{
						Convert(k, l, 3, 0);
					}
					if (Main.tile[k, l].wall == 15)
					{
						Convert(k, l, 3, 0);
					}
					if (Main.tile[k, l].type == 0)
					{
						Main.tile[k, l].type = 59;
					}
					if (Main.tile[k, l].type == 2)
					{
						Main.tile[k, l].type = 60;
					}
					if (Main.tile[k, l].wall == 63)
					{
						Main.tile[k, l].wall = 80;
					}
					if (Main.tile[k, l].wall == 65)
					{
						Main.tile[k, l].wall = 80;
					}
					if (Main.tile[k, l].wall == 66)
					{
						Main.tile[k, l].wall = 80;
					}
					if (Main.tile[k, l].wall == 68)
					{
						Main.tile[k, l].wall = 80;
					}
					if (Main.tile[k, l].wall == 64)
					{
						Main.tile[k, l].wall = 80;
					}
					if (Main.tile[k, l].wall == 205)
					{
						Main.tile[k, l].wall = 80;
					}
					if (Main.tile[k, l].wall == 206)
					{
						Main.tile[k, l].wall = 80;
					}
					if (Main.tile[k, l].wall == 207)
					{
						Main.tile[k, l].wall = 80;
					}
				}
			}
		}

		public static void DoWorldIsFrozenFinish()
		{
			for (int i = 0; i < 8000; i++)
			{
				Chest chest = Main.chest[i];
				if (chest == null)
				{
					break;
				}
				if (genRand.Next(2) != 0 || chest.item[1].stack == 0)
				{
					continue;
				}
				for (int j = 1; j < chest.maxItems; j++)
				{
					if (chest.item[j].stack == 0)
					{
						chest.item[j].SetDefaults(1869);
						break;
					}
				}
			}
			if (skyblockWorldGen || !endlessChristmas.Enabled)
			{
				return;
			}
			for (int k = 0; k < Main.maxNPCs; k++)
			{
				if (Main.npc[k].type == 22)
				{
					int num = NPC.NewNPC(new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 142);
					Main.npc[num].homeTileX = Main.spawnTileX;
					Main.npc[num].homeTileY = Main.spawnTileY;
					Main.npc[num].direction = 1;
					Main.npc[num].homeless = true;
					Main.npc[num].position = Main.npc[k].position;
					Main.npc[k].active = false;
				}
			}
		}

		public static void DoWorldIsFrozen()
		{
			if (skyblockWorldGen)
			{
				return;
			}
			int num = Main.UnderworldLayer - Main.maxTilesY / 10;
			if (activeSecretSeedCount >= 6)
			{
				num = (int)Main.rockLayer;
			}
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				for (int j = 0; j < num + genRand.Next(3); j++)
				{
					if (Main.tile[i, j].type == 1)
					{
						Main.tile[i, j].type = 161;
					}
					if (Main.tile[i, j].type == 25)
					{
						Main.tile[i, j].type = 163;
					}
					if (Main.tile[i, j].type == 203)
					{
						Main.tile[i, j].type = 200;
					}
					if (Main.tile[i, j].type == 117)
					{
						Main.tile[i, j].type = 164;
					}
					if (Main.tile[i, j].type == 0)
					{
						Main.tile[i, j].type = 147;
					}
					if (Main.tile[i, j].type == 2)
					{
						Main.tile[i, j].type = 147;
					}
					if (Main.tile[i, j].type == 23)
					{
						Main.tile[i, j].type = 147;
					}
					if (Main.tile[i, j].type == 199)
					{
						Main.tile[i, j].type = 147;
					}
					if (Main.tile[i, j].type == 109)
					{
						Main.tile[i, j].type = 147;
					}
					if (Main.tile[i, j].type == 123)
					{
						Main.tile[i, j].type = 224;
					}
					if (Main.tile[i, j].type == 196)
					{
						Main.tile[i, j].type = 460;
					}
					if (Main.tile[i, j].wall == 2)
					{
						Main.tile[i, j].wall = 40;
					}
					if (Main.tile[i, j].wall == 59)
					{
						Main.tile[i, j].wall = 40;
					}
				}
			}
		}

		public static void DoSurfaceIsDesertFinish()
		{
			int num = FindLowestCloud() + 1;
			for (int i = 5; i < Main.maxTilesX - 5; i++)
			{
				int num2 = 0;
				bool flag = false;
				int num3 = 7;
				for (int j = 5; (double)j <= Main.worldSurface; j++)
				{
					if (Main.tile[i, j].wall == 63)
					{
						Main.tile[i, j].wall = 2;
					}
					if (Main.tile[i, j].type == 3 || Main.tile[i, j].type == 73 || Main.tile[i, j].type == 27)
					{
						TileFrame(i, j);
					}
					if (j <= num)
					{
						continue;
					}
					if (SolidTile3(i, j))
					{
						flag = true;
					}
					if (flag && num3 > 0)
					{
						num3--;
						if ((Main.tile[i, j].type == 397 || Main.tile[i, j].type == 396 || TileID.Sets.Ore[Main.tile[i, j].type] || Main.tile[i, j].type == 40) && SolidTile3(i, j + 1))
						{
							Main.tile[i, j].type = 53;
						}
					}
					if (SolidTile3(i, j) && (SolidTile3(i - 1, j) || Main.tile[i - 1, j].wall > 0) && (SolidTile3(i + 1, j) || Main.tile[i + 1, j].wall > 0))
					{
						if (num2 == 0 && (Main.tile[i, j].type == 53 || Main.tile[i, j].type == 112 || Main.tile[i, j].type == 234 || Main.tile[i, j].type == 116))
						{
							num2 = 1;
						}
						if (num2 == 1 && Main.tile[i, j].type != 53 && Main.tile[i, j].type != 112 && Main.tile[i, j].type != 234 && Main.tile[i, j].type != 116)
						{
							num2 = 2;
						}
					}
					if (num2 == 2)
					{
						if (Main.tile[i, j].wall == 0)
						{
							Main.tile[i, j].wall = 2;
						}
					}
					else if (!flag && Main.tile[i, j].wall == 2)
					{
						Main.tile[i, j].wall = 0;
					}
					else if (Main.tile[i, j].active() && Main.tile[i, j].type == 53 && !WallID.Sets.Fences[Main.tile[i, j].wall])
					{
						Main.tile[i, j].wall = 0;
					}
				}
			}
		}

		public static void DoSurfaceIsDesert()
		{
			if (skyblockWorldGen)
			{
				return;
			}
			if (noSurface.Enabled)
			{
				for (int i = 5; i < Main.maxTilesY - 5; i++)
				{
					int num = Main.maxTilesX + 10;
					int num2 = -10;
					for (int j = 0; j < Main.maxTilesX; j++)
					{
						if (Main.tile[j, i].type == 147 || Main.tile[j, i].type == 161)
						{
							if (j > num2)
							{
								num2 = j;
							}
							if (j < num)
							{
								num = j;
							}
						}
					}
					for (int k = 5; k < Main.maxTilesX - 5; k++)
					{
						if (k >= num && k <= num2)
						{
							if ((double)i >= Main.worldSurface - (double)genRand.Next(3) && k > num && k < num2 && (!remixWorldGen || !((double)i > Main.rockLayer + (double)genRand.Next(-1, 2))) && (Main.tile[k, i].wall == 0 || Main.tile[k, i].wall == 40 || Main.tile[k, i].wall == 71))
							{
								if (SolidTile(k, i) || Main.tile[k, i].wall == 40 || Main.tile[k, i].wall == 71)
								{
									Main.tile[k, i].wall = 216;
								}
								else
								{
									Main.tile[k, i].wall = 187;
									if (genRand.Next(3) == 0)
									{
										Main.tile[k, i - 1].wall = 187;
									}
									if (genRand.Next(3) == 0)
									{
										Main.tile[k, i + 1].wall = 187;
										if (genRand.Next(3) == 0)
										{
											Main.tile[k, i + 2].wall = 187;
										}
									}
								}
							}
							if (Main.tile[k, i].type == 147)
							{
								Main.tile[k, i].type = 397;
							}
							else if (Main.tile[k, i].type == 161)
							{
								Main.tile[k, i].type = 396;
							}
							if (remixWorldGen && (double)i > Main.rockLayer + (double)genRand.Next(-1, 2))
							{
								if (Main.tile[k, i - 1].active())
								{
									continue;
								}
								int num3 = genRand.Next(5, 8);
								for (int l = i; l < Main.UnderworldLayer && l <= i + num3 && SolidTile3(k, l) && SolidTile3(k, l + 1); l++)
								{
									if (Main.tile[k, l].type == 147 || Main.tile[k, l].type == 161 || Main.tile[k, l].type == 397 || Main.tile[k, l].type == 396)
									{
										Main.tile[k, l].type = 53;
									}
								}
							}
							else if (genRand.Next(2) == 0 && !Main.tile[k, i - 1].active() && !Main.tile[k + 1, i - 1].active() && !Main.tile[k, i - 2].active() && !Main.tile[k + 1, i - 2].active())
							{
								if (genRand.Next(2) == 0)
								{
									PlaceTile(k, i - 1, 485);
								}
								else
								{
									PlaceTile(k, i - 1, 484);
								}
							}
						}
						else
						{
							if (Main.tile[k, i].wall != 187 && Main.tile[k, i].wall != 216)
							{
								continue;
							}
							if (!Main.tile[k, i].active() && Main.tile[k, i].type == 0)
							{
								Main.tile[k, i].type = 147;
							}
							if (Main.tile[k, i].type == 484 || Main.tile[k, i].type == 485)
							{
								KillTile(k, i);
							}
							int num4 = k;
							while (num4 > 0 && Main.tile[num4, i].active() && (Main.tile[num4, i].type == 397 || Main.tile[num4, i].type == 396 || Main.tile[num4, i].type == 53 || Main.tile[num4, i].type == 404))
							{
								if (Main.tile[num4, i].type == 397)
								{
									Main.tile[num4, i].type = 147;
								}
								if (Main.tile[num4, i].type == 396)
								{
									Main.tile[num4, i].type = 161;
								}
								if (Main.tile[num4, i].type == 53)
								{
									Main.tile[num4, i].type = 224;
								}
								num4--;
							}
							for (num4 = k + 1; num4 < Main.maxTilesX && Main.tile[num4, i].active() && (Main.tile[num4, i].type == 397 || Main.tile[num4, i].type == 396 || Main.tile[num4, i].type == 53 || Main.tile[num4, i].type == 404); num4++)
							{
								if (Main.tile[num4, i].type == 397)
								{
									Main.tile[num4, i].type = 147;
								}
								if (Main.tile[num4, i].type == 396)
								{
									Main.tile[num4, i].type = 161;
								}
								if (Main.tile[num4, i].type == 53)
								{
									Main.tile[num4, i].type = 224;
								}
							}
							int num5 = i - 1;
							while (num5 > 0 && (i == (int)(Main.rockLayer / 2.0) || Main.tile[k, num5].type == 397 || Main.tile[k, num5].type == 396 || Main.tile[k, num5].type == 53 || Main.tile[k, num5].type == 404))
							{
								if (Main.tile[k, num5].type == 397)
								{
									Main.tile[k, num5].type = 147;
								}
								if (Main.tile[k, num5].type == 396)
								{
									Main.tile[k, num5].type = 161;
								}
								if (Main.tile[k, num5].type == 53)
								{
									Main.tile[k, num5].type = 224;
								}
								num5--;
							}
							Main.tile[k, i].wall = 0;
						}
					}
				}
				return;
			}
			for (int m = 0; m < Main.maxTilesX; m++)
			{
				for (int n = 0; (double)n < Main.worldSurface + (double)genRand.Next(3); n++)
				{
					if (Main.tile[m, n].active())
					{
						if (Main.tile[m, n].type == 1)
						{
							Main.tile[m, n].type = 396;
						}
						if (Main.tile[m, n].type == 25)
						{
							Main.tile[m, n].type = 398;
						}
						if (Main.tile[m, n].type == 203)
						{
							Main.tile[m, n].type = 399;
						}
						if (Main.tile[m, n].type == 117)
						{
							Main.tile[m, n].type = 402;
						}
						if (Main.tile[m, n].type == 0)
						{
							Main.tile[m, n].type = 53;
						}
						if (Main.tile[m, n].type == 2)
						{
							Main.tile[m, n].type = 53;
						}
						if (Main.tile[m, n].type == 23)
						{
							Main.tile[m, n].type = 112;
							for (int num6 = m - 3; num6 <= m + 3; num6++)
							{
								for (int num7 = n - 3; num7 <= n + 3; num7++)
								{
									if (Main.tile[num6, num7].type == 53)
									{
										Main.tile[num6, num7].type = 112;
									}
								}
							}
						}
						if (Main.tile[m, n].type == 199)
						{
							Main.tile[m, n].type = 234;
							for (int num8 = m - 3; num8 <= m + 3; num8++)
							{
								for (int num9 = n - 3; num9 <= n + 3; num9++)
								{
									if (Main.tile[num8, num9].type == 53)
									{
										Main.tile[num8, num9].type = 234;
									}
								}
							}
						}
						if (Main.tile[m, n].type == 109)
						{
							Main.tile[m, n].type = 116;
							for (int num10 = m - 3; num10 <= m + 3; num10++)
							{
								for (int num11 = n - 3; num11 <= n + 3; num11++)
								{
									if (Main.tile[num10, num11].type == 53)
									{
										Main.tile[num10, num11].type = 116;
									}
								}
							}
						}
					}
					if ((Main.tile[m, n].wall == 2 || Main.tile[m, n].wall == 59) && Main.tile[m, n].active() && Main.tile[m, n].type == 53)
					{
						Main.tile[m, n].wall = 0;
					}
				}
			}
		}

		public static void DoSurfaceIsDesertNoSurfaceCleanup()
		{
			if (skyblockWorldGen)
			{
				return;
			}
			for (int i = 5; i < Main.maxTilesY - 5; i++)
			{
				for (int j = 5; j < Main.maxTilesX - 5; j++)
				{
					if (Main.tile[j, i].wall == 187 || Main.tile[j, i].wall == 216)
					{
						if (Main.tile[j, i].type == 147)
						{
							Main.tile[j, i].type = 397;
						}
						else if (Main.tile[j, i].type == 161)
						{
							Main.tile[j, i].type = 396;
						}
					}
				}
			}
		}

		public static void DoNoSpiderCavesILiedMoreSpiderCaves()
		{
			for (int i = 5; i < Main.maxTilesY - 5; i++)
			{
				for (int j = 5; j < Main.maxTilesX - 5; j++)
				{
					if (Main.tile[j, i].wall == 204 || Main.tile[j, i].wall == 205 || Main.tile[j, i].wall == 206 || Main.tile[j, i].wall == 207 || Main.tile[j, i].wall == 180 || Main.tile[j, i].wall == 178 || Main.tile[j, i].wall == 86 || Main.tile[j, i].wall == 15)
					{
						Main.tile[j, i].wall = 62;
					}
				}
			}
		}

		public static void DoActuallyNoTraps()
		{
			if (Variations.actuallyNoTrapsForRealIMeanIt)
			{
				for (int i = 0; i < Main.maxTilesX; i++)
				{
					for (int j = 0; j < Main.maxTilesY; j++)
					{
						if (Main.tile[i, j].type == 48)
						{
							KillTile(i, j);
						}
						if (Main.tile[i, j].type == 232)
						{
							KillTile(i, j);
						}
					}
				}
				return;
			}
			int num = 20;
			for (int k = num; k < Main.maxTilesX - num; k++)
			{
				for (int l = num; l < Main.maxTilesY - num; l++)
				{
					if (!Main.tile[k, l].active() || (Main.tile[k, l].type != 21 && Main.tile[k, l].type != 467 && Main.tile[k, l].type != 12 && Main.tile[k, l].type != 639 && Main.tile[k, l].type != 665) || Math.Abs(k - Main.spawnTileX) + Math.Abs(l - Main.spawnTileY) <= 100)
					{
						continue;
					}
					int num2 = genRand.Next(1, 10);
					int num3 = num2;
					if (!coatEverythingEcho.Enabled)
					{
						num3 = 1;
					}
					for (int m = k - num2; m <= k + num2; m++)
					{
						for (int n = l - num2; n <= l + num3; n++)
						{
							if ((!Main.tile[m, n].active() || Main.tileCut[Main.tile[m, n].type] || (!coatEverythingEcho.Enabled && !Main.tileFrameImportant[Main.tile[m, n].type] && SolidTile3(m, n))) && !Main.tile[m, n].actuator() && Main.tile[m, n].type != 60 && Main.tile[m, n].type != 70)
							{
								Main.tile[m, n].active(active: true);
								Main.tile[m, n].slope(0);
								Main.tile[m, n].halfBrick(halfBrick: false);
								if (Main.tile[m, n].wall == 87)
								{
									Main.tile[m, n].type = 232;
								}
								else
								{
									Main.tile[m, n].type = 48;
								}
								if (coatEverythingEcho.Enabled)
								{
									Main.tile[m, n].invisibleBlock(invisibleBlock: true);
								}
							}
						}
					}
				}
			}
		}

		public static void DoRainbowStuff()
		{
			Main.tileSolid[379] = false;
			bool flag = !extraLiquid.Enabled || !roundLandmasses.Enabled;
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				for (int j = 0; j < Main.maxTilesY; j++)
				{
					if (Main.tile[i, j].type == 189)
					{
						Main.tile[i, j].type = 719;
					}
					if (Main.tile[i, j].type == 4)
					{
						Main.tile[i, j].frameY = 308;
						Main.tile[i, j].ClearBlockPaintAndCoating();
					}
					if (flag && Main.tile[i, j].halfBrick())
					{
						if (Main.tile[i - 1, j].liquid == byte.MaxValue && Main.tile[i - 1, j].liquidType() == 0 && (!Main.tile[i + 1, j].active() || Main.tile[i + 1, j].halfBrick()) && Main.tile[i + 1, j].liquid == 0)
						{
							Main.tile[i, j].type = 160;
							Main.tile[i, j].ClearBlockPaintAndCoating();
						}
						if (Main.tile[i + 1, j].liquid == byte.MaxValue && Main.tile[i + 1, j].liquidType() == 0 && (!Main.tile[i - 1, j].active() || Main.tile[i - 1, j].halfBrick()) && Main.tile[i - 1, j].liquid == 0)
						{
							Main.tile[i, j].type = 160;
							Main.tile[i, j].ClearBlockPaintAndCoating();
						}
					}
					if (Main.tile[i, j].type == 138 && Main.tile[i, j].frameX == 0 && Main.tile[i, j].frameY == 0 && genRand.Next(4) == 0)
					{
						Main.tile[i, j].type = 711;
						Main.tile[i + 1, j].type = 711;
						Main.tile[i, j + 1].type = 711;
						Main.tile[i + 1, j + 1].type = 711;
						Main.tile[i, j].ClearBlockPaintAndCoating();
						Main.tile[i + 1, j].ClearBlockPaintAndCoating();
						Main.tile[i, j + 1].ClearBlockPaintAndCoating();
						Main.tile[i + 1, j + 1].ClearBlockPaintAndCoating();
					}
					if (Main.tile[i, j].type == 202)
					{
						Main.tile[i, j].type = 692;
						Main.tile[i, j].ClearBlockPaintAndCoating();
					}
					if (Main.tile[i, j].wall == 82)
					{
						Main.tile[i, j].wall = 346;
						Main.tile[i, j].ClearBlockPaintAndCoating();
					}
					if (Main.tile[i, j].type == 91 && Main.tile[i, j].frameY % 54 == 0 && (genRand.Next(5) == 0 || ((double)j < Main.worldSurface && genRand.Next(2) == 0)))
					{
						Main.tile[i, j].frameX = 1206;
						Main.tile[i, j].frameY = 54;
						Main.tile[i, j + 1].frameX = 1206;
						Main.tile[i, j + 1].frameY = 72;
						Main.tile[i, j + 2].frameX = 1206;
						Main.tile[i, j + 2].frameY = 90;
						Main.tile[i, j].ClearBlockPaintAndCoating();
						Main.tile[i, j + 1].ClearBlockPaintAndCoating();
						Main.tile[i, j + 2].ClearBlockPaintAndCoating();
					}
					if (TileID.Sets.Conversion.Moss[Main.tile[i, j].type])
					{
						Main.tile[i, j].type = 627;
						Main.tile[i, j].ClearBlockPaintAndCoating();
					}
					else if (Main.tile[i, j].type == 184)
					{
						Main.tile[i, j].frameX = 220;
						Main.tile[i, j].ClearBlockPaintAndCoating();
					}
				}
			}
			int num = Main.maxTilesX * 2;
			if (skyblockWorldGen)
			{
				num /= 2;
			}
			else if (!flag)
			{
				num *= 2;
			}
			int num2 = 40;
			for (int k = 0; k < num; k++)
			{
				int num3 = genRand.Next(num2, Main.maxTilesX - num2);
				int num4 = genRand.Next(num2, Main.maxTilesY - num2);
				if (Main.tile[num3, num4].active())
				{
					continue;
				}
				while (!Main.tile[num3, num4].active())
				{
					num4--;
					if (!InWorld(num3, num4, num2))
					{
						break;
					}
				}
				num4++;
				if (!Main.tile[num3 + 1, num4].active() && Main.tile[num3 + 1, num4].type != 162 && SolidTile(num3 - 1, num4 - 1) && SolidTile(num3, num4 - 1) && Main.tile[num3 - 1, num4 - 1].type != 48 && Main.tile[num3, num4 - 1].type != 48 && Main.tile[num3 - 1, num4 - 1].type != 232 && Main.tile[num3, num4 - 1].type != 232 && !IsTileNearby(num3, num4, 126, 20) && PlaceTile(num3, num4, 126))
				{
					Main.tile[num3 - 1, num4].ClearBlockPaintAndCoating();
					Main.tile[num3, num4].ClearBlockPaintAndCoating();
					Main.tile[num3 - 1, num4 + 1].ClearBlockPaintAndCoating();
					Main.tile[num3, num4 + 1].ClearBlockPaintAndCoating();
				}
			}
			for (int l = 0; l < 8000; l++)
			{
				Chest chest = Main.chest[l];
				if (chest == null)
				{
					break;
				}
				if (genRand.Next(3) != 0 || chest.item[1].stack == 0)
				{
					continue;
				}
				for (int m = 1; m < chest.maxItems; m++)
				{
					if (chest.item[m].stack == 0)
					{
						chest.item[m].SetDefaults(genRand.NextFromList(new short[6] { 3556, 2870, 1067, 1066, 5075, 4469 }));
						if (chest.item[m].dye > 0)
						{
							chest.item[m].stack = 3;
						}
						break;
					}
				}
			}
			OverGrownDungeonWithRainbowMoss();
			Main.tileSolid[379] = true;
		}

		public static void DoDigExtraHoles()
		{
			int num = (int)((double)Main.maxTilesX * 0.1);
			for (int i = 0; i < num; i++)
			{
				int i2 = genRand.Next(50, Main.maxTilesX - 50);
				int j = genRand.Next(50, Main.maxTilesY - 50);
				int num2 = genRand.Next(5, 16);
				if (genRand.Next(3) == 0)
				{
					num2 += genRand.Next(15);
				}
				int steps = genRand.Next(30, 201);
				TileRunner(i2, j, num2, steps, -1, addTile: false, (float)genRand.Next(-15, 16) * 0.1f, (float)genRand.Next(10, 26) * 0.1f, noYChange: true);
			}
		}

		public static void DoRoundLandMasses()
		{
			int num = Main.maxTilesX * 10;
			int num2 = 25;
			GenVars.landmassData.Clear();
			for (int i = 0; i < 3; i++)
			{
				int num3 = genRand.Next(235, 266);
				Vector2 vector = new Vector2(115 + genRand.Next(20), (int)Main.worldSurface - 100 + genRand.Next(-20, 21));
				switch (i)
				{
				case 1:
					vector = new Vector2(Main.maxTilesX - 115 - genRand.Next(20), (int)Main.worldSurface - 100 + genRand.Next(-20, 21));
					break;
				case 2:
					vector = new Vector2(Main.maxTilesX / 2 + genRand.Next(-50, 51), (int)Main.worldSurface - genRand.Next(101));
					num3 = genRand.Next(100, 201);
					break;
				}
				LandmassData item = new LandmassData
				{
					DataType = LandmassDataType.RoundLandmass,
					Position = vector,
					RadiusOrHalfSize = num3
				};
				GenVars.landmassData.Add(item);
				for (int j = (int)vector.X - num3; (float)j <= vector.X + (float)num3; j++)
				{
					for (int k = (int)vector.Y - num3; (float)k <= vector.Y + (float)num3; k++)
					{
						if (InWorld(j, k) && Vector2.Distance(vector, new Vector2(j, k)) < (float)num3)
						{
							Main.tile[j, k].fullbrightBlock(fullbrightBlock: true);
						}
					}
				}
			}
			for (int l = 0; l < num; l++)
			{
				Vector2 vector2 = new Vector2(genRand.Next(50, Main.maxTilesX - 50), genRand.Next(50, Main.maxTilesY - 50));
				int num4 = 10;
				int num5 = genRand.Next(30, 170);
				if (l > num / 2)
				{
					num5 /= 2;
					num4 /= 2;
				}
				bool flag = false;
				for (int m = (int)vector2.X - num5 - num4; (float)m <= vector2.X + (float)num5 + (float)num4; m++)
				{
					for (int n = (int)vector2.Y - num5 - num4; (float)n <= vector2.Y + (float)num5 + (float)num4; n++)
					{
						if (InWorld(m, n) && Vector2.Distance(vector2, new Vector2(m, n)) < (float)(num5 + num4) && Main.tile[m, n].fullbrightBlock())
						{
							flag = true;
							break;
						}
					}
					if (flag)
					{
						break;
					}
				}
				if (flag)
				{
					continue;
				}
				LandmassData item2 = new LandmassData
				{
					DataType = LandmassDataType.RoundLandmass,
					Position = vector2,
					RadiusOrHalfSize = num5
				};
				GenVars.landmassData.Add(item2);
				for (int num6 = (int)vector2.X - num5; (float)num6 <= vector2.X + (float)num5; num6++)
				{
					for (int num7 = (int)vector2.Y - num5; (float)num7 <= vector2.Y + (float)num5; num7++)
					{
						if (InWorld(num6, num7) && Vector2.Distance(vector2, new Vector2(num6, num7)) < (float)num5)
						{
							Main.tile[num6, num7].fullbrightBlock(fullbrightBlock: true);
						}
					}
				}
			}
			for (int num8 = num2; num8 < Main.maxTilesX - num2; num8++)
			{
				for (int num9 = num2; num9 < Main.maxTilesY - 100; num9++)
				{
					if (!Main.tile[num8, num9].fullbrightBlock())
					{
						Main.tile[num8, num9].active(active: false);
						Main.tile[num8, num9].wall = 0;
					}
				}
			}
			for (int num10 = 0; num10 < Main.maxTilesX; num10++)
			{
				for (int num11 = 0; num11 < Main.maxTilesY; num11++)
				{
					Main.tile[num10, num11].fullbrightBlock(fullbrightBlock: false);
				}
			}
		}

		public static void DoPooEverywhere()
		{
			int num = 40;
			int num2 = (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0002);
			int num3 = (2 + activeSecretSeedCount) / 3;
			if (num3 < 1)
			{
				num3 = 1;
			}
			num2 /= num3;
			for (int i = 0; i < num2; i++)
			{
				int num4 = genRand.Next(num, Main.maxTilesX - num);
				int num5 = genRand.Next(num, Main.maxTilesY - num);
				for (int j = 0; j < 30; j++)
				{
					if (SolidTile(num4, num5))
					{
						break;
					}
					num5++;
				}
				if ((skyblockWorldGen || !Main.tile[num4, num5].active() || (!Main.tileDungeon[Main.tile[num4, num5].type] && !Main.wallDungeon[Main.tile[num4, num5].wall] && !TileID.Sets.Clouds[Main.tile[num4, num5].type] && Main.tile[num4, num5].wall != 73)) && SolidTile(num4, num5))
				{
					TileRunner(num4, num5, genRand.Next(5, 12), genRand.Next(10, 31), 666, addTile: true);
				}
			}
		}

		public static void DoPortalGunInChests()
		{
			for (int i = 0; i < 8000; i++)
			{
				Chest chest = Main.chest[i];
				if (chest == null)
				{
					break;
				}
				if (genRand.Next(7) != 0 || chest.item[1].stack == 0)
				{
					continue;
				}
				for (int j = 1; j < chest.maxItems; j++)
				{
					if (chest.item[j].stack == 0)
					{
						chest.item[j].SetDefaults(3384);
						break;
					}
				}
			}
		}
	}

	public static class Skyblock
	{
		public static bool noAltars = false;

		public static bool noDungeon = false;

		public static bool noTemple = false;

		public static bool noHellstone = false;

		public static bool noFossils = false;

		public static bool noLifeCrystals = false;

		public static bool noHellforge = false;

		public static bool lowTiles = false;

		public static bool[] hasTile = new bool[TileID.Count];

		public static bool[] hasWall = new bool[WallID.Count];

		public static int currentActiveTiles = 0;

		public static bool denyFloatingIslands
		{
			get
			{
				if (skyblockWorldGen)
				{
					return !SecretSeed.extraFloatingIslands.Enabled;
				}
				return false;
			}
		}

		public static bool spawnSolidifier
		{
			get
			{
				if (skyblockWorldGen)
				{
					if (!tenthAnniversaryWorldGen)
					{
						return !getGoodWorldGen;
					}
					return true;
				}
				return false;
			}
		}

		public static bool spawnShimmerPool
		{
			get
			{
				if (skyblockWorldGen)
				{
					if (!tenthAnniversaryWorldGen)
					{
						return !getGoodWorldGen;
					}
					return true;
				}
				return false;
			}
		}

		public static bool denyAllGeneration => skyblockWorldGen;

		public static bool denySomeGeneration
		{
			get
			{
				if (skyblockWorldGen)
				{
					if (!SecretSeed.worldIsFrozen.Enabled && !SecretSeed.surfaceIsDesert.Enabled && !SecretSeed.surfaceIsMushrooms.Enabled && !SecretSeed.worldIsInfected.Enabled && !SecretSeed.hallowOnTheSurface.Enabled && !SecretSeed.noInfection.Enabled && !SecretSeed.extraFloatingIslands.Enabled && !SecretSeed.extraLiquid.Enabled)
					{
						return !SecretSeed.extraLivingTrees.Enabled;
					}
					return false;
				}
				return false;
			}
		}

		public static void Calculate()
		{
			noAltars = true;
			noDungeon = true;
			noTemple = true;
			noHellstone = true;
			noFossils = true;
			noLifeCrystals = true;
			noHellforge = true;
			for (int i = 0; i < TileID.Count; i++)
			{
				if (hasTile[i])
				{
					if (Main.tileDungeon[i])
					{
						noDungeon = false;
					}
					if (i == 26)
					{
						noAltars = false;
					}
					if (i == 226)
					{
						noTemple = false;
					}
					if (i == 58)
					{
						noHellstone = false;
					}
					if (i == 404)
					{
						noFossils = false;
					}
					if (i == 12)
					{
						noLifeCrystals = false;
					}
					if (i == 77)
					{
						noHellforge = false;
					}
					if (i == 133)
					{
						noHellforge = false;
					}
				}
			}
			for (int j = 0; j < WallID.Count; j++)
			{
				if (hasWall[j])
				{
					if (Main.wallDungeon[j])
					{
						noDungeon = false;
					}
					if (j == 87)
					{
						noTemple = false;
					}
				}
			}
			int num = Main.maxTilesX * Main.maxTilesY;
			float num2 = (float)currentActiveTiles / (float)num;
			currentActiveTiles = 0;
			if ((double)num2 < 0.1)
			{
				lowTiles = true;
			}
			else
			{
				lowTiles = false;
			}
			for (int k = 0; k < TileID.Count; k++)
			{
				hasTile[k] = false;
			}
			for (int l = 0; l < WallID.Count; l++)
			{
				hasWall[l] = false;
			}
			if (noDungeon)
			{
				Main.dungeonX = -1;
				Main.dungeonY = -1;
			}
		}

		public static void ScanTiles()
		{
			currentActiveTiles = 0;
			for (int i = 0; i < TileID.Count; i++)
			{
				hasTile[i] = false;
			}
			for (int j = 0; j < WallID.Count; j++)
			{
				hasWall[j] = false;
			}
			int num = Main.maxTilesX - 40;
			int num2 = 40;
			int num3 = Main.maxTilesY - 40;
			for (int k = 40; k < num; k++)
			{
				for (int l = num2; l < num3; l++)
				{
					if (Main.tile[k, l].active())
					{
						currentActiveTiles++;
						hasTile[Main.tile[k, l].type] = true;
					}
					hasWall[Main.tile[k, l].wall] = true;
				}
			}
			Calculate();
		}
	}

	public static class SavedOreTiers
	{
		public static int Copper = 7;

		public static int Iron = 6;

		public static int Silver = 9;

		public static int Gold = 8;

		public static int Cobalt = 107;

		public static int Mythril = 108;

		public static int Adamantite = 111;
	}

	public static class Hooks
	{
		public delegate void WorldGenConfigProcessEvent(ref WorldGenConfiguration config);

		public static event WorldGenConfigProcessEvent OnWorldGenConfigProcess;

		public static event Action OnWorldLoad;

		public static void Initialize()
		{
			Player.Hooks.OnEnterWorld += delegate(Player player)
			{
				if (player.whoAmI == Main.myPlayer)
				{
					WorldLoaded();
					if (Main.netMode != 1)
					{
						Main.FixUIScale();
					}
				}
			};
			OnWorldLoad += mysticLogsEvent.StartWorld;
			OnWorldLoad += Main.checkHalloween;
			OnWorldLoad += Main.checkXMas;
		}

		public static void WorldLoaded()
		{
			if (Hooks.OnWorldLoad != null)
			{
				Hooks.OnWorldLoad();
			}
		}

		public static void ProcessWorldGenConfig(ref WorldGenConfiguration config)
		{
			if (Hooks.OnWorldGenConfigProcess != null)
			{
				Hooks.OnWorldGenConfigProcess(ref config);
			}
		}
	}

	public static class Spread
	{
		public static void Wall(int x, int y, int wallType)
		{
			if (!InWorld(x, y))
			{
				return;
			}
			ushort wall = (ushort)wallType;
			List<Point> list = new List<Point>();
			List<Point> list2 = new List<Point>();
			HashSet<Point> hashSet = new HashSet<Point>();
			list2.Add(new Point(x, y));
			while (list2.Count > 0)
			{
				list.Clear();
				list.AddRange(list2);
				list2.Clear();
				while (list.Count > 0)
				{
					Point item = list[0];
					if (!InWorld(item.X, item.Y, 1))
					{
						list.Remove(item);
						continue;
					}
					hashSet.Add(item);
					list.Remove(item);
					Tile tile = Main.tile[item.X, item.Y];
					if (SolidTile(item.X, item.Y) || tile.wall != 0)
					{
						if (tile.active() && tile.wall == 0)
						{
							tile.wall = wall;
						}
						continue;
					}
					tile.wall = wall;
					Point item2 = new Point(item.X - 1, item.Y);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
					item2 = new Point(item.X + 1, item.Y);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
					item2 = new Point(item.X, item.Y - 1);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
					item2 = new Point(item.X, item.Y + 1);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
				}
			}
		}

		public static void Wall2(int x, int y, int wallType)
		{
			if (!InWorld(x, y))
			{
				return;
			}
			ushort num = (ushort)wallType;
			int num2 = 0;
			int maxWallOut = maxWallOut2;
			List<Point> list = new List<Point>();
			List<Point> list2 = new List<Point>();
			HashSet<Point> hashSet = new HashSet<Point>();
			list2.Add(new Point(x, y));
			while (list2.Count > 0)
			{
				list.Clear();
				list.AddRange(list2);
				list2.Clear();
				while (list.Count > 0)
				{
					Point item = list[0];
					if (!InWorld(item.X, item.Y, 1))
					{
						list.Remove(item);
						continue;
					}
					hashSet.Add(item);
					list.Remove(item);
					Tile tile = Main.tile[item.X, item.Y];
					if (tile.wall == num || WallID.Sets.CannotBeReplacedByWallSpread[tile.wall])
					{
						continue;
					}
					if (!SolidTile(item.X, item.Y))
					{
						bool flag = WallID.Sets.WallSpreadStopsAtAir[num];
						if (flag && tile.wall == 0)
						{
							list.Remove(item);
							continue;
						}
						num2++;
						if (num2 >= maxWallOut)
						{
							list.Remove(item);
							continue;
						}
						tile.wall = num;
						Point item2 = new Point(item.X - 1, item.Y);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X + 1, item.Y);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X, item.Y - 1);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X, item.Y + 1);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						if (flag)
						{
							item2 = new Point(item.X - 1, item.Y - 1);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							item2 = new Point(item.X + 1, item.Y - 1);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							item2 = new Point(item.X - 1, item.Y + 1);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							item2 = new Point(item.X + 1, item.Y + 1);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							item2 = new Point(item.X - 2, item.Y);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							item2 = new Point(item.X + 2, item.Y);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
						}
					}
					else if (tile.active())
					{
						tile.wall = num;
					}
				}
			}
		}

		public static void Moss(int x, int y)
		{
			if (!InWorld(x, y))
			{
				return;
			}
			ushort mossWall = GenVars.mossWall;
			ushort mossTile = GenVars.mossTile;
			List<Point> list = new List<Point>();
			List<Point> list2 = new List<Point>();
			HashSet<Point> hashSet = new HashSet<Point>();
			list2.Add(new Point(x, y));
			while (list2.Count > 0)
			{
				list.Clear();
				list.AddRange(list2);
				list2.Clear();
				while (list.Count > 0)
				{
					Point item = list[0];
					if (!InWorld(item.X, item.Y, 1))
					{
						list.Remove(item);
						continue;
					}
					hashSet.Add(item);
					list.Remove(item);
					Tile tile = Main.tile[item.X, item.Y];
					if (SolidTile(item.X, item.Y) || tile.wall != 0)
					{
						if (tile.active())
						{
							if (tile.wall == 0)
							{
								tile.wall = mossWall;
							}
							if (tile.type == 1)
							{
								tile.type = mossTile;
							}
						}
						continue;
					}
					tile.wall = mossWall;
					Point item2 = new Point(item.X - 1, item.Y);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
					item2 = new Point(item.X + 1, item.Y);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
					item2 = new Point(item.X, item.Y - 1);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
					item2 = new Point(item.X, item.Y + 1);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
				}
			}
		}

		public static void Gem(int x, int y)
		{
			if (!InWorld(x, y))
			{
				return;
			}
			List<Point> list = new List<Point>();
			List<Point> list2 = new List<Point>();
			HashSet<Point> hashSet = new HashSet<Point>();
			list2.Add(new Point(x, y));
			while (list2.Count > 0)
			{
				list.Clear();
				list.AddRange(list2);
				list2.Clear();
				while (list.Count > 0)
				{
					Point item = list[0];
					if (!InWorld(item.X, item.Y, 1))
					{
						list.Remove(item);
						continue;
					}
					hashSet.Add(item);
					list.Remove(item);
					Tile tile = Main.tile[item.X, item.Y];
					if (SolidTile(item.X, item.Y) || tile.wall != 0)
					{
						if (tile.active())
						{
							if (Gemmable(tile.type))
							{
								tile.type = randGemTile();
							}
							Tile tile2 = Main.tile[item.X - 1, item.Y];
							if (tile2.active() && Gemmable(tile2.type))
							{
								tile2.type = randGemTile();
							}
							tile2 = Main.tile[item.X + 1, item.Y];
							if (tile2.active() && Gemmable(tile2.type))
							{
								tile2.type = randGemTile();
							}
							tile2 = Main.tile[item.X, item.Y - 1];
							if (tile2.active() && Gemmable(tile2.type))
							{
								tile2.type = randGemTile();
							}
							tile2 = Main.tile[item.X, item.Y + 1];
							if (tile2.active() && Gemmable(tile2.type))
							{
								tile2.type = randGemTile();
							}
						}
					}
					else
					{
						tile.wall = (ushort)(48 + randGem());
						if (!tile.active() && genRand.Next(2) == 0)
						{
							PlaceTile(item.X, item.Y, 178, mute: true, forced: false, -1, randGem());
						}
						Point item2 = new Point(item.X - 1, item.Y);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X + 1, item.Y);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X, item.Y - 1);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X, item.Y + 1);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
					}
				}
			}
		}

		public static void Spider(int x, int y)
		{
			if (!InWorld(x, y))
			{
				return;
			}
			byte wall = 62;
			List<Point> list = new List<Point>();
			List<Point> list2 = new List<Point>();
			HashSet<Point> hashSet = new HashSet<Point>();
			list2.Add(new Point(x, y));
			while (list2.Count > 0)
			{
				list.Clear();
				list.AddRange(list2);
				list2.Clear();
				while (list.Count > 0)
				{
					Point item = list[0];
					if (!InWorld(item.X, item.Y, 1))
					{
						list.Remove(item);
						continue;
					}
					if (item.Y >= Main.UnderworldLayer - genRand.Next(5))
					{
						list.Remove(item);
						continue;
					}
					if ((double)item.Y < Main.worldSurface + (double)genRand.Next(5))
					{
						list.Remove(item);
						continue;
					}
					hashSet.Add(item);
					list.Remove(item);
					Tile tile = Main.tile[item.X, item.Y];
					if (SolidTile(item.X, item.Y) || tile.wall != 0)
					{
						if (tile.active() && tile.wall == 0)
						{
							tile.wall = wall;
						}
						continue;
					}
					tile.wall = wall;
					SquareWallFrame(item.X, item.Y);
					if (!tile.active())
					{
						tile.liquid = 0;
						tile.lava(lava: false);
						if (SolidTile(item.X, item.Y + 1) && genRand.Next(3) == 0)
						{
							if (genRand.Next(15) == 0)
							{
								AddBuriedChest(item.X, item.Y, 939, notNearOtherChests: true, 15, trySlope: false, 0);
							}
							else
							{
								PlacePot(item.X, item.Y, 28, genRand.Next(19, 21));
							}
						}
						if (!tile.active())
						{
							if (SolidTile(item.X, item.Y - 1) && genRand.Next(3) == 0)
							{
								PlaceTight(item.X, item.Y, spiders: true);
							}
							else if (SolidTile(item.X, item.Y + 1))
							{
								PlaceTile(item.X, item.Y, 187, mute: true, forced: false, -1, 9 + genRand.Next(5));
								if (genRand.Next(3) == 0)
								{
									if (!tile.active())
									{
										PlaceSmallPile(item.X, item.Y, 34 + genRand.Next(4), 1, 185);
									}
									if (!tile.active())
									{
										PlaceSmallPile(item.X, item.Y, 48 + genRand.Next(6), 0, 185);
									}
								}
							}
						}
					}
					Point item2 = new Point(item.X - 1, item.Y);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
					item2 = new Point(item.X + 1, item.Y);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
					item2 = new Point(item.X, item.Y - 1);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
					item2 = new Point(item.X, item.Y + 1);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
				}
			}
		}

		private static bool Gemmable(int type)
		{
			if (type != 0 && type != 1 && type != 40 && type != 59 && type != 60 && type != 70 && type != 147)
			{
				return type == 161;
			}
			return true;
		}
	}

	public delegate void WorldGenerationFinishCallback(bool playable);

	public static class TenthAnniversaryWorldInfo
	{
		public static int[] GoodPrefixIdsForAccessory = new int[4] { 65, 68, 72, 76 };

		public static int[] GoodPrefixIdsForMeleeWeapon = new int[3] { 81, 59, 57 };

		public static int[] GoodPrefixIdsForRangedWeapon = new int[3] { 82, 57, 60 };

		public static int[] GoodPrefixIdsForMagicWeapon = new int[3] { 83, 57, 60 };

		public static int[] GoodPrefixIdsForSummonerWeapon = new int[5] { 85, 59, 95, 96, 97 };
	}

	public struct GrowTreeSettings
	{
		public delegate bool IsTileFitForTreeGroundTest(int tileType);

		public delegate bool IsWallTypeFitForTreeBack(int wallType);

		public static class Profiles
		{
			public static GrowTreeSettings GemTree_Ruby = new GrowTreeSettings
			{
				GroundTest = GemTreeGroundTest,
				WallTest = GemTreeWallTest,
				TreeHeightMax = 12,
				TreeHeightMin = 7,
				TreeTileType = 587,
				TreeTopPaddingNeeded = 4,
				SaplingTileType = 590
			};

			public static GrowTreeSettings GemTree_Diamond = new GrowTreeSettings
			{
				GroundTest = GemTreeGroundTest,
				WallTest = GemTreeWallTest,
				TreeHeightMax = 12,
				TreeHeightMin = 7,
				TreeTileType = 588,
				TreeTopPaddingNeeded = 4,
				SaplingTileType = 590
			};

			public static GrowTreeSettings GemTree_Topaz = new GrowTreeSettings
			{
				GroundTest = GemTreeGroundTest,
				WallTest = GemTreeWallTest,
				TreeHeightMax = 12,
				TreeHeightMin = 7,
				TreeTileType = 583,
				TreeTopPaddingNeeded = 4,
				SaplingTileType = 590
			};

			public static GrowTreeSettings GemTree_Amethyst = new GrowTreeSettings
			{
				GroundTest = GemTreeGroundTest,
				WallTest = GemTreeWallTest,
				TreeHeightMax = 12,
				TreeHeightMin = 7,
				TreeTileType = 584,
				TreeTopPaddingNeeded = 4,
				SaplingTileType = 590
			};

			public static GrowTreeSettings GemTree_Sapphire = new GrowTreeSettings
			{
				GroundTest = GemTreeGroundTest,
				WallTest = GemTreeWallTest,
				TreeHeightMax = 12,
				TreeHeightMin = 7,
				TreeTileType = 585,
				TreeTopPaddingNeeded = 4,
				SaplingTileType = 590
			};

			public static GrowTreeSettings GemTree_Emerald = new GrowTreeSettings
			{
				GroundTest = GemTreeGroundTest,
				WallTest = GemTreeWallTest,
				TreeHeightMax = 12,
				TreeHeightMin = 7,
				TreeTileType = 586,
				TreeTopPaddingNeeded = 4,
				SaplingTileType = 590
			};

			public static GrowTreeSettings GemTree_Amber = new GrowTreeSettings
			{
				GroundTest = GemTreeGroundTest,
				WallTest = GemTreeWallTest,
				TreeHeightMax = 12,
				TreeHeightMin = 7,
				TreeTileType = 589,
				TreeTopPaddingNeeded = 4,
				SaplingTileType = 590
			};

			public static GrowTreeSettings VanityTree_Sakura = new GrowTreeSettings
			{
				GroundTest = VanityTreeGroundTest,
				WallTest = DefaultTreeWallTest,
				TreeHeightMax = 12,
				TreeHeightMin = 7,
				TreeTileType = 596,
				TreeTopPaddingNeeded = 4,
				SaplingTileType = 595
			};

			public static GrowTreeSettings VanityTree_Willow = new GrowTreeSettings
			{
				GroundTest = VanityTreeGroundTest,
				WallTest = DefaultTreeWallTest,
				TreeHeightMax = 12,
				TreeHeightMin = 7,
				TreeTileType = 616,
				TreeTopPaddingNeeded = 4,
				SaplingTileType = 615
			};

			public static GrowTreeSettings Tree_Ash = new GrowTreeSettings
			{
				GroundTest = AshTreeGroundTest,
				WallTest = DefaultTreeWallTest,
				TreeHeightMax = 12,
				TreeHeightMin = 7,
				TreeTileType = 634,
				TreeTopPaddingNeeded = 4,
				SaplingTileType = 20
			};

			public static bool TryGetFromItemId(int itemType, out GrowTreeSettings profile)
			{
				switch (itemType)
				{
				default:
					profile = default(GrowTreeSettings);
					return false;
				case 4857:
					profile = GemTree_Amber;
					return true;
				case 4852:
					profile = GemTree_Amethyst;
					return true;
				case 4856:
					profile = GemTree_Diamond;
					return true;
				case 4854:
					profile = GemTree_Emerald;
					return true;
				case 4855:
					profile = GemTree_Ruby;
					return true;
				case 4853:
					profile = GemTree_Sapphire;
					return true;
				case 4851:
					profile = GemTree_Topaz;
					return true;
				case 4907:
					profile = VanityTree_Willow;
					return true;
				case 4871:
					profile = VanityTree_Sakura;
					return true;
				}
			}

			public static bool TryGetFromTreeId(int tileType, out GrowTreeSettings profile)
			{
				switch (tileType)
				{
				default:
					profile = default(GrowTreeSettings);
					return false;
				case 589:
					profile = GemTree_Amber;
					return true;
				case 584:
					profile = GemTree_Amethyst;
					return true;
				case 588:
					profile = GemTree_Diamond;
					return true;
				case 586:
					profile = GemTree_Emerald;
					return true;
				case 587:
					profile = GemTree_Ruby;
					return true;
				case 585:
					profile = GemTree_Sapphire;
					return true;
				case 583:
					profile = GemTree_Topaz;
					return true;
				case 616:
					profile = VanityTree_Willow;
					return true;
				case 596:
					profile = VanityTree_Sakura;
					return true;
				case 634:
					profile = Tree_Ash;
					return true;
				}
			}
		}

		public ushort TreeTileType;

		public int TreeHeightMin;

		public int TreeHeightMax;

		public int TreeTopPaddingNeeded;

		public IsTileFitForTreeGroundTest GroundTest;

		public IsWallTypeFitForTreeBack WallTest;

		public ushort SaplingTileType;
	}

	public struct CheckTreeSettings
	{
		public delegate bool GroundValidTest(int groundTileType);

		public GroundValidTest IsGroundValid;
	}

	public enum SpecialKillTileContext
	{
		None,
		MowingTheGrass
	}

	public delegate bool GetTreeFoliageDataMethod(int i, int j, int xoffset, ref int treeFrame, ref int treeStyle, out int floorY, out int topTextureFrameWidth, out int topTextureFrameHeight);

	public struct TileMergeCullCache
	{
		public bool CullTop;

		public bool CullBottom;

		public bool CullLeft;

		public bool CullRight;

		public bool CullTopLeft;

		public bool CullTopRight;

		public bool CullBottomLeft;

		public bool CullBottomRight;

		public void Cull(ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight)
		{
			if (CullTop)
			{
				up = -1;
			}
			if (CullBottom)
			{
				down = -1;
			}
			if (CullLeft)
			{
				left = -1;
			}
			if (CullRight)
			{
				right = -1;
			}
			if (CullTopLeft)
			{
				upLeft = -1;
			}
			if (CullTopRight)
			{
				upRight = -1;
			}
			if (CullBottomLeft)
			{
				downLeft = -1;
			}
			if (CullBottomRight)
			{
				downRight = -1;
			}
		}
	}

	public static TownRoomManager TownManager = new TownRoomManager();

	public static WorldManifest Manifest;

	public static int tileReframeCount;

	public static int treeBG1;

	public static int treeBG2;

	public static int treeBG3;

	public static int treeBG4;

	public static int corruptBG;

	public static int jungleBG;

	public static int snowBG;

	public static int hallowBG;

	public static int crimsonBG;

	public static int desertBG;

	public static int oceanBG;

	public static int mushroomBG;

	public static int underworldBG;

	public static readonly int oceanDistance = 250;

	public static readonly int beachDistance = 380;

	public static readonly int shimmerSafetyDistance = 150;

	public static bool crimson;

	public static bool generatingRandomEvil;

	public static int[] tileCounts = new int[TileID.Count];

	public static int totalEvil;

	public static int totalBlood;

	public static int totalGood;

	public static int totalSolid;

	public static int totalEvil2;

	public static int totalBlood2;

	public static int totalGood2;

	public static int totalSolid2;

	public static byte tEvil;

	public static byte tBlood;

	public static byte tGood;

	public static int totalX;

	public static int totalD;

	private static int _transformingWorld;

	public static bool spawnEye;

	public static int spawnHardBoss;

	public static volatile bool isGeneratingOrLoadingWorld;

	public static bool shadowOrbSmashed;

	public static int shadowOrbCount;

	public static int altarCount;

	public static bool builtHouseWithNoFurniture;

	public static bool builtHouseWithNoLight;

	public static bool spawnMeteor;

	public static bool loadFailed = false;

	public static bool worldCleared;

	public static bool worldBackup;

	public static bool loadBackup = false;

	private static int lastMaxTilesX;

	private static int lastMaxTilesY;

	private static bool mergeUp;

	private static bool mergeDown;

	private static bool mergeLeft;

	private static bool mergeRight;

	private static bool stopDrops;

	public static bool AllowedToSpreadInfections = true;

	public static string statusText = "";

	public static bool destroyObject;

	public static int npcSpawnDelay;

	public static int npcSpawnPeriod;

	public static int prioritizedTownNPCType;

	public static int numTileCount;

	public static int maxTileCount = 3500;

	public static int maxWallOut2 = 5000;

	public static Dictionary<Point, bool> CountedTiles = new Dictionary<Point, bool>(maxTileCount);

	public static int lavaCount;

	public static int iceCount;

	public static int sandCount;

	public static int rockCount;

	public static int shroomCount;

	public static int maxRoomTiles = 750;

	public static int maxRoomTilesForQuery = 8100;

	public static int maxRoomSize = 100;

	public static BitSet2D roomTiles = new BitSet2D();

	public static int numRoomTiles;

	public static int roomX1;

	public static int roomX2;

	public static int roomY1;

	public static int roomY2;

	public static bool canSpawn;

	public static bool[] houseTile = new bool[TileID.Count];

	public static int bestX;

	public static int bestY;

	public static int hiScore;

	private static bool roomTorch;

	private static bool roomDoor;

	private static bool roomChair;

	private static bool roomTable;

	private static bool roomOccupied;

	private static bool roomEvil;

	private static bool roomHasStandingSpace;

	private static bool roomHasStinkbug;

	private static bool roomHasEchoStinkbug;

	public static int WorldGenParam_Evil = -1;

	public static readonly int cactusWaterWidth = 50;

	public static readonly int cactusWaterHeight = 25;

	public static readonly int cactusWaterLimit = 25;

	public static MysticLogFairiesEvent mysticLogsEvent = new MysticLogFairiesEvent();

	private static Point LastFoundHouse;

	private static bool currentlyTryingToUseAlternateHousingSpot;

	private static int sharedRoomX;

	private static Stack<Point> _roomCheckStack = new Stack<Point>();

	public static TownNPCRoomCheckFailureReason roomCheckFailureReason = TownNPCRoomCheckFailureReason.None;

	public static int meteorShowerCount;

	public const int WorldSizeSmallX = 4200;

	public const int WorldSizeSmallY = 1200;

	public const int WorldSizeMediumX = 6400;

	public const int WorldSizeMediumY = 1800;

	public const int WorldSizeLargeX = 8400;

	public const int WorldSizeLargeY = 2400;

	public const int InfectionAndGrassSpreadOuterWorldBuffer = 10;

	public static bool generatingWorld = false;

	[ThreadStatic]
	public static bool generatingWorldOnThisThread;

	private static int[,] trapDiag = new int[4, 2];

	private static bool[] gem = new bool[6];

	private static int[] mossType = new int[3];

	private static ushort neonMossType;

	private static int tileCounterNum;

	private static int tileCounterMax = 20;

	private static int[] tileCounterX = new int[tileCounterMax];

	private static int[] tileCounterY = new int[tileCounterMax];

	private static WorldGenerator _generator;

	public static int SmallConsecutivesFound = 0;

	public static int SmallConsecutivesEliminated = 0;

	public static bool remixWorldGen = false;

	public static bool everythingWorldGen = false;

	public static bool noTrapsWorldGen = false;

	public static bool drunkWorldGen = false;

	public static bool getGoodWorldGen = false;

	public static bool tenthAnniversaryWorldGen = false;

	public static bool dontStarveWorldGen = false;

	public static bool notTheBees = false;

	public static bool skyblockWorldGen = false;

	public static bool drunkWorldGenText = false;

	public static bool placingTraps = false;

	private static bool[] tileSolidBackup;

	private const int ItemSpawnProtectionTime = 18000;

	private static List<Color> _coatingColors = new List<Color>();

	private static int catTailDistance = 8;

	public static TreeTopsInfo TreeTops = new TreeTopsInfo();

	public static BackgroundChangeFlashInfo BackgroundsCache = new BackgroundChangeFlashInfo();

	private static int maxTreeShakes = 500;

	private static int numTreeShakes = 0;

	private static int[] treeShakeX = new int[maxTreeShakes];

	private static int[] treeShakeY = new int[maxTreeShakes];

	private static bool fossilBreak = false;

	public static Queue<Point> ExploitDestroyQueue = new Queue<Point>();

	private static bool hardModeWorldUpdates = false;

	private static bool growGrassUnderground = false;

	private static bool _isRainingBoulders = false;

	private static List<Rectangle> _SpawnThunderStorm_SafeSpots = new List<Rectangle>();

	public const bool BUBBLES_SOLID_STATE_FOR_HOUSING = true;

	public static int grassSpread;

	private static Point[] heartPos = new Point[100];

	private static int heartCount;

	private const int strip_w = 200;

	private const int strip_h = 50;

	private static readonly Vertical64BitStrips bitStrip = new Vertical64BitStrips(202);

	public static bool _preventInfiniteRopeFraming = false;

	public static bool TransformingWorld => _transformingWorld > 0;

	public static UnifiedRandom genRand => Main.rand;

	public static double oceanLevel => (Main.worldSurface + Main.rockLayer) / 2.0 + 40.0;

	public static void SetupStatueList()
	{
		List<Point16> list = new List<Point16>();
		for (int i = 0; i < 44; i++)
		{
			list.Add(new Point16(105, i));
		}
		list[34] = new Point16(349, 0);
		list[43] = new Point16(105, 50);
		list.Add(new Point16(105, 63));
		list.Add(new Point16(105, 64));
		list.Add(new Point16(105, 65));
		list.Add(new Point16(105, 66));
		list.Add(new Point16(105, 68));
		list.Add(new Point16(105, 69));
		list.Add(new Point16(105, 70));
		list.Add(new Point16(105, 71));
		list.Add(new Point16(105, 72));
		list.Add(new Point16(105, 73));
		list.Add(new Point16(105, 75));
		list.Add(new Point16(105, 51));
		list.Add(new Point16(105, 52));
		list.Add(new Point16(105, 53));
		list.Add(new Point16(105, 54));
		list.Add(new Point16(105, 55));
		list.Add(new Point16(105, 56));
		list.Add(new Point16(105, 57));
		list.Add(new Point16(105, 58));
		list.Add(new Point16(105, 59));
		list.Add(new Point16(105, 60));
		list.Add(new Point16(105, 61));
		list.Add(new Point16(105, 62));
		list.Add(new Point16(105, 77));
		list.Add(new Point16(105, 78));
		list.Add(new Point16(105, 67));
		list.Add(new Point16(105, 74));
		list.Add(new Point16(105, 37));
		list.Add(new Point16(105, 2));
		GenVars.statueList = list.ToArray();
	}

	public static void PlaceStatueTrap(int x, int y)
	{
		if (SecretSeed.Variations.actuallyNoTrapsForRealIMeanIt || !InWorld(x, y, 20))
		{
			return;
		}
		for (int i = -10; i <= 10; i++)
		{
			for (int j = -10; j <= 10; j++)
			{
				Tile tile = Main.tile[x + i, y + j + 1];
				Tile tile2 = Main.tile[x + i, y + j];
				if (!tile2.active() && SolidTile2(tile) && tile.type != 162)
				{
					PlaceTile(x + i, y + j, 135, mute: true);
					if (tile2.active() && tile2.type == 135)
					{
						WorldUtils.WireLine(new Point(x, y), new Point(x + i, y + j));
						return;
					}
				}
			}
		}
	}

	private static EntitySource_TileBreak GetProjectileSource_TileBreak(int x, int y)
	{
		return new EntitySource_TileBreak(x, y);
	}

	private static EntitySource_TileBreak GetNPCSource_TileBreak(int x, int y)
	{
		return new EntitySource_TileBreak(x, y);
	}

	public static EntitySource_ShakeTree GetNPCSource_ShakeTree(int x, int y)
	{
		return new EntitySource_ShakeTree(x, y);
	}

	private static EntitySource_ShakeTree GetProjectileSource_ShakeTree(int x, int y)
	{
		return new EntitySource_ShakeTree(x, y);
	}

	private static EntitySource_ShakeTree GetItemSource_ShakeTree(int x, int y)
	{
		return new EntitySource_ShakeTree(x, y);
	}

	private static IEntitySource GetProjectileSource_PlayerOrWires(int x, int y, bool fromWiring, Player player)
	{
		if (fromWiring)
		{
			return new EntitySource_Wiring(x, y);
		}
		return new EntitySource_TileInteraction(player, x, y);
	}

	public static bool EmptyLiquid(int x, int y)
	{
		if (!InWorld(x, y))
		{
			return false;
		}
		Tile tile = Main.tile[x, y];
		if (tile == null)
		{
			return false;
		}
		tile.liquidType();
		if (tile.nactive() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type])
		{
			return false;
		}
		tile.Clear(TileDataType.Liquid);
		SquareTileFrame(x, y, resetFrame: false);
		if (Main.netMode != 0)
		{
			NetMessage.sendWater(x, y);
		}
		else
		{
			Liquid.AddWater(x, y);
		}
		return true;
	}

	public static bool PlaceLiquid(int x, int y, byte liquidType, byte amount)
	{
		if (!InWorld(x, y))
		{
			return false;
		}
		Tile tile = Main.tile[x, y];
		if (tile == null)
		{
			return false;
		}
		byte b = tile.liquidType();
		if (tile.nactive() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type])
		{
			return false;
		}
		if (tile.liquid == 0 || liquidType == b)
		{
			tile.liquidType(liquidType);
			if (amount + tile.liquid > 255)
			{
				amount = (byte)(255 - tile.liquid);
			}
			tile.liquid += amount;
			SquareTileFrame(x, y);
			if (Main.netMode != 0)
			{
				NetMessage.sendWater(x, y);
			}
			return true;
		}
		int liquidMergeTileType = 0;
		bool waterNearby = b == 0;
		bool lavaNearby = b == 1;
		bool honeyNearby = b == 2;
		bool shimmerNearby = b == 3;
		int liquidMergeType = 0;
		Liquid.GetLiquidMergeTypes(liquidType, out liquidMergeTileType, out liquidMergeType, waterNearby, lavaNearby, honeyNearby, shimmerNearby);
		if (liquidMergeTileType != 0)
		{
			tile.liquid = 0;
			tile.liquidType(0);
			PlaceTile(x, y, liquidMergeTileType, mute: true);
			SquareTileFrame(x, y);
			if (Main.netMode != 0)
			{
				NetMessage.SendTileSquare(-1, x, y, GetLiquidChangeType(liquidType, b));
			}
			return true;
		}
		return false;
	}

	public static void PlayLiquidChangeSound(TileChangeType eventType, int x, int y, int count = 1)
	{
		switch (eventType)
		{
		case TileChangeType.LavaWater:
			SoundEngine.PlaySound(SoundID.LiquidsWaterLava, x * 16 + count * 8, y * 16 + count * 8);
			break;
		case TileChangeType.HoneyWater:
			SoundEngine.PlaySound(SoundID.LiquidsHoneyWater, x * 16 + count * 8, y * 16 + count * 8);
			break;
		case TileChangeType.HoneyLava:
			SoundEngine.PlaySound(SoundID.LiquidsHoneyLava, x * 16 + count * 8, y * 16 + count * 8);
			break;
		case TileChangeType.ShimmerWater:
			SoundEngine.PlaySound(19, x * 16 + count * 8, y * 16 + count * 8, 4);
			break;
		case TileChangeType.ShimmerLava:
			SoundEngine.PlaySound(19, x * 16 + count * 8, y * 16 + count * 8, 4);
			break;
		case TileChangeType.ShimmerHoney:
			SoundEngine.PlaySound(19, x * 16 + count * 8, y * 16 + count * 8, 4);
			break;
		}
	}

	public static TileChangeType GetLiquidChangeType(int liquidType, int otherLiquidType)
	{
		if ((liquidType == 0 && otherLiquidType == 1) || (liquidType == 1 && otherLiquidType == 0))
		{
			return TileChangeType.LavaWater;
		}
		if ((liquidType == 0 && otherLiquidType == 2) || (liquidType == 2 && otherLiquidType == 0))
		{
			return TileChangeType.HoneyWater;
		}
		if ((liquidType == 1 && otherLiquidType == 2) || (liquidType == 2 && otherLiquidType == 1))
		{
			return TileChangeType.HoneyLava;
		}
		if ((liquidType == 0 && otherLiquidType == 3) || (liquidType == 3 && otherLiquidType == 0))
		{
			return TileChangeType.ShimmerWater;
		}
		if ((liquidType == 1 && otherLiquidType == 3) || (liquidType == 3 && otherLiquidType == 1))
		{
			return TileChangeType.ShimmerLava;
		}
		if ((liquidType == 2 && otherLiquidType == 3) || (liquidType == 3 && otherLiquidType == 2))
		{
			return TileChangeType.ShimmerHoney;
		}
		return TileChangeType.None;
	}

	public static bool MoveTownNPC(int x, int y, int n, IRoomCheckFeedback feedback = null)
	{
		if (feedback == null)
		{
			feedback = NoRoomCheckFeedback.WithText;
		}
		bool stopOnFail = feedback.StopOnFail;
		bool displayText = feedback.DisplayText;
		feedback.BeginSpread(x, y);
		bool num = StartRoomCheck(x, y, feedback);
		feedback.EndSpread();
		if (!num)
		{
			string newText = Lang.inter[40].Value;
			switch (roomCheckFailureReason)
			{
			case TownNPCRoomCheckFailureReason.TooManyUnsafeWalls:
				newText = Language.GetTextValue("TownNPCHousingFailureReasons.RoomHasUnsafeWalls");
				break;
			case TownNPCRoomCheckFailureReason.HoleInWallIsTooBig:
				newText = Language.GetTextValue("TownNPCHousingFailureReasons.HoleInWallIsTooBig");
				break;
			case TownNPCRoomCheckFailureReason.RoomCheckStartedInASolidTile:
				newText = Language.GetTextValue("TownNPCHousingFailureReasons.RoomCheckStartedInASolidTile");
				break;
			case TownNPCRoomCheckFailureReason.RoomIsTooBig:
				newText = Language.GetTextValue("TownNPCHousingFailureReasons.RoomIsTooBig");
				break;
			case TownNPCRoomCheckFailureReason.RoomIsTooSmall:
				newText = Language.GetTextValue("TownNPCHousingFailureReasons.RoomIsTooSmall");
				break;
			case TownNPCRoomCheckFailureReason.TooCloseToWorldEdge:
				newText = Language.GetTextValue("TownNPCHousingFailureReasons.TooCloseToWorldEdge");
				break;
			}
			if (displayText)
			{
				Main.NewText(newText, byte.MaxValue, 240, 20);
			}
			if (stopOnFail)
			{
				return false;
			}
		}
		if (!RoomNeeds())
		{
			int num2 = 0;
			int num3 = ((!roomTorch) ? 1 : 0) + ((!roomDoor) ? 1 : 0) + ((!roomTable) ? 1 : 0) + ((!roomChair) ? 1 : 0);
			string[] array = new string[num3];
			if (!roomTorch)
			{
				array[num2] = Language.GetTextValue("Game.HouseLightSource");
				num2++;
			}
			if (!roomDoor)
			{
				array[num2] = Language.GetTextValue("Game.HouseDoor");
				num2++;
			}
			if (!roomTable)
			{
				array[num2] = Language.GetTextValue("Game.HouseTable");
				num2++;
			}
			if (!roomChair)
			{
				array[num2] = Language.GetTextValue("Game.HouseChair");
				num2++;
			}
			string key = "Game.HouseMissing_" + num3;
			object[] args = array;
			string textValue = Language.GetTextValue(key, args);
			if (!roomTable || !roomChair)
			{
				builtHouseWithNoFurniture = true;
			}
			if (!roomTorch)
			{
				builtHouseWithNoLight = true;
			}
			if (displayText)
			{
				Main.NewText(textValue, byte.MaxValue, 240, 20);
			}
			if (stopOnFail)
			{
				return false;
			}
		}
		int type = prioritizedTownNPCType;
		if (n >= 0)
		{
			type = Main.npc[n].type;
		}
		bool flag = NPCID.Sets.IsTownPet[type];
		if (roomHasStinkbug && !flag)
		{
			if (displayText)
			{
				Main.NewText(Language.GetTextValue("TownNPCHousingFailureReasons.RoomHasAStinkbug"), byte.MaxValue, 240, 20);
			}
			if (stopOnFail)
			{
				return false;
			}
		}
		if (roomHasEchoStinkbug && !flag)
		{
			if (displayText)
			{
				Main.NewText(Language.GetTextValue("TownNPCHousingFailureReasons.RoomHasAnEchoStinkbug"), byte.MaxValue, 240, 20);
			}
			if (stopOnFail)
			{
				return false;
			}
		}
		feedback.BeginScoring();
		ScoreRoom(-1, type, feedback);
		feedback.EndScoring();
		if (hiScore <= 0)
		{
			if (displayText)
			{
				if (roomOccupied)
				{
					Main.NewText(Lang.inter[41].Value, byte.MaxValue, 240, 20);
				}
				else if (roomEvil)
				{
					Main.NewText(Lang.inter[42].Value, byte.MaxValue, 240, 20);
				}
				else if (!roomHasStandingSpace)
				{
					Main.NewText(Language.GetTextValue("TownNPCHousingFailureReasons.RoomHasNoStandingSpace"), byte.MaxValue, 240, 20);
				}
				else
				{
					Main.NewText(Lang.inter[40].Value, byte.MaxValue, 240, 20);
				}
			}
			if (stopOnFail)
			{
				return false;
			}
		}
		if (n >= 0 && !CheckSpecialTownNPCSpawningConditions(Main.npc[n].type))
		{
			if (displayText)
			{
				Main.NewText(Lang.inter[55].Value + " " + Main.npc[n].TypeName, byte.MaxValue, 240, 20);
			}
			if (stopOnFail)
			{
				return false;
			}
		}
		return true;
	}

	public static void moveRoom(int x, int y, int n)
	{
		if (Main.netMode == 1)
		{
			NetMessage.SendData(60, -1, -1, null, n, x, y);
			return;
		}
		prioritizedTownNPCType = Main.npc[n].type;
		Main.npc[n].homeless = true;
		Main.npc[n].lookForHomeTimeout = 0;
		SpawnTownNPC(x, y);
		TownManager.SetRoom(Main.npc[n].type, Main.npc[n].homeTileX, Main.npc[n].homeTileY);
	}

	public static bool IsNPCEvictable(int n)
	{
		if (n < 0)
		{
			return false;
		}
		Rectangle hitbox = Main.LocalPlayer.Hitbox;
		hitbox.Inflate(Main.MaxWorldViewSize.X / 2, Main.MaxWorldViewSize.Y / 2);
		NPC nPC = Main.npc[n];
		Rectangle value = new Rectangle(nPC.homeTileX * 16, nPC.homeTileY * 16, 16, 16);
		return hitbox.Intersects(value);
	}

	public static void kickOut(int n)
	{
		if (Main.netMode == 1)
		{
			NetMessage.SendData(60, -1, -1, null, n, 0f, 0f, 1f);
			return;
		}
		Main.npc[n].homeless = true;
		Main.npc[n].lookForHomeTimeout = NPC.KickOutLookForHomeTimeout;
		TownManager.KickOut(Main.npc[n]);
	}

	public static int IsThereASpawnablePrioritizedTownNPC(int x, int y)
	{
		List<int> list = new List<int>();
		TownManager.AddOccupantsToList(x, y, list);
		for (int i = 0; i < list.Count; i++)
		{
			int num = list[i];
			if (Main.townNPCCanSpawn[num] && !NPC.AnyNPCs(num) && CheckSpecialTownNPCSpawningConditions(num))
			{
				return num;
			}
		}
		int result = -1;
		for (int j = 0; j < NPCID.Count; j++)
		{
			if (!Main.townNPCCanSpawn[j] || !CheckSpecialTownNPCSpawningConditions(j))
			{
				continue;
			}
			if (NPC.AnyNPCs(j))
			{
				Main.townNPCCanSpawn[j] = false;
				continue;
			}
			if (TownManager.HasRoomQuick(j))
			{
				return j;
			}
			if (NPCID.Sets.IsTownPet[j])
			{
				return j;
			}
			if (j == prioritizedTownNPCType)
			{
				result = j;
			}
		}
		return result;
	}

	public static bool IsThereASpawnablePrioritizedTownNPC_Old(int x, int y)
	{
		if (CheckSpecialTownNPCSpawningConditions(prioritizedTownNPCType) && NPC.AnyNPCs(prioritizedTownNPCType))
		{
			return true;
		}
		List<int> list = new List<int>();
		TownManager.AddOccupantsToList(x, y, list);
		for (int i = 0; i < list.Count; i++)
		{
			int num = list[i];
			if (Main.townNPCCanSpawn[num] && !NPC.AnyNPCs(num) && CheckSpecialTownNPCSpawningConditions(num))
			{
				prioritizedTownNPCType = num;
				return true;
			}
		}
		int num2 = -1;
		for (int j = 0; j < NPCID.Count; j++)
		{
			if (!Main.townNPCCanSpawn[j] || !CheckSpecialTownNPCSpawningConditions(j))
			{
				continue;
			}
			if (NPC.AnyNPCs(j))
			{
				Main.townNPCCanSpawn[j] = false;
			}
			else if (TownManager.HasRoomQuick(j))
			{
				if (num2 == -1)
				{
					num2 = j;
				}
			}
			else if (!NPCID.Sets.IsTownPet[prioritizedTownNPCType] || NPCID.Sets.IsTownPet[j])
			{
				prioritizedTownNPCType = j;
				return true;
			}
		}
		if (num2 != -1)
		{
			prioritizedTownNPCType = num2;
			return true;
		}
		return false;
	}

	public static bool CheckSpecialTownNPCSpawningConditions(int type)
	{
		if (type == 160)
		{
			if (!NPC.unlockedTruffleSpawn && ((double)roomY2 > Main.worldSurface || SecretSeed.noSurface.Enabled))
			{
				return false;
			}
			Housing_GetTestedRoomBounds(out var startX, out var endX, out var startY, out var endY);
			int num = 0;
			for (int i = startX + 1; i < endX; i++)
			{
				for (int j = startY + 2; j < endY + 2; j++)
				{
					Tile tile = Main.tile[i, j];
					if (tile.active() && (tile.type == 70 || tile.type == 71 || tile.type == 72 || tile.type == 528))
					{
						num++;
					}
				}
			}
			if (num >= SceneMetrics.MushroomTileThreshold)
			{
				return true;
			}
			return false;
		}
		return true;
	}

	public static void UnspawnTravelNPC()
	{
		int num = -1;
		for (int i = 0; i < Main.maxNPCs; i++)
		{
			if (Main.npc[i].active && Main.npc[i].type == 368)
			{
				num = i;
				break;
			}
		}
		if (num < 0)
		{
			return;
		}
		int num2 = (int)(Main.npc[num].Center.X / 16f);
		int num3 = (int)(Main.npc[num].Center.Y / 16f);
		bool flag = true;
		Rectangle value = new Rectangle(num2 * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, num3 * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
		for (int j = 0; j < 255; j++)
		{
			if (Main.player[j].active && new Rectangle((int)Main.player[j].position.X, (int)Main.player[j].position.Y, Main.player[j].width, Main.player[j].height).Intersects(value))
			{
				flag = false;
				break;
			}
		}
		if (flag)
		{
			string fullName = Main.npc[num].FullName;
			if (Main.netMode == 0)
			{
				Main.NewText(Lang.misc[35].Format(fullName), 50, 125);
			}
			else if (Main.netMode == 2)
			{
				ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[35].Key, Main.npc[num].GetFullNetName()), new Color(50, 125, 255));
			}
			Main.npc[num].active = false;
			Main.npc[num].life = 0;
			NetMessage.SendData(23, -1, -1, null, num);
		}
	}

	public static void SpawnHomelessNPC()
	{
		if (Main.eclipse || !Main.dayTime || (Main.invasionType > 0 && Main.invasionDelay == 0 && Main.invasionSize > 0) || prioritizedTownNPCType == 0 || FindAnyHomelessTownNPC(includeGuide: true) != -1)
		{
			return;
		}
		for (int i = 0; i < Main.maxNPCs; i++)
		{
			if (Main.npc[i].active && Main.npc[i].type == prioritizedTownNPCType)
			{
				return;
			}
		}
		bool flag = Main.tileSolid[379];
		Main.tileSolid[379] = true;
		try
		{
			if (SpawnTownNPC(LastFoundHouse.X, LastFoundHouse.Y) == TownNPCSpawnResult.Successful)
			{
				return;
			}
		}
		finally
		{
			Main.tileSolid[379] = flag;
		}
		_ = Point.Zero;
		int[] array = new int[Main.maxNPCs];
		Point[] array2 = new Point[Main.maxNPCs];
		int num = 0;
		for (int j = 0; j < Main.maxNPCs; j++)
		{
			NPC nPC = Main.npc[j];
			if (nPC.active && nPC.townNPC && nPC.type != 37 && !nPC.homeless)
			{
				array[num] = j;
				array2[num] = new Point(nPC.homeTileX, nPC.homeTileY);
				num++;
			}
		}
		if (num == 0)
		{
			return;
		}
		int num2 = Main.rand.Next(num);
		_ = array[num2];
		Point point = array2[num2];
		bestX = point.X;
		bestY = point.Y;
		int minValue = bestX;
		int num3 = bestX;
		int num4 = bestY;
		int num5 = bestX;
		while (num5 > bestX - 10 && (SolidTile(num5, num4) || Main.tileSolidTop[Main.tile[num5, num4].type]) && (!Main.tile[num5, num4 - 1].active() || !Main.tileSolid[Main.tile[num5, num4 - 1].type] || Main.tileSolidTop[Main.tile[num5, num4 - 1].type]) && (!Main.tile[num5, num4 - 2].active() || !Main.tileSolid[Main.tile[num5, num4 - 2].type] || Main.tileSolidTop[Main.tile[num5, num4 - 2].type]) && (!Main.tile[num5, num4 - 3].active() || !Main.tileSolid[Main.tile[num5, num4 - 3].type] || Main.tileSolidTop[Main.tile[num5, num4 - 3].type]))
		{
			minValue = num5;
			num5--;
		}
		for (int k = bestX; k < bestX + 10 && (SolidTile(k, num4) || Main.tileSolidTop[Main.tile[k, num4].type]) && (!Main.tile[k, num4 - 1].active() || !Main.tileSolid[Main.tile[k, num4 - 1].type] || Main.tileSolidTop[Main.tile[k, num4 - 1].type]) && (!Main.tile[k, num4 - 2].active() || !Main.tileSolid[Main.tile[k, num4 - 2].type] || Main.tileSolidTop[Main.tile[k, num4 - 2].type]) && (!Main.tile[k, num4 - 3].active() || !Main.tileSolid[Main.tile[k, num4 - 3].type] || Main.tileSolidTop[Main.tile[k, num4 - 3].type]); k++)
		{
			num3 = k;
		}
		for (int l = 0; l < 30; l++)
		{
			int num6 = Main.rand.Next(minValue, num3 + 1);
			if (l < 20)
			{
				if (num6 < bestX - 1 || num6 > bestX + 1)
				{
					bestX = num6;
					break;
				}
			}
			else if (num6 != bestX)
			{
				bestX = num6;
				break;
			}
		}
		int num7 = bestX;
		int num8 = bestY;
		bool flag2 = false;
		if (!flag2 && !((double)num8 > Main.worldSurface))
		{
			for (int m = 20; m < 500; m++)
			{
				for (int n = 0; n < 2; n++)
				{
					num7 = ((n != 0) ? (bestX - m * 2) : (bestX + m * 2));
					if (num7 > 10 && num7 < Main.maxTilesX - 10)
					{
						int num9 = bestY - m;
						double num10 = bestY + m;
						if (num9 < 10)
						{
							num9 = 10;
						}
						if (num10 > Main.worldSurface)
						{
							num10 = Main.worldSurface;
						}
						for (int num11 = num9; (double)num11 < num10; num11++)
						{
							num8 = num11;
							if (!Main.tile[num7, num8].nactive() || !Main.tileSolid[Main.tile[num7, num8].type])
							{
								continue;
							}
							if (Main.tile[num7, num8 - 3].liquid != 0 || Main.tile[num7, num8 - 2].liquid != 0 || Main.tile[num7, num8 - 1].liquid != 0 || Collision.SolidTiles(num7 - 1, num7 + 1, num8 - 3, num8 - 1))
							{
								break;
							}
							flag2 = true;
							Rectangle value = new Rectangle(num7 * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, num8 * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
							for (int num12 = 0; num12 < 255; num12++)
							{
								if (Main.player[num12].active && new Rectangle((int)Main.player[num12].position.X, (int)Main.player[num12].position.Y, Main.player[num12].width, Main.player[num12].height).Intersects(value))
								{
									flag2 = false;
									break;
								}
							}
							break;
						}
					}
					if (flag2)
					{
						break;
					}
				}
				if (flag2)
				{
					break;
				}
			}
		}
		int num13 = NPC.NewNPC(NPC.GetSpawnSourceForTownSpawn(), num7 * 16, num8 * 16, prioritizedTownNPCType, 1);
		Main.npc[num13].homeTileX = bestX;
		Main.npc[num13].homeTileY = bestY;
		Main.npc[num13].homeless = true;
		Main.npc[num13].homelessDespawn = true;
		if (num7 < bestX)
		{
			Main.npc[num13].direction = 1;
		}
		else if (num7 > bestX)
		{
			Main.npc[num13].direction = -1;
		}
		Main.npc[num13].netUpdate = true;
		QuickFindHome(num13);
		int num14 = Main.rand.Next(6);
		string fullName = Main.npc[num13].FullName;
		string key = ((!Main.npc[num13].homeless) ? "Announcement.HasArrived" : ("Announcement.HomelessArrived_" + num14));
		if (Main.netMode == 0)
		{
			Main.NewText(Language.GetTextValue(key, fullName), 50, 125);
		}
		else if (Main.netMode == 2)
		{
			ChatHelper.BroadcastChatMessage(NetworkText.FromKey(key, Main.npc[num13].GetFullNetName()), new Color(50, 125, 255));
		}
	}

	public static void UnspawnHomelessNPC()
	{
		int num = -1;
		for (int i = 0; i < Main.maxNPCs; i++)
		{
			if (Main.npc[i].active && Main.npc[i].homelessDespawn)
			{
				num = i;
				break;
			}
		}
		if (num == -1)
		{
			return;
		}
		if (!Main.npc[num].homeless || !Main.npc[num].active || !Main.npc[num].townNPC)
		{
			Main.npc[num].homelessDespawn = false;
			num = -1;
		}
		if (num == -1)
		{
			return;
		}
		int num2 = (int)(Main.npc[num].Center.X / 16f);
		int num3 = (int)(Main.npc[num].Center.Y / 16f);
		bool flag = true;
		Rectangle value = new Rectangle(num2 * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, num3 * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
		for (int j = 0; j < 255; j++)
		{
			if (Main.player[j].active && new Rectangle((int)Main.player[j].position.X, (int)Main.player[j].position.Y, Main.player[j].width, Main.player[j].height).Intersects(value))
			{
				flag = false;
				break;
			}
		}
		if (flag)
		{
			string fullName = Main.npc[num].FullName;
			if (Main.netMode == 0)
			{
				Main.NewText(Lang.misc[35].Format(fullName), 50, 125);
			}
			else if (Main.netMode == 2)
			{
				ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[35].Key, Main.npc[num].GetFullNetName()), new Color(50, 125, 255));
			}
			Main.npc[num].active = false;
			Main.npc[num].life = 0;
			NetMessage.SendData(23, -1, -1, null, num);
		}
	}

	public static void SpawnTravelNPC()
	{
		if (Main.eclipse || !Main.dayTime || (Main.invasionType > 0 && Main.invasionDelay == 0 && Main.invasionSize > 0))
		{
			return;
		}
		for (int i = 0; i < Main.maxNPCs; i++)
		{
			if (Main.npc[i].active && Main.npc[i].type == 368)
			{
				return;
			}
		}
		Chest.SetupTravelShop();
		NetMessage.SendTravelShop(-1);
		_ = Point.Zero;
		int[] array = new int[Main.maxNPCs];
		Point[] array2 = new Point[Main.maxNPCs];
		int num = 0;
		for (int j = 0; j < Main.maxNPCs; j++)
		{
			NPC nPC = Main.npc[j];
			if (nPC.active && nPC.townNPC && nPC.type != 37 && !nPC.homeless)
			{
				array[num] = j;
				array2[num] = new Point(nPC.homeTileX, nPC.homeTileY);
				num++;
			}
		}
		if (num == 0)
		{
			for (int k = 0; k < Main.maxNPCs; k++)
			{
				NPC nPC2 = Main.npc[k];
				if (nPC2.active && nPC2.townNPC && nPC2.type != 37 && nPC2.homeless)
				{
					Point roomPosition = Point.Zero;
					if (TownManager.HasRoom(nPC2.type, out roomPosition))
					{
						array[num] = k;
						array2[num] = roomPosition;
						num++;
					}
				}
			}
		}
		if (num == 0)
		{
			return;
		}
		int num2 = Main.rand.Next(num);
		_ = array[num2];
		Point point = array2[num2];
		bestX = point.X;
		bestY = point.Y;
		int minValue = bestX;
		int num3 = bestX;
		int num4 = bestY;
		int num5 = bestX;
		while (num5 > bestX - 10 && (SolidTile(num5, num4) || Main.tileSolidTop[Main.tile[num5, num4].type]) && (!Main.tile[num5, num4 - 1].active() || !Main.tileSolid[Main.tile[num5, num4 - 1].type] || Main.tileSolidTop[Main.tile[num5, num4 - 1].type]) && (!Main.tile[num5, num4 - 2].active() || !Main.tileSolid[Main.tile[num5, num4 - 2].type] || Main.tileSolidTop[Main.tile[num5, num4 - 2].type]) && (!Main.tile[num5, num4 - 3].active() || !Main.tileSolid[Main.tile[num5, num4 - 3].type] || Main.tileSolidTop[Main.tile[num5, num4 - 3].type]))
		{
			minValue = num5;
			num5--;
		}
		for (int l = bestX; l < bestX + 10 && (SolidTile(l, num4) || Main.tileSolidTop[Main.tile[l, num4].type]) && (!Main.tile[l, num4 - 1].active() || !Main.tileSolid[Main.tile[l, num4 - 1].type] || Main.tileSolidTop[Main.tile[l, num4 - 1].type]) && (!Main.tile[l, num4 - 2].active() || !Main.tileSolid[Main.tile[l, num4 - 2].type] || Main.tileSolidTop[Main.tile[l, num4 - 2].type]) && (!Main.tile[l, num4 - 3].active() || !Main.tileSolid[Main.tile[l, num4 - 3].type] || Main.tileSolidTop[Main.tile[l, num4 - 3].type]); l++)
		{
			num3 = l;
		}
		for (int m = 0; m < 30; m++)
		{
			int num6 = Main.rand.Next(minValue, num3 + 1);
			if (m < 20)
			{
				if (num6 < bestX - 1 || num6 > bestX + 1)
				{
					bestX = num6;
					break;
				}
			}
			else if (num6 != bestX)
			{
				bestX = num6;
				break;
			}
		}
		int num7 = bestX;
		int num8 = bestY;
		bool flag = false;
		if (!flag && !((double)num8 > Main.worldSurface))
		{
			for (int n = 20; n < 500; n++)
			{
				for (int num9 = 0; num9 < 2; num9++)
				{
					num7 = ((num9 != 0) ? (bestX - n * 2) : (bestX + n * 2));
					if (num7 > 10 && num7 < Main.maxTilesX - 10)
					{
						int num10 = bestY - n;
						double num11 = bestY + n;
						if (num10 < 10)
						{
							num10 = 10;
						}
						if (num11 > Main.worldSurface)
						{
							num11 = Main.worldSurface;
						}
						for (int num12 = num10; (double)num12 < num11; num12++)
						{
							num8 = num12;
							if (!Main.tile[num7, num8].nactive() || !Main.tileSolid[Main.tile[num7, num8].type])
							{
								continue;
							}
							if (Main.tile[num7, num8 - 3].liquid != 0 || Main.tile[num7, num8 - 2].liquid != 0 || Main.tile[num7, num8 - 1].liquid != 0 || Collision.SolidTiles(num7 - 1, num7 + 1, num8 - 3, num8 - 1))
							{
								break;
							}
							flag = true;
							Rectangle value = new Rectangle(num7 * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, num8 * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
							for (int num13 = 0; num13 < 255; num13++)
							{
								if (Main.player[num13].active && new Rectangle((int)Main.player[num13].position.X, (int)Main.player[num13].position.Y, Main.player[num13].width, Main.player[num13].height).Intersects(value))
								{
									flag = false;
									break;
								}
							}
							break;
						}
					}
					if (flag)
					{
						break;
					}
				}
				if (flag)
				{
					break;
				}
			}
		}
		int num14 = NPC.NewNPC(NPC.GetSpawnSourceForTownSpawn(), num7 * 16, num8 * 16, 368, 1);
		Main.npc[num14].homeTileX = bestX;
		Main.npc[num14].homeTileY = bestY;
		Main.npc[num14].homeless = true;
		if (num7 < bestX)
		{
			Main.npc[num14].direction = 1;
		}
		else if (num7 > bestX)
		{
			Main.npc[num14].direction = -1;
		}
		Main.npc[num14].netUpdate = true;
		string fullName = Main.npc[num14].FullName;
		if (Main.netMode == 0)
		{
			Main.NewText(Language.GetTextValue("Announcement.HasArrived", fullName), 50, 125);
		}
		else if (Main.netMode == 2)
		{
			ChatHelper.BroadcastChatMessage(NetworkText.FromKey("Announcement.HasArrived", Main.npc[num14].GetFullNetName()), new Color(50, 125, 255));
		}
	}

	public static TownNPCSpawnResult SpawnTownNPC(int x, int y, bool canSpawnNewTownNPC = true)
	{
		if (Main.wallHouse[Main.tile[x, y].wall])
		{
			canSpawn = true;
		}
		if (!canSpawn)
		{
			return TownNPCSpawnResult.Blocked;
		}
		if (!StartRoomCheck(x, y))
		{
			return TownNPCSpawnResult.Blocked;
		}
		if (!RoomNeeds())
		{
			return TownNPCSpawnResult.Blocked;
		}
		int num = prioritizedTownNPCType;
		int num2 = FindNPCLookingForHomeThatCanMoveIn(num);
		Point roomPosition = Point.Zero;
		bool flag = NPCID.Sets.IsTownPet[num] && TownManager.HasRoom(num, out roomPosition);
		if ((roomHasStinkbug || roomHasEchoStinkbug) && !flag)
		{
			return TownNPCSpawnResult.Blocked;
		}
		ScoreRoom(-1, num);
		if (hiScore <= 0)
		{
			return TownNPCSpawnResult.Blocked;
		}
		if (CheckSpecialTownNPCSpawningConditions(prioritizedTownNPCType) && NPC.AnyNPCs(prioritizedTownNPCType))
		{
			canSpawnNewTownNPC = false;
		}
		else
		{
			num2 = -1;
			if (canSpawnNewTownNPC)
			{
				num = IsThereASpawnablePrioritizedTownNPC(bestX, bestY);
				canSpawnNewTownNPC = num > 0;
			}
		}
		if (num2 != -1)
		{
			Main.townNPCCanSpawn[prioritizedTownNPCType] = false;
			Main.npc[num2].homeTileX = bestX;
			Main.npc[num2].homeTileY = bestY;
			Main.npc[num2].homeless = false;
			Main.npc[num2].homelessDespawn = false;
			AchievementsHelper.NotifyProgressionEvent(8);
			prioritizedTownNPCType = 0;
			return TownNPCSpawnResult.RelocatedHomeless;
		}
		if (NPC.AnyNPCs(prioritizedTownNPCType))
		{
			canSpawnNewTownNPC = false;
		}
		if (canSpawnNewTownNPC)
		{
			if (TownManager.HasRoom(num, out var roomPosition2) && !currentlyTryingToUseAlternateHousingSpot)
			{
				int num3 = bestX;
				int num4 = bestY;
				currentlyTryingToUseAlternateHousingSpot = true;
				TownNPCSpawnResult townNPCSpawnResult = SpawnTownNPC(roomPosition2.X, roomPosition2.Y - 2);
				currentlyTryingToUseAlternateHousingSpot = false;
				bestX = num3;
				bestY = num4;
				if (townNPCSpawnResult == TownNPCSpawnResult.Successful)
				{
					return townNPCSpawnResult;
				}
			}
			int num5 = bestX;
			int num6 = bestY;
			int npcTypeToSpawn = prioritizedTownNPCType;
			if (IsRoomConsideredAlreadyOccupied(num5, num6, npcTypeToSpawn))
			{
				return TownNPCSpawnResult.BlockedInfiHousing;
			}
			bool flag2 = false;
			if (!flag2)
			{
				flag2 = true;
				Rectangle value = new Rectangle(num5 * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, num6 * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
				for (int i = 0; i < 255; i++)
				{
					if (Main.player[i].active && new Rectangle((int)Main.player[i].position.X, (int)Main.player[i].position.Y, Main.player[i].width, Main.player[i].height).Intersects(value))
					{
						flag2 = false;
						break;
					}
				}
			}
			if (!flag2 && !((double)num6 > Main.worldSurface))
			{
				for (int j = 1; j < 500; j++)
				{
					for (int k = 0; k < 2; k++)
					{
						num5 = ((k != 0) ? (bestX - j) : (bestX + j));
						if (num5 > 10 && num5 < Main.maxTilesX - 10)
						{
							int num7 = bestY - j;
							double num8 = bestY + j;
							if (num7 < 10)
							{
								num7 = 10;
							}
							if (num8 > Main.worldSurface)
							{
								num8 = Main.worldSurface;
							}
							for (int l = num7; (double)l < num8; l++)
							{
								num6 = l;
								if (!Main.tile[num5, num6].nactive() || !Main.tileSolid[Main.tile[num5, num6].type])
								{
									continue;
								}
								if (Collision.SolidTiles(num5 - 1, num5 + 1, num6 - 3, num6 - 1))
								{
									break;
								}
								flag2 = true;
								Rectangle value2 = new Rectangle(num5 * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, num6 * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
								for (int m = 0; m < 255; m++)
								{
									if (Main.player[m].active && new Rectangle((int)Main.player[m].position.X, (int)Main.player[m].position.Y, Main.player[m].width, Main.player[m].height).Intersects(value2))
									{
										flag2 = false;
										break;
									}
								}
								break;
							}
						}
						if (flag2)
						{
							break;
						}
					}
					if (flag2)
					{
						break;
					}
				}
			}
			int num9 = NPC.NewNPC(NPC.GetSpawnSourceForTownSpawn(), num5 * 16, num6 * 16, num, 1);
			if (num9 == Main.maxNPCs && Main.npc[num9].type != num)
			{
				return TownNPCSpawnResult.BlockedTooManyNPCs;
			}
			Main.townNPCCanSpawn[num] = false;
			Main.npc[num9].homeTileX = bestX;
			Main.npc[num9].homeTileY = bestY;
			if (num5 < bestX)
			{
				Main.npc[num9].direction = 1;
			}
			else if (num5 > bestX)
			{
				Main.npc[num9].direction = -1;
			}
			Main.npc[num9].netUpdate = true;
			string fullName = Main.npc[num9].FullName;
			if (Main.netMode == 0)
			{
				Main.NewText(Language.GetTextValue("Announcement.HasArrived", fullName), 50, 125);
			}
			else if (Main.netMode == 2)
			{
				ChatHelper.BroadcastChatMessage(NetworkText.FromKey("Announcement.HasArrived", Main.npc[num9].GetFullNetName()), new Color(50, 125, 255));
			}
			AchievementsHelper.NotifyProgressionEvent(8);
			switch (Main.npc[num9].type)
			{
			case 160:
				AchievementsHelper.NotifyProgressionEvent(18);
				NPC.unlockedTruffleSpawn = true;
				NetMessage.SendData(7);
				break;
			case 17:
				NPC.unlockedMerchantSpawn = true;
				break;
			case 207:
				NPC.unlockedDyeTraderSpawn = true;
				break;
			case 18:
				NPC.unlockedNurseSpawn = true;
				break;
			case 19:
				NPC.unlockedArmsDealerSpawn = true;
				break;
			case 38:
				NPC.unlockedDemolitionistSpawn = true;
				break;
			case 208:
				NPC.unlockedPartyGirlSpawn = true;
				break;
			case 663:
				NPC.unlockedPrincessSpawn = true;
				break;
			case 678:
				NPC.unlockedSlimeGreenSpawn = true;
				break;
			}
			CheckAchievement_RealEstateAndTownSlimes();
			prioritizedTownNPCType = 0;
			return TownNPCSpawnResult.Successful;
		}
		LastFoundHouse = new Point(x, y);
		return TownNPCSpawnResult.FoundHouseNoSpawn;
	}

	private static int FindNPCLookingForHomeThatCanMoveIn(int npcType)
	{
		for (int i = 0; i < Main.maxNPCs; i++)
		{
			if (Main.npc[i].active && Main.npc[i].homeless && Main.npc[i].type == npcType && Main.npc[i].lookForHomeTimeout == 0 && CheckSpecialTownNPCSpawningConditions(Main.npc[i].type))
			{
				return i;
			}
		}
		return -1;
	}

	private static int FindAnyHomelessTownNPC(bool includeGuide)
	{
		int result = -1;
		for (int i = 0; i < Main.maxNPCs; i++)
		{
			if (Main.npc[i].active && Main.npc[i].townNPC && Main.npc[i].homeless && Main.npc[i].type != 37 && Main.npc[i].type != 453 && Main.npc[i].type != 368 && (includeGuide || Main.npc[i].type != 22))
			{
				result = i;
				break;
			}
		}
		return result;
	}

	private static bool IsRoomConsideredAlreadyOccupied(int spawnTileX, int spawnTileY, int npcTypeToSpawn)
	{
		bool result = false;
		for (int i = 0; i < Main.maxNPCs; i++)
		{
			NPC nPC = Main.npc[i];
			if (nPC.active && nPC.townNPC && !nPC.homeless && nPC.homeTileX == spawnTileX && nPC.homeTileY == spawnTileY && !TownManager.CanNPCsLiveWithEachOther(npcTypeToSpawn, nPC))
			{
				result = true;
				break;
			}
		}
		return result;
	}

	public static void CheckAchievement_RealEstateAndTownSlimes()
	{
		bool[] array = new bool[NPCID.Count];
		for (int i = 0; i < Main.maxNPCs; i++)
		{
			if (Main.npc[i].active && Main.npc[i].type >= 0 && Main.npc[i].type < NPCID.Count)
			{
				array[Main.npc[i].type] = true;
			}
		}
		if (array[38] && array[17] && array[107] && array[19] && array[22] && array[124] && array[228] && array[178] && array[18] && array[229] && array[209] && array[54] && array[108] && array[160] && array[20] && array[369] && array[207] && array[227] && array[208] && array[441] && array[353] && array[550] && array[588] && array[633] && array[663])
		{
			AchievementsHelper.NotifyProgressionEvent(17);
		}
		if (array[670] && array[678] && array[679] && array[680] && array[681] && array[682] && array[683] && array[684])
		{
			AchievementsHelper.NotifyProgressionEvent(26);
		}
	}

	public static bool RoomNeeds()
	{
		roomChair = false;
		roomDoor = false;
		roomTable = false;
		roomTorch = false;
		for (int i = 0; i < TileID.Sets.RoomNeeds.CountsAsChairTypes.Length; i++)
		{
			if (houseTile[TileID.Sets.RoomNeeds.CountsAsChairTypes[i]])
			{
				roomChair = true;
				break;
			}
		}
		for (int j = 0; j < TileID.Sets.RoomNeeds.CountsAsTableTypes.Length; j++)
		{
			if (houseTile[TileID.Sets.RoomNeeds.CountsAsTableTypes[j]])
			{
				roomTable = true;
				break;
			}
		}
		for (int k = 0; k < TileID.Sets.RoomNeeds.CountsAsTorchTypes.Length; k++)
		{
			if (houseTile[TileID.Sets.RoomNeeds.CountsAsTorchTypes[k]])
			{
				roomTorch = true;
				break;
			}
		}
		for (int l = 0; l < TileID.Sets.RoomNeeds.CountsAsDoorTypes.Length; l++)
		{
			if (houseTile[TileID.Sets.RoomNeeds.CountsAsDoorTypes[l]])
			{
				roomDoor = true;
				break;
			}
		}
		if (roomChair && roomTable && roomDoor && roomTorch)
		{
			canSpawn = true;
		}
		else
		{
			canSpawn = false;
		}
		return canSpawn;
	}

	public static void QuickFindHome(int npc)
	{
		bool flag = Main.tileSolid[379];
		Main.tileSolid[379] = true;
		if (Main.npc[npc].homeTileX > 10 && Main.npc[npc].homeTileY > 10 && Main.npc[npc].homeTileX < Main.maxTilesX - 10 && Main.npc[npc].homeTileY < Main.maxTilesY)
		{
			canSpawn = false;
			StartRoomCheck(Main.npc[npc].homeTileX, Main.npc[npc].homeTileY - 1);
			if (!canSpawn)
			{
				for (int i = Main.npc[npc].homeTileX - 1; i < Main.npc[npc].homeTileX + 2; i++)
				{
					for (int j = Main.npc[npc].homeTileY - 1; j < Main.npc[npc].homeTileY + 2 && !StartRoomCheck(i, j); j++)
					{
					}
				}
			}
			if (!canSpawn)
			{
				int num = 10;
				for (int k = Main.npc[npc].homeTileX - num; k <= Main.npc[npc].homeTileX + num; k += 2)
				{
					for (int l = Main.npc[npc].homeTileY - num; l <= Main.npc[npc].homeTileY + num && !StartRoomCheck(k, l); l += 2)
					{
					}
				}
			}
			if (!CheckSpecialTownNPCSpawningConditions(Main.npc[npc].type))
			{
				canSpawn = false;
			}
			if (canSpawn)
			{
				RoomNeeds();
				if (canSpawn)
				{
					ScoreRoom(npc, Main.npc[npc].type);
				}
				if (canSpawn && hiScore > 0)
				{
					canSpawn = IsRoomConsideredOccupiedForNPCIndex(npc);
				}
				if (canSpawn && hiScore > 0)
				{
					Main.npc[npc].homeTileX = bestX;
					Main.npc[npc].homeTileY = bestY;
					Main.npc[npc].homeless = false;
					Main.npc[npc].homelessDespawn = false;
					AchievementsHelper.NotifyProgressionEvent(8);
					canSpawn = false;
				}
				else
				{
					Main.npc[npc].homeless = true;
				}
			}
			else
			{
				Main.npc[npc].homeless = true;
			}
		}
		Main.tileSolid[379] = flag;
	}

	private static bool IsRoomConsideredOccupiedForNPCIndex(int npc)
	{
		bool result = true;
		for (int i = 0; i < Main.maxNPCs; i++)
		{
			if (i != npc)
			{
				NPC nPC = Main.npc[i];
				if (nPC.active && nPC.townNPC && !nPC.homeless && nPC.homeTileX == bestX && nPC.homeTileY == bestY && !TownManager.CanNPCsLiveWithEachOther(Main.npc[npc], nPC))
				{
					result = false;
					break;
				}
			}
		}
		return result;
	}

	private static bool ScoreRoom_IsThisRoomOccupiedBySomeone(int ignoreNPC = -1, int npcTypeAsking = -1)
	{
		for (int i = 0; i < Main.maxNPCs; i++)
		{
			NPC nPC = Main.npc[i];
			if (nPC.active && nPC.townNPC && ignoreNPC != i && !nPC.homeless && Housing_CheckIfInRoom(nPC.homeTileX, nPC.homeTileY) && Housing_CheckIfInRoom(nPC.homeTileX, nPC.homeTileY - 1))
			{
				if (!TownManager.CanNPCsLiveWithEachOther(npcTypeAsking, nPC))
				{
					return true;
				}
				sharedRoomX = nPC.homeTileX;
			}
		}
		return false;
	}

	public static void CountTileTypesInArea(int[] tileTypeCounts, int startX, int endX, int startY, int endY)
	{
		for (int i = startX; i <= endX; i++)
		{
			for (int j = startY; j <= endY; j++)
			{
				if (Main.tile[i, j].active())
				{
					tileTypeCounts[Main.tile[i, j].type]++;
				}
			}
		}
	}

	public static int GetTileTypeCountByCategory(int[] tileTypeCounts, TileScanGroup group)
	{
		switch (group)
		{
		case TileScanGroup.None:
			return 0;
		case TileScanGroup.Corruption:
			return tileTypeCounts[23] + tileTypeCounts[24] + tileTypeCounts[25] + tileTypeCounts[32] + tileTypeCounts[112] + tileTypeCounts[163] + tileTypeCounts[400] + tileTypeCounts[398] + -5 * tileTypeCounts[27];
		case TileScanGroup.Crimson:
			return tileTypeCounts[199] + tileTypeCounts[203] + tileTypeCounts[200] + tileTypeCounts[401] + tileTypeCounts[399] + tileTypeCounts[234] + tileTypeCounts[352] - 5 * tileTypeCounts[27];
		case TileScanGroup.Hallow:
			return tileTypeCounts[109] + tileTypeCounts[110] + tileTypeCounts[113] + tileTypeCounts[117] + tileTypeCounts[116] + tileTypeCounts[164] + tileTypeCounts[403] + tileTypeCounts[402];
		case TileScanGroup.TotalGoodEvil:
		{
			int tileTypeCountByCategory = GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.Hallow);
			int tileTypeCountByCategory2 = GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.Corruption);
			int tileTypeCountByCategory3 = GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.Crimson);
			int num = 5 * tileTypeCounts[27];
			int num2 = tileTypeCountByCategory2 + tileTypeCountByCategory3 + num;
			return tileTypeCountByCategory - num2;
		}
		default:
			return 0;
		}
	}

	public static void ScoreRoom(int ignoreNPC = -1, int npcTypeAskingToScoreRoom = -1, IRoomCheckFeedback feedback = null)
	{
		if (feedback == null)
		{
			feedback = NoRoomCheckFeedback.WithText;
		}
		roomOccupied = false;
		roomHasStandingSpace = false;
		roomEvil = false;
		sharedRoomX = -1;
		if (ScoreRoom_IsThisRoomOccupiedBySomeone(ignoreNPC, npcTypeAskingToScoreRoom))
		{
			roomOccupied = true;
			hiScore = -1;
			return;
		}
		hiScore = 0;
		int num = 0;
		int num2 = 50;
		Housing_GetTestedRoomBounds(out var startX, out var endX, out var startY, out var endY);
		int[] tileTypeCounts = new int[TileID.Count];
		CountTileTypesInArea(tileTypeCounts, startX + 1, endX - 1, startY + 2, endY + 1);
		int num3 = -GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.TotalGoodEvil);
		if (num3 < 50)
		{
			num3 = 0;
		}
		num2 -= num3;
		if (num3 > 0)
		{
			roomEvil = true;
		}
		if (num2 <= -250)
		{
			hiScore = num2;
			return;
		}
		startX = roomX1;
		endX = roomX2;
		startY = roomY1;
		endY = roomY2;
		for (int i = startX + 1; i < endX; i++)
		{
			for (int j = startY + 2; j < endY + 2; j++)
			{
				if (!Main.tile[i, j].nactive() || !ScoreRoom_CanBeHomeSpot(i, j) || !Main.tileSolid[Main.tile[i, j].type] || Collision.SolidTiles(i - 1, i + 1, j - 3, j - 1) || !Main.tile[i - 1, j].nactive() || !Main.tileSolid[Main.tile[i - 1, j].type] || !Main.tile[i + 1, j].nactive() || !Main.tileSolid[Main.tile[i + 1, j].type])
				{
					continue;
				}
				num = num2;
				int num4 = 0;
				int num5 = 0;
				for (int k = i - 2; k < i + 3; k++)
				{
					for (int l = j - 4; l < j; l++)
					{
						Tile tile = Main.tile[k, l];
						if (tile.nactive() && !TileID.Sets.IgnoredInHouseScore[tile.type] && (tile.type != 11 || IsOpenDoorAnchorFrame(k, l)))
						{
							if (k == i)
							{
								num4++;
							}
							else if (TileID.Sets.BasicChest[tile.type])
							{
								num5++;
							}
							else
							{
								num = ((tile.type != 10 && tile.type != 388) ? ((!IsOpenDoorAnchorFrame(k, l) && tile.type != 389) ? ((!Main.tileSolid[tile.type]) ? (num + 5) : (num - 5)) : (num - 20)) : (num - 20));
							}
						}
					}
				}
				if (num > 0)
				{
					roomHasStandingSpace = true;
				}
				if (sharedRoomX >= 0 && num >= 1 && Math.Abs(sharedRoomX - i) < 3)
				{
					num = 1;
				}
				if (num > 0 && num5 > 0)
				{
					num -= 30 * num5;
					if (num < 1)
					{
						num = 1;
					}
				}
				if (num > 0 && num4 > 0)
				{
					num -= 15 * num4;
					if (num < 1)
					{
						num = 1;
					}
				}
				feedback.ReportScore(i, j, num);
				if (num <= hiScore)
				{
					continue;
				}
				bool flag = Housing_CheckIfInRoom(i, j);
				bool[] array = new bool[3];
				for (int m = 1; m <= 3; m++)
				{
					if (!Main.tile[i, j - m].active() || !Main.tileSolid[Main.tile[i, j - m].type])
					{
						array[m - 1] = true;
					}
					if (!Housing_CheckIfInRoom(i, j - m))
					{
						array[m - 1] = false;
					}
				}
				bool[] array2 = array;
				for (int n = 0; n < array2.Length; n++)
				{
					if (!array2[n])
					{
						flag = false;
						break;
					}
				}
				if (flag && Housing_CheckIfInRoom(i, j - 1))
				{
					feedback.SetAsHighScore(i, j, num);
					hiScore = num;
					bestX = i;
					bestY = j;
				}
			}
		}
	}

	public static void Housing_GetTestedRoomBounds(out int startX, out int endX, out int startY, out int endY)
	{
		int num = 40;
		int num2 = 5;
		int num3 = 3;
		startX = roomX1 - num2 - 1 - num;
		endX = roomX2 + num2 + 1 + num;
		startY = roomY1 - num3 - 1 - num;
		endY = roomY2 + num3 + 1 + num;
		if (startX < 5)
		{
			startX = 5;
		}
		if (endX >= Main.maxTilesX - 5)
		{
			endX = Main.maxTilesX - 6;
		}
		if (startY < 5)
		{
			startY = 5;
		}
		if (endY >= Main.maxTilesY - 5)
		{
			endY = Main.maxTilesY - 6;
		}
	}

	private static bool ScoreRoom_CanBeHomeSpot(int x, int y)
	{
		Tile tile = Main.tile[x, y];
		if (tile.active())
		{
			ushort type = tile.type;
			if (type == 379)
			{
				return false;
			}
		}
		return true;
	}

	private static bool Housing_CheckIfInRoom(int i, int j)
	{
		Point p = new Point(i, j);
		if (roomTiles.InBounds(p))
		{
			return roomTiles[p];
		}
		return false;
	}

	public static bool StartRoomCheck(int x, int y, IRoomCheckFeedback feedback = null)
	{
		if (feedback == null)
		{
			feedback = NoRoomCheckFeedback.WithText;
		}
		roomHasStinkbug = false;
		roomHasEchoStinkbug = false;
		roomX1 = x;
		roomX2 = x;
		roomY1 = y;
		roomY2 = y;
		roomTiles.Reset(new Point(x, y), maxRoomSize);
		numRoomTiles = 0;
		for (int i = 0; i < TileID.Count; i++)
		{
			houseTile[i] = false;
		}
		canSpawn = true;
		if (Main.tile[x, y].nactive() && Main.tileSolid[Main.tile[x, y].type])
		{
			feedback.StartedInASolidTile(x, y);
			roomCheckFailureReason = TownNPCRoomCheckFailureReason.RoomCheckStartedInASolidTile;
			canSpawn = false;
			return false;
		}
		roomCheckFailureReason = TownNPCRoomCheckFailureReason.None;
		Stack<Point> roomCheckStack = _roomCheckStack;
		roomCheckStack.Clear();
		roomCheckStack.Push(new Point(x, y));
		while (roomCheckStack.Count > 0 && (canSpawn || !feedback.StopOnFail))
		{
			Point point = roomCheckStack.Pop();
			if (!CheckRoom(point.X, point.Y, roomCheckStack.Count, feedback))
			{
				continue;
			}
			for (int j = -1; j <= 1; j++)
			{
				for (int k = -1; k <= 1; k++)
				{
					if (j != 0 || k != 0)
					{
						roomCheckStack.Push(new Point(point.X + j, point.Y + k));
					}
				}
			}
		}
		if (!canSpawn)
		{
			return false;
		}
		if (numRoomTiles < 60)
		{
			roomCheckFailureReason = TownNPCRoomCheckFailureReason.RoomIsTooSmall;
			canSpawn = false;
			return false;
		}
		if (canSpawn)
		{
			return true;
		}
		return false;
	}

	private static bool CheckRoom(int x, int y, int iteration, IRoomCheckFeedback feedback)
	{
		bool stopOnFail = feedback.StopOnFail;
		if (x < 10 || y < 10 || x >= Main.maxTilesX - 10 || y >= lastMaxTilesY - 10)
		{
			feedback.TooCloseToWorldEdge(x, y, iteration);
			roomCheckFailureReason = TownNPCRoomCheckFailureReason.TooCloseToWorldEdge;
			canSpawn = false;
			return false;
		}
		if (!roomTiles.InBounds(new Point(x, y)))
		{
			feedback.RoomTooBig(x, y, iteration);
			roomCheckFailureReason = TownNPCRoomCheckFailureReason.RoomIsTooBig;
			canSpawn = false;
			return false;
		}
		if (!roomTiles.Add(new Point(x, y)))
		{
			return false;
		}
		numRoomTiles++;
		if (stopOnFail && numRoomTiles >= maxRoomTiles)
		{
			feedback.RoomTooBig(x, y, iteration);
			roomCheckFailureReason = TownNPCRoomCheckFailureReason.RoomIsTooBig;
			canSpawn = false;
			return false;
		}
		if (x < roomX1)
		{
			roomX1 = x;
		}
		if (x > roomX2)
		{
			roomX2 = x;
		}
		if (y < roomY1)
		{
			roomY1 = y;
		}
		if (y > roomY2)
		{
			roomY2 = y;
		}
		if (stopOnFail && (roomX2 - roomX1 >= maxRoomSize || roomY2 - roomY1 >= maxRoomSize))
		{
			feedback.RoomTooBig(x, y, iteration);
			roomCheckFailureReason = TownNPCRoomCheckFailureReason.RoomIsTooBig;
			canSpawn = false;
			return false;
		}
		feedback.AnyBlockScannedHere(x, y, iteration);
		if (Main.tile[x, y].nactive())
		{
			houseTile[Main.tile[x, y].type] = true;
			if (Main.tileSolid[Main.tile[x, y].type])
			{
				feedback.BlockingWall(x, y, iteration);
				return false;
			}
			if (Main.tile[x, y].type == 11 && (Main.tile[x, y].frameX == 0 || Main.tile[x, y].frameX == 54 || Main.tile[x, y].frameX == 72 || Main.tile[x, y].frameX == 126))
			{
				feedback.BlockingOpenGate(x, y, iteration);
				return false;
			}
			if (Main.tile[x, y].type == 389)
			{
				feedback.BlockingOpenGate(x, y, iteration);
				return false;
			}
			if (Main.tile[x, y].type == 386 && ((Main.tile[x, y].frameX < 36 && Main.tile[x, y].frameY == 18) || (Main.tile[x, y].frameX >= 36 && Main.tile[x, y].frameY == 0)))
			{
				feedback.BlockingOpenGate(x, y, iteration);
				return false;
			}
			if (Main.tile[x, y].type == 630)
			{
				roomHasStinkbug = true;
				feedback.Stinkbug(x, y, iteration);
			}
			if (Main.tile[x, y].type == 631)
			{
				roomHasEchoStinkbug = true;
				feedback.EchoStinkbug(x, y, iteration);
			}
		}
		bool flag = false;
		bool flag2 = false;
		for (int i = -2; i < 3; i++)
		{
			if (Main.wallHouse[Main.tile[x + i, y].wall])
			{
				flag = true;
			}
			if (Main.tile[x + i, y].nactive() && (Main.tileSolid[Main.tile[x + i, y].type] || TileID.Sets.HousingWalls[Main.tile[x + i, y].type]))
			{
				flag = true;
			}
			if (Main.wallHouse[Main.tile[x, y + i].wall])
			{
				flag2 = true;
			}
			if (Main.tile[x, y + i].nactive() && (Main.tileSolid[Main.tile[x, y + i].type] || TileID.Sets.HousingWalls[Main.tile[x, y + i].type]))
			{
				flag2 = true;
			}
		}
		if (!flag || !flag2)
		{
			if (Main.tile[x, y].wall > 0)
			{
				feedback.UnsafeWall(x, y, iteration);
				roomCheckFailureReason = TownNPCRoomCheckFailureReason.TooManyUnsafeWalls;
			}
			else
			{
				feedback.MissingAWall(x, y, iteration);
				roomCheckFailureReason = TownNPCRoomCheckFailureReason.HoleInWallIsTooBig;
			}
			canSpawn = false;
			return false;
		}
		return true;
	}

	public static void StartMeteorShower()
	{
		meteorShowerCount = genRand.Next(650, 751);
		meteorShowerCount *= 4;
		if (Main.netMode == 0)
		{
			Main.NewText(Lang.gen[92].Value, 50, byte.MaxValue, 130);
		}
		else if (Main.netMode == 2)
		{
			ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.gen[92].Key), new Color(50, 255, 130));
		}
	}

	public static bool dropMeteor(bool spawnUnderGround = false)
	{
		bool flag = true;
		if (!isGeneratingOrLoadingWorld)
		{
			if (Main.netMode == 1)
			{
				return false;
			}
			if (!Main.isThereAWorldSurface)
			{
				return false;
			}
			for (int i = 0; i < 255; i++)
			{
				if (Main.player[i].active)
				{
					flag = false;
					break;
				}
			}
		}
		else
		{
			flag = false;
		}
		if (!isGeneratingOrLoadingWorld)
		{
			int num = 0;
			double num2 = (double)Main.maxTilesX / 4200.0;
			int num3 = (int)(400.0 * num2);
			for (int j = 5; j < Main.maxTilesX - 5; j++)
			{
				for (int k = 5; (double)k < Main.worldSurface; k++)
				{
					if (Main.tile[j, k].active() && Main.tile[j, k].type == 37)
					{
						num++;
						if (num > num3)
						{
							return false;
						}
					}
				}
			}
		}
		double num4 = 600.0;
		int num5 = 0;
		int num6 = (int)(Main.worldSurface * 0.3);
		if (spawnUnderGround)
		{
			num6 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.UnderworldLayer);
		}
		while (!flag)
		{
			double num7 = (double)Main.maxTilesX * 0.08;
			int num8 = Main.rand.Next(150, Main.maxTilesX - 150);
			while ((double)num8 > (double)Main.spawnTileX - num7 && (double)num8 < (double)Main.spawnTileX + num7)
			{
				num8 = Main.rand.Next(150, Main.maxTilesX - 150);
			}
			for (int l = num6; l < Main.maxTilesY; l++)
			{
				if (!InWorld(num8, l, 2))
				{
					continue;
				}
				Tile tile = Main.tile[num8, l];
				if (!tile.active() || !Main.tileSolid[tile.type] || TileID.Sets.Platforms[tile.type])
				{
					continue;
				}
				int num9 = 0;
				int num10 = 15;
				for (int m = num8 - num10; m < num8 + num10; m++)
				{
					for (int n = l - num10; n < l + num10; n++)
					{
						if (!InWorld(m, n, 2))
						{
							continue;
						}
						if (SolidTile(m, n))
						{
							num9++;
							if (Main.tile[m, n].type == 189 || Main.tile[m, n].type == 202)
							{
								num9 -= 100;
							}
						}
						else if (Main.tile[m, n].liquid > 0)
						{
							num9--;
						}
					}
				}
				if ((double)num9 >= num4)
				{
					flag = meteor(num8, l);
					if (!flag)
					{
						break;
					}
					return flag;
				}
				num4 -= 0.5;
				break;
			}
			num5++;
			if (num4 < 100.0)
			{
				return false;
			}
			if (num5 >= Main.maxTilesX * 5)
			{
				return false;
			}
		}
		return false;
	}

	public static bool meteor(int i, int j, bool ignorePlayers = false)
	{
		if (i < 50 || i > Main.maxTilesX - 50)
		{
			return false;
		}
		if (j < 50 || j > Main.maxTilesY - 50)
		{
			return false;
		}
		int num = 35;
		int centeredSquareSize = num * 2 + 5;
		Rectangle rectangle = new Rectangle((i - num) * 16, (j - num) * 16, num * 2 * 16, num * 2 * 16);
		if (!InWorld(i - num, j - num, 10) || !InWorld(i + num, j + num, 10))
		{
			return false;
		}
		for (int k = 0; k < 255; k++)
		{
			if (Main.player[k].active && !ignorePlayers)
			{
				Rectangle value = new Rectangle((int)(Main.player[k].position.X + (float)(Main.player[k].width / 2) - (float)(NPC.sWidth / 2) - (float)NPC.safeRangeX), (int)(Main.player[k].position.Y + (float)(Main.player[k].height / 2) - (float)(NPC.sHeight / 2) - (float)NPC.safeRangeY), NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
				if (rectangle.Intersects(value))
				{
					return false;
				}
			}
		}
		for (int l = 0; l < Main.maxNPCs; l++)
		{
			if (Main.npc[l].active)
			{
				Rectangle value2 = new Rectangle((int)Main.npc[l].position.X, (int)Main.npc[l].position.Y, Main.npc[l].width, Main.npc[l].height);
				if (rectangle.Intersects(value2))
				{
					return false;
				}
			}
		}
		for (int m = i - num; m < i + num; m++)
		{
			for (int n = j - num; n < j + num; n++)
			{
				if (Main.tile[m, n].active())
				{
					if (TileID.Sets.BasicChest[Main.tile[m, n].type] || Main.tileDungeon[Main.tile[m, n].type])
					{
						return false;
					}
					switch (Main.tile[m, n].type)
					{
					case 26:
					case 226:
					case 470:
					case 475:
					case 488:
					case 597:
						return false;
					}
				}
			}
		}
		stopDrops = true;
		num = genRand.Next(17, 23);
		for (int num2 = i - num; num2 < i + num; num2++)
		{
			for (int num3 = j - num; num3 < j + num; num3++)
			{
				if (num3 <= j + Main.rand.Next(-2, 3) - 5)
				{
					continue;
				}
				double num4 = Math.Abs(i - num2);
				double num5 = Math.Abs(j - num3);
				if (Math.Sqrt(num4 * num4 + num5 * num5) < (double)num * 0.9 + (double)Main.rand.Next(-4, 5))
				{
					if (!Main.tileSolid[Main.tile[num2, num3].type])
					{
						Main.tile[num2, num3].active(active: false);
					}
					paintTile(num2, num3, 0, Main.netMode == 2, paintEffects: false);
					paintCoatTile(num2, num3, 0, Main.netMode == 2, coatingEffects: false);
					Main.tile[num2, num3].ClearSlope();
					Main.tile[num2, num3].type = 37;
				}
			}
		}
		num = genRand.Next(8, 14);
		for (int num6 = i - num; num6 < i + num; num6++)
		{
			for (int num7 = j - num; num7 < j + num; num7++)
			{
				if (num7 > j + Main.rand.Next(-2, 3) - 4)
				{
					double num8 = Math.Abs(i - num6);
					double num9 = Math.Abs(j - num7);
					if (Math.Sqrt(num8 * num8 + num9 * num9) < (double)num * 0.8 + (double)Main.rand.Next(-3, 4))
					{
						Main.tile[num6, num7].active(active: false);
					}
				}
			}
		}
		num = genRand.Next(25, 35);
		for (int num10 = i - num; num10 < i + num; num10++)
		{
			for (int num11 = j - num; num11 < j + num; num11++)
			{
				double num12 = Math.Abs(i - num10);
				double num13 = Math.Abs(j - num11);
				if (Math.Sqrt(num12 * num12 + num13 * num13) < (double)num * 0.7)
				{
					if (TileID.Sets.GetsDestroyedForMeteors[Main.tile[num10, num11].type])
					{
						KillTile(num10, num11);
					}
					Main.tile[num10, num11].liquid = 0;
				}
				if (Main.tile[num10, num11].type == 37)
				{
					if (!SolidTile(num10 - 1, num11) && !SolidTile(num10 + 1, num11) && !SolidTile(num10, num11 - 1) && !SolidTile(num10, num11 + 1))
					{
						Main.tile[num10, num11].active(active: false);
					}
					else if ((Main.tile[num10, num11].halfBrick() || Main.tile[num10 - 1, num11].topSlope()) && !SolidTile(num10, num11 + 1))
					{
						Main.tile[num10, num11].active(active: false);
					}
				}
				SquareTileFrame(num10, num11);
				SquareWallFrame(num10, num11);
			}
		}
		num = genRand.Next(23, 32);
		for (int num14 = i - num; num14 < i + num; num14++)
		{
			for (int num15 = j - num; num15 < j + num; num15++)
			{
				if (num15 <= j + genRand.Next(-3, 4) - 3 || !Main.tile[num14, num15].active() || Main.rand.Next(10) != 0)
				{
					continue;
				}
				double num16 = Math.Abs(i - num14);
				double num17 = Math.Abs(j - num15);
				if (Math.Sqrt(num16 * num16 + num17 * num17) < (double)num * 0.8)
				{
					if (TileID.Sets.GetsDestroyedForMeteors[Main.tile[num14, num15].type])
					{
						KillTile(num14, num15);
					}
					paintTile(num14, num15, 0, Main.netMode == 2, paintEffects: false);
					paintCoatTile(num14, num15, 0, Main.netMode == 2, coatingEffects: false);
					Main.tile[num14, num15].ClearSlope();
					Main.tile[num14, num15].type = 37;
					SquareTileFrame(num14, num15);
				}
			}
		}
		num = genRand.Next(30, 38);
		for (int num18 = i - num; num18 < i + num; num18++)
		{
			for (int num19 = j - num; num19 < j + num; num19++)
			{
				if (num19 <= j + genRand.Next(-2, 3) || !Main.tile[num18, num19].active() || Main.rand.Next(20) != 0)
				{
					continue;
				}
				double num20 = Math.Abs(i - num18);
				double num21 = Math.Abs(j - num19);
				if (Math.Sqrt(num20 * num20 + num21 * num21) < (double)num * 0.85)
				{
					if (TileID.Sets.GetsDestroyedForMeteors[Main.tile[num18, num19].type])
					{
						KillTile(num18, num19);
					}
					paintTile(num18, num19, 0, Main.netMode == 2, paintEffects: false);
					paintCoatTile(num18, num19, 0, Main.netMode == 2, coatingEffects: false);
					Main.tile[num18, num19].ClearSlope();
					Main.tile[num18, num19].type = 37;
					SquareTileFrame(num18, num19);
				}
			}
		}
		stopDrops = false;
		if (Main.netMode == 0)
		{
			Main.NewText(Lang.gen[59].Value, 50, byte.MaxValue, 130);
		}
		else if (Main.netMode == 2)
		{
			ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.gen[59].Key), new Color(50, 255, 130));
		}
		if (Main.netMode != 1)
		{
			NetMessage.SendTileSquare(-1, i, j, centeredSquareSize);
		}
		return true;
	}

	public static void setWorldSize()
	{
		Main.bottomWorld = Main.maxTilesY * 16;
		Main.rightWorld = Main.maxTilesX * 16;
		Main.maxSectionsX = Main.maxTilesX / 200;
		Main.maxSectionsY = Main.maxTilesY / 150;
	}

	public static int GetWorldSize()
	{
		if (Main.maxTilesX <= 4200)
		{
			return 0;
		}
		if (Main.maxTilesX <= 6400)
		{
			return 1;
		}
		return 2;
	}

	public static void SetWorldSize(int size)
	{
		switch (size)
		{
		case 0:
			Main.maxTilesX = 4200;
			Main.maxTilesY = 1200;
			break;
		case 1:
			Main.maxTilesX = 6400;
			Main.maxTilesY = 1800;
			break;
		default:
			Main.maxTilesX = 8400;
			Main.maxTilesY = 2400;
			break;
		}
	}

	public static void worldGenCallback(GenerationProgress customProgressObject, WorldGenerator.Controller customGenController, WorldGenerationFinishCallback afterGeneration)
	{
		SoundEngine.PlaySound(10);
		bool flag = GenerateWorld(customProgressObject, customGenController);
		if (flag)
		{
			WorldFile.SaveWorld(Main.ActiveWorldFileData.IsCloudSave, resetTime: true);
		}
		if (Main.menuMode == 10 || Main.menuMode == 888)
		{
			Main.menuMode = 6;
		}
		SoundEngine.PlaySound(10);
		afterGeneration?.Invoke(flag);
	}

	public static Task CreateNewWorld(GenerationProgress progress = null, WorldGenerator.Controller controller = null, WorldGenerationFinishCallback afterGeneration = null)
	{
		UIWorldSelect.NewlyGeneratedWorld = Main.ActiveWorldFileData;
		generatingWorld = true;
		Main.rand = new UnifiedRandom(Main.ActiveWorldFileData.Seed);
		isGeneratingOrLoadingWorld = true;
		Main.menuMode = 888;
		try
		{
			Main.MenuUI.SetState(new UIWorldLoad());
		}
		catch
		{
		}
		return Task.Factory.StartNew(delegate
		{
			worldGenCallback(progress, controller, afterGeneration);
		});
	}

	public static void JustQuit()
	{
		try
		{
			SoundEngine.PlaySound(34, -1, -1, 0);
			SoundEngine.PlaySound(35, -1, -1, 0);
		}
		catch
		{
		}
		Main.invasionProgress = -1;
		Main.invasionProgressDisplayLeft = 0;
		Main.invasionProgressAlpha = 0f;
		Main.invasionProgressIcon = 0;
		Main.menuMode = 10;
		Main.gameMenu = true;
		SoundEngine.StopTrackedSounds();
		CaptureInterface.ResetFocus();
		Main.ActivePlayerFileData.StopPlayTimer();
		Main.fastForwardTimeToDawn = false;
		Main.fastForwardTimeToDusk = false;
		Main.UpdateTimeRate();
		if (Main.netMode == 0)
		{
			Main.GoToWorldSelect();
			Main.player[Main.myPlayer].position = new Vector2(0f, 0f);
		}
		else if (Main.netMode == 1)
		{
			Main.menuMode = 0;
			Netplay.Disconnect = true;
			Main.netMode = 0;
		}
	}

	private static void SaveAndQuitCallBack(object threadContext)
	{
		Tuple<int, Action> obj = (Tuple<int, Action>)threadContext;
		int item = obj.Item1;
		Action item2 = obj.Item2;
		Main.ActivePlayerFileData.StopPlayTimer();
		Player.SavePlayer(Main.ActivePlayerFileData);
		Player.ClearPlayerTempInfo();
		Rain.ClearRain();
		if (item == 0)
		{
			WorldFile.ReuseTempsForNextSave();
			WorldFile.SaveWorld();
			SoundEngine.PlaySound(10);
		}
		else
		{
			Netplay.Disconnect = true;
			Main.netMode = 0;
		}
		Main.fastForwardTimeToDawn = false;
		Main.fastForwardTimeToDusk = false;
		Main.UpdateTimeRate();
		Main.menuMode = 0;
		if (item2 != null)
		{
			Main.QueueMainThreadAction(item2);
		}
	}

	public static void StopWaterfallAmbienceAudio()
	{
		try
		{
			SoundEngine.PlaySound(34, -1, -1, 0);
			SoundEngine.PlaySound(35, -1, -1, 0);
		}
		catch
		{
		}
	}

	public static void SaveAndQuit(Action callback = null)
	{
		SoundEngine.PlaySound(11);
		StopWaterfallAmbienceAudio();
		Main.invasionProgress = -1;
		Main.invasionProgressDisplayLeft = 0;
		Main.invasionProgressAlpha = 0f;
		Main.invasionProgressIcon = 0;
		Main.menuMode = 10;
		Main.gameMenu = true;
		InGameNotificationsTracker.Clear();
		SoundEngine.StopTrackedSounds();
		CaptureInterface.ResetFocus();
		WorldFile.SetTempToOngoing();
		ThreadPool.QueueUserWorkItem(SaveAndQuitCallBack, new Tuple<int, Action>(Main.netMode, callback));
	}

	public static void RenameWorld(WorldFileData data, string newName, Action<string> callback = null)
	{
		data.SetAsActive();
		ThreadPool.QueueUserWorkItem(RenameWorldCallBack, Tuple.Create(newName, callback));
	}

	public static void RenameWorldCallBack(object threadContext)
	{
		if (threadContext == null || !(threadContext is Tuple<string, Action<string>> { Item1: var item, Item2: var item2 }))
		{
			return;
		}
		Main.ToggleGameplayUpdates(state: false);
		WorldFile.LoadWorld();
		if (loadFailed)
		{
			Main.QueueMainThreadAction(delegate
			{
				Main.LoadWorlds();
				Main.GoToWorldSelect();
			});
			return;
		}
		Main.sectionManager.SetAllSectionsLoaded();
		Main.worldName = item;
		WorldFile.ReuseTempsForNextSave();
		WorldFile.SaveWorld();
		Rain.ClearRain();
		Main.fastForwardTimeToDawn = false;
		Main.fastForwardTimeToDusk = false;
		Main.UpdateTimeRate();
		UIWorldSelect.NewlyGeneratedWorld = Main.ActiveWorldFileData;
		item2?.Invoke(item);
	}

	public static void playWorldCallBack(object threadContext)
	{
		for (int i = 0; i < 255; i++)
		{
			if (i != Main.myPlayer)
			{
				Main.player[i].active = false;
			}
		}
		Main.ToggleGameplayUpdates(state: false);
		WorldFile.LoadWorld();
		if (loadFailed)
		{
			WorldFile.LoadWorld();
			if (loadFailed)
			{
				bool isCloudSave = Main.ActiveWorldFileData.IsCloudSave;
				if (FileUtilities.Exists(Main.worldPathName + ".bak", isCloudSave))
				{
					worldBackup = true;
				}
				else
				{
					worldBackup = false;
				}
				if (!Main.dedServ)
				{
					if (worldBackup)
					{
						Main.menuMode = 200;
					}
					else
					{
						Main.menuMode = 201;
					}
					return;
				}
				if (!worldBackup)
				{
					Console.WriteLine(Language.GetTextValue("Error.LoadFailedNoBackup"));
					return;
				}
				FileUtilities.Copy(Main.worldPathName, Main.worldPathName + ".bad", isCloudSave);
				FileUtilities.Copy(Main.worldPathName + ".bak", Main.worldPathName, isCloudSave);
				FileUtilities.Delete(Main.worldPathName + ".bak", isCloudSave);
				WorldFile.LoadWorld();
				if (loadFailed)
				{
					WorldFile.LoadWorld();
					if (loadFailed)
					{
						FileUtilities.Copy(Main.worldPathName, Main.worldPathName + ".bak", isCloudSave);
						FileUtilities.Copy(Main.worldPathName + ".bad", Main.worldPathName, isCloudSave);
						FileUtilities.Delete(Main.worldPathName + ".bad", isCloudSave);
						Console.WriteLine(Language.GetTextValue("Error.LoadFailed"));
						return;
					}
				}
			}
		}
		if (Main.mapEnabled)
		{
			Main.Map.Load();
		}
		if (Main.netMode != 2)
		{
			Main.sectionManager.SetAllSectionsLoaded();
		}
		while (Main.loadMapLock)
		{
			float num = (float)Main.loadMapLastX / (float)Main.maxTilesX;
			Main.statusText = Lang.gen[68].Value + " " + (int)(num * 100f + 1f) + "%";
			Thread.Sleep(0);
			if (!Main.mapEnabled)
			{
				break;
			}
		}
		if (Main.netMode == 0 && Main.anglerWhoFinishedToday.Contains(Main.player[Main.myPlayer].name))
		{
			Main.anglerQuestFinished = true;
		}
		Main.RunOnMainThread(delegate
		{
			Main.gameMenu = false;
			Main.player[Main.myPlayer].Spawn(PlayerSpawnContext.SpawningIntoWorld);
			WorldFile.SetOngoingToTemps();
		}).Wait();
		SoundEngine.PlaySound(11);
		Main.resetClouds = true;
	}

	public static void playWorld()
	{
		ThreadPool.QueueUserWorkItem(playWorldCallBack, 1);
	}

	private static void saveAndPlayCallBack(object threadContext)
	{
		WorldFile.ReuseTempsForNextSave();
		WorldFile.SaveWorld();
	}

	public static void saveAndPlay()
	{
		WorldFile.SetTempToOngoing();
		ThreadPool.QueueUserWorkItem(saveAndPlayCallBack, 1);
	}

	public static void saveToonWhilePlayingCallBack(object threadContext)
	{
		Player.SavePlayer(Main.ActivePlayerFileData);
	}

	public static void saveToonWhilePlaying()
	{
		ThreadPool.QueueUserWorkItem(saveToonWhilePlayingCallBack, 1);
	}

	public static void serverLoadWorldCallBack()
	{
		WorldFile.LoadWorld();
		if (loadFailed)
		{
			WorldFile.LoadWorld();
			if (loadFailed)
			{
				bool isCloudSave = Main.ActiveWorldFileData.IsCloudSave;
				if (FileUtilities.Exists(Main.worldPathName + ".bak", isCloudSave))
				{
					worldBackup = true;
				}
				else
				{
					worldBackup = false;
				}
				if (!Main.dedServ)
				{
					if (worldBackup)
					{
						Main.menuMode = 200;
					}
					else
					{
						Main.menuMode = 201;
					}
					return;
				}
				if (!worldBackup)
				{
					Console.WriteLine(Language.GetTextValue("Error.LoadFailedNoBackup"));
					return;
				}
				FileUtilities.Copy(Main.worldPathName + ".bak", Main.worldPathName, isCloudSave);
				FileUtilities.Delete(Main.worldPathName + ".bak", isCloudSave);
				WorldFile.LoadWorld();
				if (loadFailed)
				{
					WorldFile.LoadWorld();
					if (loadFailed)
					{
						Console.WriteLine(Language.GetTextValue("Error.LoadFailed"));
						return;
					}
				}
			}
		}
		SoundEngine.PlaySound(10);
		WorldFile.SetOngoingToTemps();
		Hooks.WorldLoaded();
	}

	public static Task serverLoadWorld()
	{
		return Task.Factory.StartNew(serverLoadWorldCallBack);
	}

	public static void clearWorld()
	{
		TimeLogger.Reset();
		ResetTreeShakes();
		_isRainingBoulders = false;
		meteorShowerCount = 0;
		Main.coinRain = 0;
		Main.ladyBugRainBoost = 0;
		Main.ClearWorldSeedFlags();
		Main.afterPartyOfDoom = false;
		Main.shimmerAlpha = 0f;
		Main.shimmerDarken = 0f;
		NPC.ResetBadgerHatTime();
		NPC.freeCake = false;
		NPC.mechQueen = -1;
		Main.mapDelay = 2;
		Main.waterStyle = 0;
		Main.ResetWindCounter(resetExtreme: true);
		TownManager = new TownRoomManager();
		PressurePlateHelper.Reset();
		TownManager.Clear();
		BannerSystem.Clear();
		Main.instance.ClearCachedTileDraws();
		TileEntity.Clear();
		Main.checkXMas();
		Main.checkHalloween();
		DontStarveDarknessDamageDealer.Reset();
		Wiring.ClearAll();
		Main.ParticleSystem_World_BehindPlayers.Particles.Clear();
		Main.ParticleSystem_World_OverPlayers.Particles.Clear();
		if (Main.mapReady)
		{
			for (int i = 0; i < lastMaxTilesX; i++)
			{
				_ = (float)i / (float)lastMaxTilesX;
				Main.statusText = Lang.gen[65].Value;
			}
			if (Main.Map != null)
			{
				Main.Map.Clear();
			}
		}
		Main.Pings.Clear();
		NPC.MoonLordCountdown = 0;
		Main.forceHalloweenForToday = false;
		Main.forceXMasForToday = false;
		Main.forceHalloweenForever = false;
		Main.forceXMasForever = false;
		NPC.RevengeManager.Reset();
		Main.pumpkinMoon = false;
		Main.clearMap = true;
		Main.mapTime = 0;
		Main.updateMap = null;
		Main.mapReady = false;
		Main.refreshMap = false;
		Main.eclipse = false;
		Main.slimeRain = false;
		Main.slimeRainTime = 0.0;
		Main.slimeWarningTime = 0;
		Main.sundialCooldown = 0;
		Main.moondialCooldown = 0;
		Main.fastForwardTimeToDawn = false;
		Main.fastForwardTimeToDusk = false;
		BirthdayParty.WorldClear();
		LanternNight.WorldClear();
		mysticLogsEvent.WorldClear();
		CreditsRollEvent.Reset();
		Sandstorm.WorldClear();
		Main.DroneCameraTracker.WorldClear();
		Main.LocalGolfState.WorldClear();
		Main.CurrentPan = Vector2.Zero;
		Main.UpdateTimeRate();
		Main.wofNPCIndex = -1;
		NPC.waveKills = 0f;
		spawnHardBoss = 0;
		totalSolid2 = 0;
		totalGood2 = 0;
		totalEvil2 = 0;
		totalBlood2 = 0;
		totalSolid = 0;
		totalGood = 0;
		totalEvil = 0;
		totalBlood = 0;
		WorldFile.ResetTemps();
		Main.maxRaining = 0f;
		totalX = 0;
		totalD = 0;
		tEvil = 0;
		tBlood = 0;
		tGood = 0;
		spawnEye = false;
		prioritizedTownNPCType = 0;
		shadowOrbCount = 0;
		altarCount = 0;
		builtHouseWithNoFurniture = false;
		builtHouseWithNoLight = false;
		SavedOreTiers.Copper = -1;
		SavedOreTiers.Iron = -1;
		SavedOreTiers.Silver = -1;
		SavedOreTiers.Gold = -1;
		SavedOreTiers.Cobalt = -1;
		SavedOreTiers.Mythril = -1;
		SavedOreTiers.Adamantite = -1;
		GenVars.shimmerPosition = Vector2D.Zero;
		Main.cloudBGActive = 0f;
		Main.raining = false;
		Main.hardMode = false;
		Main.helpText = 0;
		Main.BartenderHelpTextIndex = 0;
		Main.dungeonX = 0;
		Main.dungeonY = 0;
		NPC.downedBoss1 = false;
		NPC.downedBoss2 = false;
		NPC.downedBoss3 = false;
		NPC.downedQueenBee = false;
		NPC.downedSlimeKing = false;
		NPC.downedMechBossAny = false;
		NPC.downedMechBoss1 = false;
		NPC.downedMechBoss2 = false;
		NPC.downedMechBoss3 = false;
		NPC.downedFishron = false;
		NPC.downedAncientCultist = false;
		NPC.downedMoonlord = false;
		NPC.downedHalloweenKing = false;
		NPC.downedHalloweenTree = false;
		NPC.downedChristmasIceQueen = false;
		NPC.downedChristmasSantank = false;
		NPC.downedChristmasTree = false;
		NPC.downedPlantBoss = false;
		NPC.downedGolemBoss = false;
		NPC.downedEmpressOfLight = false;
		NPC.downedQueenSlime = false;
		NPC.downedDeerclops = false;
		NPC.combatBookWasUsed = false;
		NPC.combatBookVolumeTwoWasUsed = false;
		NPC.peddlersSatchelWasUsed = false;
		NPC.savedStylist = false;
		NPC.savedGoblin = false;
		NPC.savedWizard = false;
		NPC.savedMech = false;
		NPC.savedTaxCollector = false;
		NPC.savedAngler = false;
		NPC.savedBartender = false;
		NPC.savedGolfer = false;
		NPC.boughtCat = false;
		NPC.boughtDog = false;
		NPC.boughtBunny = false;
		NPC.unlockedSlimeBlueSpawn = false;
		NPC.unlockedSlimeGreenSpawn = false;
		NPC.unlockedSlimeOldSpawn = false;
		NPC.unlockedSlimePurpleSpawn = false;
		NPC.unlockedSlimeRainbowSpawn = false;
		NPC.unlockedSlimeRedSpawn = false;
		NPC.unlockedSlimeYellowSpawn = false;
		NPC.unlockedSlimeCopperSpawn = false;
		NPC.unlockedMerchantSpawn = false;
		NPC.unlockedDemolitionistSpawn = false;
		NPC.unlockedPartyGirlSpawn = false;
		NPC.unlockedDyeTraderSpawn = false;
		NPC.unlockedTruffleSpawn = false;
		NPC.unlockedArmsDealerSpawn = false;
		NPC.unlockedNurseSpawn = false;
		NPC.unlockedPrincessSpawn = false;
		Array.Clear(NPC.ShimmeredTownNPCs, 0, NPC.ShimmeredTownNPCs.Length);
		NPC.downedGoblins = false;
		NPC.downedClown = false;
		NPC.downedFrost = false;
		NPC.downedPirates = false;
		NPC.downedMartians = false;
		NPC.downedTowerSolar = (NPC.downedTowerVortex = (NPC.downedTowerNebula = (NPC.downedTowerStardust = (NPC.LunarApocalypseIsUp = false))));
		NPC.TowerActiveSolar = (NPC.TowerActiveVortex = (NPC.TowerActiveNebula = (NPC.TowerActiveStardust = false)));
		DD2Event.ResetProgressEntirely();
		NPC.ClearFoundActiveNPCs();
		Main.BestiaryTracker.Reset();
		Main.PylonSystem.Reset();
		CreativePowerManager.Instance.Reset();
		Main.CreativeMenu.Reset();
		NPCDamageTracker.Reset();
		shadowOrbSmashed = false;
		spawnMeteor = false;
		stopDrops = false;
		Main.invasionDelay = 0;
		Main.invasionType = 0;
		Main.invasionSize = 0;
		Main.invasionWarn = 0;
		Main.invasionX = 0.0;
		Main.invasionSizeStart = 0;
		Main.treeX[0] = Main.maxTilesX;
		Main.treeX[1] = Main.maxTilesX;
		Main.treeX[2] = Main.maxTilesX;
		Main.treeStyle[0] = 0;
		Main.treeStyle[1] = 0;
		Main.treeStyle[2] = 0;
		Main.treeStyle[3] = 0;
		Liquid.numLiquid = 0;
		LiquidBuffer.numLiquidBuffer = 0;
		if (Main.netMode == 1 || lastMaxTilesX > Main.maxTilesX || lastMaxTilesY > Main.maxTilesY)
		{
			for (int j = 0; j < lastMaxTilesX; j++)
			{
				float num = (float)j / (float)lastMaxTilesX;
				Main.statusText = Lang.gen[46].Value + " " + (int)(num * 100f + 1f) + "%";
				for (int k = 0; k < lastMaxTilesY; k++)
				{
					Main.tile[j, k] = null;
				}
			}
		}
		lastMaxTilesX = Main.maxTilesX;
		lastMaxTilesY = Main.maxTilesY;
		if (Main.netMode != 2)
		{
			Main.sectionManager = new WorldSections(Main.maxTilesX / 200, Main.maxTilesY / 150);
		}
		if (Main.netMode != 1)
		{
			for (int l = 0; l < Main.maxTilesX; l++)
			{
				float num2 = (float)l / (float)Main.maxTilesX;
				Main.statusText = Lang.gen[47].Value + " " + (int)(num2 * 100f + 1f) + "%";
				for (int m = 0; m < Main.maxTilesY; m++)
				{
					if (Main.tile[l, m] == null)
					{
						Main.tile[l, m] = new Tile();
					}
					else
					{
						Main.tile[l, m].ClearEverything();
					}
				}
			}
		}
		for (int n = 0; n < Main.countsAsHostForGameplay.Length; n++)
		{
			Main.countsAsHostForGameplay[n] = false;
		}
		CombatText.clearAll();
		PopupText.ClearAll();
		for (int num3 = 0; num3 < 6000; num3++)
		{
			Main.dust[num3] = new Dust();
			Main.dust[num3].dustIndex = num3;
		}
		for (int num4 = 0; num4 < 600; num4++)
		{
			Main.gore[num4] = new Gore();
		}
		for (int num5 = 0; num5 < 400; num5++)
		{
			Main.item[num5] = new WorldItem();
			Main.item[num5].whoAmI = num5;
			Main.timeItemSlotCannotBeReusedFor[num5] = 0;
		}
		for (int num6 = 0; num6 < Main.maxNPCs; num6++)
		{
			Main.npc[num6] = new NPC();
			Main.npc[num6].whoAmI = num6;
			NPC.spawnSlotProtected[num6] = 0;
		}
		for (int num7 = 0; num7 < 1000; num7++)
		{
			Main.projectile[num7] = new Projectile();
			Main.projectile[num7].whoAmI = num7;
		}
		Chest.Clear();
		for (int num8 = 0; num8 < 32000; num8++)
		{
			Main.sign[num8] = null;
		}
		for (int num9 = 0; num9 < Liquid.maxLiquid; num9++)
		{
			Main.liquid[num9] = new Liquid();
		}
		for (int num10 = 0; num10 < 50000; num10++)
		{
			Main.liquidBuffer[num10] = new LiquidBuffer();
		}
		setWorldSize();
		Star.SpawnStars();
		ActiveSections.Reset();
		LeashedEntity.Clear();
		Manifest = new WorldManifest();
		worldCleared = true;
	}

	public static void setBG(int bg, int style)
	{
		switch (bg)
		{
		case 0:
			treeBG1 = style;
			SetForestBGSet(style, Main.treeMntBGSet1, Main.treeBGSet1);
			break;
		case 10:
			treeBG2 = style;
			SetForestBGSet(style, Main.treeMntBGSet2, Main.treeBGSet2);
			break;
		case 11:
			treeBG3 = style;
			SetForestBGSet(style, Main.treeMntBGSet3, Main.treeBGSet3);
			break;
		case 12:
			treeBG4 = style;
			SetForestBGSet(style, Main.treeMntBGSet4, Main.treeBGSet4);
			break;
		case 1:
			corruptBG = style;
			switch (style)
			{
			default:
				Main.corruptBG[0] = 12;
				Main.corruptBG[1] = 13;
				Main.corruptBG[2] = 14;
				break;
			case 1:
				Main.corruptBG[0] = 56;
				Main.corruptBG[1] = 57;
				Main.corruptBG[2] = 58;
				break;
			case 2:
				Main.corruptBG[0] = 211;
				Main.corruptBG[1] = 212;
				Main.corruptBG[2] = 213;
				break;
			case 3:
				Main.corruptBG[0] = 225;
				Main.corruptBG[1] = 226;
				Main.corruptBG[2] = 227;
				break;
			case 4:
				Main.corruptBG[0] = 240;
				Main.corruptBG[1] = 241;
				Main.corruptBG[2] = 242;
				break;
			case 51:
				Main.corruptBG[0] = 324;
				Main.corruptBG[1] = 323;
				Main.corruptBG[2] = 322;
				break;
			case 52:
				Main.corruptBG[0] = 324;
				Main.corruptBG[1] = 226;
				Main.corruptBG[2] = 322;
				break;
			}
			break;
		case 2:
			jungleBG = style;
			switch (style)
			{
			default:
				Main.jungleBG[0] = 15;
				Main.jungleBG[1] = 16;
				Main.jungleBG[2] = 17;
				break;
			case 1:
				Main.jungleBG[0] = 59;
				Main.jungleBG[1] = 60;
				Main.jungleBG[2] = 61;
				break;
			case 2:
				Main.jungleBG[0] = 222;
				Main.jungleBG[1] = 223;
				Main.jungleBG[2] = 224;
				break;
			case 3:
				Main.jungleBG[0] = 237;
				Main.jungleBG[1] = 238;
				Main.jungleBG[2] = 239;
				break;
			case 4:
				Main.jungleBG[0] = 284;
				Main.jungleBG[1] = 285;
				Main.jungleBG[2] = 286;
				break;
			case 5:
				Main.jungleBG[0] = 271;
				Main.jungleBG[1] = 272;
				Main.jungleBG[2] = 273;
				break;
			case 6:
				Main.jungleBG[0] = 302;
				Main.jungleBG[1] = 301;
				Main.jungleBG[2] = 300;
				break;
			}
			break;
		case 3:
			snowBG = style;
			Main.snowMntBG[0] = 35;
			Main.snowMntBG[1] = 36;
			switch (style)
			{
			default:
				Main.snowBG[0] = 37;
				Main.snowBG[1] = 38;
				Main.snowBG[2] = 39;
				break;
			case 1:
				Main.snowBG[0] = 97;
				Main.snowBG[1] = 96;
				Main.snowBG[2] = 95;
				break;
			case 2:
				Main.snowMntBG[0] = 98;
				Main.snowMntBG[1] = 99;
				Main.snowBG[0] = -1;
				Main.snowBG[1] = -1;
				Main.snowBG[2] = -1;
				break;
			case 21:
				Main.snowMntBG[0] = 98;
				Main.snowMntBG[1] = 99;
				Main.snowBG[0] = 95;
				Main.snowBG[1] = 96;
				Main.snowBG[2] = 97;
				break;
			case 22:
				Main.snowMntBG[0] = 98;
				Main.snowMntBG[1] = 99;
				Main.snowBG[0] = 37;
				Main.snowBG[1] = 38;
				Main.snowBG[2] = 39;
				break;
			case 3:
				Main.snowMntBG[0] = 98;
				Main.snowMntBG[1] = 100;
				Main.snowBG[0] = -1;
				Main.snowBG[1] = -1;
				Main.snowBG[2] = -1;
				break;
			case 31:
				Main.snowMntBG[0] = 98;
				Main.snowMntBG[1] = 100;
				Main.snowBG[0] = 95;
				Main.snowBG[1] = 96;
				Main.snowBG[2] = 97;
				break;
			case 32:
				Main.snowMntBG[0] = 98;
				Main.snowMntBG[1] = 100;
				Main.snowBG[0] = 37;
				Main.snowBG[1] = 38;
				Main.snowBG[2] = 39;
				break;
			case 4:
				Main.snowMntBG[0] = 98;
				Main.snowMntBG[1] = 101;
				Main.snowBG[0] = -1;
				Main.snowBG[1] = -1;
				Main.snowBG[2] = -1;
				break;
			case 41:
				Main.snowMntBG[0] = 98;
				Main.snowMntBG[1] = 101;
				Main.snowBG[0] = 95;
				Main.snowBG[1] = 96;
				Main.snowBG[2] = 97;
				break;
			case 42:
				Main.snowMntBG[0] = 98;
				Main.snowMntBG[1] = 101;
				Main.snowBG[0] = 37;
				Main.snowBG[1] = 38;
				Main.snowBG[2] = 39;
				break;
			case 5:
				Main.snowMntBG[0] = -1;
				Main.snowMntBG[1] = -1;
				Main.snowBG[0] = 258;
				Main.snowBG[1] = 259;
				Main.snowBG[2] = 260;
				break;
			case 6:
				Main.snowMntBG[0] = -1;
				Main.snowMntBG[1] = -1;
				Main.snowBG[0] = 263;
				Main.snowBG[1] = 264;
				Main.snowBG[2] = 265;
				break;
			case 7:
				Main.snowMntBG[0] = 269;
				Main.snowMntBG[1] = 270;
				Main.snowBG[0] = 267;
				Main.snowBG[1] = 266;
				Main.snowBG[2] = 268;
				break;
			case 8:
				Main.snowBG[0] = 299;
				Main.snowBG[1] = 298;
				Main.snowBG[2] = -1;
				break;
			}
			break;
		case 4:
			hallowBG = style;
			switch (style)
			{
			default:
				Main.hallowBG[0] = 29;
				Main.hallowBG[1] = 30;
				Main.hallowBG[2] = 31;
				break;
			case 1:
				Main.hallowBG[0] = 102;
				Main.hallowBG[1] = 103;
				Main.hallowBG[2] = 104;
				break;
			case 2:
				Main.hallowBG[0] = 219;
				Main.hallowBG[1] = 220;
				Main.hallowBG[2] = 221;
				break;
			case 3:
				Main.hallowBG[0] = 243;
				Main.hallowBG[1] = 244;
				Main.hallowBG[2] = 245;
				break;
			case 4:
				Main.hallowBG[0] = -1;
				Main.hallowBG[1] = 261;
				Main.hallowBG[2] = 262;
				break;
			case 5:
				Main.hallowBG[0] = 327;
				Main.hallowBG[1] = 326;
				Main.hallowBG[2] = 325;
				break;
			}
			break;
		case 5:
			crimsonBG = style;
			switch (style)
			{
			default:
				Main.crimsonBG[0] = 43;
				Main.crimsonBG[1] = 44;
				Main.crimsonBG[2] = 45;
				break;
			case 1:
				Main.crimsonBG[0] = 105;
				Main.crimsonBG[1] = 106;
				Main.crimsonBG[2] = 107;
				break;
			case 2:
				Main.crimsonBG[0] = 174;
				Main.crimsonBG[1] = -1;
				Main.crimsonBG[2] = 175;
				break;
			case 3:
				Main.crimsonBG[0] = 214;
				Main.crimsonBG[1] = 215;
				Main.crimsonBG[2] = 216;
				break;
			case 4:
				Main.crimsonBG[0] = -1;
				Main.crimsonBG[1] = 229;
				Main.crimsonBG[2] = 230;
				break;
			case 5:
				Main.crimsonBG[0] = 255;
				Main.crimsonBG[1] = 256;
				Main.crimsonBG[2] = 257;
				break;
			case 6:
				Main.crimsonBG[0] = 339;
				Main.crimsonBG[1] = 338;
				Main.crimsonBG[2] = 337;
				break;
			}
			break;
		case 6:
			desertBG = style;
			switch (style)
			{
			default:
				Main.desertBackgroundSet.Clear();
				Main.desertBackgroundSet.Pure.Set(21, 20, -1);
				break;
			case 1:
				Main.desertBackgroundSet.Clear();
				Main.desertBackgroundSet.Pure.Set(108, 109, -1);
				break;
			case 2:
				Main.desertBackgroundSet.Clear();
				Main.desertBackgroundSet.Pure.Set(207, 208, -1);
				break;
			case 3:
				Main.desertBackgroundSet.Clear();
				Main.desertBackgroundSet.Pure.Set(217, 218, -1);
				break;
			case 4:
				Main.desertBackgroundSet.Clear();
				Main.desertBackgroundSet.Pure.Set(248, 249, 250);
				break;
			case 51:
				Main.desertBackgroundSet.Clear();
				Main.desertBackgroundSet.Pure.Set(306, 303, -1);
				Main.desertBackgroundSet.Corrupt.Set(310, 307, -1);
				Main.desertBackgroundSet.Hallow.Set(314, 311, -1);
				Main.desertBackgroundSet.Crimson.Set(318, 315, -1);
				break;
			case 52:
				Main.desertBackgroundSet.Clear();
				Main.desertBackgroundSet.Pure.Set(306, 304, -1);
				Main.desertBackgroundSet.Corrupt.Set(310, 308, -1);
				Main.desertBackgroundSet.Hallow.Set(314, 312, -1);
				Main.desertBackgroundSet.Crimson.Set(318, 316, -1);
				break;
			case 53:
				Main.desertBackgroundSet.Clear();
				Main.desertBackgroundSet.Pure.Set(306, 305, -1);
				Main.desertBackgroundSet.Corrupt.Set(310, 309, -1);
				Main.desertBackgroundSet.Hallow.Set(314, 313, -1);
				Main.desertBackgroundSet.Crimson.Set(318, 317, -1);
				break;
			}
			break;
		case 7:
			oceanBG = style;
			switch (style)
			{
			default:
				Main.oceanBG = 28;
				break;
			case 1:
				Main.oceanBG = 110;
				break;
			case 2:
				Main.oceanBG = 111;
				break;
			case 3:
				Main.oceanBG = 209;
				break;
			case 4:
				Main.oceanBG = 210;
				break;
			case 5:
				Main.oceanBG = 283;
				break;
			case 6:
				Main.oceanBG = 332;
				break;
			case 7:
				Main.oceanBG = 340;
				break;
			}
			break;
		case 8:
			mushroomBG = style;
			switch (style)
			{
			default:
				Main.mushroomBG[0] = 46;
				Main.mushroomBG[1] = 47;
				Main.mushroomBG[2] = 48;
				break;
			case 1:
				Main.mushroomBG[0] = 231;
				Main.mushroomBG[1] = 232;
				Main.mushroomBG[2] = 233;
				break;
			case 2:
				Main.mushroomBG[0] = 234;
				Main.mushroomBG[1] = 235;
				Main.mushroomBG[2] = 236;
				break;
			case 3:
				Main.mushroomBG[0] = 287;
				Main.mushroomBG[1] = 288;
				Main.mushroomBG[2] = 289;
				break;
			case 4:
				Main.mushroomBG[0] = 321;
				Main.mushroomBG[1] = 320;
				Main.mushroomBG[2] = 319;
				break;
			}
			break;
		case 9:
			underworldBG = style;
			switch (style)
			{
			default:
				Main.underworldBG[0] = 0;
				Main.underworldBG[1] = 1;
				Main.underworldBG[2] = 2;
				Main.underworldBG[3] = 3;
				Main.underworldBG[4] = 4;
				break;
			case 1:
				Main.underworldBG[0] = 5;
				Main.underworldBG[1] = 6;
				Main.underworldBG[2] = 7;
				Main.underworldBG[3] = 8;
				Main.underworldBG[4] = 9;
				break;
			case 2:
				Main.underworldBG[0] = 10;
				Main.underworldBG[1] = 11;
				Main.underworldBG[2] = 12;
				Main.underworldBG[3] = 13;
				Main.underworldBG[4] = 9;
				break;
			}
			break;
		}
	}

	private static void SetForestBGSet(int style, int[] mountainSet, int[] treeSet)
	{
		mountainSet[0] = 7;
		mountainSet[1] = 8;
		switch (style)
		{
		case 1:
			treeSet[0] = 50;
			treeSet[1] = 51;
			treeSet[2] = 52;
			break;
		case 2:
			treeSet[0] = 53;
			treeSet[1] = 54;
			treeSet[2] = 55;
			break;
		case 3:
			mountainSet[1] = 90;
			treeSet[0] = 91;
			treeSet[1] = -1;
			treeSet[2] = 92;
			break;
		case 31:
			mountainSet[1] = 90;
			treeSet[0] = 91;
			treeSet[1] = -1;
			treeSet[2] = 11;
			break;
		case 4:
			mountainSet[0] = 93;
			mountainSet[1] = 94;
			treeSet[0] = -1;
			treeSet[1] = -1;
			treeSet[2] = -1;
			break;
		case 5:
			mountainSet[0] = 93;
			mountainSet[1] = 94;
			treeSet[0] = -1;
			treeSet[1] = -1;
			treeSet[2] = 55;
			break;
		case 51:
			mountainSet[0] = 93;
			mountainSet[1] = 94;
			treeSet[0] = -1;
			treeSet[1] = -1;
			treeSet[2] = 11;
			break;
		case 6:
			mountainSet[0] = 171;
			mountainSet[1] = 172;
			treeSet[0] = 173;
			treeSet[1] = -1;
			treeSet[2] = -1;
			break;
		case 7:
			mountainSet[0] = 176;
			mountainSet[1] = 177;
			treeSet[0] = 178;
			treeSet[1] = -1;
			treeSet[2] = -1;
			break;
		case 71:
			mountainSet[0] = 176;
			mountainSet[1] = 177;
			treeSet[0] = 178;
			treeSet[1] = -1;
			treeSet[2] = 11;
			break;
		case 72:
			mountainSet[0] = 176;
			mountainSet[1] = 177;
			treeSet[0] = 178;
			treeSet[1] = -1;
			treeSet[2] = 52;
			break;
		case 73:
			mountainSet[0] = 176;
			mountainSet[1] = 177;
			treeSet[0] = 178;
			treeSet[1] = -1;
			treeSet[2] = 55;
			break;
		case 8:
			mountainSet[0] = 179;
			mountainSet[1] = 180;
			treeSet[0] = 184;
			treeSet[1] = -1;
			treeSet[2] = -1;
			break;
		case 9:
			mountainSet[0] = 277;
			mountainSet[1] = 278;
			treeSet[0] = 279;
			treeSet[1] = -1;
			treeSet[2] = -1;
			break;
		case 10:
			mountainSet[0] = 280;
			mountainSet[1] = 281;
			treeSet[0] = 282;
			treeSet[1] = -1;
			treeSet[2] = -1;
			break;
		case 11:
			mountainSet[1] = 331;
			treeSet[0] = 330;
			treeSet[1] = 329;
			treeSet[2] = 328;
			break;
		case 12:
			mountainSet[1] = 336;
			treeSet[0] = 335;
			treeSet[1] = 334;
			treeSet[2] = 333;
			break;
		case 13:
			mountainSet[1] = -1;
			treeSet[0] = 343;
			treeSet[1] = 342;
			treeSet[2] = 341;
			break;
		default:
			treeSet[0] = 9;
			treeSet[1] = 10;
			treeSet[2] = 11;
			break;
		}
	}

	public static void RandomizeWeather()
	{
		Main.numClouds = genRand.Next(10, 200);
		Main.windSpeedCurrent = 0f;
		while (Main.windSpeedCurrent == 0f)
		{
			Main.windSpeedCurrent = genRand.NextFloat() * 0.35f * (float)(genRand.Next(2) * 2 - 1);
			Main.windSpeedTarget = Main.windSpeedCurrent;
		}
		Cloud.resetClouds();
	}

	public static void RandomizeMoonState(UnifiedRandom random, bool garenteeNewStyle = false)
	{
		int moonType = Main.moonType;
		do
		{
			Main.moonType = random.Next(9);
		}
		while (garenteeNewStyle && moonType == Main.moonType);
	}

	public static void RandomizeBackgroundBasedOnPlayer(UnifiedRandom random, Player player)
	{
		if (player.ZoneGlowshroom)
		{
			int num = mushroomBG;
			while (num == mushroomBG)
			{
				setBG(8, random.Next(5));
			}
		}
		else if (player.ZoneUnderworldHeight)
		{
			int num = underworldBG;
			while (num == underworldBG)
			{
				setBG(9, random.Next(3));
			}
		}
		else if (player.ZoneDesert)
		{
			int num = desertBG;
			do
			{
				desertBG = RandomizeBackgrounds_Desert(random);
			}
			while (num == desertBG);
			setBG(6, desertBG);
		}
		else if (player.ZoneHallow)
		{
			int num = hallowBG;
			while (num == hallowBG)
			{
				setBG(4, random.Next(6));
			}
		}
		else if (player.ZoneCorrupt)
		{
			int num = corruptBG;
			do
			{
				corruptBG = RandomizeBackgrounds_Corruption(random);
			}
			while (num == corruptBG);
			setBG(1, corruptBG);
		}
		else if (player.ZoneCrimson)
		{
			int num = crimsonBG;
			while (num == crimsonBG)
			{
				setBG(5, random.Next(7));
			}
		}
		else if (player.ZoneJungle)
		{
			int num = jungleBG;
			while (num == jungleBG)
			{
				setBG(2, random.Next(7));
			}
		}
		else if (player.ZoneSnow)
		{
			int num = snowBG;
			while (num == snowBG)
			{
				snowBG = random.Next(9);
				if (snowBG == 2 && random.Next(2) == 0)
				{
					if (random.Next(2) == 0)
					{
						snowBG = 21;
					}
					else
					{
						snowBG = 22;
					}
				}
				if (snowBG == 3 && random.Next(2) == 0)
				{
					if (random.Next(2) == 0)
					{
						snowBG = 31;
					}
					else
					{
						snowBG = 32;
					}
				}
				if (snowBG == 4 && random.Next(2) == 0)
				{
					if (random.Next(2) == 0)
					{
						snowBG = 41;
					}
					else
					{
						snowBG = 42;
					}
				}
				setBG(3, snowBG);
			}
		}
		else if (player.ZoneBeach)
		{
			int num = oceanBG;
			while (num == oceanBG)
			{
				setBG(7, random.Next(8));
			}
		}
		else
		{
			int num2 = (int)(player.Center.X / 16f);
			if (num2 < Main.treeX[0])
			{
				int num = treeBG1;
				while (IsBackgroundConsideredTheSame(num, treeBG1))
				{
					treeBG1 = RollRandomForestBGStyle(random);
				}
				setBG(0, treeBG1);
			}
			else if (num2 < Main.treeX[1])
			{
				int num = treeBG2;
				while (IsBackgroundConsideredTheSame(num, treeBG2))
				{
					treeBG2 = RollRandomForestBGStyle(random);
				}
				setBG(10, treeBG2);
			}
			else if (num2 < Main.treeX[2])
			{
				int num = treeBG3;
				while (IsBackgroundConsideredTheSame(num, treeBG3))
				{
					treeBG3 = RollRandomForestBGStyle(random);
				}
				setBG(11, treeBG3);
			}
			else
			{
				int num = treeBG4;
				while (IsBackgroundConsideredTheSame(num, treeBG4))
				{
					treeBG4 = RollRandomForestBGStyle(random);
				}
				setBG(12, treeBG4);
			}
		}
		BackgroundsCache.UpdateCache();
	}

	public static void RandomizeBackgrounds(UnifiedRandom random)
	{
		treeBG1 = RollRandomForestBGStyle(random);
		for (treeBG2 = RollRandomForestBGStyle(random); treeBG2 == treeBG1; treeBG2 = RollRandomForestBGStyle(random))
		{
		}
		treeBG3 = RollRandomForestBGStyle(random);
		while (treeBG3 == treeBG1 || treeBG3 == treeBG2)
		{
			treeBG3 = RollRandomForestBGStyle(random);
		}
		treeBG4 = RollRandomForestBGStyle(random);
		while (treeBG4 == treeBG1 || treeBG4 == treeBG2 || treeBG4 == treeBG3)
		{
			treeBG4 = RollRandomForestBGStyle(random);
		}
		setBG(0, treeBG1);
		setBG(10, treeBG2);
		setBG(11, treeBG3);
		setBG(12, treeBG4);
		setBG(1, RandomizeBackgrounds_Corruption(random));
		setBG(2, random.Next(7));
		snowBG = random.Next(9);
		if (snowBG == 2 && random.Next(2) == 0)
		{
			if (random.Next(2) == 0)
			{
				snowBG = 21;
			}
			else
			{
				snowBG = 22;
			}
		}
		if (snowBG == 3 && random.Next(2) == 0)
		{
			if (random.Next(2) == 0)
			{
				snowBG = 31;
			}
			else
			{
				snowBG = 32;
			}
		}
		if (snowBG == 4 && random.Next(2) == 0)
		{
			if (random.Next(2) == 0)
			{
				snowBG = 41;
			}
			else
			{
				snowBG = 42;
			}
		}
		setBG(3, snowBG);
		setBG(4, random.Next(6));
		setBG(5, random.Next(7));
		setBG(6, RandomizeBackgrounds_Desert(random));
		setBG(7, random.Next(8));
		setBG(8, random.Next(5));
		setBG(9, random.Next(3));
	}

	private static int RandomizeBackgrounds_Corruption(UnifiedRandom random)
	{
		int num = random.Next(6);
		if (num == 5)
		{
			num = ((random.Next(2) == 0) ? 51 : 52);
		}
		return num;
	}

	private static int RandomizeBackgrounds_Desert(UnifiedRandom random)
	{
		int num = random.Next(6);
		if (num == 5)
		{
			int num2 = random.Next(5);
			num = 51 + num2 / 2;
		}
		return num;
	}

	private static int RollRandomForestBGStyle(UnifiedRandom random)
	{
		int maxValue = 14;
		int num = random.Next(maxValue);
		if ((num == 1 || num == 2) && random.Next(2) == 0)
		{
			num = random.Next(maxValue);
		}
		if (num == 0)
		{
			num = random.Next(maxValue);
		}
		if (num == 3 && random.Next(3) == 0)
		{
			num = 31;
		}
		if (num == 5 && random.Next(2) == 0)
		{
			num = 51;
		}
		if (num == 7 && random.Next(4) == 0)
		{
			num = random.Next(71, 74);
		}
		return num;
	}

	public static bool IsBackgroundConsideredTheSame(int oldBG, int newBG)
	{
		switch (oldBG)
		{
		case 3:
		case 31:
			if (newBG != 3)
			{
				return newBG == 31;
			}
			return true;
		case 5:
		case 51:
			if (newBG != 5)
			{
				return newBG == 51;
			}
			return true;
		case 7:
		case 71:
		case 72:
		case 73:
			if (newBG != 7)
			{
				if (newBG >= 71)
				{
					return newBG <= 73;
				}
				return false;
			}
			return true;
		default:
			return oldBG == newBG;
		}
	}

	public static int GetCurrentBackgroundOfStyle(int backgroundStyle)
	{
		return backgroundStyle switch
		{
			0 => treeBG1, 
			10 => treeBG2, 
			11 => treeBG3, 
			12 => treeBG4, 
			1 => corruptBG, 
			8 => crimsonBG, 
			6 => hallowBG, 
			2 => desertBG, 
			3 => jungleBG, 
			4 => oceanBG, 
			7 => snowBG, 
			9 => mushroomBG, 
			_ => -1, 
		};
	}

	public static void RandomizeTreeStyle()
	{
		if (Main.maxTilesX == 4200)
		{
			Main.treeX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.5 - (double)Main.maxTilesX * 0.25), (int)((double)Main.maxTilesX * 0.5 + (double)Main.maxTilesX * 0.25));
			Main.treeStyle[0] = genRand.Next(6);
			Main.treeStyle[1] = genRand.Next(6);
			while (Main.treeStyle[1] == Main.treeStyle[0])
			{
				Main.treeStyle[1] = genRand.Next(6);
			}
			Main.treeX[1] = Main.maxTilesX;
			Main.treeX[2] = Main.maxTilesX;
			for (int i = 0; i < 2; i++)
			{
				if (Main.treeStyle[i] == 0 && genRand.Next(3) != 0)
				{
					Main.treeStyle[i] = 4;
				}
			}
			return;
		}
		if (Main.maxTilesX == 6400)
		{
			Main.treeX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.334 - (double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.334 + (double)Main.maxTilesX * 0.2));
			Main.treeX[1] = genRand.Next((int)((double)Main.maxTilesX * 0.667 - (double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.667 + (double)Main.maxTilesX * 0.2));
			Main.treeStyle[0] = genRand.Next(6);
			Main.treeStyle[1] = genRand.Next(6);
			Main.treeStyle[2] = genRand.Next(6);
			while (Main.treeStyle[1] == Main.treeStyle[0])
			{
				Main.treeStyle[1] = genRand.Next(6);
			}
			while (Main.treeStyle[2] == Main.treeStyle[0] || Main.treeStyle[2] == Main.treeStyle[1])
			{
				Main.treeStyle[2] = genRand.Next(6);
			}
			Main.treeX[2] = Main.maxTilesX;
			for (int j = 0; j < 3; j++)
			{
				if (Main.treeStyle[j] == 0 && genRand.Next(3) != 0)
				{
					Main.treeStyle[j] = 4;
				}
			}
			return;
		}
		Main.treeX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.25 - (double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.25 + (double)Main.maxTilesX * 0.15));
		Main.treeX[1] = genRand.Next((int)((double)Main.maxTilesX * 0.5 - (double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.5 + (double)Main.maxTilesX * 0.15));
		Main.treeX[2] = genRand.Next((int)((double)Main.maxTilesX * 0.75 - (double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.75 + (double)Main.maxTilesX * 0.15));
		Main.treeStyle[0] = genRand.Next(6);
		Main.treeStyle[1] = genRand.Next(6);
		Main.treeStyle[2] = genRand.Next(6);
		Main.treeStyle[3] = genRand.Next(6);
		while (Main.treeStyle[1] == Main.treeStyle[0])
		{
			Main.treeStyle[1] = genRand.Next(6);
		}
		while (Main.treeStyle[2] == Main.treeStyle[0] || Main.treeStyle[2] == Main.treeStyle[1])
		{
			Main.treeStyle[2] = genRand.Next(6);
		}
		while (Main.treeStyle[3] == Main.treeStyle[0] || Main.treeStyle[3] == Main.treeStyle[1] || Main.treeStyle[3] == Main.treeStyle[2])
		{
			Main.treeStyle[3] = genRand.Next(6);
		}
		for (int k = 0; k < 4; k++)
		{
			if (Main.treeStyle[k] == 0 && genRand.Next(3) != 0)
			{
				Main.treeStyle[k] = 4;
			}
		}
	}

	public static void RandomizeCaveBackgrounds()
	{
		int maxValue = 8;
		if (Main.maxTilesX == 4200)
		{
			Main.caveBackX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.5 - (double)Main.maxTilesX * 0.25), (int)((double)Main.maxTilesX * 0.5 + (double)Main.maxTilesX * 0.25));
			Main.caveBackX[1] = Main.maxTilesX;
			Main.caveBackX[2] = Main.maxTilesX;
			Main.caveBackStyle[0] = genRand.Next(maxValue);
			Main.caveBackStyle[1] = genRand.Next(maxValue);
			while (Main.caveBackStyle[1] == Main.caveBackStyle[0])
			{
				Main.caveBackStyle[1] = genRand.Next(maxValue);
			}
		}
		else if (Main.maxTilesX == 6400)
		{
			Main.caveBackX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.334 - (double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.334 + (double)Main.maxTilesX * 0.2));
			Main.caveBackX[1] = genRand.Next((int)((double)Main.maxTilesX * 0.667 - (double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.667 + (double)Main.maxTilesX * 0.2));
			Main.caveBackX[2] = Main.maxTilesX;
			Main.caveBackStyle[0] = genRand.Next(maxValue);
			Main.caveBackStyle[1] = genRand.Next(maxValue);
			Main.caveBackStyle[2] = genRand.Next(maxValue);
			while (Main.caveBackStyle[1] == Main.caveBackStyle[0])
			{
				Main.caveBackStyle[1] = genRand.Next(maxValue);
			}
			while (Main.caveBackStyle[2] == Main.caveBackStyle[0] || Main.caveBackStyle[2] == Main.caveBackStyle[1])
			{
				Main.caveBackStyle[2] = genRand.Next(maxValue);
			}
		}
		else
		{
			Main.caveBackX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.25 - (double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.25 + (double)Main.maxTilesX * 0.15));
			Main.caveBackX[1] = genRand.Next((int)((double)Main.maxTilesX * 0.5 - (double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.5 + (double)Main.maxTilesX * 0.15));
			Main.caveBackX[2] = genRand.Next((int)((double)Main.maxTilesX * 0.75 - (double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.75 + (double)Main.maxTilesX * 0.15));
			Main.caveBackStyle[0] = genRand.Next(maxValue);
			Main.caveBackStyle[1] = genRand.Next(maxValue);
			Main.caveBackStyle[2] = genRand.Next(maxValue);
			Main.caveBackStyle[3] = genRand.Next(maxValue);
			while (Main.caveBackStyle[1] == Main.caveBackStyle[0])
			{
				Main.caveBackStyle[1] = genRand.Next(maxValue);
			}
			while (Main.caveBackStyle[2] == Main.caveBackStyle[0] || Main.caveBackStyle[2] == Main.caveBackStyle[1])
			{
				Main.caveBackStyle[2] = genRand.Next(maxValue);
			}
			while (Main.caveBackStyle[3] == Main.caveBackStyle[0] || Main.caveBackStyle[3] == Main.caveBackStyle[1] || Main.caveBackStyle[3] == Main.caveBackStyle[2])
			{
				Main.caveBackStyle[3] = genRand.Next(maxValue);
			}
		}
		Main.iceBackStyle = genRand.Next(4);
		Main.hellBackStyle = genRand.Next(3);
		Main.jungleBackStyle = genRand.Next(2);
	}

	public static int[] GetTilesToAvoidForSpawn_TeamBasedSpawns()
	{
		int[] array = new int[37]
		{
			70, 23, 199, 661, 662, 41, 43, 44, 226, 57,
			633, 397, 396, 25, 163, 112, 398, 400, 203, 200,
			234, 399, 401, 117, 164, 116, 402, 403, 379, 135,
			37, 189, 196, 460, 717, 718, 719
		};
		for (int i = 0; i < array.Length; i++)
		{
			if (Main.noTrapsWorld && array[i] == 135)
			{
				array[i] = -1;
			}
			if (SecretSeed.extraLiquid.Enabled && array[i] == 379)
			{
				array[i] = -1;
			}
			if (skyblockWorldGen && (array[i] == 189 || array[i] == 196 || array[i] == 460 || array[i] == 717 || array[i] == 718 || array[i] == 719))
			{
				array[i] = -1;
			}
			if (Main.remixWorld && array[i] == 70)
			{
				array[i] = -1;
			}
			if (SecretSeed.errorWorld.Enabled && (array[i] == 57 || array[i] == 70 || array[i] == 161 || array[i] == 53 || array[i] == 397 || array[i] == 396 || array[i] == 163 || array[i] == 200 || array[i] == 135 || array[i] == 379 || array[i] == 37))
			{
				array[i] = -1;
			}
			if (SecretSeed.worldIsFrozen.Enabled)
			{
				if (array[i] == 161 || array[i] == 147 || array[i] == 162)
				{
					array[i] = -1;
				}
				if (SecretSeed.worldIsInfected.Enabled && (array[i] == 163 || array[i] == 200))
				{
					array[i] = -1;
				}
			}
			if (Main.notTheBeesWorld)
			{
				if (array[i] == 60)
				{
					array[i] = -1;
				}
				if (SecretSeed.worldIsInfected.Enabled && (array[i] == 661 || array[i] == 662))
				{
					array[i] = -1;
				}
			}
			if (SecretSeed.worldIsInfected.Enabled && (array[i] == 23 || array[i] == 199 || array[i] == 25 || array[i] == 203))
			{
				array[i] = -1;
			}
		}
		return array;
	}

	private static void ResetGenerator()
	{
		GenVars.worldSpawnHasBeenRandomized = false;
		GenVars.landmassData.Clear();
		GenVars.boulderPetsPlaced = 0;
		GenVars.numOrePatch = 0;
		GenVars.numTunnels = 0;
		GenVars.numLakes = 0;
		GenVars.numMushroomBiomes = 0;
		GenVars.numOceanCaveTreasure = 0;
		GenVars.numOasis = 0;
		GenVars.mudWall = false;
		GenVars.hellChest = 0;
		GenVars.JungleX = 0;
		GenVars.numMCaves = 0;
		GenVars.numIslandHouses = 0;
		GenVars.skyIslandHouseCount = 0;
		GenVars.dungeonGenVars.Clear();
		GenVars.CurrentDungeon = 0;
		GenVars.generatedShadowKey = false;
		GenVars.generatedRamRune = false;
		GenVars.numJChests = 0;
		GenVars.JungleItemCount = 0;
		GenVars.gennedLivingMahoganyWands = false;
		GenVars.crimStoneWall = 83;
		GenVars.crimStone = 203;
		GenVars.ebonStoneWall = 3;
		GenVars.ebonStone = 25;
	}

	public static bool mayanTrap(int x2, int y2)
	{
		if (SecretSeed.Variations.actuallyNoTrapsForRealIMeanIt)
		{
			return true;
		}
		int num = Main.maxTilesY - 300;
		if (Main.dualDungeonsSeed)
		{
			num = Main.UnderworldLayer - 5;
		}
		int num2 = 1;
		if (genRand.Next(3) == 0)
		{
			num2 = 0;
		}
		int num3 = y2;
		while (!SolidOrSlopedTile(x2, num3))
		{
			num3++;
			if (num3 >= num)
			{
				return false;
			}
		}
		if (Main.tile[x2, num3].type == 232 || Main.tile[x2, num3].type == 10)
		{
			return false;
		}
		num3--;
		if (Main.tile[x2, num3].liquid > 0 && Main.tile[x2, num3].lava())
		{
			return false;
		}
		if (num2 == -1 && genRand.Next(20) == 0)
		{
			num2 = 2;
		}
		else if (num2 == -1)
		{
			num2 = genRand.Next(2);
		}
		if (Main.tile[x2, num3].nactive() || Main.tile[x2 - 1, num3].nactive() || Main.tile[x2 + 1, num3].nactive() || Main.tile[x2, num3 - 1].nactive() || Main.tile[x2 - 1, num3 - 1].nactive() || Main.tile[x2 + 1, num3 - 1].nactive() || Main.tile[x2, num3 - 2].nactive() || Main.tile[x2 - 1, num3 - 2].nactive() || Main.tile[x2 + 1, num3 - 2].nactive())
		{
			return false;
		}
		if (Main.tile[x2, num3 + 1].type == 10)
		{
			return false;
		}
		if (Main.tile[x2, num3 + 1].type == 48)
		{
			return false;
		}
		if (Main.tile[x2, num3 + 1].type == 232)
		{
			return false;
		}
		switch (num2)
		{
		case 0:
		{
			int num11 = x2;
			int num12 = num3;
			num12 -= genRand.Next(3);
			while (InWorld(num11, num12, 5) && !SolidOrSlopedTile(num11, num12))
			{
				num11--;
			}
			int num13 = num11;
			for (num11 = x2; InWorld(num11, num12, 5) && !SolidOrSlopedTile(num11, num12); num11++)
			{
			}
			int num14 = num11;
			int num15 = x2 - num13;
			int num16 = num14 - x2;
			bool flag = false;
			bool flag2 = false;
			if (num15 > 5 && num15 < 50)
			{
				flag = true;
			}
			if (num16 > 5 && num16 < 50)
			{
				flag2 = true;
			}
			if (flag && !SolidOrSlopedTile(num13, num12 + 1))
			{
				flag = false;
			}
			if (flag2 && !SolidOrSlopedTile(num14, num12 + 1))
			{
				flag2 = false;
			}
			ushort num17 = 48;
			if (Main.dualDungeonsSeed)
			{
				num17 = 232;
			}
			if (flag && (Main.tile[num13, num12].type == 10 || Main.tile[num13, num12].type == num17 || Main.tile[num13, num12 + 1].type == 10 || Main.tile[num13, num12 + 1].type == num17))
			{
				flag = false;
			}
			if (flag2 && (Main.tile[num14, num12].type == 10 || Main.tile[num14, num12].type == num17 || Main.tile[num14, num12 + 1].type == 10 || Main.tile[num14, num12 + 1].type == num17))
			{
				flag2 = false;
			}
			int num18 = 0;
			if (flag && flag2)
			{
				num18 = 1;
				num11 = num13;
				if (genRand.Next(2) == 0)
				{
					num11 = num14;
					num18 = -1;
				}
			}
			else if (flag2)
			{
				num11 = num14;
				num18 = -1;
			}
			else
			{
				if (!flag)
				{
					return false;
				}
				num11 = num13;
				num18 = 1;
			}
			if (Main.tile[num11, num12].wall != 87)
			{
				return false;
			}
			if (Main.tile[num11, num12].type == 190)
			{
				return false;
			}
			if (Main.tile[num11, num12].type == 135)
			{
				return false;
			}
			if (Main.tile[num11, num12].type == 137)
			{
				return false;
			}
			if (Main.tile[num11, num12].type == 232)
			{
				return false;
			}
			if (Main.tile[num11, num12].type == 237)
			{
				return false;
			}
			if (Main.tile[num11, num12].type == 10)
			{
				return false;
			}
			if (!SolidTileAllowBottomSlope(x2, num3 + 1))
			{
				SlopeTile(x2, num3 + 1);
			}
			if (!CanGeneratePressurePlateAt(x2, num3))
			{
				return false;
			}
			PlaceTile(x2, num3, 135, mute: true, forced: true, -1, 6);
			KillTile(num11, num12);
			int num19 = genRand.Next(3);
			if (Main.tile[x2, num3].wire())
			{
				num19 = 0;
			}
			if (Main.tile[x2, num3].wire2())
			{
				num19 = 1;
			}
			if (Main.tile[x2, num3].wire3())
			{
				num19 = 2;
			}
			int num20 = Math.Abs(num11 - x2);
			int style2 = 1;
			if (num20 < 10 && genRand.Next(3) != 0)
			{
				style2 = 2;
			}
			PlaceTile(num11, num12, 137, mute: true, forced: true, -1, style2);
			if (num18 == 1)
			{
				Main.tile[num11, num12].frameX += 18;
			}
			int num21 = genRand.Next(5);
			int num22 = num12;
			while (num21 > 0)
			{
				num21--;
				num22--;
				if (!SolidTile(num11, num22) || !SolidTile(num11 - num18, num22) || SolidOrSlopedTile(num11 + num18, num22))
				{
					break;
				}
				PlaceTile(num11, num22, 137, mute: true, forced: true, -1, style2);
				if (num18 == 1)
				{
					Main.tile[num11, num22].frameX += 18;
				}
				switch (num19)
				{
				case 0:
					Main.tile[num11, num22].wire(wire: true);
					break;
				case 1:
					Main.tile[num11, num22].wire2(wire2: true);
					break;
				case 2:
					Main.tile[num11, num22].wire3(wire3: true);
					break;
				}
			}
			AddWireFromPointToPoint(x2, num3, num11, num12, num19);
			return true;
		}
		case 1:
		{
			int num4 = x2;
			int num5 = num3;
			while (!SolidOrSlopedTile(num4, num5))
			{
				num5--;
				if ((double)num5 < Main.worldSurface)
				{
					return false;
				}
			}
			int num6 = Math.Abs(num5 - num3);
			if (num6 < 3)
			{
				return false;
			}
			int num7 = genRand.Next(3);
			if (Main.tile[x2, num3].wire())
			{
				num7 = 0;
			}
			if (Main.tile[x2, num3].wire2())
			{
				num7 = 1;
			}
			if (Main.tile[x2, num3].wire3())
			{
				num7 = 2;
			}
			int style = 3;
			if (num6 < 16 && genRand.Next(3) != 0)
			{
				style = 4;
			}
			if (Main.tile[num4, num5].type == 135)
			{
				return false;
			}
			if (Main.tile[num4, num5].type == 137)
			{
				return false;
			}
			if (Main.tile[num4, num5].type == 232)
			{
				return false;
			}
			if (Main.tile[num4, num5].type == 237)
			{
				return false;
			}
			if (Main.tile[num4, num5].type == 10)
			{
				return false;
			}
			if (Main.tile[num4, num5].wall != 87)
			{
				return false;
			}
			if (!SolidTileAllowBottomSlope(x2, num3 + 1))
			{
				SlopeTile(x2, num3 + 1);
			}
			if (!CanGeneratePressurePlateAt(x2, num3))
			{
				return false;
			}
			PlaceTile(x2, num3, 135, mute: true, forced: true, -1, 6);
			PlaceTile(num4, num5, 137, mute: true, forced: true, -1, style);
			for (int i = 0; i < 2; i++)
			{
				int num8 = genRand.Next(1, 5);
				int num9 = num4;
				int num10 = -1;
				if (i == 1)
				{
					num10 = 1;
				}
				while (num8 > 0)
				{
					num8--;
					num9 += num10;
					if (!SolidTile(num9, num5 - 1) || SolidOrSlopedTile(num9, num5 + 1))
					{
						break;
					}
					PlaceTile(num9, num5, 137, mute: true, forced: true, -1, style);
					switch (num7)
					{
					case 0:
						Main.tile[num9, num5].wire(wire: true);
						break;
					case 1:
						Main.tile[num9, num5].wire2(wire2: true);
						break;
					case 2:
						Main.tile[num9, num5].wire3(wire3: true);
						break;
					}
				}
			}
			AddWireFromPointToPoint(x2, num3, num4, num5, num7);
			return true;
		}
		default:
			return false;
		}
	}

	public static bool placeLavaTrap(int x, int y)
	{
		if (SecretSeed.Variations.actuallyNoTrapsForRealIMeanIt)
		{
			return true;
		}
		int num = 5;
		int num2 = 50;
		int num3 = 40;
		int num4 = 20;
		int num5 = 4;
		if (Main.tile[x, y].active() || Main.tile[x, y].liquid < byte.MaxValue || !Main.tile[x, y].lava())
		{
			return false;
		}
		int num6 = 0;
		for (int i = x - num; i <= x + num; i++)
		{
			for (int j = y - num; j <= y + num; j++)
			{
				if (Main.tile[i, j].lava() && !Main.tile[i, j].active() && Main.tile[i, j].liquid == byte.MaxValue)
				{
					num6++;
				}
			}
		}
		if (num6 < num2)
		{
			return false;
		}
		int num7 = y;
		while (!Main.tile[x, num7].active())
		{
			num7++;
			if (num7 > Main.maxTilesY - 200)
			{
				return false;
			}
		}
		if (!Main.tileSolid[Main.tile[x, num7].type] || Main.tileSolidTop[Main.tile[x, num7].type])
		{
			return false;
		}
		int num8 = num7;
		for (int k = x - num4; k <= x + num4; k++)
		{
			for (int l = num7 - num4; l <= num7 + num4; l++)
			{
				if (Main.tile[k, l].wire())
				{
					return false;
				}
			}
		}
		while (Main.tile[x, num7].active() && Main.tileSolid[Main.tile[x, num7].type] && !Main.tileSolidTop[Main.tile[x, num7].type])
		{
			num7++;
			if (num7 > Main.maxTilesY - 200)
			{
				return false;
			}
		}
		Tile tile = Main.tile[x, num7 - 1];
		if (Main.tileDungeon[tile.type] || tile.type == 225 || tile.type == 226)
		{
			return false;
		}
		int num9 = num7;
		while (!Main.tile[x, num7].active())
		{
			num7++;
			if (num7 > Main.maxTilesY - 200 || Main.tile[x, num7].liquid > 0)
			{
				return false;
			}
		}
		if (!Main.tileSolid[Main.tile[x, num7].type] || Main.tileSolidTop[Main.tile[x, num7].type] || Main.tile[x, num7].type == 162)
		{
			return false;
		}
		int num10 = num7 - 1;
		if (num10 - num8 > num3)
		{
			return false;
		}
		if (num10 - num9 < num5)
		{
			return false;
		}
		Main.tile[x, num7].slope(0);
		Main.tile[x, num7].halfBrick(halfBrick: false);
		PlaceTile(x, num10, 135, mute: false, forced: true, -1, 7);
		for (int m = num8; m <= num10; m++)
		{
			Main.tile[x, m].wire(wire: true);
			if (m < num9)
			{
				Main.tile[x, m].slope(0);
				Main.tile[x, m].halfBrick(halfBrick: false);
				Main.tile[x, m].actuator(actuator: true);
			}
		}
		return true;
	}

	public static bool AreAnyTilesInSetNearby(int x, int y, bool[] tileset, int distance)
	{
		for (int i = x - distance; i <= x + distance; i++)
		{
			for (int j = y - distance; j <= y + distance; j++)
			{
				if (InWorld(i, j))
				{
					Tile tile = Main.tile[i, j];
					if (tile != null && tile.active() && tile.type >= 0 && tileset[tile.type])
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	private static bool closeEnoughToDungeonToSpawnGhoulder(int x, int y)
	{
		if (GenVars.CurrentDungeonGenVars.dungeonSide <= DungeonSide.Left && x > Main.maxTilesX / 2)
		{
			return false;
		}
		if (GenVars.CurrentDungeonGenVars.dungeonSide >= DungeonSide.Right && x < Main.maxTilesX / 2)
		{
			return false;
		}
		int num = 1000;
		for (int i = x - num; i <= x + num; i += 10)
		{
			for (int j = y - num; j <= y + num; j += 10)
			{
				if (InWorld(i, j) && Main.wallDungeon[Main.tile[i, j].wall])
				{
					return true;
				}
			}
		}
		return false;
	}

	private static bool closeEnoughToSpidersToSpawnSpiderBoulder(int x, int y)
	{
		int num = 80;
		for (int i = x - num; i <= x + num; i += 3)
		{
			for (int j = y - num; j <= y + num; j += 3)
			{
				if (InWorld(i, j) && Main.tile[i, j].wall == 62)
				{
					return true;
				}
			}
		}
		return false;
	}

	private static bool closeEnoughToLavaToSpawnLavaBoulder(int x, int y)
	{
		int num = 60;
		for (int i = x - num; i <= x + num; i += 3)
		{
			for (int j = y - num; j <= y + num; j += 3)
			{
				if (InWorld(i, j) && Main.tile[i, j].liquid > 0 && Main.tile[i, j].lava())
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool IsTileNearby(int x, int y, int type, int distance)
	{
		int num = 1;
		if (type == 235)
		{
			num = 3;
		}
		for (int i = x - distance; i <= x + distance; i += num)
		{
			for (int j = y - distance; j <= y + distance; j++)
			{
				if (InWorld(i, j))
				{
					Tile tile = Main.tile[i, j];
					if (tile != null && tile.active() && tile.type == type)
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	private static bool placeTNTBarrel(int x, int y)
	{
		int num = y;
		while (!Main.tile[x, num].active())
		{
			num++;
			if (num > Main.maxTilesY - 350)
			{
				return false;
			}
		}
		num--;
		if (Main.tile[x, num].anyShimmer())
		{
			return false;
		}
		if (PlaceTile(x, num, 654))
		{
			return true;
		}
		return false;
	}

	public static bool placeTrap(int x2, int y2, int type = -1)
	{
		if (SecretSeed.Variations.actuallyNoTrapsForRealIMeanIt)
		{
			return true;
		}
		int num = y2;
		if (Vector2D.Distance(new Vector2D(x2, y2), GenVars.shimmerPosition) < 100.0)
		{
			return false;
		}
		bool flag = false;
		bool flag2 = false;
		if (noTrapsWorldGen)
		{
			SetBoulderSolidity(solid: false);
		}
		while (!SolidTile(x2, num))
		{
			num++;
			if (num > Main.maxTilesY - 10)
			{
				return false;
			}
			if (num >= Main.maxTilesY - 300)
			{
				flag2 = true;
			}
		}
		if (noTrapsWorldGen)
		{
			SetBoulderSolidity(solid: true);
		}
		num--;
		if (!noTrapsWorldGen && IsTileNearby(x2, num, 70, 20))
		{
			return false;
		}
		if (Main.tile[x2, num].wall == 87)
		{
			return false;
		}
		if (Main.tile[x2, num].wall == 350)
		{
			return false;
		}
		if (Main.tile[x2, num].liquid > 0 && Main.tile[x2, num].lava())
		{
			flag = true;
		}
		if (Main.remixWorld)
		{
			if (type == -1 && genRand.Next(20) == 0)
			{
				type = 2;
			}
			else if (type == -1 && (double)num < Main.rockLayer - 30.0 && genRand.Next(3) != 0)
			{
				type = 3;
			}
			else if (type == -1)
			{
				type = genRand.Next(2);
			}
		}
		else
		{
			if (type == -1 && genRand.Next(20) == 0)
			{
				type = 2;
			}
			else if (type == -1 && num > GenVars.lavaLine + 30 && genRand.Next(6) != 0)
			{
				type = 3;
			}
			else if (type == -1)
			{
				type = genRand.Next(2);
			}
			if (noTrapsWorldGen && tenthAnniversaryWorldGen && genRand.Next(4) == 0)
			{
				type = 1;
			}
		}
		if (!InWorld(x2, num, 3))
		{
			return false;
		}
		if (flag && type != 3)
		{
			return false;
		}
		if (flag2 && type != 3)
		{
			return false;
		}
		if (Main.tile[x2, num].nactive() || Main.tile[x2 - 1, num].nactive() || Main.tile[x2 + 1, num].nactive() || Main.tile[x2, num - 1].nactive() || Main.tile[x2 - 1, num - 1].nactive() || Main.tile[x2 + 1, num - 1].nactive() || Main.tile[x2, num - 2].nactive() || Main.tile[x2 - 1, num - 2].nactive() || Main.tile[x2 + 1, num - 2].nactive())
		{
			return false;
		}
		Tile tile = Main.tile[x2, num + 1];
		if (tile.active() && (tile.type == 48 || tile.type == 232))
		{
			return false;
		}
		if (!CanGeneratePressurePlateAt(x2, num))
		{
			return false;
		}
		if (type == 1)
		{
			for (int i = x2 - 3; i <= x2 + 3; i++)
			{
				for (int j = num - 3; j <= num + 3; j++)
				{
					if (Main.tile[i, j].active() && (Main.tile[i, j].type == 147 || Main.tile[i, j].type == 161))
					{
						type = 0;
					}
				}
			}
		}
		if (skyblockWorldGen && type == 2)
		{
			return false;
		}
		if (noTrapsWorldGen)
		{
			SetBoulderSolidity(solid: false);
		}
		switch (type)
		{
		case 0:
		{
			int num26 = x2;
			int num27 = num;
			num27 -= genRand.Next(3);
			while (!SolidTile(num26, num27) && (!Main.tile[num26, num27].active() || !Main.tileCracked[Main.tile[num26, num27].type]))
			{
				num26--;
				if (num26 < 0)
				{
					return false;
				}
			}
			int num28 = num26;
			num26 = x2;
			while (!SolidTile(num26, num27) && (!Main.tile[num26, num27].active() || !Main.tileCracked[Main.tile[num26, num27].type]))
			{
				num26++;
				if (num26 > Main.maxTilesX)
				{
					return false;
				}
			}
			int num29 = num26;
			int num30 = x2 - num28;
			int num31 = num29 - x2;
			bool flag5 = false;
			bool flag6 = false;
			if (num30 > 5 && num30 < 50)
			{
				flag5 = true;
			}
			if (num31 > 5 && num31 < 50)
			{
				flag6 = true;
			}
			if (flag5 && !SolidTile(num28, num27 + 1))
			{
				flag5 = false;
			}
			if (flag6 && !SolidTile(num29, num27 + 1))
			{
				flag6 = false;
			}
			if (flag5 && ((Main.tile[num28, num27].active() && (Main.tile[num28, num27].type == 10 || Main.tile[num28, num27].type == 48)) || (Main.tile[num28, num27 + 1].active() && (Main.tile[num28, num27 + 1].type == 10 || Main.tile[num28, num27 + 1].type == 48))))
			{
				flag5 = false;
			}
			if (flag6 && ((Main.tile[num29, num27].active() && (Main.tile[num29, num27].type == 10 || Main.tile[num29, num27].type == 48)) || (Main.tile[num29, num27 + 1].active() && (Main.tile[num29, num27 + 1].type == 10 || Main.tile[num29, num27 + 1].type == 48))))
			{
				flag6 = false;
			}
			int num32 = 0;
			if (flag5 && flag6)
			{
				num32 = 1;
				num26 = num28;
				if (genRand.Next(2) == 0)
				{
					num26 = num29;
					num32 = -1;
				}
			}
			else if (flag6)
			{
				num26 = num29;
				num32 = -1;
			}
			else
			{
				if (!flag5)
				{
					trapDiag[type, 0]++;
					return false;
				}
				num26 = num28;
				num32 = 1;
			}
			if (Main.tile[num26, num27].type == 190)
			{
				trapDiag[type, 0]++;
				return false;
			}
			if (Main.tile[num26, num27].wall == 350)
			{
				trapDiag[type, 0]++;
				return false;
			}
			if (Main.tile[x2, num].wall > 0)
			{
				PlaceTile(x2, num, 135, mute: true, forced: true, -1, 2);
			}
			else
			{
				PlaceTile(x2, num, 135, mute: true, forced: true, -1, genRand.Next(2, 4));
			}
			KillTile(num26, num27);
			int num33 = 0;
			if (notTheBees && noTrapsWorldGen && !remixWorldGen)
			{
				num33 = genRand.Next(1, 3);
				if (Main.tile[num26, num27].liquid > 0 || Main.tile[num26 - 1, num27].liquid > 0 || Main.tile[num26 + 1, num27].liquid > 0)
				{
					num33 = 1;
				}
			}
			PlaceTile(num26, num27, 137, mute: true, forced: true, -1, num33);
			if (num33 > 0 && dontStarveWorldGen)
			{
				Main.tile[num26, num27].color(27);
			}
			if (num32 == 1)
			{
				Main.tile[num26, num27].frameX += 18;
			}
			int num34 = x2;
			int num35 = num;
			while (num34 != num26 || num35 != num27)
			{
				Main.tile[num34, num35].wire(wire: true);
				if (num34 > num26)
				{
					num34--;
				}
				if (num34 < num26)
				{
					num34++;
				}
				Main.tile[num34, num35].wire(wire: true);
				if (num35 > num27)
				{
					num35--;
				}
				if (num35 < num27)
				{
					num35++;
				}
				Main.tile[num34, num35].wire(wire: true);
			}
			trapDiag[type, 1]++;
			return true;
		}
		case 1:
		{
			int num3 = GetWorldSize() switch
			{
				1 => 4, 
				2 => 6, 
				_ => 2, 
			};
			if (noTrapsWorldGen)
			{
				num3 *= 2;
				SetBoulderSolidity(solid: true);
			}
			int num4 = x2;
			int num5 = num - 8;
			num4 += genRand.Next(-1, 2);
			if (noTrapsWorldGen)
			{
				if (AreAnyTilesInSetNearby(num4, num5, TileID.Sets.Boulders, 6))
				{
					return false;
				}
			}
			else if (AreAnyTilesInSetNearby(num4, num5, TileID.Sets.Boulders, 10))
			{
				return false;
			}
			bool flag3 = true;
			while (flag3)
			{
				bool flag4 = true;
				int num6 = 0;
				for (int m = num4 - 2; m <= num4 + 3; m++)
				{
					for (int n = num5; n <= num5 + 3; n++)
					{
						if (!SolidTile(m, n))
						{
							flag4 = false;
						}
						Tile tile2 = Main.tile[m, n];
						if (tile2.active())
						{
							if (tile2.type == 226 || (tile2.type >= 0 && tile2.type < TileID.Count && Main.tileDungeon[tile2.type]))
							{
								trapDiag[type, 0]++;
								return false;
							}
							if (tile2.wall == 350)
							{
								trapDiag[type, 0]++;
								return false;
							}
							if (tile2.type == 0 || tile2.type == 1 || tile2.type == 59)
							{
								num6++;
							}
						}
					}
				}
				num5--;
				if ((double)num5 < Main.worldSurface)
				{
					trapDiag[type, 0]++;
					return false;
				}
				if (flag4 && num6 > 2)
				{
					flag3 = false;
				}
			}
			if (num - num5 <= 5 || num - num5 >= 40)
			{
				trapDiag[type, 0]++;
				return false;
			}
			if (IsTileNearby(num4, num5, 21, 4) || IsTileNearby(num4, num5, 467, 4))
			{
				trapDiag[type, 0]++;
				return false;
			}
			for (int num7 = num4; num7 <= num4 + 1; num7++)
			{
				for (int num8 = num5; num8 <= num; num8++)
				{
					if (Main.tile[num7, num8].type != 379)
					{
						KillTile(num7, num8);
					}
				}
			}
			for (int num9 = num4 - 2; num9 <= num4 + 3; num9++)
			{
				for (int num10 = num5 - 2; num10 <= num5 + 3; num10++)
				{
					if (SolidTile(num9, num10))
					{
						Main.tile[num9, num10].type = 1;
					}
				}
			}
			PlaceTile(x2, num, 135, mute: true, forced: true, -1, 7);
			PlaceTile(num4, num5 + 2, 1, mute: true);
			PlaceTile(num4 + 1, num5 + 2, 1, mute: true);
			ushort num11 = 138;
			int maxValue = 7;
			int maxValue2 = 2;
			int maxValue3 = 3;
			int maxValue4 = 6;
			if (noTrapsWorldGen)
			{
				maxValue2 = 1;
				maxValue3 = 2;
				maxValue4 = 4;
			}
			if (noTrapsWorldGen && !remixWorldGen)
			{
				maxValue = 5;
			}
			if (genRand.Next(maxValue2) == 0 && closeEnoughToSpidersToSpawnSpiderBoulder(num4, num5))
			{
				num11 = 714;
			}
			else if (genRand.Next(maxValue4) == 0 && closeEnoughToDungeonToSpawnGhoulder(num4, num5))
			{
				num11 = 715;
			}
			else if (genRand.Next(maxValue3) == 0 && closeEnoughToLavaToSpawnLavaBoulder(num4, num5))
			{
				num11 = 713;
			}
			else if ((notTheBees || noTrapsWorldGen || SecretSeed.pooEverywhere.Enabled) && genRand.Next(5) == 0)
			{
				num11 = 712;
			}
			else if (tenthAnniversaryWorldGen && genRand.Next(maxValue) == 0)
			{
				num11 = 711;
			}
			else if ((tenthAnniversaryWorldGen || noTrapsWorldGen) && genRand.Next(3) == 0)
			{
				num11 = 664;
			}
			else if (genRand.Next(25) == 0)
			{
				num11 = 711;
			}
			else if (genRand.Next(20) == 0)
			{
				num11 = 664;
			}
			if (num11 == 138 && GenVars.boulderPetsPlaced < num3)
			{
				GenVars.boulderPetsPlaced++;
				num11 = 716;
			}
			PlaceTile(num4 + 1, num5 + 1, num11, mute: true);
			num5 += 2;
			for (int num12 = 0; num12 < 2; num12++)
			{
				for (int num13 = 0; num13 < 3; num13++)
				{
					int num14 = num4 + num12;
					int num15 = num5 + num13;
					PlaceTile(num14, num15, 1, mute: true);
					Main.tile[num14, num15].wire(wire: true);
					Main.tile[num14, num15].actuator(actuator: true);
				}
			}
			int num16 = x2;
			int num17 = num;
			while (num16 != num4 || num17 != num5)
			{
				Main.tile[num16, num17].wire(wire: true);
				if (num16 > num4)
				{
					num16--;
				}
				if (num16 < num4)
				{
					num16++;
				}
				Main.tile[num16, num17].wire(wire: true);
				if (num17 > num5)
				{
					num17--;
				}
				if (num17 < num5)
				{
					num17++;
				}
				Main.tile[num16, num17].wire(wire: true);
			}
			trapDiag[type, 1]++;
			return true;
		}
		case 2:
		{
			int num18 = genRand.Next(4, 7);
			int num19 = x2;
			num19 += genRand.Next(-1, 2);
			int num20 = num;
			for (int num21 = 0; num21 < num18; num21++)
			{
				num20++;
				if (!SolidTile(num19, num20))
				{
					trapDiag[type, 0]++;
					return false;
				}
			}
			for (int num22 = num19 - 2; num22 <= num19 + 2; num22++)
			{
				for (int num23 = num20 - 2; num23 <= num20 + 2; num23++)
				{
					if (InWorld(num22, num23))
					{
						Tile tile3 = Main.tile[num22, num23];
						if (tile3 != null && tile3.wall == 350)
						{
							trapDiag[type, 0]++;
							return false;
						}
						if (!SolidTile(num22, num23))
						{
							trapDiag[type, 0]++;
							return false;
						}
					}
				}
			}
			KillTile(num19, num20);
			Main.tile[num19, num20].active(active: true);
			Main.tile[num19, num20].type = 141;
			Main.tile[num19, num20].frameX = 0;
			Main.tile[num19, num20].frameY = (short)(18 * genRand.Next(2));
			PlaceTile(x2, num, 135, mute: true, forced: true, -1, genRand.Next(2, 4));
			int num24 = x2;
			int num25 = num;
			while (num24 != num19 || num25 != num20)
			{
				Main.tile[num24, num25].wire(wire: true);
				if (num24 > num19)
				{
					num24--;
				}
				if (num24 < num19)
				{
					num24++;
				}
				Main.tile[num24, num25].wire(wire: true);
				if (num25 > num20)
				{
					num25--;
				}
				if (num25 < num20)
				{
					num25++;
				}
				Main.tile[num24, num25].wire(wire: true);
			}
			trapDiag[type, 1]++;
			break;
		}
		case 3:
		{
			if (Main.tile[x2 + 1, num].active())
			{
				return false;
			}
			if (Main.tile[x2, num].liquid > 0 && !Main.tile[x2, num].lava())
			{
				return false;
			}
			if (noTrapsWorldGen && (tenthAnniversaryWorldGen || notTheBees))
			{
				if (genRand.Next(3) != 0)
				{
					return false;
				}
				if (IsTileNearby(x2, num, 443, 30))
				{
					return false;
				}
			}
			for (int k = x2; k <= x2 + 1; k++)
			{
				int j2 = num + 1;
				if (!SolidTile(k, j2))
				{
					return false;
				}
			}
			int num2 = genRand.Next(2);
			for (int l = 0; l < 2; l++)
			{
				Main.tile[x2 + l, num].active(active: true);
				Main.tile[x2 + l, num].type = 443;
				Main.tile[x2 + l, num].frameX = (short)(18 * l + 36 * num2);
				Main.tile[x2 + l, num].frameY = 0;
			}
			return true;
		}
		}
		if (noTrapsWorldGen)
		{
			SetBoulderSolidity(solid: true);
		}
		return false;
	}

	public static int countWires(int x, int y, int size)
	{
		int num = 0;
		for (int i = x - size; i <= x + size; i++)
		{
			for (int j = y - size; j <= y + size; j++)
			{
				if (InWorld(i, j))
				{
					if (Main.tile[i, j].wire())
					{
						num++;
					}
					if (Main.tile[i, j].wire2())
					{
						num++;
					}
					if (Main.tile[i, j].wire3())
					{
						num++;
					}
					if (Main.tile[i, j].wire4())
					{
						num++;
					}
				}
			}
		}
		return num;
	}

	public static int countTiles(int x, int y, bool jungle = false, bool lavaOk = false)
	{
		numTileCount = 0;
		shroomCount = 0;
		lavaCount = 0;
		iceCount = 0;
		sandCount = 0;
		rockCount = 0;
		CountedTiles.Clear();
		nextCount(x, y, jungle, lavaOk);
		return numTileCount;
	}

	public static void nextCount(int x, int y, bool jungle = false, bool lavaOk = false)
	{
		if (numTileCount >= maxTileCount)
		{
			return;
		}
		if (x <= 1 || x >= Main.maxTilesX - 1 || y <= 1 || y >= Main.maxTilesY - 1)
		{
			numTileCount = maxTileCount;
		}
		else
		{
			if (CountedTiles.ContainsKey(new Point(x, y)))
			{
				return;
			}
			if (Main.tile[x, y].wall == 244)
			{
				numTileCount = maxTileCount;
				return;
			}
			if (Main.tile[x, y].shimmer() && Main.tile[x, y].liquid > 0)
			{
				numTileCount = maxTileCount;
				return;
			}
			if (!jungle)
			{
				if (Main.tile[x, y].wall != 0)
				{
					numTileCount = maxTileCount;
					return;
				}
				if (!lavaOk)
				{
					if (Main.tile[x, y].lava() && Main.tile[x, y].liquid > 0)
					{
						lavaCount++;
						numTileCount = maxTileCount;
						return;
					}
				}
				else if (Main.tile[x, y].lava() && Main.tile[x, y].liquid > 0)
				{
					lavaCount++;
				}
			}
			if (Main.tile[x, y].active())
			{
				if (Main.tile[x, y].type == 70)
				{
					shroomCount++;
				}
				if (Main.tile[x, y].type == 1)
				{
					rockCount++;
				}
				if (Main.tile[x, y].type == 147 || Main.tile[x, y].type == 161)
				{
					iceCount++;
				}
				if (Main.tile[x, y].type == 53 || Main.tile[x, y].type == 396 || Main.tile[x, y].type == 397)
				{
					sandCount++;
				}
			}
			if (!SolidTile(x, y))
			{
				CountedTiles.Add(new Point(x, y), value: true);
				numTileCount++;
				nextCount(x - 1, y, jungle, lavaOk);
				nextCount(x + 1, y, jungle, lavaOk);
				nextCount(x, y - 1, jungle, lavaOk);
				nextCount(x, y + 1, jungle, lavaOk);
			}
		}
	}

	public static int countDirtTiles(int x, int y)
	{
		numTileCount = 0;
		CountedTiles.Clear();
		nextDirtCount(x, y);
		return numTileCount;
	}

	public static void nextDirtCount(int x, int y)
	{
		if (numTileCount >= maxTileCount)
		{
			return;
		}
		if (x <= 1 || x >= Main.maxTilesX - 1 || y <= 1 || y >= Main.maxTilesY - 1)
		{
			numTileCount = maxTileCount;
		}
		else if (!CountedTiles.ContainsKey(new Point(x, y)))
		{
			if (Main.tile[x, y].active() && (Main.tile[x, y].type == 147 || Main.tile[x, y].type == 161))
			{
				numTileCount = maxTileCount;
			}
			else if (Main.tile[x, y].wall == 244 || Main.tile[x, y].wall == 83 || Main.tile[x, y].wall == 3 || Main.tile[x, y].wall == 187 || Main.tile[x, y].wall == 216)
			{
				numTileCount = maxTileCount;
			}
			else if (!SolidTile(x, y) && (Main.tile[x, y].wall == 2 || Main.tile[x, y].wall == 59))
			{
				CountedTiles.Add(new Point(x, y), value: true);
				numTileCount++;
				nextDirtCount(x - 1, y);
				nextDirtCount(x + 1, y);
				nextDirtCount(x, y - 1);
				nextDirtCount(x, y + 1);
				nextDirtCount(x - 1, y - 1);
				nextDirtCount(x - 1, y + 1);
				nextDirtCount(x + 1, y - 1);
				nextDirtCount(x + 1, y + 1);
				nextDirtCount(x - 2, y);
				nextDirtCount(x + 2, y);
			}
		}
	}

	public static bool InWorld(Point p, int fluff = 0)
	{
		return InWorld(p.X, p.Y, fluff);
	}

	public static bool InWorld(int x, int y, int fluff = 0)
	{
		if (x < fluff || x >= Main.maxTilesX - fluff || y < fluff || y >= Main.maxTilesY - fluff)
		{
			return false;
		}
		return true;
	}

	public static bool InWorld(Rectangle rect, int fluff = 0)
	{
		int x = rect.X;
		int y = rect.Y;
		int num = rect.X + rect.Width;
		int num2 = rect.Y + rect.Height;
		if (x < fluff || num >= Main.maxTilesX - fluff || y < fluff || num2 >= Main.maxTilesY - fluff)
		{
			return false;
		}
		return true;
	}

	public static void gemCave(int x, int y)
	{
		countTiles(x, y);
		for (int i = 0; i < 6; i++)
		{
			gem[i] = false;
		}
		gem[genRand.Next(6)] = true;
		for (int j = 0; j < 6; j++)
		{
			if (genRand.Next(6) == 0)
			{
				gem[j] = true;
			}
		}
		Spread.Gem(x, y);
	}

	public static int randGem()
	{
		int num = genRand.Next(6);
		while (!gem[num])
		{
			num = genRand.Next(6);
		}
		return num;
	}

	public static ushort randGemTile()
	{
		if (genRand.Next(20) != 0)
		{
			return 1;
		}
		return (ushort)randGem() switch
		{
			0 => 67, 
			1 => 66, 
			2 => 63, 
			3 => 65, 
			4 => 64, 
			_ => 68, 
		};
	}

	public static void randMoss(bool justNeon = false)
	{
		neonMossType = genRand.NextFromList(new ushort[4] { 539, 536, 534, 625 });
		if (!justNeon)
		{
			mossType[0] = genRand.Next(5);
			mossType[1] = genRand.Next(5);
			while (mossType[1] == mossType[0])
			{
				mossType[1] = genRand.Next(5);
			}
			mossType[2] = genRand.Next(5);
			while (mossType[2] == mossType[0] || mossType[2] == mossType[1])
			{
				mossType[2] = genRand.Next(5);
			}
		}
	}

	public static void neonMossBiome(int i, int j, int maxY = 99999)
	{
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = genRand.NextDouble() * 4.0 - 2.0;
		vector2D2.Y = genRand.NextDouble() * 4.0 - 2.0;
		if (vector2D2.X == 0.0)
		{
			vector2D2.X = 1.0;
		}
		while (vector2D2.Length() < 4.0)
		{
			vector2D2 *= 1.5;
		}
		double num = genRand.Next(60, 80);
		double num2 = genRand.Next(30, 40);
		double num3 = (double)Main.maxTilesX / 4200.0;
		if (getGoodWorldGen)
		{
			num3 *= 1.5;
		}
		num *= num3;
		num2 *= num3;
		while (num2 > 0.0)
		{
			num *= 0.98;
			num2 -= 1.0;
			int num4 = (int)(vector2D.X - num);
			int num5 = (int)(vector2D.X + num);
			int num6 = (int)(vector2D.Y - num);
			int num7 = (int)(vector2D.Y + num);
			if (num4 < 1)
			{
				num4 = 1;
			}
			if (num5 > Main.maxTilesX - 1)
			{
				num5 = Main.maxTilesX - 1;
			}
			if (num6 < 1)
			{
				num6 = 1;
			}
			if (num7 > Main.maxTilesY - 1)
			{
				num7 = Main.maxTilesY - 1;
			}
			if (Main.remixWorld)
			{
				if ((double)num6 < Main.worldSurface)
				{
					num6 = (int)Main.worldSurface;
					if (vector2D2.Y < 5.0)
					{
						vector2D2.Y = 5.0;
					}
				}
			}
			else if ((double)num6 < Main.rockLayer)
			{
				num6 = (int)Main.rockLayer;
				if (vector2D2.Y < 5.0)
				{
					vector2D2.Y = 5.0;
				}
			}
			if (num7 > maxY)
			{
				num7 = maxY;
				if (vector2D2.Y > -5.0)
				{
					vector2D2.Y = -5.0;
				}
			}
			double num8 = num * (1.0 + genRand.NextDouble() * 0.4 - 0.2);
			for (int k = num4; k < num5; k++)
			{
				for (int l = num6; l < num7; l++)
				{
					if (new Vector2D(Math.Abs((double)k - vector2D.X), Math.Abs((double)l - vector2D.Y)).Length() < num8 * 0.8 && TileType(k, l) == 1 && (!Main.tile[k - 1, l].active() || !Main.tile[k + 1, l].active() || !Main.tile[k, l - 1].active() || !Main.tile[k, l + 1].active()))
					{
						SpreadGrass(k - 1, l, 1, neonMossType);
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += genRand.NextDouble() * 4.0 - 2.0;
			vector2D2.Y += genRand.NextDouble() * 4.0 - 2.0;
			vector2D2.Y = Utils.Clamp(vector2D2.Y, -10.0, 10.0);
			vector2D2.X = Utils.Clamp(vector2D2.X, -10.0, 10.0);
		}
	}

	public static void setMoss(int x, int y)
	{
		int num = 0;
		num = ((!((double)x < (double)Main.maxTilesX * 0.334)) ? (((double)x < (double)Main.maxTilesX * 0.667) ? 1 : 2) : 0);
		GenVars.mossWall = (ushort)(54 + mossType[num]);
		GenVars.mossTile = (ushort)(179 + mossType[num]);
	}

	public static void FillWallHolesInArea(Rectangle worldCoordsArea)
	{
		int num = Math.Max(worldCoordsArea.Left, 0);
		int num2 = Math.Min(worldCoordsArea.Right, Main.maxTilesX);
		int num3 = 0;
		for (int i = num; i <= num2; i++)
		{
			if (i >= 0 && i < Main.maxTilesX)
			{
				num3 += FillWallHolesInColumn(i, worldCoordsArea.Top, worldCoordsArea.Bottom);
			}
		}
	}

	private static int FillWallHolesInColumn(int x, int startY, int endY)
	{
		int num = 0;
		x = Utils.Clamp(x, 2, Main.maxTilesX - 1 - 2);
		startY = Math.Max(startY, 2);
		endY = Math.Min(endY, Main.maxTilesY - 2);
		bool flag = false;
		for (int i = startY; i < endY; i++)
		{
			if (Main.tile[x, i].wall == 0)
			{
				if (flag)
				{
					flag = false;
					if (FillWallHolesInSpot(x, i, 150))
					{
						num++;
					}
				}
			}
			else
			{
				flag = true;
			}
		}
		return num;
	}

	private static bool FillWallHolesInSpot(int originX, int originY, int maxWallsThreshold)
	{
		if (!InWorld(originX, originY, 2))
		{
			return false;
		}
		List<Point> list = new List<Point>();
		List<Point> list2 = new List<Point>();
		HashSet<Point> hashSet = new HashSet<Point>();
		Dictionary<ushort, int> dictionary = new Dictionary<ushort, int>();
		list2.Add(new Point(originX, originY));
		while (list2.Count > 0)
		{
			list.Clear();
			list.AddRange(list2);
			list2.Clear();
			while (list.Count > 0)
			{
				if (hashSet.Count >= maxWallsThreshold)
				{
					return false;
				}
				Point item = list[0];
				if (hashSet.Contains(item))
				{
					list.Remove(item);
					continue;
				}
				if (!InWorld(item.X, item.Y, 1))
				{
					list.Remove(item);
					continue;
				}
				hashSet.Add(item);
				list.Remove(item);
				Tile tile = Main.tile[item.X, item.Y];
				if (tile.wall != 0)
				{
					if (dictionary.ContainsKey(tile.wall))
					{
						dictionary[tile.wall] = dictionary[tile.wall] + 1;
					}
					else
					{
						dictionary[tile.wall] = 1;
					}
					continue;
				}
				bool flag = false;
				if (!flag)
				{
					int y = item.Y;
					for (int i = item.X - 1; i <= item.X + 1; i++)
					{
						if (!Main.tile[i, y].active())
						{
							flag = true;
							break;
						}
					}
				}
				if (!flag)
				{
					int x = item.X;
					for (int j = item.Y - 1; j <= item.Y + 1; j++)
					{
						if (!Main.tile[x, j].active())
						{
							flag = true;
							break;
						}
					}
				}
				if (flag)
				{
					Point item2 = new Point(item.X - 1, item.Y);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
					item2 = new Point(item.X + 1, item.Y);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
					item2 = new Point(item.X, item.Y - 1);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
					item2 = new Point(item.X, item.Y + 1);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
				}
			}
		}
		if (hashSet.Count == 1)
		{
			return false;
		}
		ushort wall = 0;
		int num = -1;
		foreach (KeyValuePair<ushort, int> item3 in dictionary)
		{
			if (item3.Value > num)
			{
				wall = item3.Key;
				num = item3.Value;
			}
		}
		if (num == -1)
		{
			wall = 2;
		}
		foreach (Point item4 in hashSet)
		{
			Tile tile2 = Main.tile[item4.X, item4.Y];
			if (tile2.wall == 0)
			{
				tile2.wall = wall;
			}
		}
		return true;
	}

	public static void tileCountAndDestroy()
	{
		for (int i = 10; i < Main.maxTilesX - 10; i++)
		{
			for (int j = 10; j < Main.maxTilesY - 10; j++)
			{
				if (Main.tile[i, j].active() && tileCounter(i, j) < tileCounterMax)
				{
					tileCounterKill();
				}
			}
		}
	}

	public static int tileCounter(int x, int y)
	{
		tileCounterNum = 0;
		tileCounterNext(x, y);
		return tileCounterNum;
	}

	public static void tileCounterNext(int x, int y)
	{
		if (tileCounterNum >= tileCounterMax || x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5 || !Main.tile[x, y].active() || !Main.tileSolid[Main.tile[x, y].type] || !TileID.Sets.CanBeClearedDuringGeneration[Main.tile[x, y].type])
		{
			return;
		}
		for (int i = 0; i < tileCounterNum; i++)
		{
			if (tileCounterX[i] == x && tileCounterY[i] == y)
			{
				return;
			}
		}
		tileCounterX[tileCounterNum] = x;
		tileCounterY[tileCounterNum] = y;
		tileCounterNum++;
		tileCounterNext(x - 1, y);
		tileCounterNext(x + 1, y);
		tileCounterNext(x, y - 1);
		tileCounterNext(x, y + 1);
	}

	public static void tileCounterKill()
	{
		for (int i = 0; i < tileCounterNum; i++)
		{
			int num = tileCounterX[i];
			int num2 = tileCounterY[i];
			Main.tile[num, num2].active(active: false);
		}
	}

	private static void AddGenerationPass(string name, WorldGenLegacyMethod method)
	{
		_generator.Append(new PassLegacy(name, method));
	}

	private static void AddGenerationPass(GenPass pass)
	{
		_generator.Append(pass);
	}

	private static void AddGenerationPass(string name, double weight, WorldGenLegacyMethod method)
	{
		_generator.Append(new PassLegacy(name, method, weight));
	}

	public static bool checkUnderground(int x, int y)
	{
		try
		{
			int num = 120;
			int num2 = 80;
			int num3 = 3;
			if ((double)y > Main.worldSurface + (double)num2)
			{
				return true;
			}
			if ((double)y < Main.worldSurface / 2.0)
			{
				return false;
			}
			int num4 = y - num2;
			int num5 = x - num / 2;
			int num6 = 0;
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num5 >= Main.maxTilesX - num)
			{
				num5 = Main.maxTilesX - num - 1;
			}
			for (int i = num5; i < num5 + num; i++)
			{
				for (int j = num4; j < num4 + num3; j++)
				{
					if (SolidTile(i, j) || Main.tile[x, y].wall > 0)
					{
						num6++;
					}
				}
			}
			if ((double)num6 >= (double)(num * num3) * 0.8)
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static int GetNextJungleChestItem()
	{
		int result = 211;
		switch (GenVars.JungleItemCount % 4)
		{
		case 0:
			result = 211;
			break;
		case 1:
			result = 212;
			break;
		case 2:
			result = 213;
			break;
		case 3:
			result = 964;
			break;
		}
		if (genRand.Next(50) == 0)
		{
			result = 753;
		}
		else if (genRand.Next(15) == 0)
		{
			result = 2292;
		}
		else if (genRand.Next(20) == 0)
		{
			result = 3017;
		}
		GenVars.JungleItemCount++;
		return result;
	}

	private static void ScanTileColumnAndRemoveClumps(int x)
	{
		int num = 0;
		int y = 0;
		for (int i = 10; i < Main.maxTilesY - 10; i++)
		{
			if (Main.tile[x, i].active() && Main.tileSolid[Main.tile[x, i].type] && TileID.Sets.CanBeClearedDuringGeneration[Main.tile[x, i].type])
			{
				if (num == 0)
				{
					y = i;
				}
				num++;
				continue;
			}
			if (num > 0 && num < tileCounterMax)
			{
				SmallConsecutivesFound++;
				if (tileCounter(x, y) < tileCounterMax)
				{
					SmallConsecutivesEliminated++;
					tileCounterKill();
				}
			}
			num = 0;
		}
	}

	public static void OreHelper(int X, int Y)
	{
		for (int i = X - 1; i <= X + 1; i++)
		{
			for (int j = Y - 1; j <= Y + 1; j++)
			{
				if (Main.tile[i, j].type == 1 || Main.tile[i, j].type == 40)
				{
					Main.tile[i, j].type = 0;
				}
			}
		}
	}

	public static bool StonePatch(int X, int Y)
	{
		int num = Y;
		while (!SolidTile(X, num))
		{
			num++;
			if ((double)num > Main.worldSurface)
			{
				return false;
			}
		}
		if (!TileID.Sets.Conversion.Grass[Main.tile[X, num].type] || !TileID.Sets.Conversion.Grass[Main.tile[X - 1, num].type] || !TileID.Sets.Conversion.Grass[Main.tile[X + 1, num].type])
		{
			return false;
		}
		if (Main.tile[X, num].wall > 0)
		{
			return false;
		}
		for (int i = X - 10; i <= X + 10; i++)
		{
			for (int j = num + 7; j <= num + 30; j++)
			{
				if (!Main.tile[i, j].active() || Main.tileDungeon[Main.tile[i, j].type] || TileID.Sets.Clouds[Main.tile[i, j].type] || TileID.Sets.Conversion.Sand[Main.tile[i, j].type] || Main.tile[i, j].wall == 0 || Main.tile[i, j].type == 199 || Main.tile[i, j].type == 23)
				{
					return false;
				}
			}
		}
		Vector2D vector2D = new Vector2D(X, num);
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = genRand.NextDouble() * 0.6 - 0.3;
		vector2D2.Y = genRand.NextDouble() * 0.5 + 0.5;
		double num2 = genRand.Next(13, 18);
		int num3 = genRand.Next(13, 19);
		if (genRand.Next(3) == 0)
		{
			num2 += (double)genRand.Next(3);
		}
		if (genRand.Next(3) == 0)
		{
			num3 += genRand.Next(3);
		}
		while (num3 > 0)
		{
			num3--;
			for (int k = X - (int)num2 * 4; (double)k <= (double)X + num2 * 4.0; k++)
			{
				for (int l = num - (int)num2 * 4; (double)l <= (double)num + num2 * 4.0; l++)
				{
					double num4 = num2 * (0.7 + genRand.NextDouble() * 0.6) * 0.3;
					if (genRand.Next(8) == 0)
					{
						num4 *= 2.0;
					}
					Vector2D vector2D3 = vector2D - new Vector2D(k, l);
					if (vector2D3.Length() < num4 * 2.0 && !Main.tile[k, l].active() && Main.tile[k, l + 1].active() && Main.tile[k, l + 1].type == 1 && genRand.Next(7) == 0 && SolidTile(k - 1, l + 1) && SolidTile(k + 1, l + 1))
					{
						if (genRand.Next(3) != 0)
						{
							PlaceTile(k, l, 186, mute: true, forced: false, -1, genRand.Next(7, 13));
						}
						if (genRand.Next(3) != 0)
						{
							PlaceSmallPile(k, l, genRand.Next(6), 1, 185);
						}
						PlaceSmallPile(k, l, genRand.Next(6), 0, 185);
					}
					if (vector2D3.Length() < num4)
					{
						if (Main.tileSolid[Main.tile[k, l].type])
						{
							Main.tile[k, l].type = 1;
						}
						if (!isGeneratingOrLoadingWorld)
						{
							SquareTileFrame(k, l);
						}
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += genRand.NextDouble() * 0.2 - 0.1;
			vector2D2.Y += genRand.NextDouble() * 0.2 - 0.1;
			Utils.Clamp(vector2D2.X, -0.3, 0.3);
			Utils.Clamp(vector2D2.Y, 0.5, 1.0);
		}
		return true;
	}

	public static bool ShellPile(int X, int Y)
	{
		if (!InWorld(X, Y))
		{
			return false;
		}
		int num = Y;
		while (!SolidTile(X, num))
		{
			num++;
			if ((double)num > Main.worldSurface)
			{
				return false;
			}
		}
		if (Main.tile[X, num].type != 53)
		{
			return false;
		}
		if (Main.tile[X, num].wall > 0)
		{
			return false;
		}
		num--;
		Vector2D vector2D = new Vector2D(X, num);
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = genRand.NextDouble() * 0.6 - 0.3;
		vector2D2.Y = genRand.NextDouble() * 0.5 + 0.5;
		double num2 = genRand.Next(2, 4);
		if (genRand.Next(10) == 0)
		{
			num2 += 1.0;
		}
		int num3 = genRand.Next(3, 6);
		while (num3 > 0)
		{
			num3--;
			for (int i = X - (int)num2 * 4; (double)i <= (double)X + num2 * 4.0; i++)
			{
				int num4 = num + (int)num2 * 4;
				while ((double)num4 > (double)num - num2 * 4.0)
				{
					double num5 = num2 * (double)genRand.Next(70, 91) * 0.01;
					Vector2D vector2D3 = vector2D - new Vector2D(i, num4);
					vector2D3.X *= 0.6;
					if (vector2D3.Length() < num5)
					{
						if (num4 <= num + 1 || genRand.Next(6) == 0)
						{
							Main.tile[i, num4].type = 495;
							Main.tile[i, num4].active(active: true);
							Main.tile[i, num4].halfBrick(halfBrick: false);
							Main.tile[i, num4].slope(0);
							if (!Main.tile[i, num4 + 1].active())
							{
								Main.tile[i, num4 + 1].type = 495;
								Main.tile[i, num4 + 1].active(active: true);
								Main.tile[i, num4 + 1].halfBrick(halfBrick: false);
								Main.tile[i, num4 + 1].slope(0);
								if (!Main.tile[i, num4 + 2].active())
								{
									Main.tile[i, num4 + 2].type = 53;
									Main.tile[i, num4 + 2].active(active: true);
									Main.tile[i, num4 + 2].halfBrick(halfBrick: false);
									Main.tile[i, num4 + 2].slope(0);
									if (!Main.tile[i, num4 + 3].active())
									{
										Main.tile[i, num4 + 3].type = 397;
										Main.tile[i, num4 + 3].active(active: true);
										Main.tile[i, num4 + 3].halfBrick(halfBrick: false);
										Main.tile[i, num4 + 3].slope(0);
									}
								}
							}
							if (!isGeneratingOrLoadingWorld)
							{
								SquareTileFrame(i, num4);
							}
						}
						else if (Main.tile[i, num4].type != 495)
						{
							Main.tile[i, num4].active(active: true);
							Main.tile[i, num4].halfBrick(halfBrick: false);
							Main.tile[i, num4].slope(0);
							Main.tile[i, num4].type = 53;
							if (!isGeneratingOrLoadingWorld)
							{
								SquareTileFrame(i, num4);
							}
						}
					}
					num4--;
				}
			}
			vector2D += vector2D2;
			vector2D2.X += genRand.NextDouble() * 0.2 - 0.1;
			vector2D2.Y += genRand.NextDouble() * 0.2 - 0.1;
			Utils.Clamp(vector2D2.X, -0.3, 0.3);
			Utils.Clamp(vector2D2.Y, 0.5, 1.0);
		}
		return true;
	}

	public static bool MarblePileWithStatues(int X, int Y)
	{
		int num = Y;
		while (!SolidTile(X, num))
		{
			num++;
			if ((double)num > Main.worldSurface)
			{
				return false;
			}
		}
		if (Main.tile[X, num].type != 0 && Main.tile[X, num].type != 2)
		{
			return false;
		}
		if (Main.tile[X, num].wall > 0)
		{
			return false;
		}
		int num2 = 130;
		int num3 = 60;
		int num4 = (int)MathHelper.Clamp(X - num2, 30f, Main.maxTilesX - 30);
		int num5 = (int)MathHelper.Clamp(X + num2, 30f, Main.maxTilesX - 30);
		int num6 = (int)MathHelper.Clamp(num - num3, 30f, Main.maxTilesY - 30);
		int num7 = (int)MathHelper.Clamp(num + num3, 30f, Main.maxTilesY - 30);
		for (int i = num4; i <= num5; i++)
		{
			for (int j = num6; j <= num7; j++)
			{
				if (Main.tile[i, j].active() && (Main.tile[i, j].type == 367 || Main.tile[i, j].type == 191))
				{
					return false;
				}
			}
		}
		num--;
		Vector2D vector2D = new Vector2D(X, num);
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = genRand.NextDouble() * 0.6 - 0.3;
		vector2D2.Y = genRand.NextDouble() * 0.5 + 0.5;
		double num8 = genRand.Next(2, 4);
		if (genRand.Next(10) == 0)
		{
			num8 += 1.0;
		}
		int num9 = genRand.Next(3, 6);
		while (num9 > 0)
		{
			num9--;
			for (int k = X - (int)num8 * 5; (double)k <= (double)X + num8 * 5.0; k++)
			{
				int num10 = num + (int)num8 * 3;
				while ((double)num10 > (double)num - num8 * 3.0)
				{
					double num11 = num8 * (double)genRand.Next(70, 91) * 0.01 * 1.2;
					Vector2D vector2D3 = vector2D - new Vector2D(k, num10);
					if (vector2D3.Length() > 30.0)
					{
						vector2D = new Vector2D(X, num);
						vector2D2.X = genRand.NextDouble() * 0.6 - 0.3;
						vector2D2.Y = genRand.NextDouble() * 0.5 + 0.5;
					}
					else
					{
						vector2D3.X *= 0.25;
						vector2D3.Y *= 0.8;
						if (vector2D3.Length() < num11 && Main.tile[k, num10].active())
						{
							Main.tile[k, num10].active(active: true);
							Main.tile[k, num10].halfBrick(halfBrick: false);
							Main.tile[k, num10].slope(0);
							Main.tile[k, num10].type = 367;
							if (!isGeneratingOrLoadingWorld)
							{
								SquareTileFrame(k, num10);
							}
						}
					}
					num10--;
				}
			}
			vector2D += vector2D2;
			vector2D2.X += genRand.NextDouble() * 0.2 - 0.1;
			vector2D2.Y += (0.1 + genRand.NextDouble() * 0.1) * 0.8;
			Utils.Clamp(vector2D2.X, -0.3, 0.3);
			Utils.Clamp(vector2D2.Y, 0.5, 1.0);
		}
		int num12 = 0;
		for (int l = X - (int)num8 * 5; (double)l <= (double)X + num8 * 5.0; l++)
		{
			if (num12 >= 3)
			{
				break;
			}
			if (l % 2 != 1 && (num12 <= 0 || genRand.Next(5) == 0))
			{
				int num13 = (int)vector2D.Y - 20;
				Tile tile = Main.tile[l, num13];
				while (tile != null && !tile.active())
				{
					num13++;
					tile = Main.tile[l, num13];
				}
				if (tile != null && tile.type == 367 && !Main.tile[l, num13 - 1].active() && Statue(l, num13 - 1, 26))
				{
					num12++;
				}
			}
		}
		return true;
	}

	public static bool Statue(int x, int y, byte paint)
	{
		int num = genRand.Next(2, GenVars.statueList.Length);
		int x2 = GenVars.statueList[num].X;
		int y2 = GenVars.statueList[num].Y;
		while (!Main.tile[x, y].active())
		{
			y++;
			if (y >= Main.maxTilesY)
			{
				break;
			}
		}
		if (y >= Main.maxTilesY)
		{
			return false;
		}
		y--;
		if (PlaceTile(x, y, x2, mute: true, forced: true, -1, y2))
		{
			for (int i = 0; i < 2; i++)
			{
				for (int j = 0; j < 3; j++)
				{
					Main.tile[x + i, y + j - 2].color(paint);
				}
			}
			return true;
		}
		return false;
	}

	public static bool OrePatch(int X, int Y)
	{
		ushort type = (ushort)SavedOreTiers.Copper;
		if (genRand.Next(3) == 0)
		{
			type = (ushort)SavedOreTiers.Iron;
		}
		int num = X;
		int num2 = Y;
		while (!SolidTile(num, num2))
		{
			num2++;
			if ((double)num2 > Main.worldSurface)
			{
				return false;
			}
		}
		if (!TileID.Sets.Conversion.Grass[Main.tile[num, num2].type] || !TileID.Sets.Conversion.Grass[Main.tile[num - 1, num2].type] || !TileID.Sets.Conversion.Grass[Main.tile[num + 1, num2].type])
		{
			return false;
		}
		if (Main.tile[num, num2].wall > 0)
		{
			return false;
		}
		for (int i = num - 10; i <= num + 10; i++)
		{
			for (int j = num2 + 7; j <= num2 + 30; j++)
			{
				if (!Main.tile[i, j].active() || Main.tileDungeon[Main.tile[i, j].type] || TileID.Sets.Clouds[Main.tile[i, j].type] || TileID.Sets.Conversion.Sand[Main.tile[i, j].type] || Main.tile[i, j].wall == 0)
				{
					return false;
				}
			}
		}
		num2 += genRand.Next(2);
		Main.tile[num, num2].type = type;
		Main.tile[num, num2].active(active: true);
		OreHelper(num, num2);
		if (!isGeneratingOrLoadingWorld)
		{
			SquareTileFrame(num, num2);
		}
		int num3 = num2;
		while (num2 < num3 + genRand.Next(8, 13))
		{
			num += genRand.Next(-1, 2);
			num2 += genRand.Next(1, 3);
			if (genRand.Next(3) == 0)
			{
				num2++;
			}
			Main.tile[num, num2].type = type;
			Main.tile[num, num2].active(active: true);
			OreHelper(num, num2);
			if (!isGeneratingOrLoadingWorld)
			{
				SquareTileFrame(num, num2);
			}
			if (genRand.Next(4) == 0)
			{
				int num4 = num + genRand.Next(-2, 3);
				int num5 = num2 + genRand.Next(2);
				Main.tile[num4, num5].type = type;
				Main.tile[num4, num5].active(active: true);
				OreHelper(num4, num5);
				if (!isGeneratingOrLoadingWorld)
				{
					SquareTileFrame(num4, num5);
				}
			}
		}
		Vector2D vector2D = new Vector2D(num, num2);
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = genRand.NextDouble() * 0.6 - 0.3;
		vector2D2.Y = genRand.NextDouble() * 0.5 + 0.5;
		double num6 = genRand.Next(5, 9);
		int num7 = genRand.Next(9, 14);
		if (genRand.Next(3) == 0)
		{
			num6 += (double)genRand.Next(2);
		}
		if (genRand.Next(3) == 0)
		{
			num7 += genRand.Next(2);
		}
		while (num7 > 0)
		{
			num7--;
			for (int k = num - (int)num6 * 4; (double)k <= (double)num + num6 * 4.0; k++)
			{
				for (int l = num2 - (int)num6 * 4; (double)l <= (double)num2 + num6 * 4.0; l++)
				{
					double num8 = num6 * (0.5 + genRand.NextDouble() * 0.5) * 0.1;
					double num9 = num6 * (0.7 + genRand.NextDouble() * 0.6) * 0.3;
					if (genRand.Next(8) == 0)
					{
						num9 *= 2.0;
					}
					Vector2D vector2D3 = vector2D - new Vector2D(k, l);
					if (vector2D3.Length() < num8)
					{
						Main.tile[k, l].active(active: false);
					}
					else if (vector2D3.Length() < num9)
					{
						Main.tile[k, l].type = type;
						if (genRand.Next(4) == 0)
						{
							Main.tile[k, l].active(active: true);
						}
						OreHelper(k, l);
						if (!isGeneratingOrLoadingWorld)
						{
							SquareTileFrame(k, l);
						}
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += genRand.NextDouble() * 0.2 - 0.1;
			vector2D2.Y += genRand.NextDouble() * 0.2 - 0.1;
			Utils.Clamp(vector2D2.X, -0.3, 0.3);
			Utils.Clamp(vector2D2.Y, 0.5, 1.0);
		}
		return true;
	}

	public static bool PlaceOasis(int X, int Y)
	{
		int i = Y;
		if (!Main.tile[X, i].active() && Main.tile[X, i].wall == 0)
		{
			for (; !Main.tile[X, i].active() && Main.tile[X, i].wall == 0 && (double)i <= Main.worldSurface; i++)
			{
			}
			if ((double)i > Main.worldSurface - 10.0)
			{
				return false;
			}
			if (Main.tile[X, i].type != 53)
			{
				return false;
			}
			int num = 350;
			for (int j = 0; j < GenVars.numOasis; j++)
			{
				if (Vector2D.Distance(GenVars.oasisPosition[j].ToVector2D(), new Vector2D(X, i)) < (double)num)
				{
					return false;
				}
			}
			int num2 = genRand.Next(45, 61);
			int oasisHeight = GenVars.oasisHeight;
			int num3 = num2 + 50;
			int num4 = 4;
			for (int k = X - num3; k <= X + num3; k++)
			{
				for (int l = i - oasisHeight; l <= i + oasisHeight + num4; l++)
				{
					Tile tile = Main.tile[k, l];
					if (tile.active())
					{
						if (Main.tileSolid[tile.type])
						{
							if ((tile.type == 151 || tile.type == 397) && Math.Abs(k - X) < num2 && Math.Abs(l - i) < oasisHeight / 2)
							{
								return false;
							}
							if (tile.type != 53)
							{
								return false;
							}
						}
					}
					else if ((tile.liquid > 0 || tile.wall > 0) && Math.Abs(k - X) < num2 && Math.Abs(l - i) < oasisHeight / 2)
					{
						return false;
					}
				}
				if (k > X - num2 / 2 && k < X - num2 / 2)
				{
					if (Main.tile[k, i - 6].active())
					{
						return false;
					}
					if (!Main.tile[k, i + 1].active())
					{
						return false;
					}
				}
			}
			int num5 = 5;
			int num6 = i;
			while (!Main.tile[X - num2, i + num5].active() || Main.tile[X - num2, i + num5].wall != 0 || !Main.tile[X + num2, i + num5].active() || Main.tile[X + num2, i + num5].wall != 0)
			{
				i++;
				if (i - num6 > 20)
				{
					break;
				}
			}
			int num7 = num2 / 2;
			int num8 = X - num2 * 3;
			int num9 = X + num2 * 3;
			int num10 = i - oasisHeight * 4;
			int num11 = i + oasisHeight * 3;
			if (num8 < 0)
			{
				num8 = 0;
			}
			if (num9 > Main.maxTilesX)
			{
				num9 = Main.maxTilesX;
			}
			if (num10 < 0)
			{
				num10 = 0;
			}
			if (num11 > Main.maxTilesY)
			{
				num11 = Main.maxTilesY;
			}
			for (int m = num8; m < num9; m++)
			{
				for (int n = num10; n < num11; n++)
				{
					double num12 = (double)Math.Abs(m - X) * 0.7;
					double num13 = (double)Math.Abs(n - i) * 1.35;
					double num14 = Math.Sqrt(num12 * num12 + num13 * num13);
					double num15 = (double)num7 * (0.53 + genRand.NextDouble() * 0.04);
					double num16 = (double)Math.Abs(m - X) / (double)(num9 - X);
					num16 = 1.0 - num16;
					num16 *= 2.3;
					num16 *= num16;
					num16 *= num16;
					if (num14 < num15)
					{
						if (n == i + 1)
						{
							Main.tile[m, n].liquid = 127;
						}
						else if (n > i + 1)
						{
							Main.tile[m, n].liquid = byte.MaxValue;
						}
						Main.tile[m, n].lava(lava: false);
						Main.tile[m, n].active(active: false);
					}
					else if (n < i && num12 < num15 + (double)(Math.Abs(n - i) * 3) * num16)
					{
						if (Main.tile[m, n].type == 53)
						{
							Main.tile[m, n].active(active: false);
						}
					}
					else if (n >= i && num12 < num15 + (double)Math.Abs(n - i) * num16 && Main.tile[m, n].wall == 0)
					{
						if (Main.tile[m, n].active() && Main.tileSolid[Main.tile[m, n].type] && !Main.tileSolidTop[Main.tile[m, n].type])
						{
							Main.tile[m, n].slope(0);
							Main.tile[m, n].halfBrick(halfBrick: false);
							continue;
						}
						Main.tile[m, n].active(active: true);
						Main.tile[m, n].type = 53;
						Main.tile[m, n].slope(0);
						Main.tile[m, n].halfBrick(halfBrick: false);
					}
				}
			}
			int num17 = 50;
			num8 = X - num2 * 2;
			num9 = X + num2 * 2;
			num11 = i + oasisHeight * 2;
			for (int num18 = num8; num18 < num9; num18++)
			{
				for (int num19 = num11; num19 >= i; num19--)
				{
					double num20 = (double)Math.Abs(num18 - X) * 0.7;
					double num21 = (double)Math.Abs(num19 - i) * 1.35;
					double num22 = Math.Sqrt(num20 * num20 + num21 * num21);
					double num23 = (double)num7 * 0.5700000000000001;
					if (num22 > num23)
					{
						bool flag = false;
						if (!Main.tile[num18, num19].active() && Main.tile[num18, num19].wall == 0)
						{
							int num24 = -1;
							int num25 = -1;
							for (int num26 = num18; num26 <= num18 + num17 && Main.tile[num26, num19 + 1].active() && Main.tileSolid[Main.tile[num26, num19 + 1].type] && Main.tile[num26, num19].wall <= 0; num26++)
							{
								if (Main.tile[num26, num19].active() && Main.tileSolid[Main.tile[num26, num19].type])
								{
									if (Main.tile[num26, num19].type == 53)
									{
										flag = true;
									}
									num25 = num26;
									break;
								}
								if (Main.tile[num26, num19].active())
								{
									break;
								}
							}
							int num27 = num18;
							while (num27 >= num18 - num17 && Main.tile[num27, num19 + 1].active() && Main.tileSolid[Main.tile[num27, num19 + 1].type] && Main.tile[num27, num19].wall <= 0)
							{
								if (Main.tile[num27, num19].active() && Main.tileSolid[Main.tile[num27, num19].type])
								{
									if (Main.tile[num27, num19].type == 53)
									{
										flag = true;
									}
									num24 = num27;
									break;
								}
								if (Main.tile[num27, num19].active())
								{
									break;
								}
								num27--;
							}
							flag = true;
							if (num24 > -1 && num25 > -1 && flag)
							{
								int num28 = 0;
								for (int num29 = num24 + 1; num29 < num25; num29++)
								{
									if (num25 - num24 > 5 && genRand.Next(5) == 0)
									{
										num28 = genRand.Next(5, 10);
									}
									Main.tile[num29, num19].active(active: true);
									Main.tile[num29, num19].type = 53;
									if (num28 > 0)
									{
										num28--;
										Main.tile[num29, num19 - 1].active(active: true);
										Main.tile[num29, num19 - 1].type = 53;
									}
								}
							}
						}
					}
				}
			}
			if (GenVars.numOasis < GenVars.maxOasis)
			{
				GenVars.oasisPosition[GenVars.numOasis] = new Point(X, i);
				GenVars.oasisWidth[GenVars.numOasis] = num2;
				GenVars.numOasis++;
			}
			return true;
		}
		return false;
	}

	public static bool BiomeTileCheck(int x, int y)
	{
		int num = 50;
		for (int i = x - num; i <= x + num; i++)
		{
			for (int j = y - num; j <= y + num; j++)
			{
				if (!InWorld(i, j))
				{
					continue;
				}
				if (Main.tile[i, j].active())
				{
					int type = Main.tile[i, j].type;
					if (type == 368 || type == 367 || type == 147 || type == 161 || type == 162 || type == 70 || type == 72 || type == 396 || type == 397)
					{
						return true;
					}
				}
				int wall = Main.tile[i, j].wall;
				if (wall == 187 || wall == 216)
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool oceanDepths(int x, int y)
	{
		if ((double)y > oceanLevel)
		{
			return false;
		}
		if (x < beachDistance || x > Main.maxTilesX - beachDistance)
		{
			return true;
		}
		return false;
	}

	public static bool IsSurfaceForAtmospherics(Point tileCoords)
	{
		if (Main.remixWorld)
		{
			if ((double)tileCoords.Y > Main.rockLayer)
			{
				return tileCoords.Y < Main.maxTilesY - 350;
			}
			return false;
		}
		return (double)tileCoords.Y <= Main.worldSurface;
	}

	public static void UpdateDesertHiveBounds(int x, int y)
	{
		if (GenVars.desertHiveHigh > y)
		{
			GenVars.desertHiveHigh = y;
		}
		if (GenVars.desertHiveLow < y)
		{
			GenVars.desertHiveLow = y;
		}
		if (GenVars.desertHiveLeft > x)
		{
			GenVars.desertHiveLeft = x;
		}
		if (GenVars.desertHiveRight < x)
		{
			GenVars.desertHiveRight = x;
		}
	}

	public static void SetBoulderSolidity(bool solid)
	{
		Main.tileSolid[138] = solid;
		Main.tileSolid[484] = solid;
		Main.tileSolid[664] = solid;
		Main.tileSolid[711] = solid;
		Main.tileSolid[712] = solid;
		Main.tileSolid[713] = solid;
		Main.tileSolid[714] = solid;
		Main.tileSolid[715] = solid;
		Main.tileSolid[716] = solid;
	}

	public static void SetCrackedBrickSolidity(bool solid)
	{
		Main.tileSolid[481] = solid;
		Main.tileSolid[482] = solid;
		Main.tileSolid[483] = solid;
	}

	public static bool CanGeneratePressurePlateAt(int i, int j)
	{
		if (!InWorld(i, j, 3))
		{
			return false;
		}
		if (!SolidTileAllowBottomSlope(i, j + 1))
		{
			return false;
		}
		Tile tile = Main.tile[i, j + 1];
		if (tile.type >= 0 && TileID.Sets.Boulders[tile.type])
		{
			return false;
		}
		if (tile.wall == 350)
		{
			return false;
		}
		return true;
	}

	public static void GenerateWorld_SetupDungeonGenVars(int currentDungeon, bool clearOld = false)
	{
		if (clearOld)
		{
			GenVars.dungeonGenVars.Clear();
		}
		GenVars.CurrentDungeon = currentDungeon;
		GenVars.dungeonGenVars.Add(new DungeonGenVars());
	}

	public static void PrepForRegen()
	{
		using (BinaryReader reader = new BinaryReader(File.OpenRead(Main.ActiveWorldFileData.Path)))
		{
			WorldFile.LoadFileFormatHeader(reader, out var _, out var _);
			WorldFile.LoadHeader(reader);
		}
		WorldFileData.TryApplyingCopiedSeed(Main.ActiveWorldFileData.GetFullSeedText(), playSound: false, out var _, out var _, out var _);
	}

	public static bool GenerateWorld(GenerationProgress customProgressObject = null, WorldGenerator.Controller customController = null)
	{
		generatingWorld = true;
		isGeneratingOrLoadingWorld = true;
		generatingWorldOnThisThread = true;
		bool flag = false;
		try
		{
			Console.WriteLine("Creating world - Seed: {0}, Width: {1}, Height: {2}, Evil: {3}, Difficulty: {4}", Main.ActiveWorldFileData.SeedText, Main.maxTilesX, Main.maxTilesY, WorldGenParam_Evil, Main.GameMode);
			GenVars.configuration = WorldGenConfiguration.FromEmbeddedPath("Terraria.GameContent.WorldBuilding.Configuration.json");
			Hooks.ProcessWorldGenConfig(ref GenVars.configuration);
			_generator = new WorldGenerator(Main.ActiveWorldFileData.Seed, GenVars.configuration, customProgressObject, customController);
			clearWorld();
			Reset();
			AddPasses();
			DisablePassesForSpecialSeeds(_generator._passes);
			flag = _generator.GenerateWorld();
			Finish();
			return flag;
		}
		finally
		{
			RestoreTemporaryStateChanges();
			generatingWorld = false;
			isGeneratingOrLoadingWorld = false;
			generatingWorldOnThisThread = false;
			drunkWorldGen = false;
			notTheBees = false;
			noTrapsWorldGen = false;
			getGoodWorldGen = false;
			tenthAnniversaryWorldGen = false;
			dontStarveWorldGen = false;
			remixWorldGen = false;
			everythingWorldGen = false;
			skyblockWorldGen = false;
		}
	}

	public static void Reset()
	{
		Manifest.Version = Main.versionNumber;
		Manifest.GitSHA = GitStatus.GitSHA;
		tileSolidBackup = (bool[])Main.tileSolid.Clone();
		int seed = Main.ActiveWorldFileData.Seed;
		Main.drunkWorld = (drunkWorldGen = WorldGenerationOptions.Get<WorldSeedOption_Drunk>().Enabled);
		Main.notTheBeesWorld = (notTheBees = WorldGenerationOptions.Get<WorldSeedOption_NotTheBees>().Enabled);
		Main.noTrapsWorld = (noTrapsWorldGen = WorldGenerationOptions.Get<WorldSeedOption_NoTraps>().Enabled);
		Main.getGoodWorld = (getGoodWorldGen = WorldGenerationOptions.Get<WorldSeedOption_ForTheWorthy>().Enabled);
		Main.tenthAnniversaryWorld = (tenthAnniversaryWorldGen = WorldGenerationOptions.Get<WorldSeedOption_Anniversary>().Enabled);
		Main.dontStarveWorld = (dontStarveWorldGen = WorldGenerationOptions.Get<WorldSeedOption_DontStarve>().Enabled);
		Main.remixWorld = (remixWorldGen = WorldGenerationOptions.Get<WorldSeedOption_Remix>().Enabled);
		Main.zenithWorld = (everythingWorldGen = WorldGenerationOptions.Get<WorldSeedOption_Everything>().Enabled);
		Main.skyblockWorld = (skyblockWorldGen = WorldGenerationOptions.Get<WorldSeedOption_Skyblock>().Enabled);
		SecretSeed.InitializeSecretSeeds();
		GenVars.notTheBeesAndForTheWorthyNoCelebration = Main.notTheBeesWorld && Main.getGoodWorld && !Main.tenthAnniversaryWorld;
		GenVars.noTrapsAndForTheWorthyNoCelebration = Main.noTrapsWorld && Main.getGoodWorld && !Main.tenthAnniversaryWorld;
		GenVars.flipInfections = Main.drunkWorld && Main.getGoodWorld && !Main.remixWorld;
		Main.afterPartyOfDoom = false;
		if (tenthAnniversaryWorldGen && !skyblockWorldGen)
		{
			BirthdayParty.GenuineParty = true;
			BirthdayParty.PartyDaysOnCooldown = 5;
			if (getGoodWorldGen)
			{
				Main.afterPartyOfDoom = true;
			}
		}
		drunkWorldGenText = drunkWorldGen;
		if (drunkWorldGen && !Main.dayTime)
		{
			Main.time = 0.0;
		}
		Main.lockMenuBGChange = true;
		Main.rand = new UnifiedRandom(seed);
		GenVars.structures = new StructureMap();
		ExtraSpawnPointManager.ResetExtraSpawns();
		GenVars.desertHiveHigh = Main.maxTilesY;
		GenVars.desertHiveLow = 0;
		GenVars.desertHiveLeft = Main.maxTilesX;
		GenVars.desertHiveRight = 0;
		GenVars.worldSurfaceLow = 0.0;
		GenVars.worldSurface = 0.0;
		GenVars.worldSurfaceHigh = 0.0;
		GenVars.rockLayerLow = 0.0;
		GenVars.rockLayer = 0.0;
		GenVars.rockLayerHigh = 0.0;
		GenVars.remixMushroomLayerLow = 0;
		GenVars.remixMushroomLayerHigh = 0;
		GenVars.remixSurfaceLayerLow = 0;
		GenVars.remixSurfaceLayerHigh = 0;
		GenVars.copper = 7;
		GenVars.iron = 6;
		GenVars.silver = 9;
		GenVars.gold = 8;
		GenVars.dungeonGenVars.Clear();
		GenVars.CurrentDungeon = 0;
		GenVars.jungleHut = (ushort)genRand.Next(5);
		GenVars.shellStartXLeft = 0;
		GenVars.shellStartYLeft = 0;
		GenVars.shellStartXRight = 0;
		GenVars.shellStartYRight = 0;
		GenVars.PyrX = null;
		GenVars.PyrY = null;
		GenVars.numPyr = 0;
		GenVars.lowestCloud = -1;
		GenVars.jungleMinX = -1;
		GenVars.jungleMaxX = -1;
		GenVars.snowMinX = new int[Main.maxTilesY];
		GenVars.snowMaxX = new int[Main.maxTilesY];
		GenVars.snowTop = 0;
		GenVars.snowBottom = 0;
		GenVars.skyLakes = 1;
		if (Main.maxTilesX > 8000)
		{
			GenVars.skyLakes++;
		}
		if (Main.maxTilesX > 6000)
		{
			GenVars.skyLakes++;
		}
		GenVars.beachBordersWidth = 275;
		GenVars.beachSandRandomCenter = GenVars.beachBordersWidth + 5 + 40;
		GenVars.beachSandRandomWidthRange = 20;
		GenVars.beachSandDungeonExtraWidth = 40;
		GenVars.beachSandJungleExtraWidth = 20;
		GenVars.oceanWaterStartRandomMin = 220;
		GenVars.oceanWaterStartRandomMax = GenVars.oceanWaterStartRandomMin + 40;
		GenVars.oceanWaterForcedJungleLength = 275;
		GenVars.leftBeachEnd = 0;
		GenVars.rightBeachStart = 0;
		GenVars.evilBiomeBeachAvoidance = GenVars.beachSandRandomCenter + 60;
		GenVars.evilBiomeAvoidanceMidFixer = 50;
		GenVars.lakesBeachAvoidance = GenVars.beachSandRandomCenter + 20;
		GenVars.smallHolesBeachAvoidance = GenVars.beachSandRandomCenter + 20;
		GenVars.surfaceCavesBeachAvoidance = GenVars.beachSandRandomCenter + 20;
		GenVars.surfaceCavesBeachAvoidance2 = GenVars.beachSandRandomCenter + 20;
		GenVars.jungleOriginX = 0;
		GenVars.snowOriginLeft = 0;
		GenVars.snowOriginRight = 0;
		GenVars.logX = -1;
		GenVars.logY = -1;
		if (everythingWorldGen)
		{
			Main.starGame = true;
		}
		if (genRand.Next(2) == 0)
		{
			GenVars.crimsonLeft = false;
		}
		else
		{
			GenVars.crimsonLeft = true;
		}
		GenVars.numOceanCaveTreasure = 0;
		GenVars.skipDesertTileCheck = false;
		growGrassUnderground = false;
		Liquid.ReInit();
		SetupStatueList();
		RandomizeWeather();
		Main.cloudAlpha = 0f;
		Main.maxRaining = 0f;
		Main.raining = false;
		if (SecretSeed.rainsForAYear.Enabled)
		{
			SecretSeed.DoRainsForAYear();
		}
		heartCount = 0;
		GenVars.extraBastStatueCount = 0;
		GenVars.extraBastStatueCountMax = 2;
		Main.checkXMas();
		Main.checkHalloween();
		ResetGenerator();
		GenVars.UndergroundDesertLocation = Rectangle.Empty;
		GenVars.UndergroundDesertHiveLocation = Rectangle.Empty;
		GenVars.numLarva = 0;
		List<int> list = new List<int> { 274, 220, 112, 218, 3019 };
		if (remixWorldGen)
		{
			list = new List<int> { 274, 220, 683, 218, 3019 };
		}
		List<int> list2 = new List<int>();
		while (list.Count > 0)
		{
			int index = genRand.Next(list.Count);
			int item = list[index];
			list2.Add(item);
			list.RemoveAt(index);
		}
		GenVars.hellChestItem = list2.ToArray();
		int num = 86400;
		Main.slimeRainTime = -genRand.Next(num * 2, num * 3);
		if (skyblockWorldGen)
		{
			Main.slimeRainTime = 0.0;
		}
		Main.cloudBGActive = -genRand.Next(8640, 86400);
		SavedOreTiers.Copper = 7;
		SavedOreTiers.Iron = 6;
		SavedOreTiers.Silver = 9;
		SavedOreTiers.Gold = 8;
		GenVars.copperBar = 20;
		GenVars.ironBar = 22;
		GenVars.silverBar = 21;
		GenVars.goldBar = 19;
		if (genRand.Next(2) == 0)
		{
			GenVars.copper = 166;
			GenVars.copperBar = 703;
			SavedOreTiers.Copper = 166;
		}
		if ((!dontStarveWorldGen || drunkWorldGen) && genRand.Next(2) == 0)
		{
			GenVars.iron = 167;
			GenVars.ironBar = 704;
			SavedOreTiers.Iron = 167;
		}
		if (genRand.Next(2) == 0)
		{
			GenVars.silver = 168;
			GenVars.silverBar = 705;
			SavedOreTiers.Silver = 168;
		}
		if ((!dontStarveWorldGen || drunkWorldGen) && genRand.Next(2) == 0)
		{
			GenVars.gold = 169;
			GenVars.goldBar = 706;
			SavedOreTiers.Gold = 169;
		}
		if (GenVars.flipInfections)
		{
			GenVars.crimStoneWall = 3;
			GenVars.crimStone = 25;
			GenVars.ebonStoneWall = 83;
			GenVars.ebonStone = 203;
		}
		crimson = genRand.Next(2) == 0;
		generatingRandomEvil = true;
		if (WorldGenParam_Evil == 0)
		{
			generatingRandomEvil = false;
			crimson = false;
		}
		if (WorldGenParam_Evil == 1)
		{
			generatingRandomEvil = false;
			crimson = true;
		}
		if (GenVars.jungleHut == 0)
		{
			GenVars.jungleHut = 119;
		}
		else if (GenVars.jungleHut == 1)
		{
			GenVars.jungleHut = 120;
		}
		else if (GenVars.jungleHut == 2)
		{
			GenVars.jungleHut = 158;
		}
		else if (GenVars.jungleHut == 3)
		{
			GenVars.jungleHut = 175;
		}
		else if (GenVars.jungleHut == 4)
		{
			GenVars.jungleHut = 45;
		}
		Main.ActiveWorldFileData.WorldId = genRand.Next(int.MaxValue);
		RandomizeTreeStyle();
		RandomizeCaveBackgrounds();
		RandomizeBackgrounds(genRand);
		RandomizeMoonState(genRand);
		TreeTops.CopyExistingWorldInfoForWorldGeneration();
		GenerateWorld_SetupDungeonGenVars(0, clearOld: true);
		int num2 = (GenVars.CurrentDungeonGenVars.dungeonSide = ((genRand.Next(2) == 0) ? DungeonSide.Left : DungeonSide.Right));
		if (remixWorldGen)
		{
			if (num2 <= DungeonSide.Left)
			{
				double num3 = 1.0 - (double)genRand.Next(20, 35) * 0.01;
				GenVars.jungleOriginX = (int)((double)Main.maxTilesX * num3);
			}
			else
			{
				double num4 = (double)genRand.Next(20, 35) * 0.01;
				GenVars.jungleOriginX = (int)((double)Main.maxTilesX * num4);
			}
		}
		else
		{
			int minValue = 15;
			int maxValue = 30;
			if (tenthAnniversaryWorldGen && !remixWorldGen)
			{
				minValue = 25;
				maxValue = 35;
			}
			if (num2 <= DungeonSide.Left)
			{
				double num5 = 1.0 - (double)genRand.Next(minValue, maxValue) * 0.01;
				GenVars.jungleOriginX = (int)((double)Main.maxTilesX * num5);
			}
			else
			{
				double num6 = (double)genRand.Next(minValue, maxValue) * 0.01;
				GenVars.jungleOriginX = (int)((double)Main.maxTilesX * num6);
			}
		}
		int num7 = genRand.Next(Main.maxTilesX);
		if (drunkWorldGen && (!dontStarveWorldGen || remixWorldGen))
		{
			num2 = (GenVars.CurrentDungeonGenVars.dungeonSide = ((num2 == DungeonSide.Left) ? DungeonSide.Right : DungeonSide.Left));
		}
		if (num2 == DungeonSide.Right)
		{
			while ((double)num7 < (double)Main.maxTilesX * 0.6 || (double)num7 > (double)Main.maxTilesX * 0.75)
			{
				num7 = genRand.Next(Main.maxTilesX);
			}
		}
		else
		{
			while ((double)num7 < (double)Main.maxTilesX * 0.25 || (double)num7 > (double)Main.maxTilesX * 0.4)
			{
				num7 = genRand.Next(Main.maxTilesX);
			}
		}
		if (drunkWorldGen && (!dontStarveWorldGen || tenthAnniversaryWorldGen))
		{
			num2 = (GenVars.CurrentDungeonGenVars.dungeonSide = ((num2 == DungeonSide.Left) ? DungeonSide.Right : DungeonSide.Left));
		}
		int num8 = genRand.Next(50, 90);
		double num9 = (double)Main.maxTilesX / 4200.0;
		num8 += (int)((double)genRand.Next(20, 40) * num9);
		num8 += (int)((double)genRand.Next(20, 40) * num9);
		int num10 = num7 - num8;
		num8 = genRand.Next(50, 90);
		num8 += (int)((double)genRand.Next(20, 40) * num9);
		num8 += (int)((double)genRand.Next(20, 40) * num9);
		int num11 = num7 + num8;
		if (num10 < 0)
		{
			num10 = 0;
		}
		if (num11 > Main.maxTilesX)
		{
			num11 = Main.maxTilesX;
		}
		GenVars.snowOriginLeft = num10;
		GenVars.snowOriginRight = num11;
		GenVars.leftBeachEnd = genRand.Next(GenVars.beachSandRandomCenter - GenVars.beachSandRandomWidthRange, GenVars.beachSandRandomCenter + GenVars.beachSandRandomWidthRange);
		if (tenthAnniversaryWorldGen && !remixWorldGen)
		{
			GenVars.leftBeachEnd = GenVars.beachSandRandomCenter + GenVars.beachSandRandomWidthRange;
		}
		if (num2 == DungeonSide.Right)
		{
			GenVars.leftBeachEnd += GenVars.beachSandDungeonExtraWidth;
		}
		else
		{
			GenVars.leftBeachEnd += GenVars.beachSandJungleExtraWidth;
		}
		GenVars.rightBeachStart = Main.maxTilesX - genRand.Next(GenVars.beachSandRandomCenter - GenVars.beachSandRandomWidthRange, GenVars.beachSandRandomCenter + GenVars.beachSandRandomWidthRange);
		if (tenthAnniversaryWorldGen && !remixWorldGen)
		{
			GenVars.rightBeachStart = Main.maxTilesX - (GenVars.beachSandRandomCenter + GenVars.beachSandRandomWidthRange);
		}
		if (num2 == DungeonSide.Left)
		{
			GenVars.rightBeachStart -= GenVars.beachSandDungeonExtraWidth;
		}
		else
		{
			GenVars.rightBeachStart -= GenVars.beachSandJungleExtraWidth;
		}
		if (num2 <= DungeonSide.Left)
		{
			GenVars.CurrentDungeonGenVars.dungeonLocation = genRand.Next(GenVars.leftBeachEnd + GenVars.dungeonBeachPadding, (int)((double)Main.maxTilesX * 0.2));
		}
		else
		{
			GenVars.CurrentDungeonGenVars.dungeonLocation = genRand.Next((int)((double)Main.maxTilesX * 0.8), GenVars.rightBeachStart - GenVars.dungeonBeachPadding);
		}
		GenVars.CurrentDungeonGenVars.outerPotentialDungeonBounds.Reset();
		GenVars.CurrentDungeonGenVars.innerPotentialDungeonBounds.Reset();
		if (SecretSeed.dualDungeons.Enabled)
		{
			GenerateWorld_SetupDungeonGenVars(1);
			num2 = ((num2 != DungeonSide.Left) ? (GenVars.CurrentDungeonGenVars.dungeonSide = DungeonSide.Left) : (GenVars.CurrentDungeonGenVars.dungeonSide = DungeonSide.Right));
			if (num2 <= DungeonSide.Left)
			{
				GenVars.CurrentDungeonGenVars.dungeonLocation = genRand.Next(GenVars.leftBeachEnd + GenVars.dungeonBeachPadding, (int)((double)Main.maxTilesX * 0.2));
			}
			else
			{
				GenVars.CurrentDungeonGenVars.dungeonLocation = genRand.Next((int)((double)Main.maxTilesX * 0.8), GenVars.rightBeachStart - GenVars.dungeonBeachPadding);
			}
			GenVars.CurrentDungeonGenVars.outerPotentialDungeonBounds.Reset();
			GenVars.CurrentDungeonGenVars.innerPotentialDungeonBounds.Reset();
			GenVars.CurrentDungeon = 0;
			double num12 = (double)Main.maxTilesY / 1200.0;
			GenVars.DualDungeon_NormalizedDistanceSafeFromDither = 1.0 - 0.075 * num12;
		}
		int num13 = 0;
		if (Main.maxTilesX >= 8400)
		{
			num13 = 2;
		}
		else if (Main.maxTilesX >= 6400)
		{
			num13 = 1;
		}
		GenVars.extraBastStatueCountMax = 2 + num13;
		Main.tileSolid[659] = false;
		if (!Main.gameMenu)
		{
			Main.QueueMainThreadAction(Main.sectionManager.SetAllSectionsLoaded);
		}
	}

	public static bool IsDungeonPlatformOrShelf(Tile bottomTile)
	{
		if (bottomTile == null || !bottomTile.active() || bottomTile.type != 19)
		{
			return false;
		}
		int num = bottomTile.frameY / 18;
		if (num != 6 && num != 8 && num != 7)
		{
			if (num >= 9)
			{
				return num <= 12;
			}
			return false;
		}
		return true;
	}

	public static void AddPasses()
	{
		AddGenerationPass(new TerrainPass());
		if (skyblockWorldGen)
		{
			if (!Skyblock.denyAllGeneration)
			{
				AddGenerationPass(new JunglePass());
			}
			AddGenerationPass(GenPassNameID.Skyblock, delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[12].Value;
				GenerateSkyBlockWorld(progress);
			});
		}
		AddGenerationPass(GenPassNameID.DunesAndPyramidLocations, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			DungeonCrawler.SetupDungeonGenVarVariables(GenVars.CurrentDungeonGenVars, genRand);
			if (SecretSeed.dualDungeons.Enabled)
			{
				GenVars.CurrentDungeon = 1;
				DungeonCrawler.SetupDungeonGenVarVariables(GenVars.CurrentDungeonGenVars, genRand);
				GenVars.CurrentDungeon = 0;
			}
			if (!Skyblock.denyAllGeneration && !SecretSeed.noSurface.Enabled)
			{
				progress.Message = Lang.gen[1].Value;
				int random = passConfig.Get<WorldGenRange>("Count").GetRandom(genRand);
				double num = passConfig.Get<double>("ChanceOfPyramid");
				if (drunkWorldGen || SecretSeed.surfaceIsDesert.Enabled)
				{
					num = 1.0;
				}
				double num2 = (double)Main.maxTilesX / 4200.0;
				GenVars.PyrX = new int[random + 3];
				GenVars.PyrY = new int[random + 3];
				DunesBiome dunesBiome = GenVars.configuration.CreateBiome<DunesBiome>();
				for (int i = 0; i < random; i++)
				{
					progress.Set((double)i / (double)random);
					Point origin = Point.Zero;
					bool flag = false;
					int num3 = 0;
					while (!flag)
					{
						origin = RandomWorldPoint(0, 500, 0, 500);
						bool flag2 = Math.Abs(origin.X - GenVars.jungleOriginX) < (int)(600.0 * num2);
						bool flag3 = Math.Abs(origin.X - Main.maxTilesX / 2) < 300;
						bool flag4 = origin.X > GenVars.snowOriginLeft - 300 && origin.X < GenVars.snowOriginRight + 300;
						num3++;
						if (num3 >= Main.maxTilesX)
						{
							flag2 = false;
						}
						if (num3 >= Main.maxTilesX * 2)
						{
							flag4 = false;
						}
						flag = !(flag2 || flag3 || flag4);
					}
					dunesBiome.Place(origin, GenVars.structures);
					if (genRand.NextDouble() <= num)
					{
						int num4 = genRand.Next(origin.X - 200, origin.X + 200);
						for (int j = 0; j < Main.maxTilesY; j++)
						{
							if (Main.tile[num4, j].active())
							{
								GenVars.PyrX[GenVars.numPyr] = num4;
								GenVars.PyrY[GenVars.numPyr] = j + 20;
								GenVars.numPyr++;
								break;
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.OceanSand, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration && !SecretSeed.noSurface.Enabled)
			{
				progress.Message = Language.GetTextValue("WorldGeneration.OceanSand");
				for (int i = 0; i < 3; i++)
				{
					progress.Set((float)i / 3f);
					int num = genRand.Next(Main.maxTilesX);
					while ((double)num > (double)Main.maxTilesX * 0.4 && (double)num < (double)Main.maxTilesX * 0.6)
					{
						num = genRand.Next(Main.maxTilesX);
					}
					int num2 = genRand.Next(35, 90);
					if (i == 1)
					{
						double num3 = (double)Main.maxTilesX / 4200.0;
						num2 += (int)((double)genRand.Next(20, 40) * num3);
					}
					if (genRand.Next(3) == 0)
					{
						num2 *= 2;
					}
					if (i == 1)
					{
						num2 *= 2;
					}
					int num4 = num - num2;
					num2 = genRand.Next(35, 90);
					if (genRand.Next(3) == 0)
					{
						num2 *= 2;
					}
					if (i == 1)
					{
						num2 *= 2;
					}
					int num5 = num + num2;
					if (num4 < 0)
					{
						num4 = 0;
					}
					if (num5 > Main.maxTilesX)
					{
						num5 = Main.maxTilesX;
					}
					if (i == 0)
					{
						num4 = 0;
						num5 = GenVars.leftBeachEnd;
					}
					else if (i == 2)
					{
						num4 = GenVars.rightBeachStart;
						num5 = Main.maxTilesX;
					}
					else if (i == 1)
					{
						continue;
					}
					int num6 = genRand.Next(50, 100);
					for (int j = num4; j < num5; j++)
					{
						if (genRand.Next(2) == 0)
						{
							num6 += genRand.Next(-1, 2);
							if (num6 < 50)
							{
								num6 = 50;
							}
							if (num6 > 200)
							{
								num6 = 200;
							}
						}
						for (int k = 0; (double)k < (Main.worldSurface + Main.rockLayer) / 2.0; k++)
						{
							if (Main.tile[j, k].active())
							{
								if (j == (num4 + num5) / 2 && genRand.Next(6) == 0)
								{
									GenVars.PyrX[GenVars.numPyr] = j;
									GenVars.PyrY[GenVars.numPyr] = k;
									GenVars.numPyr++;
								}
								int num7 = num6;
								if (j - num4 < num7)
								{
									num7 = j - num4;
								}
								if (num5 - j < num7)
								{
									num7 = num5 - j;
								}
								num7 += genRand.Next(5);
								for (int l = k; l < k + num7; l++)
								{
									if (j > num4 + genRand.Next(5) && j < num5 - genRand.Next(5))
									{
										Main.tile[j, l].type = 53;
									}
								}
								break;
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.SandPatches, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Language.GetTextValue("WorldGeneration.SandPatches");
				progress.Set(0.0);
				int num = (int)((double)Main.maxTilesX * 0.013);
				if (remixWorldGen)
				{
					num /= 4;
				}
				for (int i = 0; i < num; i++)
				{
					progress.Set((float)i / (float)num);
					int num2 = genRand.Next(0, Main.maxTilesX);
					int num3 = genRand.Next((int)Main.worldSurface, (int)Main.rockLayer);
					if (remixWorldGen)
					{
						num3 = genRand.Next((int)Main.rockLayer - 100, Main.maxTilesY - 350);
					}
					while ((double)num2 > (double)Main.maxTilesX * 0.46 && (double)num2 < (double)Main.maxTilesX * 0.54 && (double)num3 < Main.worldSurface + 150.0)
					{
						num2 = genRand.Next(0, Main.maxTilesX);
						num3 = genRand.Next((int)Main.worldSurface, (int)Main.rockLayer);
					}
					int num4 = genRand.Next(15, 70);
					int steps = genRand.Next(20, 130);
					TileRunner(num2, num3, num4, steps, 53);
				}
			}
		});
		AddGenerationPass(GenPassNameID.Tunnels, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration && !SecretSeed.noSurface.Enabled && !SecretSeed.surfaceIsDesert.Enabled)
			{
				progress.Message = Language.GetTextValue("WorldGeneration.SurfaceTunnels");
				progress.Set(0.0);
				int num = (int)((double)Main.maxTilesX * 0.0015);
				if (remixWorldGen)
				{
					num = (int)((double)num * 1.5);
				}
				for (int i = 0; i < num; i++)
				{
					progress.Set((float)i / (float)num);
					if (GenVars.numTunnels >= GenVars.maxTunnels - 1)
					{
						break;
					}
					int[] array = new int[10];
					int[] array2 = new int[10];
					int num2 = genRand.Next(450, Main.maxTilesX - 450);
					if (!remixWorldGen)
					{
						if (tenthAnniversaryWorldGen)
						{
							num2 = genRand.Next((int)((double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.8));
						}
						else
						{
							while ((double)num2 > (double)Main.maxTilesX * 0.4 && (double)num2 < (double)Main.maxTilesX * 0.6)
							{
								num2 = genRand.Next(450, Main.maxTilesX - 450);
							}
						}
					}
					int j = 0;
					bool flag;
					do
					{
						flag = false;
						for (int k = 0; k < 10; k++)
						{
							for (num2 %= Main.maxTilesX; !Main.tile[num2, j].active(); j++)
							{
							}
							if (Main.tile[num2, j].type == 53)
							{
								flag = true;
							}
							array[k] = num2;
							array2[k] = j - genRand.Next(11, 16);
							num2 += genRand.Next(5, 11);
						}
					}
					while (flag);
					GenVars.tunnelX[GenVars.numTunnels] = array[5];
					GenVars.numTunnels++;
					for (int l = 0; l < 10; l++)
					{
						TileRunner(array[l], array2[l], genRand.Next(5, 8), genRand.Next(6, 9), 0, addTile: true, -2.0, -0.3);
						TileRunner(array[l], array2[l], genRand.Next(5, 8), genRand.Next(6, 9), 0, addTile: true, 2.0, -0.3);
					}
				}
				progress.Set(1.0);
			}
		});
		AddGenerationPass(GenPassNameID.MountainCaves, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration && !SecretSeed.noSurface.Enabled && !SecretSeed.surfaceIsDesert.Enabled)
			{
				GenVars.numMCaves = 0;
				progress.Message = Lang.gen[2].Value;
				progress.Set(0.0);
				int num = (int)((double)Main.maxTilesX * 0.001);
				if (remixWorldGen)
				{
					num = (int)((double)num * 1.5);
				}
				for (int i = 0; i < num; i++)
				{
					progress.Set((float)i / (float)num);
					int num2 = 0;
					bool flag = false;
					bool flag2 = false;
					int num3 = genRand.Next((int)((double)Main.maxTilesX * 0.25), (int)((double)Main.maxTilesX * 0.75));
					while (!flag2)
					{
						flag2 = true;
						if (!remixWorldGen)
						{
							while (num3 > Main.maxTilesX / 2 - 90 && num3 < Main.maxTilesX / 2 + 90)
							{
								num3 = genRand.Next((int)((double)Main.maxTilesX * 0.25), (int)((double)Main.maxTilesX * 0.75));
							}
						}
						for (int j = 0; j < GenVars.numMCaves; j++)
						{
							if (Math.Abs(num3 - GenVars.mCaveX[j]) < 100)
							{
								num2++;
								flag2 = false;
								break;
							}
						}
						if (num2 >= Main.maxTilesX / 5)
						{
							flag = true;
							break;
						}
					}
					if (!flag)
					{
						for (int k = 0; (double)k < Main.worldSurface; k++)
						{
							if (Main.tile[num3, k].active())
							{
								for (int l = num3 - 50; l < num3 + 50; l++)
								{
									for (int m = k - 25; m < k + 25; m++)
									{
										if (InWorld(l, m) && Main.tile[l, m].active() && (Main.tile[l, m].type == 53 || Main.tile[l, m].type == 151 || Main.tile[l, m].type == 274))
										{
											flag = true;
										}
									}
								}
								if (!flag)
								{
									Mountinater(num3, k);
									GenVars.mCaveX[GenVars.numMCaves] = num3;
									GenVars.mCaveY[GenVars.numMCaves] = k;
									GenVars.numMCaves++;
									break;
								}
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.DirtWallBackgrounds, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration && !SecretSeed.noSurface.Enabled)
			{
				progress.Message = Lang.gen[3].Value;
				int num = 0;
				for (int i = 1; i < Main.maxTilesX - 1; i++)
				{
					ushort wall = 2;
					double value = (double)i / (double)Main.maxTilesX;
					progress.Set(value);
					bool flag = false;
					num += genRand.Next(-1, 2);
					if (num < 0)
					{
						num = 0;
					}
					if (num > 10)
					{
						num = 10;
					}
					for (int j = 0; (double)j < Main.worldSurface + 10.0 && !((double)j > Main.worldSurface + (double)num); j++)
					{
						if (Main.tile[i, j].active())
						{
							wall = (ushort)((Main.tile[i, j].type != 147) ? 2 : 40);
						}
						if (flag && Main.tile[i, j].wall != 64)
						{
							Main.tile[i, j].wall = wall;
						}
						if (Main.tile[i, j].active() && Main.tile[i - 1, j].active() && Main.tile[i + 1, j].active() && Main.tile[i, j + 1].active() && Main.tile[i - 1, j + 1].active() && Main.tile[i + 1, j + 1].active())
						{
							flag = true;
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.RocksInDirt, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[4].Value;
				double num = (double)(Main.maxTilesX * Main.maxTilesY) * 0.00015;
				for (int i = 0; (double)i < num; i++)
				{
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(0, (int)GenVars.worldSurfaceLow + 1), genRand.Next(4, 15), genRand.Next(5, 40), 1);
				}
				progress.Set(0.34);
				num = (double)(Main.maxTilesX * Main.maxTilesY) * 0.0002;
				for (int j = 0; (double)j < num; j++)
				{
					int num2 = genRand.Next(0, Main.maxTilesX);
					int num3 = genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurfaceHigh + 1);
					if (!Main.tile[num2, num3 - 10].active())
					{
						num3 = genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurfaceHigh + 1);
					}
					TileRunner(num2, num3, genRand.Next(4, 10), genRand.Next(5, 30), 1);
				}
				progress.Set(0.67);
				num = (double)(Main.maxTilesX * Main.maxTilesY) * 0.0045;
				for (int k = 0; (double)k < num; k++)
				{
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceHigh, (int)GenVars.rockLayerHigh + 1), genRand.Next(2, 7), genRand.Next(2, 23), 1);
				}
			}
		});
		AddGenerationPass(GenPassNameID.DirtInRocks, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[5].Value;
				double num = (double)(Main.maxTilesX * Main.maxTilesY) * 0.005;
				for (int i = 0; (double)i < num; i++)
				{
					progress.Set((double)i / num);
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerLow, Main.maxTilesY), genRand.Next(2, 6), genRand.Next(2, 40), 0);
				}
				if (remixWorldGen)
				{
					for (int j = 0; j < Main.maxTilesX; j++)
					{
						for (int k = (int)Main.worldSurface + genRand.Next(-1, 3); k < Main.maxTilesY; k++)
						{
							if (Main.tile[j, k].active())
							{
								if (Main.tile[j, k].type == 0)
								{
									Main.tile[j, k].type = 1;
								}
								else if (Main.tile[j, k].type == 1)
								{
									Main.tile[j, k].type = 0;
								}
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.Clay, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[6].Value;
				for (int i = 0; i < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2E-05); i++)
				{
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(0, (int)GenVars.worldSurfaceLow), genRand.Next(4, 14), genRand.Next(10, 50), 40);
				}
				progress.Set(0.25);
				if (remixWorldGen)
				{
					for (int j = 0; j < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 7E-05); j++)
					{
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayer - 25, Main.maxTilesY - 350), genRand.Next(8, 15), genRand.Next(5, 50), 40);
					}
				}
				else
				{
					for (int k = 0; k < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 5E-05); k++)
					{
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurfaceHigh + 1), genRand.Next(8, 14), genRand.Next(15, 45), 40);
					}
					progress.Set(0.5);
					for (int l = 0; l < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2E-05); l++)
					{
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceHigh, (int)GenVars.rockLayerHigh + 1), genRand.Next(8, 15), genRand.Next(5, 50), 40);
					}
				}
				progress.Set(0.75);
				for (int m = 5; m < Main.maxTilesX - 5; m++)
				{
					for (int n = 1; (double)n < Main.worldSurface - 1.0; n++)
					{
						if (Main.tile[m, n].active())
						{
							for (int num = n; num < n + 5; num++)
							{
								if (Main.tile[m, num].type == 40)
								{
									Main.tile[m, num].type = 0;
								}
							}
							break;
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.SmallHoles, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[7].Value;
				double worldSurfaceHigh = GenVars.worldSurfaceHigh;
				int num = (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0015);
				for (int i = 0; i < num; i++)
				{
					double value = (double)i / ((double)(Main.maxTilesX * Main.maxTilesY) * 0.0015);
					progress.Set(value);
					int type = -1;
					if (genRand.Next(5) == 0)
					{
						type = -2;
					}
					int num2 = genRand.Next(0, Main.maxTilesX);
					int num3 = genRand.Next((int)GenVars.worldSurfaceHigh, Main.maxTilesY);
					if (!remixWorldGen && tenthAnniversaryWorldGen)
					{
						while ((double)num2 < (double)Main.maxTilesX * 0.2 && (double)num2 > (double)Main.maxTilesX * 0.8 && (double)num3 < GenVars.worldSurface)
						{
							num2 = genRand.Next(0, Main.maxTilesX);
							num3 = genRand.Next((int)GenVars.worldSurfaceHigh, Main.maxTilesY);
						}
					}
					else
					{
						while (((num2 < GenVars.smallHolesBeachAvoidance || num2 > Main.maxTilesX - GenVars.smallHolesBeachAvoidance) && (double)num3 < worldSurfaceHigh) || ((double)num2 > (double)Main.maxTilesX * 0.45 && (double)num2 < (double)Main.maxTilesX * 0.55 && (double)num3 < GenVars.worldSurface))
						{
							num2 = genRand.Next(0, Main.maxTilesX);
							num3 = genRand.Next((int)GenVars.worldSurfaceHigh, Main.maxTilesY);
						}
					}
					int num4 = genRand.Next(2, 5);
					int num5 = genRand.Next(2, 20);
					if (remixWorldGen && (double)num3 > Main.rockLayer)
					{
						num4 = (int)((double)num4 * 0.8);
						num5 = (int)((double)num5 * 0.9);
					}
					TileRunner(num2, num3, num4, num5, type);
					num2 = genRand.Next(0, Main.maxTilesX);
					num3 = genRand.Next((int)GenVars.worldSurfaceHigh, Main.maxTilesY);
					while (((num2 < GenVars.smallHolesBeachAvoidance || num2 > Main.maxTilesX - GenVars.smallHolesBeachAvoidance) && (double)num3 < worldSurfaceHigh) || ((double)num2 > (double)Main.maxTilesX * 0.45 && (double)num2 < (double)Main.maxTilesX * 0.55 && (double)num3 < GenVars.worldSurface))
					{
						num2 = genRand.Next(0, Main.maxTilesX);
						num3 = genRand.Next((int)GenVars.worldSurfaceHigh, Main.maxTilesY);
					}
					num4 = genRand.Next(8, 15);
					num5 = genRand.Next(7, 30);
					if (remixWorldGen && (double)num3 > Main.rockLayer)
					{
						num4 = (int)((double)num4 * 0.7);
						num5 = (int)((double)num5 * 0.9);
					}
					TileRunner(num2, num3, num4, num5, type);
				}
			}
		});
		AddGenerationPass(GenPassNameID.DirtLayerCaves, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[8].Value;
				double worldSurfaceHigh = GenVars.worldSurfaceHigh;
				int num = (int)((double)(Main.maxTilesX * Main.maxTilesY) * 3E-05);
				if (remixWorldGen)
				{
					num *= 2;
				}
				for (int i = 0; i < num; i++)
				{
					double value = (double)i / (double)num;
					progress.Set(value);
					if (GenVars.rockLayerHigh <= (double)Main.maxTilesY)
					{
						int type = -1;
						if (genRand.Next(6) == 0)
						{
							type = -2;
						}
						int num2 = genRand.Next(0, Main.maxTilesX);
						int num3 = genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.rockLayerHigh + 1);
						while (((num2 < GenVars.smallHolesBeachAvoidance || num2 > Main.maxTilesX - GenVars.smallHolesBeachAvoidance) && (double)num3 < worldSurfaceHigh) || ((double)num2 >= (double)Main.maxTilesX * 0.45 && (double)num2 <= (double)Main.maxTilesX * 0.55 && (double)num3 < Main.worldSurface))
						{
							num2 = genRand.Next(0, Main.maxTilesX);
							num3 = genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.rockLayerHigh + 1);
						}
						int num4 = genRand.Next(5, 15);
						int num5 = genRand.Next(30, 200);
						if (remixWorldGen)
						{
							num4 = (int)((double)num4 * 1.1);
							num5 = (int)((double)num5 * 1.9);
						}
						TileRunner(num2, num3, num4, num5, type);
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.RockLayerCaves, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[9].Value;
				int num = (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00013);
				if (remixWorldGen)
				{
					num = (int)((double)num * 1.1);
				}
				for (int i = 0; i < num; i++)
				{
					double value = (double)i / (double)num;
					progress.Set(value);
					if (GenVars.rockLayerHigh <= (double)Main.maxTilesY)
					{
						int type = -1;
						if (genRand.Next(10) == 0)
						{
							type = -2;
						}
						int num2 = genRand.Next(6, 20);
						int num3 = genRand.Next(50, 300);
						if (remixWorldGen)
						{
							num2 = (int)((double)num2 * 0.7);
							num3 = (int)((double)num3 * 0.7);
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerHigh, Main.maxTilesY), num2, num3, type);
					}
				}
				if (remixWorldGen)
				{
					num = (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00013 * 0.4);
					for (int j = 0; j < num; j++)
					{
						if (GenVars.rockLayerHigh <= (double)Main.maxTilesY)
						{
							int type2 = -1;
							if (genRand.Next(10) == 0)
							{
								type2 = -2;
							}
							int num4 = genRand.Next(7, 26);
							int steps = genRand.Next(50, 200);
							double num5 = (double)genRand.Next(100, 221) * 0.1;
							double num6 = (double)genRand.Next(-10, 11) * 0.02;
							int i2 = genRand.Next(0, Main.maxTilesX);
							int j2 = genRand.Next((int)GenVars.rockLayerHigh, Main.maxTilesY);
							TileRunner(i2, j2, num4, steps, type2, addTile: false, num5, num6, noYChange: true);
							TileRunner(i2, j2, num4, steps, type2, addTile: false, 0.0 - num5, 0.0 - num6, noYChange: true);
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.SurfaceCaves, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration && !SecretSeed.noSurface.Enabled)
			{
				progress.Message = Lang.gen[10].Value;
				int num = (int)((double)Main.maxTilesX * 0.002);
				int num2 = (int)((double)Main.maxTilesX * 0.0007);
				int num3 = (int)((double)Main.maxTilesX * 0.0003);
				if (remixWorldGen)
				{
					num *= 3;
					num2 *= 3;
					num3 *= 3;
				}
				for (int i = 0; i < num; i++)
				{
					progress.Set((float)i / (float)num * 0.2f);
					int num4 = genRand.Next(0, Main.maxTilesX);
					while (((double)num4 > (double)Main.maxTilesX * 0.45 && (double)num4 < (double)Main.maxTilesX * 0.55) || num4 < GenVars.leftBeachEnd + 20 || num4 > GenVars.rightBeachStart - 20)
					{
						num4 = genRand.Next(0, Main.maxTilesX);
					}
					for (int j = 0; (double)j < GenVars.worldSurfaceHigh; j++)
					{
						if (Main.tile[num4, j].active())
						{
							TileRunner(num4, j, genRand.Next(3, 6), genRand.Next(5, 50), -1, addTile: false, (double)genRand.Next(-10, 11) * 0.1, 1.0);
							break;
						}
					}
				}
				progress.Set(0.20000000298023224);
				for (int k = 0; k < num2; k++)
				{
					progress.Set(0.2f + (float)k / (float)num2 * 0.2f);
					int num5 = genRand.Next(0, Main.maxTilesX);
					while (((double)num5 > (double)Main.maxTilesX * 0.43 && (double)num5 < (double)Main.maxTilesX * 0.5700000000000001) || num5 < GenVars.leftBeachEnd + 20 || num5 > GenVars.rightBeachStart - 20)
					{
						num5 = genRand.Next(0, Main.maxTilesX);
					}
					for (int l = 0; (double)l < GenVars.worldSurfaceHigh; l++)
					{
						if (Main.tile[num5, l].active())
						{
							TileRunner(num5, l, genRand.Next(10, 15), genRand.Next(50, 130), -1, addTile: false, (double)genRand.Next(-10, 11) * 0.1, 2.0);
							break;
						}
					}
				}
				progress.Set(0.4000000059604645);
				for (int m = 0; m < num3; m++)
				{
					progress.Set(0.4f + (float)m / (float)num3 * 0.2f);
					int num6 = genRand.Next(0, Main.maxTilesX);
					while (((double)num6 > (double)Main.maxTilesX * 0.4 && (double)num6 < (double)Main.maxTilesX * 0.6) || num6 < GenVars.leftBeachEnd + 20 || num6 > GenVars.rightBeachStart - 20)
					{
						num6 = genRand.Next(0, Main.maxTilesX);
					}
					for (int n = 0; (double)n < GenVars.worldSurfaceHigh; n++)
					{
						if (Main.tile[num6, n].active())
						{
							TileRunner(num6, n, genRand.Next(12, 25), genRand.Next(150, 500), -1, addTile: false, (double)genRand.Next(-10, 11) * 0.1, 4.0);
							TileRunner(num6, n, genRand.Next(8, 17), genRand.Next(60, 200), -1, addTile: false, (double)genRand.Next(-10, 11) * 0.1, 2.0);
							TileRunner(num6, n, genRand.Next(5, 13), genRand.Next(40, 170), -1, addTile: false, (double)genRand.Next(-10, 11) * 0.1, 2.0);
							break;
						}
					}
				}
				progress.Set(0.6000000238418579);
				int num7 = (int)((double)Main.maxTilesX * 0.0004);
				for (int num8 = 0; num8 < num7; num8++)
				{
					progress.Set(0.6f + (float)num8 / (float)num7 * 0.2f);
					int num9 = genRand.Next(0, Main.maxTilesX);
					while (((double)num9 > (double)Main.maxTilesX * 0.4 && (double)num9 < (double)Main.maxTilesX * 0.6) || num9 < GenVars.leftBeachEnd + 20 || num9 > GenVars.rightBeachStart - 20)
					{
						num9 = genRand.Next(0, Main.maxTilesX);
					}
					for (int num10 = 0; (double)num10 < GenVars.worldSurfaceHigh; num10++)
					{
						if (Main.tile[num9, num10].active())
						{
							TileRunner(num9, num10, genRand.Next(7, 12), genRand.Next(150, 250), -1, addTile: false, 0.0, 1.0, noYChange: true);
							break;
						}
					}
				}
				progress.Set(0.800000011920929);
				double num11 = (double)Main.maxTilesX / 4200.0;
				int num12 = (int)(5.0 * num11);
				for (int num13 = 0; num13 < num12; num13++)
				{
					progress.Set(0.8f + (float)num13 / (float)num12 * 0.2f);
					try
					{
						int num14 = (int)Main.rockLayer;
						int num15 = Main.maxTilesY - 400;
						if (num14 >= num15)
						{
							num14 = num15 - 1;
						}
						Caverer(genRand.Next(GenVars.surfaceCavesBeachAvoidance2, Main.maxTilesX - GenVars.surfaceCavesBeachAvoidance2), genRand.Next(num14, num15));
					}
					catch
					{
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.WavyCaves, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration && dontStarveWorldGen)
			{
				progress.Message = Language.GetTextValue("WorldGeneration.WavyCaves");
				double num = (double)Main.maxTilesX / 4200.0;
				num *= num;
				int num2 = (int)(35.0 * num);
				if (Main.remixWorld)
				{
					num2 /= 3;
				}
				int num3 = 0;
				int num4 = 80;
				for (int i = 0; i < num2; i++)
				{
					double num5 = (double)i / (double)(num2 - 1);
					progress.Set(num5);
					int num6 = genRand.Next((int)Main.worldSurface + 100, Main.UnderworldLayer - 100);
					int num7 = 0;
					while (Math.Abs(num6 - num3) < num4)
					{
						num7++;
						if (num7 > 100)
						{
							break;
						}
						num6 = genRand.Next((int)Main.worldSurface + 100, Main.UnderworldLayer - 100);
					}
					num3 = num6;
					int num8 = 80;
					int startX = num8 + (int)((double)(Main.maxTilesX - num8 * 2) * num5);
					try
					{
						WavyCaverer(startX, num6, 12 + genRand.Next(3, 6), 0.25 + genRand.NextDouble(), genRand.Next(300, 500), -1);
					}
					catch
					{
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.IceBiome, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[56].Value;
				GenVars.snowTop = (int)Main.worldSurface;
				int num = GenVars.lavaLine - genRand.Next(160, 200);
				int num2 = GenVars.lavaLine;
				if (remixWorldGen)
				{
					num2 = Main.maxTilesY - 250;
					num = num2 - genRand.Next(160, 200);
				}
				int num3 = GenVars.snowOriginLeft;
				int num4 = GenVars.snowOriginRight;
				int num5 = 10;
				for (int i = 0; i <= num2 - 140; i++)
				{
					progress.Set((double)i / (double)(num2 - 140));
					num3 += genRand.Next(-4, 4);
					num4 += genRand.Next(-3, 5);
					if (i > 0)
					{
						num3 = (num3 + GenVars.snowMinX[i - 1]) / 2;
						num4 = (num4 + GenVars.snowMaxX[i - 1]) / 2;
					}
					if (GenVars.CurrentDungeonGenVars.dungeonSide >= DungeonSide.Right)
					{
						if (genRand.Next(4) == 0)
						{
							num3++;
							num4++;
						}
					}
					else if (genRand.Next(4) == 0)
					{
						num3--;
						num4--;
					}
					GenVars.snowMinX[i] = num3;
					GenVars.snowMaxX[i] = num4;
					for (int j = num3; j < num4; j++)
					{
						if (i < num)
						{
							if (Main.tile[j, i].wall == 2)
							{
								Main.tile[j, i].wall = 40;
							}
							switch ((int)Main.tile[j, i].type)
							{
							case 0:
							case 2:
							case 23:
							case 40:
							case 53:
								Main.tile[j, i].type = 147;
								break;
							case 1:
								Main.tile[j, i].type = 161;
								break;
							}
						}
						else
						{
							num5 += genRand.Next(-3, 4);
							if (genRand.Next(3) == 0)
							{
								num5 += genRand.Next(-4, 5);
								if (genRand.Next(3) == 0)
								{
									num5 += genRand.Next(-6, 7);
								}
							}
							if (num5 < 0)
							{
								num5 = genRand.Next(3);
							}
							else if (num5 > 50)
							{
								num5 = 50 - genRand.Next(3);
							}
							for (int k = i; k < i + num5; k++)
							{
								if (Main.tile[j, k].wall == 2)
								{
									Main.tile[j, k].wall = 40;
								}
								switch ((int)Main.tile[j, k].type)
								{
								case 0:
								case 2:
								case 23:
								case 40:
								case 53:
									Main.tile[j, k].type = 147;
									break;
								case 1:
									Main.tile[j, k].type = 161;
									break;
								}
							}
						}
					}
					if (GenVars.snowBottom < i)
					{
						GenVars.snowBottom = i;
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.Grass, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				if (SecretSeed.digExtraHoles.Enabled)
				{
					SecretSeed.DoDigExtraHoles();
				}
				if (SecretSeed.roundLandmasses.Enabled)
				{
					SecretSeed.DoRoundLandMasses();
				}
				double num = (double)(Main.maxTilesX * Main.maxTilesY) * 0.002;
				for (int i = 0; (double)i < num; i++)
				{
					progress.Set((double)i / num);
					int num2 = genRand.Next(1, Main.maxTilesX - 1);
					int num3 = genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurfaceHigh);
					if (num3 >= Main.maxTilesY)
					{
						num3 = Main.maxTilesY - 2;
					}
					if (Main.tile[num2 - 1, num3].active() && Main.tile[num2 - 1, num3].type == 0 && Main.tile[num2 + 1, num3].active() && Main.tile[num2 + 1, num3].type == 0 && Main.tile[num2, num3 - 1].active() && Main.tile[num2, num3 - 1].type == 0 && Main.tile[num2, num3 + 1].active() && Main.tile[num2, num3 + 1].type == 0)
					{
						Main.tile[num2, num3].active(active: true);
						Main.tile[num2, num3].type = 2;
					}
					num2 = genRand.Next(1, Main.maxTilesX - 1);
					num3 = genRand.Next(5, (int)GenVars.worldSurfaceLow);
					if (num3 >= Main.maxTilesY)
					{
						num3 = Main.maxTilesY - 2;
					}
					if (Main.tile[num2 - 1, num3].active() && Main.tile[num2 - 1, num3].type == 0 && Main.tile[num2 + 1, num3].active() && Main.tile[num2 + 1, num3].type == 0 && Main.tile[num2, num3 - 1].active() && Main.tile[num2, num3 - 1].type == 0 && Main.tile[num2, num3 + 1].active() && Main.tile[num2, num3 + 1].type == 0)
					{
						Main.tile[num2, num3].active(active: true);
						Main.tile[num2, num3].type = 2;
					}
				}
			}
		});
		if (!Skyblock.denyAllGeneration)
		{
			AddGenerationPass(new JunglePass());
		}
		AddGenerationPass(GenPassNameID.MudCavesToJungleGrass, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[77].Value;
				NotTheBees();
				if (SecretSeed.surfaceIsMushrooms.Enabled && !SecretSeed.noSurface.Enabled)
				{
					SecretSeed.DoSurfaceIsMushrooms();
				}
				for (int i = 0; i < Main.maxTilesX; i++)
				{
					for (int j = 0; j < Main.maxTilesY; j++)
					{
						if (Main.tile[i, j].active())
						{
							grassSpread = 0;
							SpreadGrass(i, j, 59, 60);
						}
						progress.Set(0.2 * ((double)(i * Main.maxTilesY + j) / (double)(Main.maxTilesX * Main.maxTilesY)));
					}
				}
				SmallConsecutivesFound = 0;
				SmallConsecutivesEliminated = 0;
				double num = Main.maxTilesX - 20;
				for (int k = 10; k < Main.maxTilesX - 10; k++)
				{
					ScanTileColumnAndRemoveClumps(k);
					double num2 = (double)(k - 10) / num;
					progress.Set(0.2 + num2 * 0.8);
				}
			}
		});
		AddGenerationPass(GenPassNameID.DesertBiome, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[78].Value;
				Main.tileSolid[484] = false;
				int num = 0;
				int num2 = GenVars.CurrentDungeonGenVars.dungeonSide;
				int num3 = Main.maxTilesX / 2;
				int num4 = genRand.Next(num3) / 8;
				num4 += num3 / 8;
				int x = num3 + num4 * -num2;
				int num5 = 0;
				DesertBiome desertBiome = GenVars.configuration.CreateBiome<DesertBiome>();
				while (!desertBiome.Place(new Point(x, (int)GenVars.worldSurfaceHigh + 25), GenVars.structures, progress))
				{
					num4 = genRand.Next(num3) / 2;
					num4 += num3 / 8;
					num4 += genRand.Next(num5 / 12);
					x = num3 + num4 * -num2;
					if (++num5 > Main.maxTilesX / 4)
					{
						num2 *= -1;
						num5 = 0;
						num++;
						if (num >= 2)
						{
							GenVars.skipDesertTileCheck = true;
						}
					}
				}
				if (remixWorldGen && !SecretSeed.Variations.surfaceIsDesertSwapDesertAndSnowBiomes)
				{
					for (int i = 50; i < Main.maxTilesX - 50; i++)
					{
						for (int j = (int)Main.rockLayer + genRand.Next(-1, 2); j < Main.maxTilesY - 50; j++)
						{
							if (Main.tile[i, j].active() && (Main.tile[i, j].type == 396 || Main.tile[i, j].type == 397 || Main.tile[i, j].type == 53) && !SolidTile(i, j - 1))
							{
								for (int k = j; k < j + genRand.Next(4, 7) && Main.tile[i, k + 1].active() && (Main.tile[i, k].type == 396 || Main.tile[i, k].type == 397); k++)
								{
									Main.tile[i, k].type = 53;
								}
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.GlowingMushroomPatches, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[13].Value;
				if (SecretSeed.surfaceIsDesert.Enabled)
				{
					SecretSeed.DoSurfaceIsDesert();
				}
				if (remixWorldGen)
				{
					for (int i = 10; i < Main.maxTilesX - 10; i++)
					{
						for (int j = GenVars.remixMushroomLayerLow + genRand.Next(3); j < Main.maxTilesY - 10; j++)
						{
							if (Main.tile[i, j].type == 0)
							{
								Main.tile[i, j].type = 59;
							}
						}
					}
				}
				double num = (double)Main.maxTilesX / 700.0;
				if (num > (double)GenVars.maxMushroomBiomes)
				{
					num = GenVars.maxMushroomBiomes;
				}
				for (int k = 0; (double)k < num; k++)
				{
					progress.Set((float)k / (float)num, 0.0, 0.33000001311302185);
					int num2 = 0;
					bool flag = true;
					while (flag)
					{
						int num3 = genRand.Next((int)((double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.8));
						if (num2 > Main.maxTilesX / 4)
						{
							num3 = genRand.Next((int)((double)Main.maxTilesX * 0.025), (int)((double)Main.maxTilesX * 0.975));
						}
						int num4;
						if (!SecretSeed.errorWorld.Enabled || notTheBees)
						{
							num4 = ((!remixWorldGen) ? genRand.Next((int)Main.rockLayer + 50, Main.maxTilesY - 300) : genRand.Next((int)Main.worldSurface + 50, (int)Main.rockLayer - 50));
						}
						else
						{
							num4 = genRand.Next(200, Main.maxTilesY - 300);
							while ((double)num4 < Main.worldSurface + 300.0 && num3 > Main.maxTilesX / 2 - 300 && num3 < Main.maxTilesX / 2 + 300)
							{
								num3 = genRand.Next((int)((double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.8));
								num4 = genRand.Next(200, Main.maxTilesY - 300);
							}
						}
						flag = false;
						int num5 = 100;
						int num6 = 500;
						if (SecretSeed.dualDungeons.Enabled)
						{
							int num7 = num3 - num5;
							int num8 = num4 - num5;
							int num9 = num3 + num5;
							int num10 = num4 + num5;
							if (DungeonUtils.IntersectsAnyPotentialDungeonBounds(new Rectangle(num7, num8, num9 - num7, num10 - num8)))
							{
								flag = true;
							}
						}
						if (!flag)
						{
							for (int l = num3 - num5; l < num3 + num5; l += 3)
							{
								for (int m = num4 - num5; m < num4 + num5; m += 3)
								{
									if (InWorld(l, m))
									{
										Tile tile = Main.tile[l, m];
										if (tile.active() && (tile.type == 147 || tile.type == 161 || tile.type == 162 || tile.type == 60 || tile.type == 368 || tile.type == 367))
										{
											flag = true;
											break;
										}
										if (GenVars.UndergroundDesertLocation.Contains(new Point(l, m)))
										{
											flag = true;
											break;
										}
									}
									else
									{
										flag = true;
									}
								}
							}
						}
						if (!flag)
						{
							for (int n = 0; n < GenVars.numMushroomBiomes; n++)
							{
								if (Vector2D.Distance(GenVars.mushroomBiomesPosition[n].ToVector2D(), new Vector2D(num3, num4)) < (double)num6)
								{
									flag = true;
								}
							}
						}
						if (!flag && GenVars.numMushroomBiomes < GenVars.maxMushroomBiomes)
						{
							ShroomPatch(num3, num4);
							for (int num11 = 0; num11 < 5; num11++)
							{
								int i2 = num3 + genRand.Next(-40, 41);
								int j2 = num4 + genRand.Next(-40, 41);
								ShroomPatch(i2, j2);
							}
							GenVars.mushroomBiomesPosition[GenVars.numMushroomBiomes].X = num3;
							GenVars.mushroomBiomesPosition[GenVars.numMushroomBiomes].Y = num4;
							GenVars.numMushroomBiomes++;
						}
						num2++;
						if (num2 > Main.maxTilesX / 2)
						{
							break;
						}
					}
				}
				if (SecretSeed.errorWorld.Enabled)
				{
					for (int num12 = 0; num12 < Main.maxTilesX; num12++)
					{
						progress.Set((float)num12 / (float)Main.maxTilesX, 0.33000001311302185, 0.6600000262260437);
						for (int num13 = 0; num13 < Main.maxTilesY; num13++)
						{
							if (InWorld(num12, num13, 50) && Main.tile[num12, num13].active())
							{
								grassSpread = 0;
								SpreadGrass(num12, num13, 59, 70, repeat: false);
							}
						}
					}
				}
				else
				{
					for (int num14 = 0; num14 < Main.maxTilesX; num14++)
					{
						progress.Set((float)num14 / (float)Main.maxTilesX, 0.33000001311302185, 0.6600000262260437);
						for (int num15 = (int)Main.worldSurface; num15 < Main.maxTilesY; num15++)
						{
							if (InWorld(num14, num15, 50) && Main.tile[num14, num15].active())
							{
								grassSpread = 0;
								SpreadGrass(num14, num15, 59, 70, repeat: false);
							}
						}
					}
				}
				for (int num16 = 0; num16 < Main.maxTilesX; num16++)
				{
					progress.Set((float)num16 / (float)Main.maxTilesX, 0.6600000262260437, 1.0);
					for (int num17 = (int)Main.worldSurface; num17 < Main.maxTilesY; num17++)
					{
						if (Main.tile[num16, num17].active() && Main.tile[num16, num17].type == 70)
						{
							int type = 59;
							for (int num18 = num16 - 1; num18 <= num16 + 1; num18++)
							{
								for (int num19 = num17 - 1; num19 <= num17 + 1; num19++)
								{
									if (Main.tile[num18, num19].active())
									{
										if (!Main.tile[num18 - 1, num19].active() && !Main.tile[num18 + 1, num19].active())
										{
											KillTile(num18, num19);
										}
										else if (!Main.tile[num18, num19 - 1].active() && !Main.tile[num18, num19 + 1].active())
										{
											KillTile(num18, num19);
										}
									}
									else if (Main.tile[num18 - 1, num19].active() && Main.tile[num18 + 1, num19].active())
									{
										PlaceTile(num18, num19, type);
										if (Main.tile[num18 - 1, num17].type == 70)
										{
											Main.tile[num18 - 1, num17].type = 59;
										}
										if (Main.tile[num18 + 1, num17].type == 70)
										{
											Main.tile[num18 + 1, num17].type = 59;
										}
									}
									else if (Main.tile[num18, num19 - 1].active() && Main.tile[num18, num19 + 1].active())
									{
										PlaceTile(num18, num19, type);
										if (Main.tile[num18, num17 - 1].type == 70)
										{
											Main.tile[num18, num17 - 1].type = 59;
										}
										if (Main.tile[num18, num17 + 1].type == 70)
										{
											Main.tile[num18, num17 + 1].type = 59;
										}
									}
								}
							}
							if (genRand.Next(4) == 0)
							{
								int num20 = num16 + genRand.Next(-20, 21);
								int num21 = num17 + genRand.Next(-20, 21);
								if (InWorld(num20, num21) && Main.tile[num20, num21].type == 59)
								{
									Main.tile[num20, num21].type = 70;
								}
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.Marble, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[80].Value;
				int num = passConfig.Get<WorldGenRange>("Count").GetRandom(genRand);
				if (SecretSeed.dualDungeons.Enabled)
				{
					num /= 2;
				}
				double num2 = (double)(Main.maxTilesX - 160) / (double)num;
				MarbleBiome marbleBiome = GenVars.configuration.CreateBiome<MarbleBiome>();
				int num3 = 0;
				int num4 = 0;
				while (num4 < num)
				{
					double num5 = (double)num4 / (double)num;
					progress.Set(num5);
					Point origin = Point.Zero;
					bool flag = false;
					int num6 = 100;
					while (!flag)
					{
						num6--;
						if (num6 <= 0)
						{
							break;
						}
						if (!SecretSeed.dualDungeons.Enabled)
						{
							origin = ((!remixWorldGen) ? RandomRectanglePoint((int)(num5 * (double)(Main.maxTilesX - 200)) + 100, (int)GenVars.rockLayer + 20, (int)num2, Main.maxTilesY - ((int)GenVars.rockLayer + 40) - 200) : RandomRectanglePoint((int)(num5 * (double)(Main.maxTilesX - 200)) + 100, (int)GenVars.worldSurface + 100, (int)num2, (int)GenVars.rockLayer - (int)GenVars.worldSurface - 100));
						}
						else
						{
							int num7 = 120;
							int num8 = num7;
							int num9 = num7 + 1;
							switch (num4)
							{
							case 0:
								num8 = num7;
								num9 = num7 + 100;
								break;
							case 1:
								num8 = Main.maxTilesX - num7 - 100;
								num9 = Main.maxTilesX - num7;
								break;
							default:
								num8 = num7;
								num9 = Main.maxTilesX - num7;
								break;
							}
							origin = ((!remixWorldGen) ? RandomRectanglePoint(num8, (int)GenVars.rockLayer + 20, num9 - num8, Main.maxTilesY - ((int)GenVars.rockLayer + 40) - 200) : RandomRectanglePoint(num8, (int)GenVars.worldSurface + 100, num9 - num8, (int)GenVars.rockLayer - (int)GenVars.worldSurface - 100));
							int num10 = 40;
							int num11 = origin.X - num10;
							int num12 = origin.Y - num10;
							int num13 = origin.X + num10;
							int num14 = origin.Y + num10;
							flag = !DungeonUtils.IntersectsAnyPotentialDungeonBounds(new Rectangle(num11, num12, num13 - num11, num14 - num12));
						}
						if (!SecretSeed.dualDungeons.Enabled)
						{
							while ((double)origin.X > (double)Main.maxTilesX * 0.45 && (double)origin.X < (double)Main.maxTilesX * 0.55)
							{
								origin.X = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
							}
							flag = true;
						}
					}
					num3++;
					if (flag && marbleBiome.Place(origin, GenVars.structures))
					{
						num4++;
						num3 = 0;
					}
					else if (num3 > Main.maxTilesX * 10)
					{
						num = num4;
						num4++;
						num3 = 0;
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.Granite, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[81].Value;
				int num = passConfig.Get<WorldGenRange>("Count").GetRandom(genRand);
				if (SecretSeed.dualDungeons.Enabled)
				{
					num /= 2;
				}
				double num2 = (double)(Main.maxTilesX - 200) / (double)num;
				List<Point> list = new List<Point>(num);
				int num3 = 0;
				int num4 = 0;
				while (num4 < num)
				{
					float num5 = (float)num4 / (float)num;
					float num6 = num5 * 0.2f;
					progress.Set(num6);
					Point point = Point.Zero;
					bool flag = false;
					int num7 = 100;
					while (!flag)
					{
						num7--;
						if (num7 <= 0)
						{
							break;
						}
						if (!SecretSeed.dualDungeons.Enabled)
						{
							point = ((!remixWorldGen) ? RandomRectanglePoint((int)(num5 * (float)(Main.maxTilesX - 200)) + 100, (int)GenVars.rockLayer + 20, (int)num2, Main.maxTilesY - ((int)GenVars.rockLayer + 40) - 200) : RandomRectanglePoint((int)(num5 * (float)(Main.maxTilesX - 200)) + 100, (int)GenVars.worldSurface + 100, (int)num2, (int)GenVars.rockLayer - (int)GenVars.worldSurface - 100));
						}
						else
						{
							int num8 = 120;
							int num9 = num8;
							int num10 = num8 + 1;
							switch (num4)
							{
							case 0:
								num9 = num8;
								num10 = num8 + 100;
								break;
							case 1:
								num9 = Main.maxTilesX - num8 - 100;
								num10 = Main.maxTilesX - num8;
								break;
							default:
								num9 = num8;
								num10 = Main.maxTilesX - num8;
								break;
							}
							point = ((!remixWorldGen) ? RandomRectanglePoint(num9, (int)GenVars.rockLayer + 20, num10 - num9, Main.maxTilesY - ((int)GenVars.rockLayer + 40) - 200) : RandomRectanglePoint(num9, (int)GenVars.worldSurface + 100, num10 - num9, (int)GenVars.rockLayer - (int)GenVars.worldSurface - 100));
							int num11 = 40;
							int num12 = point.X - num11;
							int num13 = point.Y - num11;
							int num14 = point.X + num11;
							int num15 = point.Y + num11;
							flag = !DungeonUtils.IntersectsAnyPotentialDungeonBounds(new Rectangle(num12, num13, num14 - num12, num15 - num13));
						}
						if (!SecretSeed.dualDungeons.Enabled)
						{
							while ((double)point.X > (double)Main.maxTilesX * 0.45 && (double)point.X < (double)Main.maxTilesX * 0.55)
							{
								point.X = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
							}
							flag = true;
						}
					}
					num3++;
					if (flag && GraniteBiome.CanPlace(point, GenVars.structures))
					{
						list.Add(point);
						num4++;
					}
					else if (num3 > Main.maxTilesX * 10)
					{
						num = num4;
						num4++;
						num3 = 0;
					}
				}
				GraniteBiome graniteBiome = GenVars.configuration.CreateBiome<GraniteBiome>();
				for (int i = 0; i < num; i++)
				{
					double value = 0.2f + (float)i / (float)num * 0.8f;
					progress.Set(value);
					graniteBiome.Place(list[i], GenVars.structures);
				}
			}
		});
		AddGenerationPass(GenPassNameID.FloatingIslands, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyFloatingIslands && !SecretSeed.Variations.noSurfaceNoFloatingIslands)
			{
				GenVars.numIslandHouses = 0;
				GenVars.skyIslandHouseCount = 0;
				progress.Message = Lang.gen[12].Value;
				int num = (int)((double)Main.maxTilesX * 0.0008);
				int num2 = 0;
				if (SecretSeed.errorWorld.Enabled && SecretSeed.Variations.errorWorldAdjustment(1.0) < 3)
				{
					num *= 3;
				}
				int num3 = num;
				bool flag = false;
				if (SecretSeed.extraFloatingIslands.Enabled && !SecretSeed.Variations.extraFloatingIslandsNormalAmount)
				{
					if (SecretSeed.Variations.extraFloatingIslandsReducedAmount)
					{
						num *= 2;
						GenVars.skyLakes *= 2;
					}
					else
					{
						num *= 10;
						GenVars.skyLakes *= 10;
					}
				}
				double num4 = num + GenVars.skyLakes;
				for (int i = 0; (double)i < num4; i++)
				{
					progress.Set((double)i / num4);
					int num5 = Main.maxTilesX;
					if (skyblockWorldGen)
					{
						num5 /= 42;
					}
					while (--num5 > 0)
					{
						bool flag2 = true;
						int num6 = 0;
						int num7 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
						int num8 = 150;
						if (SecretSeed.extraFloatingIslands.Enabled)
						{
							num8 = 100;
						}
						if (!SecretSeed.errorWorld.Enabled)
						{
							while (num7 > Main.maxTilesX / 2 - num8 && num7 < Main.maxTilesX / 2 + num8)
							{
								num7 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
							}
						}
						int num9 = 180;
						if (SecretSeed.extraFloatingIslands.Enabled && !SecretSeed.Variations.extraFloatingIslandsNormalAmount)
						{
							num9 = 100;
						}
						for (int j = 0; j < GenVars.numIslandHouses; j++)
						{
							if (num7 > GenVars.floatingIslandHouseX[j] - num9 && num7 < GenVars.floatingIslandHouseX[j] + num9)
							{
								flag2 = false;
								break;
							}
						}
						if (flag2)
						{
							flag2 = false;
							num6 = 0;
							if (SecretSeed.noSurface.Enabled)
							{
								num6 = genRand.Next(200, Main.UnderworldLayer - 200);
								flag2 = true;
							}
							else if (skyblockWorldGen)
							{
								num6 = (int)(Main.worldSurface / 2.0 + 100.0);
								flag2 = true;
							}
							else
							{
								for (int k = 200; (double)k < Main.worldSurface; k++)
								{
									if (Main.tile[num7, k].active())
									{
										num6 = k;
										flag2 = true;
										break;
									}
								}
							}
							if (flag2)
							{
								int num10 = 0;
								int num11 = genRand.Next(90, num6 - 100);
								if (skyblockWorldGen && flag2)
								{
									for (int l = num7 - 150; l <= num7 + 150; l++)
									{
										for (int m = num11 - 75; m <= num11 + 75; m++)
										{
											if (InWorld(l, m) && Main.tile[l, m].active())
											{
												flag2 = false;
											}
										}
									}
									if (!flag2)
									{
										continue;
									}
								}
								num5 = -1;
								if (!SecretSeed.noSurface.Enabled)
								{
									num11 = Math.Min(num11, (int)GenVars.worldSurfaceLow - 50);
									if (SecretSeed.errorWorld.Enabled && genRand.Next(4) != 0)
									{
										num11 = genRand.Next((int)Main.worldSurface + 50, Main.UnderworldLayer - 50);
									}
								}
								bool flag3 = false;
								if (num2 >= num)
								{
									flag3 = true;
								}
								if (SecretSeed.extraFloatingIslands.Enabled && i > 4)
								{
									if (!flag)
									{
										flag3 = true;
									}
									else if (genRand.Next(4) == 0)
									{
										flag3 = true;
									}
								}
								if (flag3)
								{
									flag = true;
									GenVars.skyLake[GenVars.numIslandHouses] = true;
									CloudLake(num7, num11);
								}
								else
								{
									GenVars.skyLake[GenVars.numIslandHouses] = false;
									if (drunkWorldGen && !remixWorldGen)
									{
										if (genRand.Next(2) == 0)
										{
											num10 = 3;
											SnowCloudIsland(num7, num11);
										}
										else
										{
											num10 = 1;
											DesertCloudIsland(num7, num11);
										}
									}
									else
									{
										if (remixWorldGen && drunkWorldGen && (!tenthAnniversaryWorldGen || getGoodWorldGen))
										{
											num10 = ((GenVars.crimsonLeft && num7 < Main.maxTilesX / 2) ? 5 : ((GenVars.crimsonLeft || num7 <= Main.maxTilesX / 2) ? 4 : 5));
										}
										else if (!notTheBees || remixWorldGen)
										{
											if (getGoodWorldGen || (remixWorldGen && !tenthAnniversaryWorldGen))
											{
												num10 = ((!crimson) ? 4 : 5);
											}
											else if (Main.tenthAnniversaryWorld)
											{
												num10 = 6;
											}
										}
										CloudIsland(num7, num11);
									}
								}
								GenVars.floatingIslandHouseX[GenVars.numIslandHouses] = num7;
								GenVars.floatingIslandHouseY[GenVars.numIslandHouses] = num11;
								GenVars.floatingIslandStyle[GenVars.numIslandHouses] = num10;
								GenVars.numIslandHouses++;
								num2++;
							}
						}
					}
				}
				if (SecretSeed.extraFloatingIslands.Enabled && GenVars.numIslandHouses > num3 * 2)
				{
					GenVars.numIslandHouses = num3 * 2;
				}
			}
		});
		AddGenerationPass(GenPassNameID.DirtToMud, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[14].Value;
				double num = (double)(Main.maxTilesX * Main.maxTilesY) * 0.001;
				for (int i = 0; (double)i < num; i++)
				{
					progress.Set((double)i / num);
					if (remixWorldGen)
					{
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.worldSurface, (int)GenVars.rockLayerLow), genRand.Next(2, 6), genRand.Next(2, 40), 59, addTile: false, 0.0, 0.0, noYChange: false, overRide: true, 53);
					}
					else
					{
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerLow, Main.maxTilesY), genRand.Next(2, 6), genRand.Next(2, 40), 59, addTile: false, 0.0, 0.0, noYChange: false, overRide: true, 53);
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.Silt, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[15].Value;
				progress.Set(0.0);
				int num = (int)((float)(Main.maxTilesX * Main.maxTilesY) * 0.0001f);
				for (int i = 0; i < num; i++)
				{
					float num2 = (float)i / (float)num;
					progress.Set(num2 * 0.5f);
					int num3 = genRand.Next(0, Main.maxTilesX);
					int num4 = genRand.Next((int)GenVars.rockLayerHigh, Main.maxTilesY);
					if (remixWorldGen)
					{
						num4 = genRand.Next((int)Main.worldSurface, (int)Main.rockLayer);
					}
					if (Main.tile[num3, num4].wall != 187 && Main.tile[num3, num4].wall != 216)
					{
						TileRunner(num3, num4, genRand.Next(5, 12), genRand.Next(15, 50), 123);
					}
				}
				num = (int)((float)(Main.maxTilesX * Main.maxTilesY) * 0.0005f);
				for (int j = 0; j < num; j++)
				{
					float num5 = (float)j / (float)num;
					progress.Set(0.5f + num5 * 0.5f);
					int num6 = genRand.Next(0, Main.maxTilesX);
					int num7 = genRand.Next((int)GenVars.rockLayerHigh, Main.maxTilesY);
					if (remixWorldGen)
					{
						num7 = genRand.Next((int)Main.worldSurface, (int)Main.rockLayer);
					}
					if (Main.tile[num6, num7].wall != 187 && Main.tile[num6, num7].wall != 216)
					{
						TileRunner(num6, num7, genRand.Next(2, 5), genRand.Next(2, 5), 123);
					}
				}
				progress.Set(1.0);
			}
		});
		AddGenerationPass(GenPassNameID.OresAndShinies, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[16].Value;
				progress.Set(0.0);
				float num = 12f;
				float num2 = 1f / num;
				if (remixWorldGen)
				{
					int num3 = (int)((float)(Main.maxTilesX * Main.maxTilesY) * 6E-05f);
					for (int i = 0; i < num3; i++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.copper = 7;
							}
							else
							{
								GenVars.copper = 166;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurfaceHigh), genRand.Next(3, 6), genRand.Next(2, 6), GenVars.copper);
					}
					progress.Set(num2);
					for (int j = 0; j < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 8E-05); j++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.copper = 7;
							}
							else
							{
								GenVars.copper = 166;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceHigh, (int)GenVars.rockLayerHigh), genRand.Next(3, 7), genRand.Next(3, 7), GenVars.copper);
					}
					progress.Set(num2 * 2f);
					for (int k = 0; k < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0002); k++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.copper = 7;
							}
							else
							{
								GenVars.copper = 166;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerLow, Main.maxTilesY), genRand.Next(4, 9), genRand.Next(4, 8), GenVars.copper);
					}
					progress.Set(num2 * 3f);
					for (int l = 0; l < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 3E-05); l++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.iron = 6;
							}
							else
							{
								GenVars.iron = 167;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurfaceHigh), genRand.Next(3, 7), genRand.Next(2, 5), GenVars.iron);
					}
					progress.Set(num2 * 4f);
					for (int m = 0; m < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 8E-05); m++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.iron = 6;
							}
							else
							{
								GenVars.iron = 167;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceHigh, (int)GenVars.rockLayerHigh), genRand.Next(3, 6), genRand.Next(3, 6), GenVars.iron);
					}
					progress.Set(num2 * 5f);
					for (int n = 0; n < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0002); n++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.iron = 6;
							}
							else
							{
								GenVars.iron = 167;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerLow, Main.maxTilesY), genRand.Next(4, 9), genRand.Next(4, 8), GenVars.iron);
					}
					progress.Set(num2 * 6f);
					for (int num4 = 0; num4 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.6E-05); num4++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.silver = 9;
							}
							else
							{
								GenVars.silver = 168;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.rockLayer - 100, Main.maxTilesY - 250), genRand.Next(3, 6), genRand.Next(3, 6), GenVars.silver);
					}
					progress.Set(num2 * 7f);
					for (int num5 = 0; num5 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00015); num5++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.silver = 9;
							}
							else
							{
								GenVars.silver = 168;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.worldSurface, (int)Main.rockLayer), genRand.Next(4, 9), genRand.Next(4, 8), GenVars.silver);
					}
					progress.Set(num2 * 8f);
					for (int num6 = 0; num6 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00012); num6++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.gold = 8;
							}
							else
							{
								GenVars.gold = 169;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.worldSurface, (int)Main.rockLayer), genRand.Next(4, 8), genRand.Next(4, 8), GenVars.gold);
					}
					progress.Set(num2 * 9f);
					if (!SecretSeed.noSurface.Enabled && !SecretSeed.surfaceIsInSpace.Enabled)
					{
						for (int num7 = 0; num7 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00017); num7++)
						{
							if (drunkWorldGen)
							{
								if (genRand.Next(2) == 0)
								{
									GenVars.silver = 9;
								}
								else
								{
									GenVars.silver = 168;
								}
							}
							TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(0, (int)GenVars.worldSurfaceLow), genRand.Next(4, 9), genRand.Next(4, 8), GenVars.silver);
						}
						for (int num8 = 0; num8 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00012); num8++)
						{
							if (drunkWorldGen)
							{
								if (genRand.Next(2) == 0)
								{
									GenVars.gold = 8;
								}
								else
								{
									GenVars.gold = 169;
								}
							}
							TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(0, (int)GenVars.worldSurfaceLow - 20), genRand.Next(4, 8), genRand.Next(4, 8), GenVars.gold);
						}
					}
					progress.Set(num2 * 10f);
					if (drunkWorldGen)
					{
						for (int num9 = 0; num9 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.25E-05 / 2.0); num9++)
						{
							TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.rockLayer, Main.maxTilesY), genRand.Next(3, 6), genRand.Next(4, 8), 204);
						}
						for (int num10 = 0; num10 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.25E-05 / 2.0); num10++)
						{
							TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.rockLayer, Main.maxTilesY), genRand.Next(3, 6), genRand.Next(4, 8), 22);
						}
					}
					progress.Set(num2 * 11f);
					if (crimson)
					{
						for (int num11 = 0; num11 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 4.25E-05); num11++)
						{
							TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.worldSurface, (int)Main.rockLayer), genRand.Next(3, 6), genRand.Next(4, 8), 204);
						}
					}
					else
					{
						for (int num12 = 0; num12 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 4.25E-05); num12++)
						{
							TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.worldSurface, (int)Main.rockLayer), genRand.Next(3, 6), genRand.Next(4, 8), 22);
						}
					}
				}
				else
				{
					for (int num13 = 0; num13 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 6E-05); num13++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.copper = 7;
							}
							else
							{
								GenVars.copper = 166;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurfaceHigh), genRand.Next(3, 6), genRand.Next(2, 6), GenVars.copper);
					}
					progress.Set(num2);
					for (int num14 = 0; num14 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 8E-05); num14++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.copper = 7;
							}
							else
							{
								GenVars.copper = 166;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceHigh, (int)GenVars.rockLayerHigh), genRand.Next(3, 7), genRand.Next(3, 7), GenVars.copper);
					}
					progress.Set(num2 * 2f);
					for (int num15 = 0; num15 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0002); num15++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.copper = 7;
							}
							else
							{
								GenVars.copper = 166;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerLow, Main.maxTilesY), genRand.Next(4, 9), genRand.Next(4, 8), GenVars.copper);
					}
					progress.Set(num2 * 3f);
					for (int num16 = 0; num16 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 3E-05); num16++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.iron = 6;
							}
							else
							{
								GenVars.iron = 167;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurfaceHigh), genRand.Next(3, 7), genRand.Next(2, 5), GenVars.iron);
					}
					progress.Set(num2 * 4f);
					for (int num17 = 0; num17 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 8E-05); num17++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.iron = 6;
							}
							else
							{
								GenVars.iron = 167;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceHigh, (int)GenVars.rockLayerHigh), genRand.Next(3, 6), genRand.Next(3, 6), GenVars.iron);
					}
					progress.Set(num2 * 5f);
					for (int num18 = 0; num18 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0002); num18++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.iron = 6;
							}
							else
							{
								GenVars.iron = 167;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerLow, Main.maxTilesY), genRand.Next(4, 9), genRand.Next(4, 8), GenVars.iron);
					}
					progress.Set(num2 * 6f);
					for (int num19 = 0; num19 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.6E-05); num19++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.silver = 9;
							}
							else
							{
								GenVars.silver = 168;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceHigh, (int)GenVars.rockLayerHigh), genRand.Next(3, 6), genRand.Next(3, 6), GenVars.silver);
					}
					progress.Set(num2 * 7f);
					for (int num20 = 0; num20 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00015); num20++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.silver = 9;
							}
							else
							{
								GenVars.silver = 168;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerLow, Main.maxTilesY), genRand.Next(4, 9), genRand.Next(4, 8), GenVars.silver);
					}
					progress.Set(num2 * 8f);
					for (int num21 = 0; num21 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00012); num21++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.gold = 8;
							}
							else
							{
								GenVars.gold = 169;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerLow, Main.maxTilesY), genRand.Next(4, 8), genRand.Next(4, 8), GenVars.gold);
					}
					progress.Set(num2 * 9f);
					if (!SecretSeed.noSurface.Enabled && !SecretSeed.surfaceIsInSpace.Enabled)
					{
						for (int num22 = 0; num22 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00017); num22++)
						{
							if (drunkWorldGen)
							{
								if (genRand.Next(2) == 0)
								{
									GenVars.silver = 9;
								}
								else
								{
									GenVars.silver = 168;
								}
							}
							TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(0, (int)GenVars.worldSurfaceLow), genRand.Next(4, 9), genRand.Next(4, 8), GenVars.silver);
						}
						for (int num23 = 0; num23 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00012); num23++)
						{
							if (drunkWorldGen)
							{
								if (genRand.Next(2) == 0)
								{
									GenVars.gold = 8;
								}
								else
								{
									GenVars.gold = 169;
								}
							}
							TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(0, (int)GenVars.worldSurfaceLow - 20), genRand.Next(4, 8), genRand.Next(4, 8), GenVars.gold);
						}
					}
					progress.Set(num2 * 10f);
					if (drunkWorldGen)
					{
						for (int num24 = 0; num24 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.25E-05 / 2.0); num24++)
						{
							TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.rockLayer, Main.maxTilesY), genRand.Next(3, 6), genRand.Next(4, 8), 204);
						}
						for (int num25 = 0; num25 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.25E-05 / 2.0); num25++)
						{
							TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.rockLayer, Main.maxTilesY), genRand.Next(3, 6), genRand.Next(4, 8), 22);
						}
					}
					progress.Set(num2 * 11f);
					if (crimson)
					{
						for (int num26 = 0; num26 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.25E-05); num26++)
						{
							TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.rockLayer, Main.maxTilesY), genRand.Next(3, 6), genRand.Next(4, 8), 204);
						}
					}
					else
					{
						for (int num27 = 0; num27 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.25E-05); num27++)
						{
							TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.rockLayer, Main.maxTilesY), genRand.Next(3, 6), genRand.Next(4, 8), 22);
						}
					}
				}
				progress.Set(1.0);
			}
		});
		AddGenerationPass(GenPassNameID.Webs, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[17].Value;
				for (int i = 0; i < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0006); i++)
				{
					int j = genRand.Next(20, Main.maxTilesX - 20);
					int num = genRand.Next((int)GenVars.worldSurfaceHigh, Main.maxTilesY - 20);
					if (i < GenVars.numMCaves)
					{
						j = GenVars.mCaveX[i];
						num = GenVars.mCaveY[i];
					}
					if (!Main.tile[j, num].active() && ((double)num > Main.worldSurface || Main.tile[j, num].wall > 0))
					{
						while (!Main.tile[j, num].active() && num > (int)GenVars.worldSurfaceLow)
						{
							num--;
						}
						num++;
						int num2 = 1;
						if (genRand.Next(2) == 0)
						{
							num2 = -1;
						}
						for (; !Main.tile[j, num].active() && j > 10 && j < Main.maxTilesX - 10; j += num2)
						{
						}
						j -= num2;
						if ((double)num > Main.worldSurface || Main.tile[j, num].wall > 0)
						{
							TileRunner(j, num, genRand.Next(4, 11), genRand.Next(2, 4), 51, addTile: true, num2, -1.0, noYChange: false, overRide: false);
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.Underworld, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[18].Value;
				progress.Set(0.0);
				int num = Main.maxTilesY - genRand.Next(150, 190);
				int num2 = Main.maxTilesY - genRand.Next(40, 70);
				for (int i = 0; i < Main.maxTilesX; i++)
				{
					progress.Set((float)i / (float)Main.maxTilesX, 0.0, 0.20000000298023224);
					num += genRand.Next(-3, 4);
					if (num < Main.maxTilesY - 190)
					{
						num = Main.maxTilesY - 190;
					}
					if (num > Main.maxTilesY - 160)
					{
						num = Main.maxTilesY - 160;
					}
					int num3 = num;
					if (GenVars.notTheBeesAndForTheWorthyNoCelebration)
					{
						num3 -= 30;
					}
					for (int j = num3 - 20 - genRand.Next(3); j < Main.maxTilesY; j++)
					{
						if (GenVars.notTheBeesAndForTheWorthyNoCelebration && j <= num3 && !SecretSeed.Variations.noSpiderCavesActuallyNoSpiderCaves)
						{
							Main.tile[i, j].wall = 62;
						}
						else if (j >= num)
						{
							Main.tile[i, j].active(active: false);
							Main.tile[i, j].lava(lava: false);
							Main.tile[i, j].liquid = 0;
							if (GenVars.notTheBeesAndForTheWorthyNoCelebration && !SecretSeed.Variations.noSpiderCavesActuallyNoSpiderCaves)
							{
								Main.tile[i, j].wall = 62;
								if (j < num2 && genRand.Next(10) == 0)
								{
									Main.tile[i, j].active(active: true);
									Main.tile[i, j].type = 51;
									Main.tile[i, j].ClearSlope();
								}
							}
						}
						else
						{
							Main.tile[i, j].type = 57;
							if (GenVars.notTheBeesAndForTheWorthyNoCelebration && !SecretSeed.Variations.noSpiderCavesActuallyNoSpiderCaves)
							{
								Main.tile[i, j].wall = 62;
							}
						}
					}
				}
				for (int k = 10; k < Main.maxTilesX - 10; k++)
				{
					progress.Set((float)(k - 10) / (float)(Main.maxTilesX - 20), 0.20000000298023224, 0.4000000059604645);
					num2 += genRand.Next(-10, 11);
					if (num2 > Main.maxTilesY - 60)
					{
						num2 = Main.maxTilesY - 60;
					}
					if (num2 < Main.maxTilesY - 100)
					{
						num2 = Main.maxTilesY - 120;
					}
					for (int l = num2; l < Main.maxTilesY - 10; l++)
					{
						if (!Main.tile[k, l].active())
						{
							Main.tile[k, l].lava(lava: true);
							Main.tile[k, l].liquid = byte.MaxValue;
						}
					}
				}
				for (int m = 0; m < Main.maxTilesX; m++)
				{
					progress.Set((float)m / (float)Main.maxTilesX, 0.4000000059604645, 0.6600000262260437);
					if (genRand.Next(50) == 0)
					{
						int num4 = Main.maxTilesY - 65;
						while (!Main.tile[m, num4].active() && num4 > Main.maxTilesY - 135)
						{
							num4--;
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), num4 + genRand.Next(20, 50), genRand.Next(15, 20), 1000, 57, addTile: true, 0.0, genRand.Next(1, 3), noYChange: true);
					}
				}
				Liquid.QuickWater(-2);
				for (int n = 0; n < Main.maxTilesX; n++)
				{
					double value = (double)n / (double)(Main.maxTilesX - 1);
					progress.Set(value, 0.6600000262260437, 1.0);
					if (genRand.Next(13) == 0)
					{
						int num5 = Main.maxTilesY - 65;
						while ((Main.tile[n, num5].liquid > 0 || Main.tile[n, num5].active()) && num5 > Main.maxTilesY - 140)
						{
							num5--;
						}
						if ((!drunkWorldGen && !remixWorldGen) || genRand.Next(3) == 0 || !((double)n > (double)Main.maxTilesX * 0.4) || !((double)n < (double)Main.maxTilesX * 0.6))
						{
							TileRunner(n, num5 - genRand.Next(2, 5), genRand.Next(5, 30), 1000, 57, addTile: true, 0.0, genRand.Next(1, 3), noYChange: true);
						}
						double num6 = genRand.Next(1, 3);
						if (genRand.Next(3) == 0)
						{
							num6 *= 0.5;
						}
						if ((!drunkWorldGen && !remixWorldGen) || genRand.Next(3) == 0 || !((double)n > (double)Main.maxTilesX * 0.4) || !((double)n < (double)Main.maxTilesX * 0.6))
						{
							if (genRand.Next(2) == 0)
							{
								TileRunner(n, num5 - genRand.Next(2, 5), (int)((double)genRand.Next(5, 15) * num6), (int)((double)genRand.Next(10, 15) * num6), 57, addTile: true, 1.0, 0.3);
							}
							if (genRand.Next(2) == 0)
							{
								num6 = genRand.Next(1, 3);
								TileRunner(n, num5 - genRand.Next(2, 5), (int)((double)genRand.Next(5, 15) * num6), (int)((double)genRand.Next(10, 15) * num6), 57, addTile: true, -1.0, 0.3);
							}
						}
						TileRunner(n + genRand.Next(-10, 10), num5 + genRand.Next(-10, 10), genRand.Next(5, 15), genRand.Next(5, 10), -2, addTile: false, genRand.Next(-1, 3), genRand.Next(-1, 3));
						if (genRand.Next(3) == 0)
						{
							TileRunner(n + genRand.Next(-10, 10), num5 + genRand.Next(-10, 10), genRand.Next(10, 30), genRand.Next(10, 20), -2, addTile: false, genRand.Next(-1, 3), genRand.Next(-1, 3));
						}
						if (genRand.Next(5) == 0)
						{
							TileRunner(n + genRand.Next(-15, 15), num5 + genRand.Next(-15, 10), genRand.Next(15, 30), genRand.Next(5, 20), -2, addTile: false, genRand.Next(-1, 3), genRand.Next(-1, 3));
						}
					}
				}
				for (int num7 = 0; num7 < Main.maxTilesX; num7++)
				{
					TileRunner(genRand.Next(20, Main.maxTilesX - 20), genRand.Next(Main.maxTilesY - 180, Main.maxTilesY - 10), genRand.Next(2, 7), genRand.Next(2, 7), -2);
				}
				if (drunkWorldGen || remixWorldGen)
				{
					for (int num8 = 0; num8 < Main.maxTilesX * 2; num8++)
					{
						TileRunner(genRand.Next((int)((double)Main.maxTilesX * 0.35), (int)((double)Main.maxTilesX * 0.65)), genRand.Next(Main.maxTilesY - 180, Main.maxTilesY - 10), genRand.Next(5, 20), genRand.Next(5, 10), -2);
					}
				}
				for (int num9 = 0; num9 < Main.maxTilesX; num9++)
				{
					if (!Main.tile[num9, Main.maxTilesY - 145].active())
					{
						Main.tile[num9, Main.maxTilesY - 145].liquid = byte.MaxValue;
						Main.tile[num9, Main.maxTilesY - 145].lava(lava: true);
					}
					if (!Main.tile[num9, Main.maxTilesY - 144].active())
					{
						Main.tile[num9, Main.maxTilesY - 144].liquid = byte.MaxValue;
						Main.tile[num9, Main.maxTilesY - 144].lava(lava: true);
					}
				}
				for (int num10 = 0; num10 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0008); num10++)
				{
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(Main.maxTilesY - 140, Main.maxTilesY), genRand.Next(2, 7), genRand.Next(3, 7), 58);
				}
				if (remixWorldGen)
				{
					GenerateUnderworldStartingMound();
				}
				else if (!drunkWorldGen)
				{
					for (int num11 = 25; num11 < Main.maxTilesX - 25; num11++)
					{
						if ((double)num11 < (double)Main.maxTilesX * 0.17 || (double)num11 > (double)Main.maxTilesX * 0.83)
						{
							for (int num12 = Main.maxTilesY - 300; num12 < Main.maxTilesY - 100 + genRand.Next(-1, 2); num12++)
							{
								if (Main.tile[num11, num12].type == 57 && Main.tile[num11, num12].active() && (!Main.tile[num11 - 1, num12 - 1].active() || !Main.tile[num11, num12 - 1].active() || !Main.tile[num11 + 1, num12 - 1].active() || !Main.tile[num11 - 1, num12].active() || !Main.tile[num11 + 1, num12].active() || !Main.tile[num11 - 1, num12 + 1].active() || !Main.tile[num11, num12 + 1].active() || !Main.tile[num11 + 1, num12 + 1].active()))
								{
									Main.tile[num11, num12].type = 633;
								}
							}
						}
					}
					for (int num13 = 25; num13 < Main.maxTilesX - 25; num13++)
					{
						if ((double)num13 < (double)Main.maxTilesX * 0.17 || (double)num13 > (double)Main.maxTilesX * 0.83)
						{
							for (int num14 = Main.maxTilesY - 200; num14 < Main.maxTilesY - 50; num14++)
							{
								if (Main.tile[num13, num14].type == 633 && Main.tile[num13, num14].active() && !Main.tile[num13, num14 - 1].active() && genRand.Next(3) == 0)
								{
									TryGrowingTreeByType(634, num13, num14);
								}
							}
						}
					}
				}
				AddHellHouses();
				if (drunkWorldGen)
				{
					for (int num15 = 25; num15 < Main.maxTilesX - 25; num15++)
					{
						for (int num16 = Main.maxTilesY - 300; num16 < Main.maxTilesY - 100 + genRand.Next(-1, 2); num16++)
						{
							if (Main.tile[num15, num16].type == 57 && Main.tile[num15, num16].active() && (!Main.tile[num15 - 1, num16 - 1].active() || !Main.tile[num15, num16 - 1].active() || !Main.tile[num15 + 1, num16 - 1].active() || !Main.tile[num15 - 1, num16].active() || !Main.tile[num15 + 1, num16].active() || !Main.tile[num15 - 1, num16 + 1].active() || !Main.tile[num15, num16 + 1].active() || !Main.tile[num15 + 1, num16 + 1].active()))
							{
								Main.tile[num15, num16].type = 633;
							}
						}
					}
					for (int num17 = 25; num17 < Main.maxTilesX - 25; num17++)
					{
						for (int num18 = Main.maxTilesY - 200; num18 < Main.maxTilesY - 50; num18++)
						{
							if (Main.tile[num17, num18].type == 633 && Main.tile[num17, num18].active() && !Main.tile[num17, num18 - 1].active() && genRand.Next(3) == 0)
							{
								TryGrowingTreeByType(634, num17, num18);
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.CorruptionAndCrimson, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				double num = GenVars.worldSurfaceLow;
				double num2 = Main.worldSurface;
				if (SecretSeed.surfaceIsInSpace.Enabled)
				{
					num = FindLowestCloud() + 10;
				}
				if (SecretSeed.noSurface.Enabled)
				{
					if (SecretSeed.surfaceIsDesert.Enabled)
					{
						SecretSeed.DoSurfaceIsDesertNoSurfaceCleanup();
					}
					num2 = Main.rockLayer;
					num = Main.rockLayer / 2.0;
				}
				int num3 = Main.maxTilesX;
				int num4 = 0;
				int num5 = Main.maxTilesX;
				int num6 = 0;
				for (int i = 0; i < Main.maxTilesX; i++)
				{
					for (int j = 0; (double)j < num2; j++)
					{
						if (Main.tile[i, j].active())
						{
							if (Main.tile[i, j].type == 60)
							{
								if (i < num3)
								{
									num3 = i;
								}
								if (i > num4)
								{
									num4 = i;
								}
							}
							else if (Main.tile[i, j].type == 147 || Main.tile[i, j].type == 161)
							{
								if (i < num5)
								{
									num5 = i;
								}
								if (i > num6)
								{
									num6 = i;
								}
							}
						}
					}
				}
				int num7 = 10;
				num3 -= num7;
				num4 += num7;
				num5 -= num7;
				num6 += num7;
				int num8 = 500;
				int num9 = 100;
				double num10 = (double)Main.maxTilesX * 0.00045;
				if (remixWorldGen)
				{
					num10 *= 2.0;
				}
				else if (tenthAnniversaryWorldGen && !dontStarveWorldGen)
				{
					num8 *= 2;
					num9 *= 2;
				}
				bool flag = crimson;
				if (drunkWorldGen)
				{
					flag = true;
					num10 /= 2.0;
				}
				if (flag)
				{
					progress.Message = Lang.gen[72].Value;
					for (int k = 0; (double)k < num10; k++)
					{
						int num11 = num5;
						int num12 = num6;
						int num13 = num3;
						int num14 = num4;
						double value = (double)k / num10;
						progress.Set(value);
						bool flag2 = false;
						int num15 = 0;
						int num16 = 0;
						int num17 = 0;
						while (!flag2)
						{
							flag2 = true;
							int num18 = Main.maxTilesX / 2;
							int num19 = 200;
							if (drunkWorldGen)
							{
								num19 = 100;
								num15 = ((!GenVars.crimsonLeft) ? genRand.Next((int)((double)Main.maxTilesX * 0.5), Main.maxTilesX - num8) : genRand.Next(num8, (int)((double)Main.maxTilesX * 0.5)));
							}
							else
							{
								num15 = genRand.Next(num8, Main.maxTilesX - num8);
							}
							num16 = num15 - genRand.Next(200) - 100;
							num17 = num15 + genRand.Next(200) + 100;
							if (num16 < GenVars.evilBiomeBeachAvoidance)
							{
								num16 = GenVars.evilBiomeBeachAvoidance;
							}
							if (num17 > Main.maxTilesX - GenVars.evilBiomeBeachAvoidance)
							{
								num17 = Main.maxTilesX - GenVars.evilBiomeBeachAvoidance;
							}
							if (num15 < num16 + GenVars.evilBiomeAvoidanceMidFixer)
							{
								num15 = num16 + GenVars.evilBiomeAvoidanceMidFixer;
							}
							if (num15 > num17 - GenVars.evilBiomeAvoidanceMidFixer)
							{
								num15 = num17 - GenVars.evilBiomeAvoidanceMidFixer;
							}
							if (GenVars.CurrentDungeonGenVars.dungeonSide <= DungeonSide.Left && num16 < 400)
							{
								num16 = 400;
							}
							else if (GenVars.CurrentDungeonGenVars.dungeonSide >= DungeonSide.Right && num16 > Main.maxTilesX - 400)
							{
								num16 = Main.maxTilesX - 400;
							}
							if (num16 < GenVars.CurrentDungeonGenVars.dungeonLocation + num9 && num17 > GenVars.CurrentDungeonGenVars.dungeonLocation - num9)
							{
								flag2 = false;
							}
							if (!remixWorldGen)
							{
								if (!tenthAnniversaryWorldGen || dontStarveWorldGen)
								{
									if (num15 > num18 - num19 && num15 < num18 + num19)
									{
										flag2 = false;
									}
									if (num16 > num18 - num19 && num16 < num18 + num19)
									{
										flag2 = false;
									}
									if (num17 > num18 - num19 && num17 < num18 + num19)
									{
										flag2 = false;
									}
								}
								if (num15 > GenVars.UndergroundDesertLocation.X && num15 < GenVars.UndergroundDesertLocation.X + GenVars.UndergroundDesertLocation.Width)
								{
									flag2 = false;
								}
								if (num16 > GenVars.UndergroundDesertLocation.X && num16 < GenVars.UndergroundDesertLocation.X + GenVars.UndergroundDesertLocation.Width)
								{
									flag2 = false;
								}
								if (num17 > GenVars.UndergroundDesertLocation.X && num17 < GenVars.UndergroundDesertLocation.X + GenVars.UndergroundDesertLocation.Width)
								{
									flag2 = false;
								}
								if (num16 < num12 && num17 > num11)
								{
									num11++;
									num12--;
									flag2 = false;
								}
								if ((!notTheBees || remixWorldGen) && num16 < num14 && num17 > num13)
								{
									num13++;
									num14--;
									flag2 = false;
								}
							}
						}
						if (!GenVars.flipInfections)
						{
							CrimStart(num15, (int)num - 10);
						}
						int num20 = 0;
						for (int l = num16; l < num17; l++)
						{
							if (GenVars.flipInfections)
							{
								if (num20 > 0)
								{
									num20--;
								}
								if (l == num15 || num20 == 0)
								{
									for (int m = (int)num; (double)m < num2 - 1.0; m++)
									{
										if (Main.tile[l, m].active() || Main.tile[l, m].wall > 0)
										{
											if (l == num15)
											{
												num20 = 20;
												ChasmRunner(l, m, genRand.Next(150) + 150, makeOrb: true);
											}
											else if (genRand.Next(35) == 0 && num20 == 0)
											{
												num20 = 30;
												bool makeOrb = true;
												ChasmRunner(l, m, genRand.Next(50) + 50, makeOrb);
											}
											break;
										}
									}
								}
							}
							for (int n = (int)num; (double)n < num2 - 1.0; n++)
							{
								if (Main.tile[l, n].active())
								{
									int num21 = n + genRand.Next(10, 14);
									for (int num22 = n; num22 < num21; num22++)
									{
										if (Main.tile[l, num22].active() && Main.tile[l, num22].type == 60 && l >= num16 + genRand.Next(5) && l < num17 - genRand.Next(5))
										{
											Main.tile[l, num22].type = 662;
										}
									}
									break;
								}
							}
						}
						double num23 = num2 + 40.0;
						for (int num24 = num16; num24 < num17; num24++)
						{
							num23 += (double)genRand.Next(-2, 3);
							if (num23 < num2 + 30.0)
							{
								num23 = num2 + 30.0;
							}
							if (num23 > num2 + 50.0)
							{
								num23 = num2 + 50.0;
							}
							bool flag3 = false;
							double num25 = num;
							if (SecretSeed.surfaceIsInSpace.Enabled)
							{
								num25 = 0.0;
							}
							for (int num26 = (int)num25; (double)num26 < num23; num26++)
							{
								if (((num24 > num16 + 1 && num24 < num17 - 2) || genRand.Next(2) != 0) && ((!((double)num26 <= num25 + 1.0) && !((double)num26 >= num23 - 2.0)) || genRand.Next(2) != 0))
								{
									if (SecretSeed.noSurface.Enabled)
									{
										if (Main.tile[num24, num26].wall == 216)
										{
											Main.tile[num24, num26].wall = 218;
										}
										else if (Main.tile[num24, num26].wall == 187)
										{
											Main.tile[num24, num26].wall = 221;
										}
									}
									if (Main.tile[num24, num26].active())
									{
										if (Main.tile[num24, num26].type == 53 && num24 >= num16 + genRand.Next(5) && num24 <= num17 - genRand.Next(5))
										{
											Main.tile[num24, num26].type = 234;
										}
										if ((double)num26 < num2 - 1.0 && !flag3)
										{
											if (Main.tile[num24, num26].type == 0)
											{
												grassSpread = 0;
												SpreadGrass(num24, num26, 0, 199);
											}
											else if (Main.tile[num24, num26].type == 59)
											{
												grassSpread = 0;
												SpreadGrass(num24, num26, 59, 662);
											}
										}
										flag3 = true;
										if (Main.tile[num24, num26].wall == 216)
										{
											Main.tile[num24, num26].wall = 218;
										}
										else if (Main.tile[num24, num26].wall == 187)
										{
											Main.tile[num24, num26].wall = 221;
										}
										if (Main.tile[num24, num26].type == 1)
										{
											if (num24 >= num16 + genRand.Next(5) && num24 <= num17 - genRand.Next(5))
											{
												Main.tile[num24, num26].type = 203;
											}
										}
										else if (Main.tile[num24, num26].type == 2)
										{
											Main.tile[num24, num26].type = 199;
										}
										else if (Main.tile[num24, num26].type == 60)
										{
											Main.tile[num24, num26].type = 662;
										}
										else if (Main.tile[num24, num26].type == 161)
										{
											Main.tile[num24, num26].type = 200;
										}
										else if (Main.tile[num24, num26].type == 396)
										{
											Main.tile[num24, num26].type = 401;
										}
										else if (Main.tile[num24, num26].type == 397)
										{
											Main.tile[num24, num26].type = 399;
										}
									}
								}
							}
						}
						int num27 = genRand.Next(10, 15);
						for (int num28 = 0; num28 < num27; num28++)
						{
							int num29 = 0;
							bool flag4 = false;
							int num30 = 0;
							while (!flag4)
							{
								num29++;
								int num31 = genRand.Next(num16 - num30, num17 + num30);
								int num32 = genRand.Next((int)(num2 - (double)(num30 / 2)), (int)(num2 + 100.0 + (double)num30));
								while (oceanDepths(num31, num32))
								{
									num31 = genRand.Next(num16 - num30, num17 + num30);
									num32 = genRand.Next((int)(num2 - (double)(num30 / 2)), (int)(num2 + 100.0 + (double)num30));
								}
								if (num29 > 100)
								{
									num30++;
									num29 = 0;
								}
								if (!Main.tile[num31, num32].active())
								{
									for (; !Main.tile[num31, num32].active(); num32++)
									{
									}
									num32--;
								}
								else
								{
									while (Main.tile[num31, num32].active() && (double)num32 > num2)
									{
										num32--;
									}
								}
								if ((num30 > 10 || (Main.tile[num31, num32 + 1].active() && Main.tile[num31, num32 + 1].type == 203)) && !IsTileNearby(num31, num32, 26, 3))
								{
									Place3x2(num31, num32, 26, 1);
									if (Main.tile[num31, num32].type == 26)
									{
										flag4 = true;
									}
								}
								if (num30 > 100)
								{
									flag4 = true;
								}
							}
						}
						if (GenVars.flipInfections)
						{
							for (int num33 = num16; num33 < num17; num33++)
							{
								for (int num34 = 0; num34 < Main.maxTilesY - 50; num34++)
								{
									if (Main.tile[num33, num34].active() && Main.tile[num33, num34].type == 31)
									{
										int num35 = num33 - 13;
										int num36 = num33 + 13;
										int num37 = num34 - 13;
										int num38 = num34 + 13;
										for (int num39 = num35; num39 < num36; num39++)
										{
											if (num39 > 10 && num39 < Main.maxTilesX - 10)
											{
												for (int num40 = num37; num40 < num38; num40++)
												{
													if (Math.Abs(num39 - num33) + Math.Abs(num40 - num34) < 9 + genRand.Next(11) && genRand.Next(3) != 0 && Main.tile[num39, num40].type != 31)
													{
														Main.tile[num39, num40].active(active: true);
														Main.tile[num39, num40].type = 203;
														if (Math.Abs(num39 - num33) <= 1 && Math.Abs(num40 - num34) <= 1)
														{
															Main.tile[num39, num40].active(active: false);
														}
													}
													if (Main.tile[num39, num40].type != 31 && Math.Abs(num39 - num33) <= 2 + genRand.Next(3) && Math.Abs(num40 - num34) <= 2 + genRand.Next(3))
													{
														Main.tile[num39, num40].active(active: false);
													}
												}
											}
										}
									}
								}
							}
						}
					}
					if (!GenVars.flipInfections)
					{
						CrimPlaceHearts();
					}
				}
				if (drunkWorldGen)
				{
					flag = false;
				}
				if (!flag)
				{
					progress.Message = Lang.gen[20].Value;
					for (int num41 = 0; (double)num41 < num10; num41++)
					{
						int num42 = num5;
						int num43 = num6;
						int num44 = num3;
						int num45 = num4;
						double value2 = (double)num41 / num10;
						progress.Set(value2);
						bool flag5 = false;
						int num46 = 0;
						int num47 = 0;
						int num48 = 0;
						while (!flag5)
						{
							flag5 = true;
							int num49 = Main.maxTilesX / 2;
							int num50 = 200;
							num46 = ((!drunkWorldGen) ? genRand.Next(num8, Main.maxTilesX - num8) : (GenVars.crimsonLeft ? genRand.Next((int)((double)Main.maxTilesX * 0.5), Main.maxTilesX - num8) : genRand.Next(num8, (int)((double)Main.maxTilesX * 0.5))));
							num47 = num46 - genRand.Next(200) - 100;
							num48 = num46 + genRand.Next(200) + 100;
							if (num47 < GenVars.evilBiomeBeachAvoidance)
							{
								num47 = GenVars.evilBiomeBeachAvoidance;
							}
							if (num48 > Main.maxTilesX - GenVars.evilBiomeBeachAvoidance)
							{
								num48 = Main.maxTilesX - GenVars.evilBiomeBeachAvoidance;
							}
							if (num46 < num47 + GenVars.evilBiomeAvoidanceMidFixer)
							{
								num46 = num47 + GenVars.evilBiomeAvoidanceMidFixer;
							}
							if (num46 > num48 - GenVars.evilBiomeAvoidanceMidFixer)
							{
								num46 = num48 - GenVars.evilBiomeAvoidanceMidFixer;
							}
							if (num47 < GenVars.CurrentDungeonGenVars.dungeonLocation + num9 && num48 > GenVars.CurrentDungeonGenVars.dungeonLocation - num9)
							{
								flag5 = false;
							}
							if (!remixWorldGen)
							{
								if (!tenthAnniversaryWorldGen || dontStarveWorldGen)
								{
									if (num46 > num49 - num50 && num46 < num49 + num50)
									{
										flag5 = false;
									}
									if (num47 > num49 - num50 && num47 < num49 + num50)
									{
										flag5 = false;
									}
									if (num48 > num49 - num50 && num48 < num49 + num50)
									{
										flag5 = false;
									}
								}
								if (num46 > GenVars.UndergroundDesertLocation.X && num46 < GenVars.UndergroundDesertLocation.X + GenVars.UndergroundDesertLocation.Width)
								{
									flag5 = false;
								}
								if (num47 > GenVars.UndergroundDesertLocation.X && num47 < GenVars.UndergroundDesertLocation.X + GenVars.UndergroundDesertLocation.Width)
								{
									flag5 = false;
								}
								if (num48 > GenVars.UndergroundDesertLocation.X && num48 < GenVars.UndergroundDesertLocation.X + GenVars.UndergroundDesertLocation.Width)
								{
									flag5 = false;
								}
								if (num47 < num43 && num48 > num42)
								{
									num42++;
									num43--;
									flag5 = false;
								}
								if ((!notTheBees || remixWorldGen) && num47 < num45 && num48 > num44)
								{
									num44++;
									num45--;
									flag5 = false;
								}
							}
						}
						int num51 = 0;
						if (GenVars.flipInfections)
						{
							CrimStart(num46, (int)num - 10);
						}
						for (int num52 = num47; num52 < num48; num52++)
						{
							if (!GenVars.flipInfections)
							{
								if (num51 > 0)
								{
									num51--;
								}
								if (num52 == num46 || num51 == 0)
								{
									for (int num53 = (int)num; (double)num53 < num2 - 1.0; num53++)
									{
										if (Main.tile[num52, num53].active() || Main.tile[num52, num53].wall > 0)
										{
											if (num52 == num46)
											{
												num51 = 20;
												ChasmRunner(num52, num53, genRand.Next(150) + 150, makeOrb: true);
											}
											else if (genRand.Next(35) == 0 && num51 == 0)
											{
												num51 = 30;
												bool makeOrb2 = true;
												ChasmRunner(num52, num53, genRand.Next(50) + 50, makeOrb2);
											}
											break;
										}
									}
								}
							}
							for (int num54 = (int)num; (double)num54 < num2 - 1.0; num54++)
							{
								if (Main.tile[num52, num54].active())
								{
									int num55 = num54 + genRand.Next(10, 14);
									for (int num56 = num54; num56 < num55; num56++)
									{
										if (Main.tile[num52, num56].active() && Main.tile[num52, num56].type == 60 && num52 >= num47 + genRand.Next(5) && num52 < num48 - genRand.Next(5))
										{
											Main.tile[num52, num56].type = 661;
										}
									}
									break;
								}
							}
						}
						double num57 = num2 + 40.0;
						for (int num58 = num47; num58 < num48; num58++)
						{
							num57 += (double)genRand.Next(-2, 3);
							if (num57 < num2 + 30.0)
							{
								num57 = num2 + 30.0;
							}
							if (num57 > num2 + 50.0)
							{
								num57 = num2 + 50.0;
							}
							bool flag6 = false;
							double num59 = num;
							if (SecretSeed.surfaceIsInSpace.Enabled)
							{
								num59 = 0.0;
							}
							for (int num60 = (int)num59; (double)num60 < num57; num60++)
							{
								if (((num58 > num47 + 1 && num58 < num48 - 2) || genRand.Next(2) != 0) && ((!((double)num60 <= num59 + 1.0) && !((double)num60 >= num57 - 2.0)) || genRand.Next(2) != 0))
								{
									if (SecretSeed.noSurface.Enabled)
									{
										if (Main.tile[num58, num60].wall == 216)
										{
											Main.tile[num58, num60].wall = 217;
										}
										else if (Main.tile[num58, num60].wall == 187)
										{
											Main.tile[num58, num60].wall = 220;
										}
									}
									if (Main.tile[num58, num60].active())
									{
										if (Main.tile[num58, num60].type == 53 && num58 >= num47 + genRand.Next(5) && num58 <= num48 - genRand.Next(5))
										{
											Main.tile[num58, num60].type = 112;
										}
										if ((double)num60 < num2 - 1.0 && !flag6)
										{
											if (Main.tile[num58, num60].type == 0)
											{
												grassSpread = 0;
												SpreadGrass(num58, num60, 0, 23);
											}
											else if (Main.tile[num58, num60].type == 59)
											{
												grassSpread = 0;
												SpreadGrass(num58, num60, 59, 661);
											}
										}
										flag6 = true;
										if (Main.tile[num58, num60].wall == 216)
										{
											Main.tile[num58, num60].wall = 217;
										}
										else if (Main.tile[num58, num60].wall == 187)
										{
											Main.tile[num58, num60].wall = 220;
										}
										if (Main.tile[num58, num60].type == 1)
										{
											if (num58 >= num47 + genRand.Next(5) && num58 <= num48 - genRand.Next(5))
											{
												Main.tile[num58, num60].type = 25;
											}
										}
										else if (Main.tile[num58, num60].type == 2)
										{
											Main.tile[num58, num60].type = 23;
										}
										else if (Main.tile[num58, num60].type == 60)
										{
											Main.tile[num58, num60].type = 661;
										}
										else if (Main.tile[num58, num60].type == 161)
										{
											Main.tile[num58, num60].type = 163;
										}
										else if (Main.tile[num58, num60].type == 396)
										{
											Main.tile[num58, num60].type = 400;
										}
										else if (Main.tile[num58, num60].type == 397)
										{
											Main.tile[num58, num60].type = 398;
										}
									}
								}
							}
						}
						if (GenVars.flipInfections)
						{
							CrimPlaceHearts();
						}
						else
						{
							for (int num61 = num47; num61 < num48; num61++)
							{
								for (int num62 = 0; num62 < Main.maxTilesY - 50; num62++)
								{
									if (Main.tile[num61, num62].active() && Main.tile[num61, num62].type == 31)
									{
										int num63 = num61 - 13;
										int num64 = num61 + 13;
										int num65 = num62 - 13;
										int num66 = num62 + 13;
										for (int num67 = num63; num67 < num64; num67++)
										{
											if (num67 > 10 && num67 < Main.maxTilesX - 10)
											{
												for (int num68 = num65; num68 < num66; num68++)
												{
													if (Math.Abs(num67 - num61) + Math.Abs(num68 - num62) < 9 + genRand.Next(11) && genRand.Next(3) != 0 && Main.tile[num67, num68].type != 31)
													{
														Main.tile[num67, num68].active(active: true);
														Main.tile[num67, num68].type = 25;
														if (Math.Abs(num67 - num61) <= 1 && Math.Abs(num68 - num62) <= 1)
														{
															Main.tile[num67, num68].active(active: false);
														}
													}
													if (Main.tile[num67, num68].type != 31 && Math.Abs(num67 - num61) <= 2 + genRand.Next(3) && Math.Abs(num68 - num62) <= 2 + genRand.Next(3))
													{
														Main.tile[num67, num68].active(active: false);
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.Lakes, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration && !SecretSeed.noSurface.Enabled)
			{
				progress.Message = Lang.gen[19].Value;
				double num = (double)Main.maxTilesX / 4200.0;
				int num2 = genRand.Next((int)(num * 3.0), (int)(num * 6.0));
				for (int i = 0; i < num2; i++)
				{
					int num3 = Main.maxTilesX / 4;
					if (GenVars.numLakes >= GenVars.maxLakes - 1)
					{
						break;
					}
					double value = (double)i / (double)num2;
					progress.Set(value);
					while (num3 > 0)
					{
						bool flag = false;
						num3--;
						int num4 = genRand.Next(GenVars.lakesBeachAvoidance, Main.maxTilesX - GenVars.lakesBeachAvoidance);
						if (tenthAnniversaryWorldGen && !remixWorldGen)
						{
							num4 = genRand.Next((int)((double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.85));
							while (dontStarveWorldGen && (double)num4 > (double)Main.maxTilesX * 0.45 && (double)num4 < (double)Main.maxTilesX * 0.55)
							{
								num4 = genRand.Next((int)((double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.85));
							}
						}
						else
						{
							while ((double)num4 > (double)Main.maxTilesX * 0.45 && (double)num4 < (double)Main.maxTilesX * 0.55)
							{
								num4 = genRand.Next(GenVars.lakesBeachAvoidance, Main.maxTilesX - GenVars.lakesBeachAvoidance);
							}
						}
						for (int j = 0; j < GenVars.numLakes; j++)
						{
							if (Math.Abs(num4 - GenVars.LakeX[j]) < 150)
							{
								flag = true;
								break;
							}
						}
						for (int k = 0; k < GenVars.numMCaves; k++)
						{
							if (Math.Abs(num4 - GenVars.mCaveX[k]) < 100)
							{
								flag = true;
								break;
							}
						}
						for (int l = 0; l < GenVars.numTunnels; l++)
						{
							if (Math.Abs(num4 - GenVars.tunnelX[l]) < 100)
							{
								flag = true;
								break;
							}
						}
						if (!flag)
						{
							int num5 = (int)GenVars.worldSurfaceLow - 20;
							while (!Main.tile[num4, num5].active())
							{
								num5++;
								if ((double)num5 >= Main.worldSurface || Main.tile[num4, num5].wall > 0)
								{
									flag = true;
									break;
								}
							}
							if (Main.tile[num4, num5].type == 53)
							{
								flag = true;
							}
							if (!flag)
							{
								int num6 = 50;
								for (int m = num4 - num6; m <= num4 + num6; m++)
								{
									for (int n = num5 - num6; n <= num5 + num6; n++)
									{
										if (Main.tile[m, n].type == 203 || Main.tile[m, n].type == 25)
										{
											flag = true;
											break;
										}
									}
								}
								if (!flag)
								{
									int num7 = num5;
									num6 = 20;
									while (!SolidTile(num4 - num6, num5) || !SolidTile(num4 + num6, num5))
									{
										num5++;
										if ((double)num5 > Main.worldSurface - 50.0)
										{
											flag = true;
										}
									}
									if (num5 - num7 <= 10)
									{
										num6 = 60;
										for (int num8 = num4 - num6; num8 <= num4 + num6; num8++)
										{
											int num9 = num5 - 20;
											if (Main.tile[num8, num9].active() || Main.tile[num8, num9].wall > 0)
											{
												flag = true;
											}
										}
										if (!flag)
										{
											int num10 = 0;
											for (int num11 = num4 - num6; num11 <= num4 + num6; num11++)
											{
												for (int num12 = num5; num12 <= num5 + num6 * 2; num12++)
												{
													if (SolidTile(num11, num12))
													{
														num10++;
													}
												}
											}
											int num13 = (num6 * 2 + 1) * (num6 * 2 + 1);
											if (!((double)num10 < (double)num13 * 0.8) && !GenVars.UndergroundDesertLocation.Intersects(new Rectangle(num4 - 8, num5 - 8, 16, 16)))
											{
												SonOfLakinater(num4, num5);
												GenVars.LakeX[GenVars.numLakes] = num4;
												GenVars.numLakes++;
												break;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.StoneToIceAndSiltPlusMudIntoSlush, delegate
		{
			if (!Skyblock.denyAllGeneration)
			{
				for (int i = GenVars.snowTop; i < GenVars.snowBottom; i++)
				{
					for (int j = GenVars.snowMinX[i]; j < GenVars.snowMaxX[i]; j++)
					{
						switch (Main.tile[j, i].type)
						{
						case 123:
							if (SecretSeed.surfaceIsDesert.Enabled && SecretSeed.noSurface.Enabled)
							{
								Main.tile[j, i].type = 53;
							}
							else
							{
								Main.tile[j, i].type = 224;
							}
							break;
						case 59:
						{
							bool flag = true;
							int num = 3;
							for (int k = j - num; k <= j + num; k++)
							{
								for (int l = i - num; l <= i + num; l++)
								{
									if (Main.tile[k, l].active() && (Main.tile[k, l].type == 60 || Main.tile[k, l].type == 70 || Main.tile[k, l].type == 71 || Main.tile[k, l].type == 72))
									{
										flag = false;
										break;
									}
								}
							}
							if (flag)
							{
								if (SecretSeed.surfaceIsDesert.Enabled && SecretSeed.noSurface.Enabled)
								{
									Main.tile[j, i].type = 53;
								}
								else
								{
									Main.tile[j, i].type = 224;
								}
							}
							break;
						}
						case 1:
							Main.tile[j, i].type = 161;
							break;
						}
					}
				}
			}
		});
		if (!Skyblock.denyAllGeneration && SecretSeed.dualDungeons.Enabled)
		{
			AddGenerationPass(new DitherSnakePass(GenPassNameID.DualDungeonsDitherSnake));
		}
		AddGenerationPass(GenPassNameID.Dungeon, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Set(0.0);
				for (int i = 0; i < GenVars.dungeonGenVars.Count; i++)
				{
					DungeonCrawler.SetupDungeonData(i, i == 0);
					DungeonCrawler.SetupDungeonDataVariables(i, genRand);
				}
				GenVars.CurrentDungeon = 0;
				int dungeonLocation = GenVars.CurrentDungeonGenVars.dungeonLocation;
				int num = (int)((Main.worldSurface + Main.rockLayer) / 2.0) + genRand.Next(-200, 200);
				int num2 = (int)((Main.worldSurface + Main.rockLayer) / 2.0) + 200;
				int j = num;
				bool flag = false;
				for (int k = 0; k < 10; k++)
				{
					if (SolidTile(dungeonLocation, j + k))
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					for (; j < num2 && !SolidTile(dungeonLocation, j + 10); j++)
					{
					}
				}
				if (flag)
				{
					int num3 = 60;
					int num4 = 0;
					while (SolidTile(dungeonLocation, j - num4))
					{
						num4++;
						if (num4 == num3)
						{
							break;
						}
					}
					if (num4 < num3)
					{
						j += num3 - num4;
					}
				}
				if (drunkWorldGen && !SecretSeed.noSurface.Enabled)
				{
					j = (int)Main.worldSurface + 70;
				}
				if (SecretSeed.surfaceIsDesert.Enabled)
				{
					DungeonDesertCleanup(dungeonLocation);
				}
				DungeonCrawler.MakeDungeon(dungeonLocation, j, progress);
				if (DungeonCrawler.dungeonData.Count > 1)
				{
					for (int l = 1; l < DungeonCrawler.dungeonData.Count; l++)
					{
						GenVars.CurrentDungeon = l;
						dungeonLocation = GenVars.CurrentDungeonGenVars.dungeonLocation;
						int num5 = (int)((Main.worldSurface + Main.rockLayer) / 2.0) + genRand.Next(-200, 200);
						num2 = (int)((Main.worldSurface + Main.rockLayer) / 2.0) + 200;
						j = num5;
						flag = false;
						for (int m = 0; m < 10; m++)
						{
							if (SolidTile(dungeonLocation, j + m))
							{
								flag = true;
								break;
							}
						}
						if (!flag)
						{
							for (; j < num2 && !SolidTile(dungeonLocation, j + 10); j++)
							{
							}
						}
						if (flag)
						{
							int num6 = 60;
							int num7 = 0;
							while (SolidTile(dungeonLocation, j - num7))
							{
								num7++;
								if (num7 == num6)
								{
									break;
								}
							}
							if (num7 < num6)
							{
								j += num6 - num7;
							}
						}
						if (drunkWorldGen && !SecretSeed.noSurface.Enabled)
						{
							j = (int)Main.worldSurface + 70;
						}
						if (SecretSeed.surfaceIsDesert.Enabled)
						{
							DungeonDesertCleanup(dungeonLocation);
						}
						DungeonCrawler.MakeDungeon(dungeonLocation, j, progress);
					}
					GenVars.CurrentDungeon = 0;
				}
				DungeonCrawler.dungeonData.Clear();
				if (dontStarveWorldGen && !tenthAnniversaryWorldGen && !remixWorldGen)
				{
					LavaLayerCaverer();
				}
			}
		});
		AddGenerationPass(GenPassNameID.MountainCaveOpenings, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[21].Value;
				for (int i = 0; i < GenVars.numMCaves; i++)
				{
					progress.Set((float)i / (float)GenVars.numMCaves);
					int i2 = GenVars.mCaveX[i];
					int j = GenVars.mCaveY[i];
					CaveOpenater(i2, j);
					Cavinator(i2, j, genRand.Next(40, 50));
				}
			}
		});
		AddGenerationPass(GenPassNameID.BeachesAndOceanCleanup, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				if (SecretSeed.pooEverywhere.Enabled)
				{
					SecretSeed.DoPooEverywhere();
				}
				if (!SecretSeed.noSurface.Enabled)
				{
					int num = 50;
					progress.Message = Lang.gen[22].Value;
					bool floridaStyle = false;
					bool floridaStyle2 = false;
					if (genRand.Next(4) == 0)
					{
						if (genRand.Next(2) == 0)
						{
							floridaStyle = true;
						}
						else
						{
							floridaStyle2 = true;
						}
					}
					for (int i = 0; i < 2; i++)
					{
						int num2 = 0;
						int num3 = 0;
						if (i == 0)
						{
							progress.Set(0.0);
							num2 = 0;
							num3 = genRand.Next(GenVars.oceanWaterStartRandomMin, GenVars.oceanWaterStartRandomMax);
							if (GenVars.CurrentDungeonGenVars.dungeonSide >= DungeonSide.Right)
							{
								num3 = GenVars.oceanWaterForcedJungleLength;
							}
							int num4 = GenVars.leftBeachEnd - num;
							if (num3 > num4)
							{
								num3 = num4;
							}
							int num5 = 0;
							double num6 = 1.0;
							int j;
							for (j = 0; !Main.tile[num3 - 1, j].active(); j++)
							{
							}
							GenVars.shellStartYLeft = j;
							j += genRand.Next(1, 5);
							int num7 = num3 - 1;
							for (int num8 = num7; num8 >= num2; num8--)
							{
								progress.Set((float)(num8 - num7) / (float)(num2 - num7), 0.0, 0.5);
								if (num8 > 30)
								{
									num5++;
									num6 = TuneOceanDepth(num5, num6, floridaStyle);
								}
								else
								{
									num6 += 1.0;
								}
								int num9 = genRand.Next(15, 20);
								for (int k = 0; (double)k < (double)j + num6 + (double)num9; k++)
								{
									if ((double)k < (double)j + num6 * 0.75 - 3.0)
									{
										Main.tile[num8, k].active(active: false);
										if (k > j)
										{
											Main.tile[num8, k].liquid = byte.MaxValue;
											Main.tile[num8, k].liquidType(0);
										}
										else if (k == j)
										{
											Main.tile[num8, k].liquid = 127;
											if (GenVars.shellStartXLeft == 0)
											{
												GenVars.shellStartXLeft = num8;
											}
										}
									}
									else if (k > j)
									{
										Main.tile[num8, k].type = 53;
										Main.tile[num8, k].active(active: true);
									}
									Main.tile[num8, k].wall = 0;
								}
							}
						}
						else
						{
							progress.Set(0.5);
							num2 = Main.maxTilesX - genRand.Next(GenVars.oceanWaterStartRandomMin, GenVars.oceanWaterStartRandomMax);
							num3 = Main.maxTilesX;
							if (GenVars.CurrentDungeonGenVars.dungeonSide <= DungeonSide.Left)
							{
								num2 = Main.maxTilesX - GenVars.oceanWaterForcedJungleLength;
							}
							int num10 = GenVars.rightBeachStart + num;
							if (num2 < num10)
							{
								num2 = num10;
							}
							double num11 = 1.0;
							int num12 = 0;
							int l;
							for (l = 0; !Main.tile[num2, l].active(); l++)
							{
							}
							GenVars.shellStartXRight = 0;
							GenVars.shellStartYRight = l;
							l += genRand.Next(1, 5);
							int num13 = num2;
							for (int m = num2; m < num3; m++)
							{
								progress.Set((float)(m - num13) / (float)(num3 - num13), 0.5, 1.0);
								if (m < num3 - 30)
								{
									num12++;
									num11 = TuneOceanDepth(num12, num11, floridaStyle2);
								}
								else
								{
									num11 += 1.0;
								}
								int num14 = genRand.Next(15, 20);
								for (int n = 0; (double)n < (double)l + num11 + (double)num14; n++)
								{
									if ((double)n < (double)l + num11 * 0.75 - 3.0)
									{
										Main.tile[m, n].active(active: false);
										if (n > l)
										{
											Main.tile[m, n].liquid = byte.MaxValue;
											Main.tile[m, n].liquidType(0);
										}
										else if (n == l)
										{
											Main.tile[m, n].liquid = 127;
											if (GenVars.shellStartXRight == 0)
											{
												GenVars.shellStartXRight = m;
											}
										}
									}
									else if (n > l)
									{
										Main.tile[m, n].type = 53;
										Main.tile[m, n].active(active: true);
									}
									Main.tile[m, n].wall = 0;
								}
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.Gems, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[23].Value;
				Main.tileSolid[484] = false;
				for (int i = 63; i <= 68; i++)
				{
					double value = (double)(i - 63) / 6.0;
					progress.Set(value);
					double num = 0.0;
					switch (i)
					{
					case 67:
						num = (double)Main.maxTilesX * 0.5;
						break;
					case 66:
						num = (double)Main.maxTilesX * 0.45;
						break;
					case 63:
						num = (double)Main.maxTilesX * 0.3;
						break;
					case 65:
						num = (double)Main.maxTilesX * 0.25;
						break;
					case 64:
						num = (double)Main.maxTilesX * 0.1;
						break;
					case 68:
						num = (double)Main.maxTilesX * 0.05;
						break;
					}
					num *= 0.2;
					for (int j = 0; (double)j < num; j++)
					{
						int num2 = 3;
						int num3;
						int num4;
						do
						{
							num3 = genRand.Next(0, Main.maxTilesX);
							num4 = genRand.Next((int)Main.worldSurface, Main.maxTilesY);
						}
						while ((!Main.tile[num3, num4].active() || Main.tile[num3, num4].type != 1) && --num2 > 0);
						if (num2 != 0)
						{
							TileRunner(num3, num4, genRand.Next(2, 6), genRand.Next(3, 7), i);
						}
					}
				}
				for (int k = 0; k < 2; k++)
				{
					int num5 = 1;
					int num6 = 5;
					int num7 = Main.maxTilesX - 5;
					if (k == 1)
					{
						num5 = -1;
						num6 = Main.maxTilesX - 5;
						num7 = 5;
					}
					for (int l = num6; l != num7; l += num5)
					{
						if (l <= GenVars.UndergroundDesertLocation.Left || l >= GenVars.UndergroundDesertLocation.Right)
						{
							for (int m = 10; m < Main.maxTilesY - 10; m++)
							{
								if (Main.tile[l, m].active() && Main.tile[l, m + 1].active() && Main.tileSand[Main.tile[l, m].type] && Main.tileSand[Main.tile[l, m + 1].type])
								{
									ushort type = Main.tile[l, m].type;
									int num8 = l + num5;
									int n = m + 1;
									if (!Main.tile[num8, m].active() && !Main.tile[num8, n].active())
									{
										for (; !Main.tile[num8, n].active() && InWorld(num8, n, 10); n++)
										{
										}
										n--;
										Main.tile[l, m].active(active: false);
										Main.tile[num8, n].active(active: true);
										Main.tile[num8, n].type = type;
									}
								}
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.GravitatingSandCleanup, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration && !SecretSeed.roundLandmasses.Enabled)
			{
				progress.Message = Lang.gen[24].Value;
				for (int i = 0; i < Main.maxTilesX; i++)
				{
					double value = (double)i / (double)(Main.maxTilesX - 1);
					progress.Set(value);
					bool flag = false;
					int num = 0;
					for (int num2 = Main.maxTilesY - 1; num2 > 0; num2--)
					{
						if (SolidOrSlopedTile(i, num2))
						{
							ushort type = Main.tile[i, num2].type;
							if (flag && num2 < (int)Main.worldSurface && num2 != num - 1 && TileID.Sets.Falling[type])
							{
								for (int j = num2; j < num; j++)
								{
									Main.tile[i, j].ResetToType(type);
								}
							}
							flag = true;
							num = num2;
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.OceanCaves, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration && !SecretSeed.roundLandmasses.Enabled && !SecretSeed.noSurface.Enabled)
			{
				int maxValue = 3;
				if (remixWorldGen)
				{
					maxValue = 2;
				}
				for (int i = 0; i < 2; i++)
				{
					if ((i != 0 || GenVars.CurrentDungeonGenVars.dungeonSide < DungeonSide.Right) && (i != 1 || GenVars.CurrentDungeonGenVars.dungeonSide > DungeonSide.Left) && (genRand.Next(maxValue) == 0 || drunkWorldGen || tenthAnniversaryWorldGen))
					{
						progress.Message = Lang.gen[90].Value;
						int num = genRand.Next(55, 95);
						if (i == 1)
						{
							num = genRand.Next(Main.maxTilesX - 95, Main.maxTilesX - 55);
						}
						int j;
						for (j = 0; !Main.tile[num, j].active(); j++)
						{
						}
						oceanCave(num, j);
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.Shimmer, delegate
		{
			if (!Skyblock.denyAllGeneration)
			{
				int num = 50;
				int num2 = (int)(Main.worldSurface + Main.rockLayer) / 2 + num;
				int num3 = (int)((double)((Main.maxTilesY - 250) * 2) + Main.rockLayer) / 3;
				if (num3 > Main.maxTilesY - 330 - 100 - 30)
				{
					num3 = Main.maxTilesY - 330 - 100 - 30;
				}
				if (num3 <= num2)
				{
					num3 = num2 + 50;
				}
				int num4 = genRand.Next(num2, num3);
				int num5 = ((GenVars.CurrentDungeonGenVars.dungeonSide < DungeonSide.Right) ? genRand.Next((int)((double)Main.maxTilesX * 0.89), Main.maxTilesX - 200) : genRand.Next(200, (int)((double)Main.maxTilesX * 0.11)));
				int num6 = (int)Main.worldSurface + 150;
				int num7 = (int)(Main.rockLayer + Main.worldSurface + 200.0) / 2;
				if (num7 <= num6)
				{
					num7 = num6 + 50;
				}
				if (tenthAnniversaryWorldGen)
				{
					num4 = genRand.Next(num6, num7);
				}
				int num8 = 0;
				while (!ShimmerMakeBiome(num5, num4))
				{
					num8++;
					if (tenthAnniversaryWorldGen && num8 < 10000)
					{
						num4 = genRand.Next(num6, num7);
						num5 = ((GenVars.CurrentDungeonGenVars.dungeonSide < DungeonSide.Right) ? genRand.Next((int)((double)Main.maxTilesX * 0.89), Main.maxTilesX - 200) : genRand.Next(200, (int)((double)Main.maxTilesX * 0.11)));
					}
					else if (num8 > 20000)
					{
						num4 = genRand.Next((int)Main.worldSurface + 100 + 20, num3);
						num5 = ((GenVars.CurrentDungeonGenVars.dungeonSide < DungeonSide.Right) ? genRand.Next((int)((double)Main.maxTilesX * 0.8), Main.maxTilesX - 200) : genRand.Next(200, (int)((double)Main.maxTilesX * 0.2)));
					}
					else
					{
						num4 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2 + 20, num3);
						num5 = ((GenVars.CurrentDungeonGenVars.dungeonSide < DungeonSide.Right) ? genRand.Next((int)((double)Main.maxTilesX * 0.89), Main.maxTilesX - 200) : genRand.Next(200, (int)((double)Main.maxTilesX * 0.11)));
					}
				}
				GenVars.shimmerPosition = new Vector2D(num5, num4);
				int num9 = 200;
				GenVars.structures.AddProtectedStructure(new Rectangle(num5 - num9 / 2, num4 - num9 / 2, num9, num9));
			}
		});
		AddGenerationPass(GenPassNameID.DirtWallCleanup, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				if (SecretSeed.noSurface.Enabled)
				{
					SecretSeed.DoNoSurfaceFillTheTop();
				}
				else
				{
					progress.Message = Lang.gen[25].Value;
					for (int i = 3; i < Main.maxTilesX - 3; i++)
					{
						double num = (double)i / (double)Main.maxTilesX;
						progress.Set(0.5 * num);
						bool flag = true;
						for (int j = 0; (double)j < Main.worldSurface; j++)
						{
							if (flag)
							{
								if (Main.tile[i, j].wall == 2 || Main.tile[i, j].wall == 40 || Main.tile[i, j].wall == 64 || Main.tile[i, j].wall == 86)
								{
									Main.tile[i, j].wall = 0;
								}
								if (!Main.tile[i, j].active() || (Main.tile[i, j].type != 53 && Main.tile[i, j].type != 112 && Main.tile[i, j].type != 234))
								{
									if (Main.tile[i - 1, j].wall == 2 || Main.tile[i - 1, j].wall == 40 || Main.tile[i - 1, j].wall == 40)
									{
										Main.tile[i - 1, j].wall = 0;
									}
									if ((Main.tile[i - 2, j].wall == 2 || Main.tile[i - 2, j].wall == 40 || Main.tile[i - 2, j].wall == 40) && genRand.Next(2) == 0)
									{
										Main.tile[i - 2, j].wall = 0;
									}
									if ((Main.tile[i - 3, j].wall == 2 || Main.tile[i - 3, j].wall == 40 || Main.tile[i - 3, j].wall == 40) && genRand.Next(2) == 0)
									{
										Main.tile[i - 3, j].wall = 0;
									}
									if (Main.tile[i + 1, j].wall == 2 || Main.tile[i + 1, j].wall == 40 || Main.tile[i + 1, j].wall == 40)
									{
										Main.tile[i + 1, j].wall = 0;
									}
									if ((Main.tile[i + 2, j].wall == 2 || Main.tile[i + 2, j].wall == 40 || Main.tile[i + 2, j].wall == 40) && genRand.Next(2) == 0)
									{
										Main.tile[i + 2, j].wall = 0;
									}
									if ((Main.tile[i + 3, j].wall == 2 || Main.tile[i + 3, j].wall == 40 || Main.tile[i + 3, j].wall == 40) && genRand.Next(2) == 0)
									{
										Main.tile[i + 3, j].wall = 0;
									}
									if (Main.tile[i, j].active())
									{
										flag = false;
									}
								}
							}
							else if (Main.tile[i, j].wall == 0 && Main.tile[i, j + 1].wall == 0 && Main.tile[i, j + 2].wall == 0 && Main.tile[i, j + 3].wall == 0 && Main.tile[i, j + 4].wall == 0 && Main.tile[i - 1, j].wall == 0 && Main.tile[i + 1, j].wall == 0 && Main.tile[i - 2, j].wall == 0 && Main.tile[i + 2, j].wall == 0 && !Main.tile[i, j].active() && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 2].active() && !Main.tile[i, j + 3].active())
							{
								flag = true;
							}
						}
					}
					for (int num2 = Main.maxTilesX - 5; num2 >= 5; num2--)
					{
						double num3 = (double)num2 / (double)Main.maxTilesX;
						progress.Set(1.0 - 0.5 * num3);
						bool flag2 = true;
						for (int k = 0; (double)k < Main.worldSurface; k++)
						{
							if (flag2)
							{
								if (Main.tile[num2, k].wall == 2 || Main.tile[num2, k].wall == 40 || Main.tile[num2, k].wall == 64)
								{
									Main.tile[num2, k].wall = 0;
								}
								if (!Main.tile[num2, k].active() || Main.tile[num2, k].type != 53)
								{
									if (Main.tile[num2 - 1, k].wall == 2 || Main.tile[num2 - 1, k].wall == 40 || Main.tile[num2 - 1, k].wall == 40)
									{
										Main.tile[num2 - 1, k].wall = 0;
									}
									if ((Main.tile[num2 - 2, k].wall == 2 || Main.tile[num2 - 2, k].wall == 40 || Main.tile[num2 - 2, k].wall == 40) && genRand.Next(2) == 0)
									{
										Main.tile[num2 - 2, k].wall = 0;
									}
									if ((Main.tile[num2 - 3, k].wall == 2 || Main.tile[num2 - 3, k].wall == 40 || Main.tile[num2 - 3, k].wall == 40) && genRand.Next(2) == 0)
									{
										Main.tile[num2 - 3, k].wall = 0;
									}
									if (Main.tile[num2 + 1, k].wall == 2 || Main.tile[num2 + 1, k].wall == 40 || Main.tile[num2 + 1, k].wall == 40)
									{
										Main.tile[num2 + 1, k].wall = 0;
									}
									if ((Main.tile[num2 + 2, k].wall == 2 || Main.tile[num2 + 2, k].wall == 40 || Main.tile[num2 + 2, k].wall == 40) && genRand.Next(2) == 0)
									{
										Main.tile[num2 + 2, k].wall = 0;
									}
									if ((Main.tile[num2 + 3, k].wall == 2 || Main.tile[num2 + 3, k].wall == 40 || Main.tile[num2 + 3, k].wall == 40) && genRand.Next(2) == 0)
									{
										Main.tile[num2 + 3, k].wall = 0;
									}
									if (Main.tile[num2, k].active())
									{
										flag2 = false;
									}
								}
							}
							else if (Main.tile[num2, k].wall == 0 && Main.tile[num2, k + 1].wall == 0 && Main.tile[num2, k + 2].wall == 0 && Main.tile[num2, k + 3].wall == 0 && Main.tile[num2, k + 4].wall == 0 && Main.tile[num2 - 1, k].wall == 0 && Main.tile[num2 + 1, k].wall == 0 && Main.tile[num2 - 2, k].wall == 0 && Main.tile[num2 + 2, k].wall == 0 && !Main.tile[num2, k].active() && !Main.tile[num2, k + 1].active() && !Main.tile[num2, k + 2].active() && !Main.tile[num2, k + 3].active())
							{
								flag2 = true;
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.Pyramids, delegate
		{
			if (!Skyblock.denyAllGeneration && !SecretSeed.Variations.noSurfaceNoPyramids)
			{
				Rectangle undergroundDesertLocation = GenVars.UndergroundDesertLocation;
				if (Main.tenthAnniversaryWorld && !SecretSeed.dualDungeons.Enabled)
				{
					int x = undergroundDesertLocation.Center.X;
					int j = undergroundDesertLocation.Top - 10;
					Pyramid(x, j);
				}
				for (int i = 0; i < GenVars.numPyr; i++)
				{
					int num = GenVars.PyrX[i];
					int k = GenVars.PyrY[i];
					int pyramidMinDepth = 75;
					int num2 = 125;
					bool noTunnel = false;
					if (SecretSeed.dualDungeons.Enabled)
					{
						noTunnel = true;
					}
					if (num > 300 && num < Main.maxTilesX - 300 && (GenVars.CurrentDungeonGenVars.dungeonSide > DungeonSide.Left || !((double)num < (double)GenVars.CurrentDungeonGenVars.generatingDungeonPositionX + (double)Main.maxTilesX * 0.15)) && (GenVars.CurrentDungeonGenVars.dungeonSide < DungeonSide.Right || !((double)num > (double)GenVars.CurrentDungeonGenVars.generatingDungeonPositionX - (double)Main.maxTilesX * 0.15)) && (!Main.tenthAnniversaryWorld || SecretSeed.dualDungeons.Enabled || !undergroundDesertLocation.Contains(num, k)))
					{
						for (; !Main.tile[num, k].active() && (double)k < Main.worldSurface; k++)
						{
						}
						if (!((double)k >= Main.worldSurface) && Main.tile[num, k].type == 53)
						{
							int num3 = Main.maxTilesX;
							for (int l = 0; l < i; l++)
							{
								int num4 = Math.Abs(num - GenVars.PyrX[l]);
								if (num4 < num3)
								{
									num3 = num4;
								}
							}
							int num5 = 220;
							if (drunkWorldGen)
							{
								num5 /= 2;
							}
							if (num3 >= num5)
							{
								k--;
								if (SecretSeed.dualDungeons.Enabled)
								{
									if (DungeonUtils.InAnyPotentialDungeonBounds(num, k + num2, 5))
									{
										k -= 50;
										num2 = 100;
									}
									if (SecretSeed.dualDungeons.Enabled && DungeonUtils.InAnyPotentialDungeonBounds(num, k + num2, 5))
									{
										continue;
									}
								}
								Pyramid(num, k, pyramidMinDepth, num2, noTunnel);
							}
						}
					}
				}
				if (SecretSeed.surfaceIsDesert.Enabled)
				{
					int num6 = genRand.Next(5, 8);
					num6 *= Main.maxTilesX / 4200;
					for (int m = 0; m < num6; m++)
					{
						int num7 = genRand.Next(300, Main.maxTilesX - 300);
						while ((double)num7 > (double)Main.maxTilesX * 0.47 && (double)num7 < (double)Main.maxTilesX * 0.53)
						{
							num7 = genRand.Next(300, Main.maxTilesX - 300);
						}
						int n;
						for (n = FindLowestCloud(); !Main.tile[num7, n].active() && (double)n < Main.worldSurface; n++)
						{
						}
						if (!((double)n >= Main.worldSurface) && Main.tile[num7, n].type == 53)
						{
							n--;
							Pyramid(num7, n);
						}
					}
				}
				if (SecretSeed.errorWorld.Enabled)
				{
					int num8 = genRand.Next(5, 8);
					num8 *= Main.maxTilesX / 4200;
					num8 /= SecretSeed.Variations.errorWorldAdjustment(1.0);
					for (int num9 = 0; num9 < num8; num9++)
					{
						int num10 = genRand.Next(300, Main.maxTilesX - 300);
						int num11 = genRand.Next(FindLowestCloud(), (int)Main.rockLayer);
						while (((double)num10 > (double)Main.maxTilesX * 0.47 && (double)num10 < (double)Main.maxTilesX * 0.53) || Vector2D.Distance(new Vector2D(num10, num11), GenVars.shimmerPosition) < 300.0)
						{
							num10 = genRand.Next(300, Main.maxTilesX - 300);
							num11 = genRand.Next(FindLowestCloud(), (int)Main.rockLayer);
						}
						for (; !Main.tile[num10, num11].active(); num11++)
						{
						}
						num11--;
						Pyramid(num10, num11);
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.DirtRockWallRunner, delegate
		{
			if (!Skyblock.denyAllGeneration)
			{
				for (int i = 0; i < Main.maxTilesX; i++)
				{
					int num = genRand.Next(10, Main.maxTilesX - 10);
					int num2 = genRand.Next(10, (int)Main.worldSurface);
					if (Main.tile[num, num2].wall == 2)
					{
						DirtyRockRunner(num, num2);
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.LivingTrees, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration && !SecretSeed.Variations.noSurfaceNoLivingTrees)
			{
				progress.Message = Language.GetTextValue("WorldGeneration.LivingTrees");
				progress.Set(0.0);
				int num = 200;
				int num2 = 0;
				double num3 = (double)Main.maxTilesX / 4200.0;
				int num4 = genRand.Next(0, (int)(2.0 * num3) + 1);
				if (num4 == 0 && genRand.Next(2) == 0)
				{
					num4++;
				}
				if (SecretSeed.extraFloatingIslands.Enabled)
				{
					num2 = FindLowestCloud() + 1;
				}
				if (SecretSeed.extraLivingTrees.Enabled)
				{
					num4 = ((!SecretSeed.Variations.extraLivingTreesReducedAmount) ? (num4 + (int)(30.0 * num3)) : (num4 + (int)(3.0 * num3)));
					num = 150;
					num2 = FindLowestCloud() + 1;
				}
				else if (notTheBees && tenthAnniversaryWorldGen && !drunkWorldGen)
				{
					num4 += (int)(10.0 * num3);
				}
				else if (drunkWorldGen)
				{
					num4 += (int)(2.0 * num3);
				}
				else if (Main.tenthAnniversaryWorld)
				{
					num4 += (int)(3.0 * num3);
				}
				else if (remixWorldGen)
				{
					num4 += (int)(2.0 * num3);
				}
				if (skyblockWorldGen)
				{
					num2 = 50;
				}
				for (int i = 0; i < num4; i++)
				{
					progress.Set((float)i / (float)num4, 0.0, 0.5);
					bool flag = false;
					int num5 = 0;
					while (!flag)
					{
						num5++;
						if (num5 > Main.maxTilesX / 2)
						{
							flag = true;
						}
						int num6 = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
						if (tenthAnniversaryWorldGen && !remixWorldGen)
						{
							num6 = genRand.Next((int)((double)Main.maxTilesX * 0.15), (int)((float)Main.maxTilesX * 0.85f));
						}
						if (num6 <= Main.maxTilesX / 2 - num || num6 >= Main.maxTilesX / 2 + num)
						{
							int j = num2;
							if (SecretSeed.noSurface.Enabled)
							{
								j = genRand.Next(200, Main.UnderworldLayer - 200);
							}
							else
							{
								for (; !Main.tile[num6, j].active() && (double)j < Main.worldSurface; j++)
								{
								}
								if ((double)j >= Main.worldSurface)
								{
									continue;
								}
							}
							if (Main.tile[num6, j].type == 0 || (notTheBees && Main.tile[num6, j].type == 60) || (notTheBees && tenthAnniversaryWorldGen && !drunkWorldGen))
							{
								j--;
								if (j > 150)
								{
									bool flag2 = true;
									if (IsTileNearby(num6, j, 191, 10) || IsTileNearby(num6, j, 192, 10))
									{
										flag2 = false;
									}
									if (flag2 && !SecretSeed.errorWorld.Enabled)
									{
										for (int k = num6 - 50; k < num6 + 50; k++)
										{
											for (int l = j - 50; l < j + 50; l++)
											{
												if (Main.tile[k, l].active())
												{
													switch (Main.tile[k, l].type)
													{
													case 41:
													case 43:
													case 44:
													case 481:
													case 482:
													case 483:
														flag2 = false;
														break;
													case 189:
													case 196:
													case 460:
													case 717:
													case 718:
													case 719:
														if (!SecretSeed.extraLivingTrees.Enabled)
														{
															flag2 = false;
														}
														break;
													}
												}
											}
										}
									}
									if (!SecretSeed.extraLivingTrees.Enabled)
									{
										for (int m = 0; m < GenVars.numMCaves; m++)
										{
											if (num6 > GenVars.mCaveX[m] - 50 && num6 < GenVars.mCaveX[m] + 50)
											{
												flag2 = false;
												break;
											}
										}
									}
									if (flag2)
									{
										flag = GrowLivingTree(num6, j);
										if (flag)
										{
											for (int n = -1; n <= 1; n++)
											{
												if (n != 0)
												{
													int num7 = num6;
													int num8 = genRand.Next(4);
													if (SecretSeed.extraLivingTrees.Enabled)
													{
														num8 += genRand.Next(5, 11);
													}
													else if (notTheBees && tenthAnniversaryWorldGen && !drunkWorldGen)
													{
														num8 += genRand.Next(3, 7);
													}
													else if (drunkWorldGen || Main.tenthAnniversaryWorld)
													{
														num8 += genRand.Next(2, 5);
													}
													else if (remixWorldGen)
													{
														num8 += genRand.Next(1, 6);
													}
													else if (SecretSeed.errorWorld.Enabled)
													{
														num8 += genRand.Next(1, 4);
													}
													for (int num9 = 0; num9 < num8; num9++)
													{
														num7 += genRand.Next(13, 31) * n;
														if (num7 <= Main.maxTilesX / 2 - num || num7 >= Main.maxTilesX / 2 + num)
														{
															int num10 = j;
															if (SecretSeed.noSurface.Enabled)
															{
																num10 += genRand.Next(-10, 11);
															}
															else if (Main.tile[num7, num10].active())
															{
																while (num10 > 0 && Main.tile[num7, num10].active())
																{
																	num10--;
																}
															}
															else
															{
																for (; num10 < Main.maxTilesY - 1 && !Main.tile[num7, num10].active(); num10++)
																{
																}
																num10--;
															}
															flag2 = true;
															if (!SecretSeed.errorWorld.Enabled)
															{
																for (int num11 = num6 - 50; num11 < num6 + 50; num11++)
																{
																	for (int num12 = j - 50; num12 < j + 50; num12++)
																	{
																		if (Main.tile[num11, num12].active())
																		{
																			switch (Main.tile[num11, num12].type)
																			{
																			case 41:
																			case 43:
																			case 44:
																			case 481:
																			case 482:
																			case 483:
																				flag2 = false;
																				break;
																			case 189:
																			case 196:
																			case 460:
																			case 717:
																			case 718:
																			case 719:
																				if (!SecretSeed.extraLivingTrees.Enabled)
																				{
																					flag2 = false;
																				}
																				break;
																			}
																		}
																	}
																}
															}
															if (flag2)
															{
																GrowLivingTree(num7, num10, patch: true);
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				Main.tileSolid[192] = false;
			}
		});
		AddGenerationPass(GenPassNameID.LivingTreeWalls, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Language.GetTextValue("WorldGeneration.LivingTrees");
				progress.Set(0.5);
				for (int i = 25; i < Main.maxTilesX - 25; i++)
				{
					progress.Set((float)(i - 25) / (float)(Main.maxTilesX - 50), 0.5, 1.0);
					for (int j = 25; (double)j < Main.worldSurface; j++)
					{
						if (Main.tile[i, j].type == 191 || Main.tile[i, j - 1].type == 191 || Main.tile[i - 1, j].type == 191 || Main.tile[i + 1, j].type == 191 || Main.tile[i, j + 1].type == 191)
						{
							bool flag = true;
							for (int k = i - 1; k <= i + 1; k++)
							{
								for (int l = j - 1; l <= j + 1; l++)
								{
									if (k != i && l != j && (!Main.tile[k, l].active() || Main.tile[k, l].type != 191) && Main.tile[k, l].wall != 244)
									{
										flag = false;
									}
								}
							}
							if (flag)
							{
								Main.tile[i, j].wall = 244;
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.DemonAndCrimsonAltars, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				Main.tileSolid[484] = false;
				progress.Message = Lang.gen[26].Value;
				int num = (int)((double)(Main.maxTilesX * Main.maxTilesY) * 3.3E-06);
				if (remixWorldGen)
				{
					num *= 3;
				}
				if (SecretSeed.dualDungeons.Enabled)
				{
					num /= 2;
				}
				for (int i = 0; i < num; i++)
				{
					progress.Set((float)i / (float)num);
					for (int j = 0; j < 10000; j++)
					{
						int num2 = genRand.Next(281, Main.maxTilesX - 3 - 280);
						while ((double)num2 > (double)Main.maxTilesX * 0.45 && (double)num2 < (double)Main.maxTilesX * 0.55)
						{
							num2 = genRand.Next(281, Main.maxTilesX - 3 - 280);
						}
						int num3 = genRand.Next((int)(Main.worldSurface * 2.0 + Main.rockLayer) / 3, (int)(Main.rockLayer + (double)((Main.maxTilesY - 350) * 2)) / 3);
						if (remixWorldGen)
						{
							num3 = genRand.Next(100, (int)((double)Main.maxTilesY * 0.9));
						}
						while (oceanDepths(num2, num3) || Vector2D.Distance(new Vector2D(num2, num3), GenVars.shimmerPosition) < (double)shimmerSafetyDistance || (SecretSeed.dualDungeons.Enabled && DungeonUtils.InAnyPotentialDungeonBounds(num2, num3, 0, inner: true)))
						{
							num2 = genRand.Next(281, Main.maxTilesX - 3 - 280);
							while ((double)num2 > (double)Main.maxTilesX * 0.45 && (double)num2 < (double)Main.maxTilesX * 0.55)
							{
								num2 = genRand.Next(281, Main.maxTilesX - 3 - 280);
							}
							num3 = genRand.Next((int)(Main.worldSurface * 2.0 + Main.rockLayer) / 3, (int)(Main.rockLayer + (double)((Main.maxTilesY - 350) * 2)) / 3);
							if (remixWorldGen)
							{
								num3 = genRand.Next(100, (int)((double)Main.maxTilesY * 0.9));
							}
						}
						int style = (crimson ? 1 : 0);
						if (drunkWorldGen)
						{
							style = (GenVars.crimsonLeft ? ((num2 < Main.maxTilesX / 2) ? 1 : 0) : ((num2 >= Main.maxTilesX / 2) ? 1 : 0));
						}
						if (!IsTileNearby(num2, num3, 26, 3))
						{
							Place3x2(num2, num3, 26, style);
						}
						if (Main.tile[num2, num3].type == 26)
						{
							break;
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.SurfaceWaterInJungle, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration && !SecretSeed.noSurface.Enabled)
			{
				progress.Set(1.0);
				for (int i = 0; i < Main.maxTilesX; i++)
				{
					for (int j = (int)GenVars.worldSurfaceLow; (double)j < Main.worldSurface - 1.0; j++)
					{
						if (Main.tile[i, j].active())
						{
							if (Main.tile[i, j].type == 60)
							{
								Main.tile[i, j - 1].liquidType(0);
								Main.tile[i, j - 1].liquid = byte.MaxValue;
								Main.tile[i, j - 2].liquidType(0);
								Main.tile[i, j - 2].liquid = byte.MaxValue;
							}
							break;
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.LihzahrdTemple, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				int num = 0;
				progress.Message = Lang.gen[70].Value;
				long num2 = 0L;
				double num3 = 0.25;
				bool flag = false;
				while (true)
				{
					int num4 = (int)Main.rockLayer;
					int num5 = Main.maxTilesY - 600;
					if (num4 > num5 - 1)
					{
						num4 = num5 - 1;
					}
					int num6 = genRand.Next(num4, num5);
					int num7 = (int)(((genRand.NextDouble() * num3 + 0.1) * (double)(-GenVars.CurrentDungeonGenVars.dungeonSide) + 0.5) * (double)Main.maxTilesX);
					if (remixWorldGen && !SecretSeed.noSurface.Enabled)
					{
						if (notTheBees)
						{
							num7 = ((GenVars.CurrentDungeonGenVars.dungeonSide < DungeonSide.Right) ? genRand.Next((int)((double)Main.maxTilesX * 0.6), (int)((double)Main.maxTilesX * 0.8)) : genRand.Next((int)((double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.4)));
						}
						else
						{
							num7 = genRand.Next((int)((double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.8));
							while ((double)num7 > (double)Main.maxTilesX * 0.4 && (double)num7 < (double)Main.maxTilesX * 0.6)
							{
								num7 = genRand.Next((int)((double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.8));
							}
						}
						while (Main.tile[num7, num6].active() || Main.tile[num7, num6].wall > 0 || (double)num6 > Main.worldSurface - 5.0)
						{
							num6--;
						}
						num6++;
						if (Main.tile[num7, num6].active() && (Main.tile[num7, num6].type == 60 || Main.tile[num7, num6].type == 59))
						{
							int num8 = 10;
							bool flag2 = false;
							for (int i = num7 - num8; i <= i + num8; i++)
							{
								for (int j = num6 - num8; j < num8; j++)
								{
									if (Main.tile[i, j].type == 191 || Main.tileDungeon[Main.tile[i, j].type])
									{
										flag2 = true;
									}
								}
							}
							if (!flag2)
							{
								flag = true;
								num6 -= 10 + genRand.Next(10);
								makeTemple(num7, num6, progress);
								break;
							}
						}
					}
					else if (Main.tile[num7, num6].active() && Main.tile[num7, num6].type == 60)
					{
						flag = true;
						makeTemple(num7, num6, progress);
						break;
					}
					if (num2++ > 1000000)
					{
						if (num3 == 0.35)
						{
							num++;
							if (num > 10)
							{
								break;
							}
						}
						num3 = Math.Min(0.35, num3 + 0.05);
						num2 = 0L;
					}
				}
				if (!flag)
				{
					int x = Main.maxTilesX - GenVars.CurrentDungeonGenVars.generatingDungeonPositionX;
					int y = (int)Main.rockLayer + 100;
					if (remixWorldGen)
					{
						x = ((!notTheBees) ? ((GenVars.CurrentDungeonGenVars.dungeonSide >= DungeonSide.Right) ? ((int)((double)Main.maxTilesX * 0.3)) : ((int)((double)Main.maxTilesX * 0.7))) : ((GenVars.CurrentDungeonGenVars.dungeonSide >= DungeonSide.Right) ? ((int)((double)Main.maxTilesX * 0.3)) : ((int)((double)Main.maxTilesX * 0.7))));
						y = ((!(Main.worldSurface < 150.0)) ? ((int)Main.worldSurface - 100) : genRand.Next(200, (int)Main.rockLayer));
					}
					makeTemple(x, y, progress);
				}
			}
		});
		AddGenerationPass(GenPassNameID.Beehives, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[71].Value;
				double num = (double)Main.maxTilesX / 4200.0;
				double num2 = 1 + genRand.Next((int)(5.0 * num), (int)(8.0 * num));
				if (drunkWorldGen)
				{
					num2 *= 0.667;
				}
				int num3 = 10000;
				HiveBiome hiveBiome = GenVars.configuration.CreateBiome<HiveBiome>();
				HoneyPatchBiome honeyPatchBiome = GenVars.configuration.CreateBiome<HoneyPatchBiome>();
				double num4 = num2;
				while (num2 > 0.0 && num3 > 0)
				{
					if (progress != null)
					{
						float num5 = 1f - (float)num2 / (float)num4;
						progress.Set(num5);
					}
					num3--;
					Point origin = RandomWorldPoint((int)(Main.worldSurface + Main.rockLayer) >> 1, 20, 300, 20);
					if (drunkWorldGen)
					{
						RandomWorldPoint((int)Main.worldSurface, 20, 300, 20);
					}
					if (hiveBiome.Place(origin, GenVars.structures))
					{
						num2 -= 1.0;
						int num6 = genRand.Next(5);
						if (SecretSeed.extraLiquid.Enabled)
						{
							num6 = 0;
						}
						int num7 = 0;
						int num8 = 10000;
						while (num7 < num6 && num8 > 0)
						{
							double num9 = genRand.NextDouble() * 60.0 + 30.0;
							double num10 = genRand.NextDouble() * 6.2831854820251465;
							int num11 = (int)(Math.Cos(num10) * num9) + origin.X;
							int y = (int)(Math.Sin(num10) * num9) + origin.Y;
							num8--;
							if (num11 > 50 && num11 < Main.maxTilesX - 50 && honeyPatchBiome.Place(new Point(num11, y), GenVars.structures))
							{
								num7++;
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.JungleShrines, delegate
		{
			if (!Skyblock.denyAllGeneration)
			{
				int num = genRand.Next(40, Main.maxTilesX - 40);
				int num2 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 400);
				double num3 = genRand.Next(7, 12);
				num3 *= (double)Main.maxTilesX / 4200.0;
				int num4 = 0;
				for (int i = 0; (double)i < num3; i++)
				{
					bool flag = true;
					while (flag)
					{
						num4++;
						num = genRand.Next(40, Main.maxTilesX / 2 - 40);
						if (GenVars.CurrentDungeonGenVars.dungeonSide <= DungeonSide.Left)
						{
							num += Main.maxTilesX / 2;
						}
						num2 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 400);
						int num5 = genRand.Next(2, 4);
						int num6 = genRand.Next(2, 4);
						Rectangle area = new Rectangle(num - num5 - 1, num2 - num6 - 1, num5 + 1, num6 + 1);
						if (Main.tile[num, num2].active() && Main.tile[num, num2].type == 60)
						{
							int num7 = 30;
							flag = false;
							for (int j = num - num7; j < num + num7; j += 3)
							{
								for (int k = num2 - num7; k < num2 + num7; k += 3)
								{
									if (Main.tile[j, k].active() && (Main.tile[j, k].type == 225 || Main.tile[j, k].type == 229 || Main.tile[j, k].type == 226 || Main.tile[j, k].type == 119 || Main.tile[j, k].type == 120))
									{
										flag = true;
									}
									if (Main.tile[j, k].wall == 86 || Main.tile[j, k].wall == 87)
									{
										flag = true;
									}
								}
							}
							if (!GenVars.structures.CanPlace(area, 1))
							{
								flag = true;
							}
						}
						if (!flag)
						{
							ushort wall = 0;
							if (GenVars.jungleHut == 119)
							{
								wall = 23;
							}
							else if (GenVars.jungleHut == 120)
							{
								wall = 24;
							}
							else if (GenVars.jungleHut == 158)
							{
								wall = 42;
							}
							else if (GenVars.jungleHut == 175)
							{
								wall = 45;
							}
							else if (GenVars.jungleHut == 45)
							{
								wall = 10;
							}
							for (int l = num - num5 - 1; l <= num + num5 + 1; l++)
							{
								for (int m = num2 - num6 - 1; m <= num2 + num6 + 1; m++)
								{
									Main.tile[l, m].active(active: true);
									Main.tile[l, m].type = GenVars.jungleHut;
									Main.tile[l, m].liquid = 0;
									Main.tile[l, m].lava(lava: false);
								}
							}
							for (int n = num - num5; n <= num + num5; n++)
							{
								for (int num8 = num2 - num6; num8 <= num2 + num6; num8++)
								{
									Main.tile[n, num8].active(active: false);
									Main.tile[n, num8].wall = wall;
								}
							}
							bool flag2 = false;
							int num9 = 0;
							while (!flag2 && num9 < 100)
							{
								num9++;
								int num10 = genRand.Next(num - num5, num + num5 + 1);
								int num11 = genRand.Next(num2 - num6, num2 + num6 - 2);
								PlaceTile(num10, num11, 4, mute: true, forced: false, -1, 3);
								if (Main.tile[num10, num11].active() && Main.tile[num10, num11].type == 4)
								{
									flag2 = true;
								}
							}
							for (int num12 = num - num5 - 1; num12 <= num + num5 + 1; num12++)
							{
								for (int num13 = num2 + num6 - 2; num13 <= num2 + num6; num13++)
								{
									Main.tile[num12, num13].active(active: false);
								}
							}
							for (int num14 = num - num5 - 1; num14 <= num + num5 + 1; num14++)
							{
								for (int num15 = num2 + num6 - 2; num15 <= num2 + num6 - 1; num15++)
								{
									Main.tile[num14, num15].active(active: false);
								}
							}
							for (int num16 = num - num5 - 1; num16 <= num + num5 + 1; num16++)
							{
								int num17 = 4;
								int num18 = num2 + num6 + 2;
								while (!Main.tile[num16, num18].active() && num18 < Main.maxTilesY && num17 > 0)
								{
									Main.tile[num16, num18].active(active: true);
									Main.tile[num16, num18].type = 59;
									num18++;
									num17--;
								}
							}
							num5 -= genRand.Next(1, 3);
							int num19 = num2 - num6 - 2;
							while (num5 > -1)
							{
								for (int num20 = num - num5 - 1; num20 <= num + num5 + 1; num20++)
								{
									Main.tile[num20, num19].active(active: true);
									Main.tile[num20, num19].type = GenVars.jungleHut;
								}
								num5 -= genRand.Next(1, 3);
								num19--;
							}
							GenVars.JChestX[GenVars.numJChests] = num;
							GenVars.JChestY[GenVars.numJChests] = num2;
							GenVars.structures.AddProtectedStructure(area);
							GenVars.numJChests++;
							num4 = 0;
						}
						else if (num4 > Main.maxTilesX * 10)
						{
							i++;
							num4 = 0;
							break;
						}
					}
				}
				Main.tileSolid[137] = false;
			}
		});
		AddGenerationPass(GenPassNameID.SettleLiquids, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[27].Value;
				for (int i = 0; i < Main.maxTilesX; i++)
				{
					for (int j = 0; j < Main.maxTilesY; j++)
					{
						if (oceanDepths(i, j) && Main.tile[i, j].liquid > 0 && Main.tile[i, j].liquidType() != 0)
						{
							Main.tile[i, j].liquidType(0);
						}
					}
				}
				if (SecretSeed.extraLiquid.Enabled)
				{
					progress.Message = Language.GetTextValue("WorldGeneration.WaterFeatures");
					SecretSeed.DoExtraLiquidAddLiquid();
				}
				if (notTheBees)
				{
					NotTheBees();
				}
				Liquid.worldGenTilesIgnoreWater(ignoreSolids: true);
				Liquid.QuickWater(3);
				WaterCheck();
				int num = 0;
				Liquid.quickSettle = true;
				int num2 = 10;
				while (num < num2)
				{
					int num3 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;
					num++;
					double num4 = 0.0;
					int num5 = num3 * 5;
					while (Liquid.numLiquid > 0)
					{
						num5--;
						if (num5 < 0)
						{
							if (SecretSeed.extraLiquid.Enabled)
							{
								num += num2 / 5;
							}
							break;
						}
						double num6 = (double)(num3 - (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer)) / (double)num3;
						if (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer > num3)
						{
							num3 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;
						}
						if (num6 > num4)
						{
							num4 = num6;
						}
						else
						{
							num6 = num4;
						}
						if (num == 1)
						{
							progress.Set(num6 / 3.0 + 0.33);
						}
						int num7 = 10;
						if (num > num7)
						{
							num7 = num;
						}
						Liquid.UpdateLiquid();
					}
					WaterCheck();
					progress.Set((double)num * 0.1 / 3.0 + 0.66);
				}
				ClearPendingLiquid();
				Liquid.quickSettle = false;
				Liquid.worldGenTilesIgnoreWater(ignoreSolids: false);
				Main.tileSolid[484] = false;
			}
		});
		AddGenerationPass(GenPassNameID.RemoveSurfaceWaterAboveSand, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration && !SecretSeed.extraLiquid.Enabled)
			{
				progress.Set(1.0);
				for (int i = 400; i < Main.maxTilesX - 400; i++)
				{
					for (int j = 100; (double)j < Main.worldSurface - 1.0; j++)
					{
						if (Main.tile[i, j].active())
						{
							ushort type = Main.tile[i, j].type;
							if (type == 53 || type == 396 || type == 397 || type == 404 || type == 407 || type == 151)
							{
								int num = j;
								while (num > 100)
								{
									num--;
									if (Main.tile[i, num].active())
									{
										break;
									}
									Main.tile[i, num].liquid = 0;
								}
							}
							break;
						}
					}
				}
				Main.tileSolid[192] = true;
			}
		});
		AddGenerationPass(GenPassNameID.Oasis, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration && !SecretSeed.roundLandmasses.Enabled && !SecretSeed.noSurface.Enabled && (!notTheBees || dontStarveWorldGen))
			{
				progress.Message = Language.GetTextValue("WorldGeneration.Oasis");
				progress.Set(0.0);
				int num = Main.maxTilesX / 2100;
				num += genRand.Next(2);
				for (int i = 0; i < num; i++)
				{
					progress.Set((float)i / (float)num);
					int num2 = beachDistance + 300;
					int num3 = Main.maxTilesX * 2;
					while (num3 > 0)
					{
						num3--;
						int x = genRand.Next(num2, Main.maxTilesX - num2);
						int y = genRand.Next(100, (int)Main.worldSurface);
						if (PlaceOasis(x, y))
						{
							num3 = -1;
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.ShellPilesMarblePilesAndSpikePits, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration && !SecretSeed.noSurface.Enabled)
			{
				progress.Set(0.0);
				if (dontStarveWorldGen)
				{
					progress.Message = Language.GetTextValue("WorldGeneration.MarblePiles");
					progress.Set(0.0);
					int num = (int)(5.0 * ((double)Main.maxTilesX / 4200.0));
					int num2 = 0;
					int num3 = 100;
					int num4 = Main.maxTilesX / 2;
					int num5 = num4 - num3;
					int num6 = num4 + num3;
					for (int i = 0; i < 80; i++)
					{
						int num7 = genRand.Next(100, Main.maxTilesX - 100);
						if (num7 >= num5 && num7 <= num6)
						{
							num7 = genRand.Next(100, Main.maxTilesX - 100);
							if (num7 >= num5 && num7 <= num6)
							{
								continue;
							}
						}
						int y = (int)Main.worldSurface / 2;
						if (MarblePileWithStatues(num7, y))
						{
							num2++;
							progress.Set((float)num2 / (float)num);
							if (num2 >= num)
							{
								break;
							}
						}
					}
				}
				if (GenVars.noTrapsAndForTheWorthyNoCelebration)
				{
					AddSpikeCaves(progress);
				}
				if (!notTheBees)
				{
					progress.Message = Language.GetTextValue("WorldGeneration.ShellPiles");
					progress.Set(0.0);
					if (genRand.Next(2) == 0)
					{
						progress.Set(0.33000001311302185);
						int shellStartXLeft = GenVars.shellStartXLeft;
						int shellStartYLeft = GenVars.shellStartYLeft;
						for (int j = shellStartXLeft - 20; j <= shellStartXLeft + 20; j++)
						{
							for (int k = shellStartYLeft - 10; k <= shellStartYLeft + 10; k++)
							{
								if (Main.tile[j, k].active() && Main.tile[j, k].type == 53 && !Main.tile[j, k - 1].active() && Main.tile[j, k - 1].liquid == 0 && !Main.tile[j - 1, k].active() && Main.tile[j - 1, k].liquid > 0)
								{
									GenVars.shellStartXLeft = j;
									GenVars.shellStartYLeft = k;
								}
							}
						}
						GenVars.shellStartYLeft -= 50;
						GenVars.shellStartXLeft -= genRand.Next(5);
						if (genRand.Next(2) == 0)
						{
							GenVars.shellStartXLeft -= genRand.Next(10);
						}
						if (genRand.Next(3) == 0)
						{
							GenVars.shellStartXLeft -= genRand.Next(15);
						}
						if (genRand.Next(4) != 0)
						{
							ShellPile(GenVars.shellStartXLeft, GenVars.shellStartYLeft);
						}
						int maxValue = genRand.Next(2, 4);
						if (genRand.Next(maxValue) == 0)
						{
							ShellPile(GenVars.shellStartXLeft - genRand.Next(10, 35), GenVars.shellStartYLeft);
						}
						if (genRand.Next(maxValue) == 0)
						{
							ShellPile(GenVars.shellStartXLeft - genRand.Next(40, 65), GenVars.shellStartYLeft);
						}
						if (genRand.Next(maxValue) == 0)
						{
							ShellPile(GenVars.shellStartXLeft - genRand.Next(70, 95), GenVars.shellStartYLeft);
						}
						if (genRand.Next(maxValue) == 0)
						{
							ShellPile(GenVars.shellStartXLeft - genRand.Next(100, 125), GenVars.shellStartYLeft);
						}
						if (genRand.Next(maxValue) == 0)
						{
							ShellPile(GenVars.shellStartXLeft + genRand.Next(10, 25), GenVars.shellStartYLeft);
						}
					}
					if (genRand.Next(2) == 0)
					{
						progress.Set(0.6600000262260437);
						int shellStartXRight = GenVars.shellStartXRight;
						int shellStartYRight = GenVars.shellStartYRight;
						for (int l = shellStartXRight - 20; l <= shellStartXRight + 20; l++)
						{
							for (int m = shellStartYRight - 10; m <= shellStartYRight + 10; m++)
							{
								if (Main.tile[l, m].active() && Main.tile[l, m].type == 53 && !Main.tile[l, m - 1].active() && Main.tile[l, m - 1].liquid == 0 && !Main.tile[l + 1, m].active() && Main.tile[l + 1, m].liquid > 0)
								{
									GenVars.shellStartXRight = l;
									GenVars.shellStartYRight = m;
								}
							}
						}
						GenVars.shellStartYRight -= 50;
						GenVars.shellStartXRight += genRand.Next(5);
						if (genRand.Next(2) == 0)
						{
							GenVars.shellStartXLeft += genRand.Next(10);
						}
						if (genRand.Next(3) == 0)
						{
							GenVars.shellStartXLeft += genRand.Next(15);
						}
						if (genRand.Next(4) != 0)
						{
							ShellPile(GenVars.shellStartXRight, GenVars.shellStartYRight);
						}
						int maxValue2 = genRand.Next(2, 4);
						if (genRand.Next(maxValue2) == 0)
						{
							ShellPile(GenVars.shellStartXRight + genRand.Next(10, 35), GenVars.shellStartYRight);
						}
						if (genRand.Next(maxValue2) == 0)
						{
							ShellPile(GenVars.shellStartXRight + genRand.Next(40, 65), GenVars.shellStartYRight);
						}
						if (genRand.Next(maxValue2) == 0)
						{
							ShellPile(GenVars.shellStartXRight + genRand.Next(70, 95), GenVars.shellStartYRight);
						}
						if (genRand.Next(maxValue2) == 0)
						{
							ShellPile(GenVars.shellStartXRight + genRand.Next(100, 125), GenVars.shellStartYRight);
						}
						if (genRand.Next(maxValue2) == 0)
						{
							ShellPile(GenVars.shellStartXRight - genRand.Next(10, 25), GenVars.shellStartYRight);
						}
					}
					progress.Set(1.0);
				}
			}
		});
		AddGenerationPass(GenPassNameID.SmoothWorld, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[60].Value;
			SetCrackedBrickSolidity(solid: true);
			for (int i = 20; i < Main.maxTilesX - 20; i++)
			{
				progress.Set((double)i / (double)Main.maxTilesX, 0.0, 0.5);
				for (int j = 20; j < Main.maxTilesY - 20; j++)
				{
					if ((!Main.tile[i, j].active() || !TileID.Sets.PreventsSlopesDuringGeneration[Main.tile[i, j].type]) && (!Main.tile[i, j - 1].active() || !TileID.Sets.PreventsSlopesDuringGeneration[Main.tile[i, j - 1].type]))
					{
						if (!Main.tile[i, j - 1].active() && (!Main.tile[i - 1, j].active() || Main.tile[i - 1, j].type != 136) && (!Main.tile[i + 1, j].active() || Main.tile[i + 1, j].type != 136))
						{
							if (SolidTile(i, j) && TileID.Sets.CanBeClearedDuringGeneration[Main.tile[i, j].type])
							{
								if ((!Main.tile[i - 1, j].active() || Main.tile[i - 1, j].blockType() == 0) && (!Main.tile[i + 1, j].active() || Main.tile[i + 1, j].blockType() == 0))
								{
									if (SolidTile(i, j + 1))
									{
										if (!SolidTile(i - 1, j) && !Main.tile[i - 1, j + 1].halfBrick() && SolidTile(i - 1, j + 1) && SolidTile(i + 1, j) && !Main.tile[i + 1, j - 1].active())
										{
											if (genRand.Next(2) == 0)
											{
												SlopeTile(i, j, 2);
											}
											else
											{
												PoundTile(i, j);
											}
										}
										else if (!SolidTile(i + 1, j) && !Main.tile[i + 1, j + 1].halfBrick() && SolidTile(i + 1, j + 1) && SolidTile(i - 1, j) && !Main.tile[i - 1, j - 1].active())
										{
											if (genRand.Next(2) == 0)
											{
												SlopeTile(i, j, 1);
											}
											else
											{
												PoundTile(i, j);
											}
										}
										else if (SolidTile(i + 1, j + 1) && SolidTile(i - 1, j + 1) && !Main.tile[i + 1, j].active() && !Main.tile[i - 1, j].active())
										{
											PoundTile(i, j);
										}
										if (SolidTile(i, j))
										{
											if (SolidTile(i - 1, j) && SolidTile(i + 1, j + 2) && !Main.tile[i + 1, j].active() && !Main.tile[i + 1, j + 1].active() && !Main.tile[i - 1, j - 1].active())
											{
												KillTile(i, j);
											}
											else if (SolidTile(i + 1, j) && SolidTile(i - 1, j + 2) && !Main.tile[i - 1, j].active() && !Main.tile[i - 1, j + 1].active() && !Main.tile[i + 1, j - 1].active())
											{
												KillTile(i, j);
											}
											else if (!Main.tile[i - 1, j + 1].active() && !Main.tile[i - 1, j].active() && SolidTile(i + 1, j) && SolidTile(i, j + 2))
											{
												if (genRand.Next(5) == 0)
												{
													KillTile(i, j);
												}
												else if (genRand.Next(5) == 0)
												{
													PoundTile(i, j);
												}
												else
												{
													SlopeTile(i, j, 2);
												}
											}
											else if (!Main.tile[i + 1, j + 1].active() && !Main.tile[i + 1, j].active() && SolidTile(i - 1, j) && SolidTile(i, j + 2))
											{
												if (genRand.Next(5) == 0)
												{
													KillTile(i, j);
												}
												else if (genRand.Next(5) == 0)
												{
													PoundTile(i, j);
												}
												else
												{
													SlopeTile(i, j, 1);
												}
											}
										}
									}
									if (SolidTile(i, j) && !Main.tile[i - 1, j].active() && !Main.tile[i + 1, j].active())
									{
										KillTile(i, j);
									}
								}
							}
							else if (!Main.tile[i, j].active() && SolidTile(i, j + 1) && Main.tile[i, j + 1].type != 151 && Main.tile[i, j + 1].type != 274)
							{
								if (Main.tile[i + 1, j].type != 190 && Main.tile[i + 1, j].type != 48 && Main.tile[i + 1, j].type != 232 && SolidTile(i - 1, j + 1) && SolidTile(i + 1, j) && !Main.tile[i - 1, j].active() && !Main.tile[i + 1, j - 1].active())
								{
									if (Main.tile[i + 1, j].type == 495)
									{
										PlaceTile(i, j, Main.tile[i + 1, j].type);
									}
									else
									{
										PlaceTile(i, j, Main.tile[i, j + 1].type);
									}
									if (genRand.Next(2) == 0)
									{
										SlopeTile(i, j, 2);
									}
									else
									{
										PoundTile(i, j);
									}
								}
								if (Main.tile[i - 1, j].type != 190 && Main.tile[i - 1, j].type != 48 && Main.tile[i - 1, j].type != 232 && SolidTile(i + 1, j + 1) && SolidTile(i - 1, j) && !Main.tile[i + 1, j].active() && !Main.tile[i - 1, j - 1].active())
								{
									if (Main.tile[i - 1, j].type == 495)
									{
										PlaceTile(i, j, Main.tile[i - 1, j].type);
									}
									else
									{
										PlaceTile(i, j, Main.tile[i, j + 1].type);
									}
									if (genRand.Next(2) == 0)
									{
										SlopeTile(i, j, 1);
									}
									else
									{
										PoundTile(i, j);
									}
								}
							}
						}
						else if (!Main.tile[i, j + 1].active() && genRand.Next(2) == 0 && SolidTile(i, j) && SolidTile(i, j - 1) && (!Main.tile[i + 1, j].active() || Main.tile[i + 1, j].blockType() == 0) && (!Main.tile[i - 1, j].active() || Main.tile[i - 1, j].blockType() == 0))
						{
							if (SolidTile(i - 1, j) && !SolidTile(i + 1, j) && SolidTile(i - 1, j - 1))
							{
								SlopeTile(i, j, 3);
							}
							else if (SolidTile(i + 1, j) && !SolidTile(i - 1, j) && SolidTile(i + 1, j - 1))
							{
								SlopeTile(i, j, 4);
							}
						}
					}
				}
			}
			for (int k = 20; k < Main.maxTilesX - 20; k++)
			{
				progress.Set((double)k / (double)Main.maxTilesX, 0.5, 1.0);
				for (int l = 20; l < Main.maxTilesY - 20; l++)
				{
					if (genRand.Next(2) == 0 && !Main.tile[k, l - 1].active() && Main.tile[k, l].type != 137 && Main.tile[k, l].type != 48 && Main.tile[k, l].type != 232 && Main.tile[k, l].type != 191 && Main.tile[k, l].type != 151 && Main.tile[k, l].type != 274 && Main.tile[k, l].type != 75 && Main.tile[k, l].type != 76 && SolidTile(k, l) && (!Main.tile[k - 1, l].active() || Main.tile[k - 1, l].type != 137) && (Main.tile[k + 1, l].active() || Main.tile[k + 1, l].type != 137))
					{
						if (SolidTile(k, l + 1) && SolidTile(k + 1, l) && !Main.tile[k - 1, l].active())
						{
							SlopeTile(k, l, 2);
						}
						if (SolidTile(k, l + 1) && SolidTile(k - 1, l) && !Main.tile[k + 1, l].active())
						{
							SlopeTile(k, l, 1);
						}
					}
					if (Main.tile[k, l].active() && TileID.Sets.Conversion.Sand[Main.tile[k, l].type])
					{
						Tile.SmoothSlope(k, l, applyToNeighbors: false);
					}
					if (Main.tile[k, l].slope() == 1 && !SolidTile(k - 1, l))
					{
						SlopeTile(k, l);
						PoundTile(k, l);
					}
					if (Main.tile[k, l].slope() == 2 && !SolidTile(k + 1, l))
					{
						SlopeTile(k, l);
						PoundTile(k, l);
					}
				}
			}
			if (SecretSeed.addTeleporters.Enabled && Skyblock.denySomeGeneration)
			{
				SecretSeed.DoAddTeleporters();
			}
			Main.tileSolid[137] = true;
			Main.tileSolid[190] = false;
			Main.tileSolid[192] = false;
			SetCrackedBrickSolidity(solid: false);
		});
		AddGenerationPass(GenPassNameID.Waterfalls, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denySomeGeneration)
			{
				progress.Message = Lang.gen[69].Value;
				Main.tileSolid[191] = false;
				for (int i = 20; i < Main.maxTilesX - 20; i++)
				{
					double num = (double)i / (double)Main.maxTilesX;
					progress.Set(num * 0.5);
					for (int j = 20; j < Main.maxTilesY - 20; j++)
					{
						if (SolidTile(i, j) && !Main.tile[i - 1, j].active() && SolidTile(i, j + 1) && !Main.tile[i + 1, j].active() && (Main.tile[i - 1, j].liquid > 0 || Main.tile[i + 1, j].liquid > 0))
						{
							bool flag = true;
							int num2 = genRand.Next(8, 20);
							int num3 = genRand.Next(8, 20);
							num2 = j - num2;
							num3 += j;
							for (int k = num2; k <= num3; k++)
							{
								if (Main.tile[i, k].active() && Main.tile[i, k].halfBrick())
								{
									flag = false;
								}
							}
							if ((Main.tile[i, j].type == 75 || Main.tile[i, j].type == 76) && genRand.Next(10) != 0)
							{
								flag = false;
							}
							if (flag)
							{
								PoundTile(i, j);
							}
						}
					}
				}
				for (int l = 20; l < Main.maxTilesX - 20; l++)
				{
					double num4 = (double)l / (double)Main.maxTilesX;
					progress.Set(num4 * 0.5 + 0.5);
					for (int m = 20; m < Main.maxTilesY - 20; m++)
					{
						if (Main.tile[l, m].type != 48 && Main.tile[l, m].type != 232 && SolidTile(l, m) && SolidTile(l, m + 1))
						{
							if (!SolidTile(l + 1, m) && Main.tile[l - 1, m].active() && Main.tile[l - 1, m].halfBrick() && Main.tile[l - 2, m].liquid > 0)
							{
								PoundTile(l, m);
							}
							if (!SolidTile(l - 1, m) && Main.tile[l + 1, m].active() && Main.tile[l + 1, m].halfBrick() && Main.tile[l + 2, m].liquid > 0)
							{
								PoundTile(l, m);
							}
						}
					}
				}
				Main.tileSolid[191] = true;
			}
		});
		AddGenerationPass(GenPassNameID.FragileIceOverIceBiomeWater, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denySomeGeneration)
			{
				if (notTheBees)
				{
					NotTheBees();
				}
				int num = (int)Main.worldSurface;
				int num2 = Main.maxTilesY - 100;
				if (SecretSeed.worldIsFrozen.Enabled)
				{
					SecretSeed.DoWorldIsFrozen();
					num = 0;
				}
				progress.Set(1.0);
				for (int i = 10; i < Main.maxTilesX - 10; i++)
				{
					for (int j = num; j < num2; j++)
					{
						if (Main.tile[i, j].liquid > 0 && (!Main.tile[i, j].lava() || remixWorldGen))
						{
							MakeWateryIceThing(i, j);
						}
					}
				}
				Main.tileSolid[226] = false;
				Main.tileSolid[162] = false;
			}
		});
		AddGenerationPass(GenPassNameID.CaveWallVariety, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[79].Value;
				double num = (double)(Main.maxTilesX * Main.maxTilesY) / 5040000.0;
				int num2 = (int)(300.0 * num);
				int num3 = num2;
				ShapeData shapeData = new ShapeData();
				int num4 = 100000;
				while (num2 > 0 && num4 > 0)
				{
					progress.Set(1.0 - (double)num2 / (double)num3);
					Point point = RandomWorldPoint((int)GenVars.worldSurface, 2, 190, 2);
					while (Vector2D.Distance(new Vector2D(point.X, point.Y), GenVars.shimmerPosition) < (double)shimmerSafetyDistance)
					{
						point = RandomWorldPoint((int)GenVars.worldSurface, 2, 190, 2);
					}
					Tile tile = Main.tile[point.X, point.Y];
					Tile tile2 = Main.tile[point.X, point.Y - 1];
					if (tile.active())
					{
						bool flag = tile.type == 60;
						ushort num5 = 0;
						if (flag)
						{
							num5 = (ushort)(204 + genRand.Next(4));
						}
						else if (tile.type == 1 && tile2.wall == 0)
						{
							num5 = (remixWorldGen ? (((double)point.Y > GenVars.rockLayer) ? ((ushort)(196 + genRand.Next(4))) : ((point.Y <= GenVars.lavaLine || genRand.Next(2) != 0) ? ((ushort)(212 + genRand.Next(4))) : ((ushort)(208 + genRand.Next(4))))) : (((double)point.Y < GenVars.rockLayer) ? ((ushort)(196 + genRand.Next(4))) : ((point.Y >= GenVars.lavaLine) ? ((ushort)(208 + genRand.Next(4))) : ((ushort)(212 + genRand.Next(4))))));
						}
						if (num5 != 0 && !tile2.active())
						{
							bool foundInvalidTile = false;
							bool flag2 = ((!flag) ? WorldUtils.Gen(new Point(point.X, point.Y - 1), new ShapeFloodFill(1000), Actions.Chain(new Modifiers.IsNotSolid(), new Actions.Blank().Output(shapeData), new Actions.ContinueWrapper(Actions.Chain(new Modifiers.IsTouching(true, 60, 147, 161, 396, 397, 70, 191), new Modifiers.IsTouching(true, 147, 161, 396, 397, 70, 191), new Actions.Custom(delegate
							{
								foundInvalidTile = true;
								return true;
							}))))) : WorldUtils.Gen(new Point(point.X, point.Y - 1), new ShapeFloodFill(1000), Actions.Chain(new Modifiers.IsNotSolid(), new Actions.Blank().Output(shapeData), new Actions.ContinueWrapper(Actions.Chain(new Modifiers.IsTouching(true, 147, 161, 396, 397, 70, 191), new Actions.Custom(delegate
							{
								foundInvalidTile = true;
								return true;
							}))))));
							if (shapeData.Count > 50 && flag2 && !foundInvalidTile)
							{
								WorldUtils.Gen(new Point(point.X, point.Y), new ModShapes.OuterOutline(shapeData, useDiagonals: true, useInterior: true), Actions.Chain(new Modifiers.SkipWalls(87, 86, 244), new Actions.PlaceWall(num5)));
								num2--;
							}
							else
							{
								num4--;
							}
							shapeData.Clear();
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.LifeCrystals, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denySomeGeneration)
			{
				if (SecretSeed.errorWorld.Enabled)
				{
					SecretSeed.DoErrorWorldShuffleBlocks();
				}
				if (getGoodWorldGen)
				{
					Main.tileSolid[56] = false;
				}
				if (notTheBees)
				{
					NotTheBees();
				}
				progress.Message = Lang.gen[28].Value;
				double num = (double)(Main.maxTilesX * Main.maxTilesY) * 2E-05;
				if (tenthAnniversaryWorldGen)
				{
					num *= 1.2;
				}
				if (Main.starGame)
				{
					num *= Main.starGameMath(0.2);
				}
				int num2 = 10000;
				if (skyblockWorldGen)
				{
					num2 = 10;
				}
				for (int i = 0; i < (int)num; i++)
				{
					double value = (double)i / ((double)(Main.maxTilesX * Main.maxTilesY) * 2E-05);
					progress.Set(value);
					bool flag = false;
					int num3 = 0;
					while (!flag)
					{
						int j = genRand.Next((int)(Main.worldSurface * 2.0 + Main.rockLayer) / 3, Main.maxTilesY - 300);
						if (remixWorldGen)
						{
							j = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 400);
						}
						if (AddLifeCrystal(genRand.Next(Main.offLimitBorderTiles, Main.maxTilesX - Main.offLimitBorderTiles), j))
						{
							flag = true;
						}
						else
						{
							num3++;
							if (num3 >= num2)
							{
								flag = true;
							}
						}
					}
				}
				if (SecretSeed.errorWorld.Enabled || SecretSeed.noSurface.Enabled)
				{
					num = (double)(Main.maxTilesX * Main.maxTilesY) * 1E-05;
					if (tenthAnniversaryWorldGen)
					{
						num *= 1.2;
					}
					if (Main.starGame)
					{
						num *= Main.starGameMath(0.2);
					}
					for (int k = 0; k < (int)num; k++)
					{
						double value2 = (double)k / ((double)(Main.maxTilesX * Main.maxTilesY) * 2E-05);
						progress.Set(value2);
						bool flag2 = false;
						int num4 = 0;
						while (!flag2)
						{
							int j2 = genRand.Next((int)(Main.worldSurface * 2.0 + Main.rockLayer) / 3, Main.maxTilesY - 300);
							if (remixWorldGen)
							{
								j2 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 400);
							}
							if (AddManaCrystal(genRand.Next(Main.offLimitBorderTiles, Main.maxTilesX - Main.offLimitBorderTiles), j2))
							{
								flag2 = true;
							}
							else
							{
								num4++;
								if (num4 >= num2)
								{
									flag2 = true;
								}
							}
						}
					}
				}
				Main.tileSolid[225] = false;
			}
		});
		AddGenerationPass(GenPassNameID.Statues, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denySomeGeneration)
			{
				progress.Message = Lang.gen[29].Value;
				int num = 0;
				double num2 = (double)Main.maxTilesX / 4200.0;
				int num3 = (int)((double)(GenVars.statueList.Length * 2) * num2);
				if (noTrapsWorldGen && !skyblockWorldGen)
				{
					num3 *= 15;
					if (tenthAnniversaryWorldGen || notTheBees)
					{
						num3 /= 5;
					}
				}
				if (Main.starGame)
				{
					num3 = (int)((double)num3 * Main.starGameMath(0.2));
				}
				int num4 = 10000;
				if (skyblockWorldGen)
				{
					num4 = 10;
					num3 /= 2;
				}
				for (int i = 0; i < num3; i++)
				{
					if (num >= GenVars.statueList.Length)
					{
						num = 0;
					}
					int x = GenVars.statueList[num].X;
					int y = GenVars.statueList[num].Y;
					double value = i / num3;
					progress.Set(value);
					bool flag = false;
					int num5 = 0;
					while (!flag)
					{
						int num6 = genRand.Next(20, Main.maxTilesX - 20);
						int num7 = genRand.Next((int)(Main.worldSurface * 2.0 + Main.rockLayer) / 3, Main.maxTilesY - 300);
						if (remixWorldGen)
						{
							genRand.Next((int)Main.worldSurface, Main.maxTilesY - 400);
						}
						int num8 = 100;
						while (oceanDepths(num6, num7) || (SecretSeed.dualDungeons.Enabled && DungeonUtils.InAnyPotentialDungeonBounds(num6, num7)))
						{
							num8--;
							if (num8 <= 0)
							{
								break;
							}
							num6 = genRand.Next(20, Main.maxTilesX - 20);
							num7 = genRand.Next((int)(Main.worldSurface * 2.0 + Main.rockLayer) / 3, Main.maxTilesY - 300);
							if (remixWorldGen)
							{
								genRand.Next((int)Main.worldSurface, Main.maxTilesY - 400);
							}
						}
						if (num8 <= 0)
						{
							flag = true;
						}
						else
						{
							while (!Main.tile[num6, num7].active())
							{
								num7++;
								if (num7 >= Main.maxTilesY)
								{
									break;
								}
							}
							if (num7 >= Main.maxTilesY)
							{
								flag = true;
							}
							else
							{
								num7--;
								Tile tile = Main.tile[num6, num7];
								bool flag2 = true;
								if (flag2 && tile.active() && Main.tileFrameImportant[tile.type] && !Main.tileCut[tile.type])
								{
									flag2 = false;
								}
								if (flag2 && tile.anyShimmer())
								{
									flag2 = false;
								}
								if (flag2)
								{
									PlaceTile(num6, num7, x, mute: true, forced: true, -1, y);
								}
								if (tile.active() && tile.type == x)
								{
									flag = true;
									if (GenVars.StatuesWithTraps.Contains(num))
									{
										PlaceStatueTrap(num6, num7);
									}
									num++;
								}
								else
								{
									num5++;
									if (num5 >= num4)
									{
										flag = true;
									}
								}
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.UndergroundHousesAndBuriedChests, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denySomeGeneration)
			{
				int num = 10000;
				if (skyblockWorldGen)
				{
					num = 100;
				}
				progress.Message = Lang.gen[30].Value;
				Main.tileSolid[226] = true;
				Main.tileSolid[162] = true;
				Main.tileSolid[225] = true;
				Main.tileSolid[190] = true;
				CaveHouseBiome caveHouseBiome = GenVars.configuration.CreateBiome<CaveHouseBiome>();
				int random = passConfig.Get<WorldGenRange>("CaveHouseCount").GetRandom(genRand);
				int random2 = passConfig.Get<WorldGenRange>("UnderworldChestCount").GetRandom(genRand);
				int num2 = passConfig.Get<WorldGenRange>("CaveChestCount").GetRandom(genRand);
				int num3 = passConfig.Get<WorldGenRange>("AdditionalDesertHouseCount").GetRandom(genRand);
				if (skyblockWorldGen)
				{
					num3 = 0;
				}
				if (Main.starGame)
				{
					num2 = (int)((double)num2 * Main.starGameMath(0.2));
				}
				int num4 = random + random2 + num2 + num3;
				int num5 = num;
				for (int i = 0; i < num2; i++)
				{
					if (num5 <= 0)
					{
						break;
					}
					progress.Set((double)i / (double)num4);
					int num6 = genRand.Next(20, Main.maxTilesX - 20);
					int num7 = genRand.Next((int)((GenVars.worldSurfaceHigh + 20.0 + Main.rockLayer) / 2.0), Main.maxTilesY - 230);
					if (remixWorldGen)
					{
						num7 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 400);
					}
					ushort wall = Main.tile[num6, num7].wall;
					if (Main.wallDungeon[wall] || wall == 87 || oceanDepths(num6, num7))
					{
						num5--;
						i--;
					}
					else if (SecretSeed.dualDungeons.Enabled && DungeonUtils.InAnyPotentialDungeonBounds(num6, num7))
					{
						num5--;
						i--;
					}
					else if (!AddBuriedChest(num6, num7, 0, notNearOtherChests: false, -1, trySlope: false, 0))
					{
						num5--;
						i--;
					}
				}
				num5 = num;
				for (int j = 0; j < random2; j++)
				{
					if (num5 <= 0)
					{
						break;
					}
					progress.Set((double)(j + num2) / (double)num4);
					int num8 = genRand.Next(20, Main.maxTilesX - 20);
					int num9 = genRand.Next(Main.UnderworldLayer, Main.maxTilesY - 50);
					if (Main.wallDungeon[Main.tile[num8, num9].wall])
					{
						num5--;
						j--;
					}
					else if (SecretSeed.dualDungeons.Enabled && DungeonUtils.InAnyPotentialDungeonBounds(num8, num9))
					{
						num5--;
						j--;
					}
					else if (!AddBuriedChest(num8, num9, 0, notNearOtherChests: false, -1, trySlope: false, 0))
					{
						num5--;
						j--;
					}
				}
				num5 = num;
				for (int k = 0; k < random; k++)
				{
					if (num5 <= 0)
					{
						break;
					}
					progress.Set((double)(k + num2 + random2) / (double)num4);
					int x = genRand.Next(80, Main.maxTilesX - 80);
					int num10 = genRand.Next((int)(GenVars.worldSurfaceHigh + 20.0), Main.maxTilesY - 230);
					if (remixWorldGen)
					{
						num10 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 400);
					}
					if (SecretSeed.GenerateBiggerAbandonedHouses)
					{
						int num11 = (int)(GenVars.worldSurfaceHigh + 20.0);
						int num12 = Main.maxTilesY - 230;
						if (remixWorldGen)
						{
							num11 = (int)Main.worldSurface;
							num12 = Main.maxTilesY - 400;
						}
						num11 += HouseUtils.GetMaxPossibleRoomsInABigAbandonedHouse() * 10;
						num10 = (int)MathHelper.Clamp(num10, num11, num12);
					}
					if (oceanDepths(x, num10))
					{
						num5--;
						k--;
					}
					else if (SecretSeed.dualDungeons.Enabled && DungeonUtils.InAnyPotentialDungeonBounds(x, num10))
					{
						num5--;
						k--;
					}
					else if (!caveHouseBiome.Place(new Point(x, num10), GenVars.structures))
					{
						num5--;
						k--;
					}
				}
				if (!skyblockWorldGen)
				{
					num5 = num;
					Rectangle undergroundDesertHiveLocation = GenVars.UndergroundDesertHiveLocation;
					if (undergroundDesertHiveLocation.Width > 0 && undergroundDesertHiveLocation.Height > 0)
					{
						if ((double)undergroundDesertHiveLocation.Y < Main.worldSurface + 26.0)
						{
							int num13 = (int)Main.worldSurface + 26 - undergroundDesertHiveLocation.Y;
							undergroundDesertHiveLocation.Y += num13;
							undergroundDesertHiveLocation.Height -= num13;
						}
						for (int l = 0; l < num3; l++)
						{
							if (num5 <= 0)
							{
								break;
							}
							progress.Set((double)(l + num2 + random2 + random) / (double)num4);
							if (!caveHouseBiome.Place(RandomRectanglePoint(undergroundDesertHiveLocation), GenVars.structures))
							{
								num5--;
								l--;
							}
						}
					}
				}
				Main.tileSolid[226] = false;
				Main.tileSolid[162] = false;
				Main.tileSolid[225] = false;
				Main.tileSolid[190] = false;
			}
		});
		AddGenerationPass(GenPassNameID.SurfaceChests, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denySomeGeneration && !SecretSeed.noSurface.Enabled)
			{
				progress.Message = Lang.gen[31].Value;
				int num = 2000;
				if (skyblockWorldGen)
				{
					num = 100;
				}
				for (int i = 0; i < (int)((double)Main.maxTilesX * 0.005); i++)
				{
					double value = (double)i / ((double)Main.maxTilesX * 0.005);
					progress.Set(value);
					bool flag = false;
					int num2 = 0;
					while (!flag)
					{
						int num3 = genRand.Next(200, Main.maxTilesX - 200);
						int num4 = genRand.Next((int)GenVars.worldSurfaceLow, (int)Main.worldSurface);
						if (remixWorldGen)
						{
							num4 = genRand.Next(Main.maxTilesY - 400, Main.maxTilesY - 150);
						}
						else
						{
							while (oceanDepths(num3, num4))
							{
								num3 = genRand.Next(300, Main.maxTilesX - 300);
								num4 = genRand.Next((int)GenVars.worldSurfaceLow, (int)Main.worldSurface);
							}
						}
						bool flag2 = false;
						bool flag3 = false;
						if (!Main.tile[num3, num4].active())
						{
							if (Main.tile[num3, num4].wall == 2 || Main.tile[num3, num4].wall == 59 || Main.tile[num3, num4].wall == 244 || remixWorldGen)
							{
								if (Main.tile[num3, num4].wall == 244)
								{
									flag2 = true;
								}
								flag3 = true;
							}
						}
						else
						{
							int num5 = 50;
							int num6 = num3;
							int num7 = num4;
							int num8 = 1;
							for (int j = num6 - num5; j <= num6 + num5; j += 2)
							{
								for (int k = num7 - num5; k <= num7 + num5; k += 2)
								{
									if ((double)k < Main.worldSurface && !Main.tile[j, k].active() && Main.tile[j, k].wall == 244 && genRand.Next(num8) == 0)
									{
										flag2 = true;
										num8++;
										flag3 = true;
										num3 = j;
										num4 = k;
									}
								}
							}
						}
						if (flag3 && AddBuriedChest(num3, num4, 0, notNearOtherChests: true, flag2 ? 12 : (-1), trySlope: false, 0))
						{
							flag = true;
						}
						else
						{
							num2++;
							if (num2 >= num)
							{
								flag = true;
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.ChestsInJungleShrines, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[32].Value;
				for (int i = 0; i < GenVars.numJChests; i++)
				{
					double value = (double)i / (double)GenVars.numJChests;
					progress.Set(value);
					int nextJungleChestItem = GetNextJungleChestItem();
					if (!AddBuriedChest(GenVars.JChestX[i] + genRand.Next(2), GenVars.JChestY[i], nextJungleChestItem, notNearOtherChests: false, 10, trySlope: false, 0))
					{
						for (int j = GenVars.JChestX[i] - 1; j <= GenVars.JChestX[i] + 1; j++)
						{
							for (int k = GenVars.JChestY[i]; k <= GenVars.JChestY[i] + 2; k++)
							{
								KillTile(j, k);
							}
						}
						for (int l = GenVars.JChestX[i] - 1; l <= GenVars.JChestX[i] + 1; l++)
						{
							for (int m = GenVars.JChestY[i]; m <= GenVars.JChestY[i] + 3; m++)
							{
								if (m < Main.maxTilesY)
								{
									Main.tile[l, m].slope(0);
									Main.tile[l, m].halfBrick(halfBrick: false);
								}
							}
						}
						AddBuriedChest(GenVars.JChestX[i], GenVars.JChestY[i], nextJungleChestItem, notNearOtherChests: false, 10, trySlope: false, 0);
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.UnderwaterChests, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[33].Value;
				for (int i = 0; i < GenVars.numOceanCaveTreasure; i++)
				{
					int mainItemInChest = genRand.NextFromList(new short[5] { 863, 186, 277, 187, 4404 });
					if (SecretSeed.extraLiquid.Enabled)
					{
						mainItemInChest = genRand.NextFromList(new short[6] { 863, 186, 277, 187, 4404, 268 });
					}
					bool flag = false;
					double num = 2.0;
					while (!flag && num < 50.0)
					{
						num += 0.1;
						int num2 = genRand.Next(GenVars.oceanCaveTreasure[i].X - (int)num, GenVars.oceanCaveTreasure[i].X + (int)num + 1);
						int num3 = genRand.Next(GenVars.oceanCaveTreasure[i].Y - (int)num / 2, GenVars.oceanCaveTreasure[i].Y + (int)num / 2 + 1);
						num2 = ((num2 >= Main.maxTilesX) ? ((int)((double)num2 + num / 2.0)) : ((int)((double)num2 - num / 2.0)));
						if (InWorld(num2, num3) && Main.tile[num2, num3].liquid > 250 && (Main.tile[num2, num3].liquidType() == 0 || notTheBees || remixWorldGen))
						{
							flag = AddBuriedChest(num2, num3, mainItemInChest, notNearOtherChests: false, 17, trySlope: true, 0);
						}
					}
				}
				int num4 = 0;
				double num5 = (double)Main.maxTilesX / 4200.0;
				if (SecretSeed.extraLiquid.Enabled)
				{
					num5 *= 3.0;
				}
				for (int j = 0; (double)j < 9.0 * num5; j++)
				{
					double value = (double)j / (9.0 * num5);
					progress.Set(value);
					int num6 = 0;
					num4++;
					int maxValue = 10;
					if (tenthAnniversaryWorldGen)
					{
						maxValue = 7;
					}
					if (genRand.Next(maxValue) == 0)
					{
						num6 = 863;
					}
					else
					{
						switch (num4)
						{
						case 1:
							num6 = 186;
							break;
						case 2:
							num6 = 4404;
							break;
						case 3:
							num6 = 277;
							break;
						default:
							if (SecretSeed.extraLiquid.Enabled && num4 == 4)
							{
								num6 = 268;
							}
							else
							{
								num6 = 187;
								num4 = 0;
							}
							break;
						}
					}
					bool flag2 = false;
					int num7 = 0;
					while (!flag2)
					{
						int num8 = genRand.Next(50, Main.maxTilesX - 50);
						int num9 = genRand.Next(1, Main.UnderworldLayer);
						while (Main.tile[num8, num9].liquid < 250 || (Main.tile[num8, num9].liquidType() != 0 && !notTheBees && !remixWorldGen))
						{
							num8 = genRand.Next(50, Main.maxTilesX - 50);
							num9 = genRand.Next(50, Main.UnderworldLayer);
						}
						flag2 = AddBuriedChest(num8, num9, num6, notNearOtherChests: false, 17, num8 < beachDistance || num8 > Main.maxTilesX - beachDistance, 0);
						num7++;
						if (num7 > 10000)
						{
							break;
						}
					}
					flag2 = false;
					num7 = 0;
					while (!flag2)
					{
						int num10 = genRand.Next(50, Main.maxTilesX - 50);
						int num11 = genRand.Next((int)Main.worldSurface, Main.UnderworldLayer);
						while (Main.tile[num10, num11].liquid < 250 || (Main.tile[num10, num11].liquidType() != 0 && !notTheBees))
						{
							num10 = genRand.Next(50, Main.maxTilesX - 50);
							num11 = genRand.Next((int)Main.worldSurface, Main.UnderworldLayer);
						}
						flag2 = AddBuriedChest(num10, num11, num6, notNearOtherChests: false, 17, num10 < beachDistance || num10 > Main.maxTilesX - beachDistance, 0);
						num7++;
						if (num7 > 10000)
						{
							break;
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.SpiderCaves, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration && !SecretSeed.Variations.noSpiderCavesActuallyNoSpiderCaves)
			{
				Main.tileSolid[379] = false;
				progress.Message = Lang.gen[64].Value;
				maxTileCount = 3500;
				int num = Main.maxTilesX / 2;
				int num2 = (int)((double)Main.maxTilesX * 0.005);
				int num3 = 500;
				int num4 = 3500;
				if (GenVars.notTheBeesAndForTheWorthyNoCelebration)
				{
					num = (int)((float)num * 1.25f);
					num3 = 1000;
					num2 *= 2;
					num4 = 5000;
				}
				else if (SecretSeed.roundLandmasses.Enabled)
				{
					num /= 2;
				}
				else if (getGoodWorldGen)
				{
					num2 *= 3;
				}
				if (notTheBees)
				{
					Main.tileSolid[225] = true;
				}
				for (int i = 0; i < num2; i++)
				{
					double value = (double)i / ((double)Main.maxTilesX * 0.005);
					progress.Set(value);
					int num5 = 0;
					int x = genRand.Next(200, Main.maxTilesX - 200);
					int y = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 230);
					if (remixWorldGen)
					{
						y = genRand.Next((int)Main.worldSurface, (int)Main.rockLayer);
					}
					int num6 = countTiles(x, y, jungle: false, lavaOk: true);
					while ((num6 >= num4 || num6 < num3) && num5 < num)
					{
						num5++;
						x = genRand.Next(200, Main.maxTilesX - 200);
						y = genRand.Next((int)Main.rockLayer + 30, Main.maxTilesY - 230);
						if (remixWorldGen)
						{
							y = genRand.Next((int)Main.worldSurface, (int)Main.rockLayer);
						}
						num6 = countTiles(x, y, jungle: false, lavaOk: true);
						if (shroomCount > 1)
						{
							num6 = 0;
						}
					}
					if (num5 < num)
					{
						Spread.Spider(x, y);
					}
				}
				if (notTheBees)
				{
					Main.tileSolid[225] = false;
				}
				Main.tileSolid[162] = true;
				if (SecretSeed.Variations.noSpiderCavesILiedMoreSpiderCaves)
				{
					SecretSeed.DoNoSpiderCavesILiedMoreSpiderCaves();
				}
			}
		});
		AddGenerationPass(GenPassNameID.GemCaves, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration && !notTheBees)
			{
				progress.Message = Lang.gen[64].Value;
				maxTileCount = 300;
				double num = (double)Main.maxTilesX * 0.003;
				if (tenthAnniversaryWorldGen)
				{
					num *= 1.5;
				}
				if (Main.starGame)
				{
					num *= Main.starGameMath(0.2);
				}
				for (int i = 0; (double)i < num; i++)
				{
					double value = (double)i / num;
					progress.Set(value);
					int num2 = 0;
					int x = genRand.Next(200, Main.maxTilesX - 200);
					int y = genRand.Next((int)Main.rockLayer + 30, Main.maxTilesY - 230);
					if (remixWorldGen)
					{
						y = genRand.Next((int)Main.worldSurface + 30, (int)Main.rockLayer - 30);
					}
					int num3 = countTiles(x, y);
					while ((num3 >= 300 || num3 < 50 || lavaCount > 0 || iceCount > 0 || rockCount == 0) && num2 < 1000)
					{
						num2++;
						x = genRand.Next(200, Main.maxTilesX - 200);
						y = genRand.Next((int)Main.rockLayer + 30, Main.maxTilesY - 230);
						if (remixWorldGen)
						{
							y = genRand.Next((int)Main.worldSurface + 30, (int)Main.rockLayer - 30);
						}
						num3 = countTiles(x, y);
					}
					if (num2 < 1000)
					{
						gemCave(x, y);
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.MossAndMossCaves, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration && !SecretSeed.worldIsFrozen.Enabled && (!notTheBees || remixWorldGen || dontStarveWorldGen))
			{
				progress.Message = Lang.gen[61].Value;
				randMoss();
				int num = Main.maxTilesX / 2100;
				if (remixWorldGen)
				{
					num = (int)((double)num * 1.5);
				}
				else if (tenthAnniversaryWorldGen)
				{
					num *= 2;
				}
				int num2 = 0;
				int num3 = 0;
				while (num3 < num)
				{
					int num4 = genRand.Next(100, Main.maxTilesX - 100);
					if (remixWorldGen)
					{
						num4 = genRand.Next((int)((double)Main.maxTilesX * 0.3), (int)((double)Main.maxTilesX * 0.7));
					}
					else if (tenthAnniversaryWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							randMoss(justNeon: true);
						}
					}
					else if (getGoodWorldGen)
					{
						while ((double)num4 > (double)Main.maxTilesX * 0.42 && (double)num4 < (double)Main.maxTilesX * 0.48)
						{
							num4 = genRand.Next(100, Main.maxTilesX - 100);
						}
					}
					else if (!drunkWorldGen)
					{
						while ((double)num4 > (double)Main.maxTilesX * 0.38 && (double)num4 < (double)Main.maxTilesX * 0.62)
						{
							num4 = genRand.Next(100, Main.maxTilesX - 100);
						}
					}
					int num5 = ((!remixWorldGen) ? genRand.Next((int)Main.rockLayer + 40, GenVars.lavaLine - 40) : genRand.Next((int)Main.worldSurface + 50, (int)Main.rockLayer - 50));
					bool flag = false;
					int num6 = 50;
					for (int i = num4 - num6; i <= num4 + num6; i++)
					{
						for (int j = num5 - num6; j <= num5 + num6; j++)
						{
							if (Main.tile[i, j].active())
							{
								int type = Main.tile[i, j].type;
								if (remixWorldGen)
								{
									if (type == 60 || type == 161 || type == 147 || Main.tileDungeon[type] || type == 25 || type == 203)
									{
										flag = true;
										i = num4 + num6 + 1;
										break;
									}
								}
								else if (notTheBees && dontStarveWorldGen)
								{
									if (type == 70 || type == 367 || type == 368 || type == 161 || type == 147 || type == 396 || type == 397 || Main.tileDungeon[type])
									{
										flag = true;
										i = num4 + num6 + 1;
										break;
									}
								}
								else if (type == 70 || type == 60 || type == 367 || type == 368 || type == 161 || type == 147 || type == 396 || type == 397 || Main.tileDungeon[type])
								{
									flag = true;
									i = num4 + num6 + 1;
									break;
								}
							}
						}
					}
					if (flag)
					{
						num2++;
						if (num2 > Main.maxTilesX)
						{
							num3++;
						}
					}
					else
					{
						num2 = 0;
						num3++;
						int maxY = GenVars.lavaLine;
						if (remixWorldGen)
						{
							maxY = (int)Main.rockLayer + 50;
						}
						neonMossBiome(num4, num5, maxY);
					}
				}
				maxTileCount = 2500;
				for (int k = 0; k < (int)((double)Main.maxTilesX * 0.01); k++)
				{
					double value = (double)k / ((double)Main.maxTilesX * 0.01);
					progress.Set(value);
					int num7 = 0;
					int num8 = genRand.Next(200, Main.maxTilesX - 200);
					int num9 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, GenVars.waterLine);
					if (remixWorldGen)
					{
						num9 = genRand.Next((int)Main.worldSurface, (int)Main.rockLayer);
					}
					if (!(Vector2D.Distance(new Vector2D(num8, num9), GenVars.shimmerPosition) < (double)shimmerSafetyDistance))
					{
						int num10 = countTiles(num8, num9);
						while ((num10 >= 2500 || num10 < 10 || lavaCount > 0 || iceCount > 0 || rockCount == 0 || shroomCount > 0) && num7 < 1000)
						{
							num7++;
							num8 = genRand.Next(200, Main.maxTilesX - 200);
							num9 = genRand.Next((int)Main.rockLayer + 30, Main.maxTilesY - 230);
							num10 = countTiles(num8, num9);
						}
						if (num7 < 1000)
						{
							setMoss(num8, num9);
							Spread.Moss(num8, num9);
						}
					}
				}
				for (int l = 0; l < Main.maxTilesX; l++)
				{
					int num11 = genRand.Next(50, Main.maxTilesX - 50);
					int num12 = ((!remixWorldGen) ? genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, GenVars.lavaLine) : genRand.Next((int)Main.worldSurface, Main.maxTilesY - 300));
					if (!(Vector2D.Distance(new Vector2D(num11, num12), GenVars.shimmerPosition) < (double)shimmerSafetyDistance) && Main.tile[num11, num12].active() && Main.tile[num11, num12].type == 1)
					{
						setMoss(num11, num12);
						Main.tile[num11, num12].type = GenVars.mossTile;
					}
				}
				double num13 = (double)Main.maxTilesX * 0.05;
				while (num13 > 0.0)
				{
					int num14 = genRand.Next(50, Main.maxTilesX - 50);
					int num15 = ((!remixWorldGen) ? genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, GenVars.lavaLine) : genRand.Next((int)Main.worldSurface, Main.maxTilesY - 300));
					if (!(Vector2D.Distance(new Vector2D(num14, num15), GenVars.shimmerPosition) < (double)shimmerSafetyDistance) && Main.tile[num14, num15].active() && Main.tile[num14, num15].type == 1 && (!Main.tile[num14 - 1, num15].active() || !Main.tile[num14 + 1, num15].active() || !Main.tile[num14, num15 - 1].active() || !Main.tile[num14, num15 + 1].active()))
					{
						setMoss(num14, num15);
						Main.tile[num14, num15].type = GenVars.mossTile;
						num13 -= 1.0;
					}
				}
				num13 = (double)Main.maxTilesX * 0.065;
				if (remixWorldGen)
				{
					num13 *= 2.0;
				}
				while (num13 > 0.0)
				{
					int num16 = genRand.Next(50, Main.maxTilesX - 50);
					int num17 = ((!remixWorldGen) ? genRand.Next(GenVars.waterLine, Main.UnderworldLayer) : genRand.Next(GenVars.lavaLine, (int)Main.rockLayer + 50));
					if (Main.tile[num16, num17].active() && Main.tile[num16, num17].type == 1 && (!Main.tile[num16 - 1, num17].active() || !Main.tile[num16 + 1, num17].active() || !Main.tile[num16, num17 - 1].active() || !Main.tile[num16, num17 + 1].active()))
					{
						int num18 = 25;
						int num19 = 0;
						for (int m = num16 - num18; m < num16 + num18; m++)
						{
							for (int n = num17 - num18; n < num17 + num18; n++)
							{
								if (Main.tile[m, n].liquid > 0 && Main.tile[m, n].lava())
								{
									num19++;
								}
							}
						}
						if (num19 > 20)
						{
							Main.tile[num16, num17].type = 381;
							num13 -= 1.0;
						}
						else
						{
							num13 -= 0.002;
						}
					}
					num13 -= 0.001;
				}
				for (int num20 = 0; num20 < Main.maxTilesX; num20++)
				{
					for (int num21 = 0; num21 < Main.maxTilesY; num21++)
					{
						if (Main.tile[num20, num21].active() && Main.tileMoss[Main.tile[num20, num21].type])
						{
							for (int num22 = 0; num22 < 4; num22++)
							{
								int num23 = num20;
								int num24 = num21;
								if (num22 == 0)
								{
									num23--;
								}
								if (num22 == 1)
								{
									num23++;
								}
								if (num22 == 2)
								{
									num24--;
								}
								if (num22 == 3)
								{
									num24++;
								}
								try
								{
									grassSpread = 0;
									SpreadGrass(num23, num24, 1, Main.tile[num20, num21].type);
								}
								catch
								{
									grassSpread = 0;
									SpreadGrass(num23, num24, 1, Main.tile[num20, num21].type, repeat: false);
								}
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.LihzahrdTemplePart2, delegate
		{
			if (!Skyblock.denyAllGeneration)
			{
				Main.tileSolid[162] = false;
				Main.tileSolid[226] = true;
				templePart2();
				Main.tileSolid[232] = false;
			}
		});
		AddGenerationPass(GenPassNameID.CaveWallsInEnclosedSpaces, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			Main.tileSolid[162] = false;
			Main.tileSolid[226] = true;
			Main.tileSolid[232] = false;
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[63].Value;
				maxTileCount = 1500;
				for (int i = 0; i < (int)((double)Main.maxTilesX * 0.04); i++)
				{
					double num = (double)i / ((double)Main.maxTilesX * 0.04);
					progress.Set(num * 0.66);
					int num2 = 0;
					int x = genRand.Next(200, Main.maxTilesX - 200);
					int y = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 220);
					if (remixWorldGen)
					{
						y = genRand.Next((int)Main.worldSurface + 25, (int)Main.rockLayer);
					}
					int num3 = countTiles(x, y, jungle: false, lavaOk: true);
					while ((num3 >= maxTileCount || num3 < 10) && num2 < 500)
					{
						num2++;
						x = genRand.Next(200, Main.maxTilesX - 200);
						y = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 220);
						if (remixWorldGen)
						{
							y = genRand.Next((int)Main.worldSurface + 25, (int)Main.rockLayer);
						}
						num3 = countTiles(x, y, jungle: false, lavaOk: true);
					}
					if (num2 < 500)
					{
						int num4 = genRand.Next(2);
						if ((double)shroomCount > (double)rockCount * 0.75)
						{
							num4 = 80;
						}
						else if (iceCount > 0)
						{
							switch (num4)
							{
							case 0:
								num4 = 40;
								break;
							case 1:
								num4 = 71;
								break;
							}
						}
						else if (lavaCount > 0)
						{
							num4 = 79;
						}
						else
						{
							num4 = genRand.Next(4);
							switch (num4)
							{
							case 0:
								num4 = 59;
								break;
							case 1:
								num4 = 61;
								break;
							case 2:
								num4 = 170;
								break;
							case 3:
								num4 = 171;
								break;
							}
						}
						Spread.Wall(x, y, num4);
					}
				}
				if (remixWorldGen)
				{
					maxTileCount = 1500;
					for (int j = 0; j < (int)((double)Main.maxTilesX * 0.04); j++)
					{
						double num5 = (double)j / ((double)Main.maxTilesX * 0.04);
						progress.Set(num5 * 0.66);
						int num6 = 0;
						int x2 = genRand.Next(200, Main.maxTilesX - 200);
						int y2 = genRand.Next((int)Main.rockLayer, Main.maxTilesY - 350);
						int num7 = countTiles(x2, y2, jungle: false, lavaOk: true);
						while ((num7 >= maxTileCount || num7 < 10) && num6 < 500)
						{
							num6++;
							x2 = genRand.Next(200, Main.maxTilesX - 200);
							y2 = genRand.Next((int)Main.rockLayer, Main.maxTilesY - 350);
							num7 = countTiles(x2, y2, jungle: false, lavaOk: true);
						}
						if (num6 < 500 && iceCount == 0 && lavaCount == 0 && sandCount == 0)
						{
							int wallType = ((genRand.Next(2) != 0) ? 63 : 2);
							Spread.Wall(x2, y2, wallType);
						}
					}
				}
				maxTileCount = 1500;
				double num8 = (double)Main.maxTilesX * 0.02;
				for (int k = 0; (double)k < num8; k++)
				{
					double num9 = (double)k / ((double)Main.maxTilesX * 0.02);
					progress.Set(num9 * 0.33 + 0.66);
					int num10 = 0;
					int num11 = genRand.Next(200, Main.maxTilesX - 200);
					int num12 = genRand.Next((int)Main.worldSurface, GenVars.lavaLine);
					int num13 = 0;
					if (Main.tile[num11, num12].wall == 64)
					{
						num13 = countTiles(num11, num12, jungle: true);
					}
					while ((num13 >= maxTileCount || num13 < 10) && num10 < 1000)
					{
						num10++;
						num11 = genRand.Next(200, Main.maxTilesX - 200);
						num12 = genRand.Next((int)Main.worldSurface, GenVars.lavaLine);
						if (!Main.wallHouse[Main.tile[num11, num12].wall] && Main.tile[num11, num12].wall != 244)
						{
							num13 = ((Main.tile[num11, num12].wall == 64) ? countTiles(num11, num12, jungle: true) : 0);
						}
					}
					if (num10 < 1000)
					{
						Spread.Wall2(num11, num12, 15);
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.UndergroundJungleTrees, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				Main.tileSolid[379] = true;
				progress.Message = Lang.gen[83].Value;
				for (int i = 0; i < Main.maxTilesX; i++)
				{
					progress.Set((double)i / (double)Main.maxTilesX);
					for (int j = (int)Main.worldSurface - 1; j < Main.maxTilesY - 350; j++)
					{
						if (genRand.Next(10) == 0 || drunkWorldGen)
						{
							GrowUndergroundTree(i, j);
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.FloatingIslandHouses, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyFloatingIslands)
			{
				progress.Message = Language.GetTextValue("WorldGeneration.FloatingIslandHouses");
				progress.Set(0.0);
				for (int i = 0; i < GenVars.numIslandHouses; i++)
				{
					progress.Set((float)i / (float)GenVars.numIslandHouses);
					if (!GenVars.skyLake[i])
					{
						IslandHouse(GenVars.floatingIslandHouseX[i], GenVars.floatingIslandHouseY[i], GenVars.floatingIslandStyle[i]);
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.QuickCleanup, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Language.GetTextValue("WorldGeneration.QuickCleanup");
				progress.Set(0.0);
				if (notTheBees)
				{
					NotTheBees();
				}
				Main.tileSolid[137] = false;
				Main.tileSolid[130] = false;
				for (int i = 20; i < Main.maxTilesX - 20; i++)
				{
					progress.Set((float)(i - 20) / (float)(Main.maxTilesX - 40));
					for (int j = 20; j < Main.maxTilesY - 20; j++)
					{
						Tile tile = Main.tile[i, j];
						if (oceanDepths(i, j) && tile.liquid > 0 && tile.liquidType() != 0)
						{
							tile.liquidType(0);
						}
						if ((double)j < Main.worldSurface && oceanDepths(i, j) && !SecretSeed.roundLandmasses.Enabled && tile.type == 53 && tile.active())
						{
							if (tile.bottomSlope())
							{
								tile.slope(0);
							}
							for (int k = j + 1; k < j + genRand.Next(4, 7) && (!Main.tile[i, k].active() || (Main.tile[i, k].type != 397 && Main.tile[i, k].type != 53)) && (!Main.tile[i, k + 1].active() || (Main.tile[i, k + 1].type != 397 && Main.tile[i, k + 1].type != 53 && Main.tile[i, k + 1].type != 495)) && (!Main.tile[i, k + 2].active() || (Main.tile[i, k + 2].type != 397 && Main.tile[i, k + 2].type != 53 && Main.tile[i, k + 2].type != 495)); k++)
							{
								Main.tile[i, k].type = 0;
								Main.tile[i, k].active(active: true);
								Main.tile[i, k].halfBrick(halfBrick: false);
								Main.tile[i, k].slope(0);
							}
						}
						if (tile.wall == 187 || tile.wall == 216)
						{
							if (tile.type == 59 || tile.type == 123 || tile.type == 224)
							{
								tile.type = 397;
							}
							if (tile.type == 368 || tile.type == 367)
							{
								tile.type = 397;
							}
							if (!Main.dualDungeonsSeed)
							{
								if ((double)j <= Main.rockLayer)
								{
									tile.liquid = 0;
								}
								else if (tile.liquid > 0)
								{
									tile.liquid = byte.MaxValue;
									tile.lava(lava: true);
								}
							}
						}
						if ((double)j < Main.worldSurface && tile.active() && tile.type == 53 && Main.tile[i, j + 1].wall == 0 && !SolidTile(i, j + 1))
						{
							ushort num = 0;
							int num2 = 3;
							for (int l = i - num2; l <= i + num2; l++)
							{
								for (int m = j - num2; m <= j + num2; m++)
								{
									if (Main.tile[l, m].wall > 0)
									{
										num = Main.tile[l, m].wall;
										break;
									}
								}
							}
							if (num > 0)
							{
								Main.tile[i, j + 1].wall = num;
								if (tile.wall == 0)
								{
									tile.wall = num;
								}
							}
						}
						if (!tile.active() || !TileID.Sets.SaveSlopes[tile.type])
						{
							tile.ClearSlope();
						}
						else if (!TileID.Sets.Platforms[tile.type] && TileID.Sets.CanBeClearedDuringGeneration[tile.type])
						{
							if (tile.topSlope() || tile.halfBrick())
							{
								if (tile.type != 225 || !tile.halfBrick())
								{
									if (!SolidTile(i, j + 1))
									{
										tile.active(active: false);
									}
									if (Main.tile[i + 1, j].type == 137 || Main.tile[i - 1, j].type == 137)
									{
										tile.active(active: false);
									}
								}
							}
							else if (tile.bottomSlope())
							{
								if (!SolidTile(i, j - 1))
								{
									tile.active(active: false);
								}
								if (Main.tile[i + 1, j].type == 137 || Main.tile[i - 1, j].type == 137)
								{
									tile.active(active: false);
								}
							}
						}
					}
				}
				Main.tileSolid[137] = true;
				Main.tileSolid[130] = true;
			}
		});
		AddGenerationPass(GenPassNameID.PotsGraveyardsAndBoulderPiles, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denySomeGeneration)
			{
				progress.Message = Lang.gen[35].Value;
				if (SecretSeed.addTeleporters.Enabled)
				{
					SecretSeed.DoAddTeleporters();
				}
				if ((dontStarveWorldGen && (drunkWorldGen || getGoodWorldGen) && !tenthAnniversaryWorldGen) || SecretSeed.graveyardBloodmoonStart.Enabled)
				{
					SpawnGraveyardBiomesEverywhere();
				}
				if ((noTrapsWorldGen || SecretSeed.errorWorld.Enabled) && !SecretSeed.Variations.actuallyNoTrapsForRealIMeanIt)
				{
					SetBoulderSolidity(solid: true);
					int num = (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0004);
					if (remixWorldGen)
					{
						num /= 2;
					}
					for (int i = 0; i < num; i++)
					{
						int num2 = genRand.Next(50, Main.maxTilesX - 50);
						int j = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 250);
						if (dontStarveWorldGen && !remixWorldGen && i < num / 10)
						{
							j = genRand.Next(100, Main.maxTilesY - 250);
							while ((double)num2 > (double)Main.maxTilesX * 0.4 && (double)num2 < (double)Main.maxTilesX * 0.6)
							{
								num2 = genRand.Next(50, Main.maxTilesX - 50);
							}
						}
						for (; !Main.tile[num2, j].active() && j < Main.maxTilesY - 250; j++)
						{
						}
						j--;
						if (!Main.tile[num2, j].anyShimmer())
						{
							int num3 = 138;
							if (tenthAnniversaryWorldGen && genRand.Next(5) == 0)
							{
								num3 = 711;
							}
							if (PlaceTile(num2, j, num3, mute: true) && SecretSeed.errorWorld.Enabled && Main.tile[num2, j].type == num3)
							{
								for (int k = num2 - 1; k <= num2; k++)
								{
									for (int l = j - 1; l <= j; l++)
									{
										Main.tile[k, l].invisibleBlock(invisibleBlock: true);
									}
								}
							}
							if (PlaceTile(num2 + 2, j, num3, mute: true) && SecretSeed.errorWorld.Enabled && Main.tile[num2 + 2, j].type == num3)
							{
								for (int m = num2 + 1; m <= num2 + 2; m++)
								{
									for (int n = j - 1; n <= j; n++)
									{
										Main.tile[m, n].invisibleBlock(invisibleBlock: true);
									}
								}
							}
							if (PlaceTile(num2 + 1, j - 2, num3, mute: true) && SecretSeed.errorWorld.Enabled && Main.tile[num2 + 1, j - 2].type == num3)
							{
								for (int num4 = num2; num4 <= num2 + 1; num4++)
								{
									for (int num5 = j - 3; num5 <= j - 2; num5++)
									{
										Main.tile[num4, num5].invisibleBlock(invisibleBlock: true);
									}
								}
							}
						}
					}
					SetBoulderSolidity(solid: false);
				}
				double num6 = (double)(Main.maxTilesX * Main.maxTilesY) * 0.0008;
				if (Main.starGame)
				{
					num6 *= Main.starGameMath(0.2);
				}
				int num7 = 10000;
				if (skyblockWorldGen)
				{
					num7 = 5;
					num6 /= 5.0;
				}
				for (int num8 = 0; (double)num8 < num6; num8++)
				{
					double num9 = (double)num8 / num6;
					progress.Set(num9);
					bool flag = false;
					int num10 = 0;
					while (!flag)
					{
						int num11 = genRand.Next((int)GenVars.worldSurfaceHigh, Main.maxTilesY - 10);
						if (num9 > 0.93)
						{
							num11 = Main.maxTilesY - 150;
						}
						else if (num9 > 0.75)
						{
							num11 = (int)GenVars.worldSurfaceLow;
						}
						int num12 = genRand.Next(20, Main.maxTilesX - 20);
						bool flag2 = false;
						for (int num13 = num11; num13 < Main.maxTilesY - 20; num13++)
						{
							if (!flag2)
							{
								if (Main.tile[num12, num13].active() && Main.tileSolid[Main.tile[num12, num13].type])
								{
									if (!Main.tile[num12, num13 - 1].anyLava() && !Main.tile[num12, num13 - 1].anyShimmer())
									{
										flag2 = true;
									}
								}
								else if (skyblockWorldGen && (double)num13 > Main.worldSurface + 50.0)
								{
									flag2 = true;
								}
							}
							else if (!((double)num13 < Main.worldSurface) || Main.tile[num12, num13].wall != 0)
							{
								int style = genRand.Next(0, 4);
								Tile tile = Main.tile[num12, num13 + 1];
								if (tile.active() && !oceanDepths(num12, num13) && !Main.tile[num12, num13].anyShimmer() && !Main.tile[num12, num13].anyLava())
								{
									ushort type = tile.type;
									if (type == 19)
									{
										_ = tile.frameY % 18;
									}
									ushort wall = Main.tile[num12, num13].wall;
									if (type == 147 || type == 161 || type == 162)
									{
										style = genRand.Next(4, 7);
									}
									if (type == 60)
									{
										style = genRand.Next(7, 10);
									}
									if (Main.wallDungeon[wall] || type == 41 || type == 43 || type == 44 || type == 481 || type == 482 || type == 483 || IsDungeonPlatformOrShelf(tile))
									{
										style = genRand.Next(10, 13);
									}
									if (type == 23 || type == 25 || type == 22 || type == 163)
									{
										style = genRand.Next(16, 19);
									}
									if (type == 199 || type == 203 || type == 204 || type == 200)
									{
										style = genRand.Next(22, 25);
									}
									if (type == 367)
									{
										style = genRand.Next(31, 34);
									}
									if (type == 226)
									{
										style = genRand.Next(28, 31);
									}
									if (wall == 187 || wall == 216 || wall == 223)
									{
										style = genRand.Next(34, 37);
									}
									if (num13 > Main.UnderworldLayer)
									{
										style = genRand.Next(13, 16);
									}
									if (PlacePot(num12, num13, 28, style))
									{
										flag = true;
										break;
									}
								}
							}
						}
						num10++;
						if (num10 >= num7)
						{
							flag = true;
							break;
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.Hellforges, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[36].Value;
				int num = Main.maxTilesX / 200;
				for (int i = 0; i < num; i++)
				{
					float num2 = (float)i / (float)num;
					progress.Set(num2);
					bool flag = false;
					int num3 = 0;
					while (!flag)
					{
						int num4 = genRand.Next(1, Main.maxTilesX);
						int j = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 30);
						try
						{
							if (Main.tile[num4, j].wall == 13 || Main.tile[num4, j].wall == 14)
							{
								for (; !Main.tile[num4, j].active() && j < Main.maxTilesY - 20; j++)
								{
								}
								j--;
								PlaceTile(num4, j, 77);
								if (Main.tile[num4, j].type == 77)
								{
									flag = true;
								}
								else
								{
									num3++;
									if (num3 >= 10000)
									{
										flag = true;
									}
								}
							}
						}
						catch
						{
							num3++;
							if (num3 >= 10000)
							{
								flag = true;
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.SpreadingGrassOnSurfaceSunflowersEvilsOnSurfaceAndLavaCleanup, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration && (!notTheBees || remixWorldGen || tenthAnniversaryWorldGen))
			{
				progress.Message = Lang.gen[37].Value;
				for (int i = 50; i < Main.maxTilesX - 50; i++)
				{
					progress.Set((float)(i - 50) / (float)(Main.maxTilesX - 100), 0.0, 0.30000001192092896);
					for (int j = 50; (double)j <= Main.worldSurface; j++)
					{
						if (Main.tile[i, j].active())
						{
							int type = Main.tile[i, j].type;
							if (Main.tile[i, j].active() && type == 60)
							{
								for (int k = i - 1; k <= i + 1; k++)
								{
									for (int l = j - 1; l <= j + 1; l++)
									{
										if (Main.tile[k, l].active() && Main.tile[k, l].type == 0)
										{
											if (!Main.tile[k, l - 1].active())
											{
												Main.tile[k, l].type = 60;
											}
											else
											{
												Main.tile[k, l].type = 59;
											}
										}
									}
								}
							}
							else if (type == 1 || type == 40 || TileID.Sets.Ore[type])
							{
								int num = 3;
								bool flag = false;
								ushort num2 = 0;
								for (int m = i - num; m <= i + num; m++)
								{
									for (int n = j - num; n <= j + num; n++)
									{
										if (Main.tile[m, n].active())
										{
											if (Main.tile[m, n].type == 53 || num2 == 53)
											{
												num2 = 53;
											}
											else if (Main.tile[m, n].type == 59 || Main.tile[m, n].type == 60 || Main.tile[m, n].type == 147 || Main.tile[m, n].type == 161 || Main.tile[m, n].type == 199 || Main.tile[m, n].type == 23)
											{
												num2 = Main.tile[m, n].type;
											}
										}
										else if (n < j && Main.tile[m, n].wall == 0)
										{
											flag = true;
										}
									}
								}
								if (flag)
								{
									switch (num2)
									{
									case 23:
									case 199:
										if (Main.tile[i, j - 1].active())
										{
											num2 = 0;
										}
										break;
									case 59:
									case 60:
										if (i >= GenVars.jungleMinX && i <= GenVars.jungleMaxX)
										{
											num2 = (ushort)(Main.tile[i, j - 1].active() ? 59 : 60);
										}
										break;
									}
									Main.tile[i, j].type = num2;
								}
							}
						}
					}
				}
				for (int num3 = 10; num3 < Main.maxTilesX - 10; num3++)
				{
					progress.Set((float)(num3 - 10) / (float)(Main.maxTilesX - 20), 0.30000001192092896, 0.550000011920929);
					bool flag2 = true;
					for (int num4 = 0; (double)num4 < Main.worldSurface - 1.0; num4++)
					{
						if (Main.tile[num3, num4].active())
						{
							if (flag2 && Main.tile[num3, num4].type == 0)
							{
								try
								{
									grassSpread = 0;
									SpreadGrass(num3, num4);
								}
								catch
								{
									grassSpread = 0;
									SpreadGrass(num3, num4, 0, 2, repeat: false);
								}
							}
							if ((double)num4 > GenVars.worldSurfaceHigh)
							{
								break;
							}
							flag2 = false;
						}
						else if (Main.tile[num3, num4].wall == 0)
						{
							flag2 = true;
						}
					}
				}
				if (remixWorldGen)
				{
					progress.Set(0.550000011920929);
					for (int num5 = 5; num5 < Main.maxTilesX - 5; num5++)
					{
						for (int num6 = GenVars.remixSurfaceLayerLow + genRand.Next(-1, 2); num6 < GenVars.remixSurfaceLayerHigh; num6++)
						{
							if (Main.tile[num5, num6].type == 0 && Main.tile[num5, num6].active() && (!Main.tile[num5 - 1, num6 - 1].active() || !Main.tile[num5, num6 - 1].active() || !Main.tile[num5 + 1, num6 - 1].active() || !Main.tile[num5 - 1, num6].active() || !Main.tile[num5 + 1, num6].active() || !Main.tile[num5 - 1, num6 + 1].active() || !Main.tile[num5, num6 + 1].active() || !Main.tile[num5 + 1, num6 + 1].active()))
							{
								Main.tile[num5, num6].type = 2;
							}
						}
					}
					progress.Set(0.6499999761581421);
					for (int num7 = 5; num7 < Main.maxTilesX - 5; num7++)
					{
						for (int num8 = GenVars.remixSurfaceLayerLow + genRand.Next(-1, 2); num8 < GenVars.remixSurfaceLayerHigh; num8++)
						{
							if (Main.tile[num7, num8].type == 2 && !Main.tile[num7, num8 - 1].active() && genRand.Next(20) == 0)
							{
								PlaceTile(num7, num8 - 1, 27, mute: true);
							}
						}
					}
					progress.Set(0.75);
					int conversionType = 1;
					if (crimson)
					{
						conversionType = 4;
					}
					int num9 = Main.maxTilesX / 7;
					for (int num10 = 10; num10 < Main.maxTilesX - 10; num10++)
					{
						progress.Set((float)(num10 - 10) / (float)(Main.maxTilesX - 20), 0.75, 0.8999999761581421);
						for (int num11 = 10; num11 < Main.maxTilesY - 10; num11++)
						{
							if ((double)num11 < Main.worldSurface + (double)genRand.Next(3) || num10 < num9 + genRand.Next(3) || num10 >= Main.maxTilesX - num9 - genRand.Next(3))
							{
								if (drunkWorldGen)
								{
									if (GenVars.crimsonLeft)
									{
										if (num10 < Main.maxTilesX / 2 + genRand.Next(-2, 3))
										{
											Convert(num10, num11, 4);
										}
										else
										{
											Convert(num10, num11, 1);
										}
									}
									else if (num10 < Main.maxTilesX / 2 + genRand.Next(-2, 3))
									{
										Convert(num10, num11, 1);
									}
									else
									{
										Convert(num10, num11, 4);
									}
								}
								else
								{
									Convert(num10, num11, conversionType);
								}
								Main.tile[num10, num11].color(0);
								Main.tile[num10, num11].wallColor(0);
							}
						}
					}
					progress.Set(0.8999999761581421);
					if (remixWorldGen)
					{
						Main.tileSolid[225] = true;
						int num12 = (int)((double)Main.maxTilesX * 0.31);
						int num13 = (int)((double)Main.maxTilesX * 0.69);
						_ = Main.maxTilesY;
						int num14 = Main.maxTilesY - 135;
						_ = Main.maxTilesY;
						Liquid.QuickWater(-2);
						for (int num15 = num12; num15 < num13 + 15; num15++)
						{
							for (int num16 = Main.maxTilesY - 200; num16 < num14; num16++)
							{
								Main.tile[num15, num16].liquid = 0;
							}
						}
						Main.tileSolid[225] = false;
						Main.tileSolid[484] = false;
					}
				}
				progress.Set(1.0);
			}
		});
		AddGenerationPass(GenPassNameID.SurfaceOreAndStone, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Set(1.0);
				int num = genRand.Next(Main.maxTilesX * 5 / 4200, Main.maxTilesX * 10 / 4200);
				for (int i = 0; i < num; i++)
				{
					int num2 = Main.maxTilesX / 420;
					while (num2 > 0)
					{
						num2--;
						int num3 = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
						while ((double)num3 >= (double)Main.maxTilesX * 0.48 && (double)num3 <= (double)Main.maxTilesX * 0.52)
						{
							num3 = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
						}
						int y = genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurface);
						bool flag = false;
						for (int j = 0; j < GenVars.numOrePatch; j++)
						{
							if (Math.Abs(num3 - GenVars.orePatchX[j]) < 200)
							{
								flag = true;
							}
						}
						if (!flag && OrePatch(num3, y))
						{
							if (GenVars.numOrePatch < GenVars.maxOrePatch - 1)
							{
								GenVars.orePatchX[GenVars.numOrePatch] = num3;
								GenVars.numOrePatch++;
							}
							break;
						}
					}
				}
				num = genRand.Next(1, Main.maxTilesX * 7 / 4200);
				for (int k = 0; k < num; k++)
				{
					int num4 = Main.maxTilesX / 420;
					while (num4 > 0)
					{
						num4--;
						int num5 = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
						while ((double)num5 >= (double)Main.maxTilesX * 0.47 && (double)num5 <= (double)Main.maxTilesX * 0.53)
						{
							num5 = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
						}
						int y2 = genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurface);
						bool flag2 = false;
						for (int l = 0; l < GenVars.numOrePatch; l++)
						{
							if (Math.Abs(num5 - GenVars.orePatchX[l]) < 100)
							{
								flag2 = true;
							}
						}
						if (!flag2 && StonePatch(num5, y2))
						{
							break;
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.FallenLogsAndWaterFeatures, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denySomeGeneration)
			{
				if (SecretSeed.extraLiquid.Enabled && !SecretSeed.roundLandmasses.Enabled)
				{
					progress.Message = Language.GetTextValue("WorldGeneration.WaterFeatures");
					SecretSeed.DoExtraLiquidAddBubbleBlocks();
				}
				if (!SecretSeed.noSurface.Enabled)
				{
					progress.Message = Lang.gen[85].Value;
					int num = Main.maxTilesX / 2100;
					num = ((!remixWorldGen) ? (num + genRand.Next(-1, 2)) : (num + genRand.Next(0, 2)));
					for (int i = 0; i < num; i++)
					{
						progress.Set((double)i / (double)num);
						int num2 = beachDistance + 20;
						int num3 = 30000;
						int num4 = 5000;
						if (skyblockWorldGen)
						{
							num3 /= 10;
							num4 /= 10;
						}
						while (num3 > 0)
						{
							num3--;
							int num5 = genRand.Next(num2, Main.maxTilesX - num2);
							int j = genRand.Next(10, (int)Main.worldSurface);
							if (remixWorldGen)
							{
								j = genRand.Next(GenVars.remixSurfaceLayerLow, GenVars.remixSurfaceLayerHigh);
							}
							bool flag = false;
							if (num3 < num4)
							{
								flag = true;
							}
							if (num3 > num4 / 2)
							{
								while ((double)num5 > (double)Main.maxTilesX * 0.4 && (double)num5 < (double)Main.maxTilesX * 0.6)
								{
									num5 = genRand.Next(num2, Main.maxTilesX - num2);
								}
							}
							if (!Main.tile[num5, j].active() && Main.tile[num5, j].wall == 0)
							{
								bool flag2 = true;
								if (remixWorldGen)
								{
									for (; !Main.tile[num5, j].active() && Main.tile[num5, j].wall == 0 && j <= GenVars.remixSurfaceLayerHigh; j++)
									{
									}
								}
								else
								{
									for (; !Main.tile[num5, j].active() && Main.tile[num5, j].wall == 0 && (double)j <= Main.worldSurface; j++)
									{
									}
								}
								if ((double)j > Main.worldSurface - 10.0 && !remixWorldGen)
								{
									flag2 = false;
								}
								else if (!flag)
								{
									int num6 = 50;
									for (int k = num5 - num6; k < num5 + num6; k++)
									{
										if (k > 10 && k < Main.maxTilesX - 10)
										{
											for (int l = j - num6; l < j + num6; l++)
											{
												if (l > 10 && l < Main.maxTilesY - 10)
												{
													int type = Main.tile[k, l].type;
													switch (type)
													{
													case 189:
														flag2 = false;
														break;
													case 53:
														flag2 = false;
														break;
													default:
														if (Main.tileDungeon[type])
														{
															flag2 = false;
														}
														else if (TileID.Sets.Crimson[type])
														{
															flag2 = false;
														}
														else if (TileID.Sets.Corrupt[type])
														{
															flag2 = false;
														}
														break;
													}
												}
											}
										}
									}
									if (flag2)
									{
										int num7 = 10;
										int num8 = 10;
										for (int m = num5 - num7; m < num5 + num7; m++)
										{
											for (int n = j - num8; n < j - 1; n++)
											{
												if (Main.tile[m, n].active() && Main.tileSolid[Main.tile[m, n].type])
												{
													flag2 = false;
												}
												if (Main.tile[m, n].wall != 0)
												{
													flag2 = false;
												}
											}
										}
									}
								}
								if (flag2 && (Main.tile[num5, j - 1].liquid == 0 || num3 < num4 / 5) && (Main.tile[num5, j].type == 2 || (notTheBees && Main.tile[num5, j].type == 60) || (SecretSeed.worldIsFrozen.Enabled && Main.tile[num5, j].type == 147) || (SecretSeed.surfaceIsDesert.Enabled && Main.tile[num5, j].type == 53)) && (Main.tile[num5 - 1, j].type == 2 || (notTheBees && Main.tile[num5 - 1, j].type == 60) || (SecretSeed.worldIsFrozen.Enabled && Main.tile[num5 - 1, j].type == 147) || (SecretSeed.surfaceIsDesert.Enabled && Main.tile[num5 - 1, j].type == 53)) && (Main.tile[num5 + 1, j].type == 2 || (notTheBees && Main.tile[num5 + 1, j].type == 60) || (SecretSeed.worldIsFrozen.Enabled && Main.tile[num5 + 1, j].type == 147) || (SecretSeed.surfaceIsDesert.Enabled && Main.tile[num5 + 1, j].type == 53)))
								{
									j--;
									PlaceTile(num5, j, 488);
									if (Main.tile[num5, j].active() && Main.tile[num5, j].type == 488)
									{
										if (genRand.Next(2) == 0)
										{
											GenVars.logX = num5;
											GenVars.logY = j;
										}
										num3 = -1;
									}
								}
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.Traps, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denySomeGeneration && !SecretSeed.Variations.actuallyNoTrapsForRealIMeanIt && (!notTheBees || noTrapsWorldGen || remixWorldGen))
			{
				Main.tileSolid[379] = false;
				placingTraps = true;
				progress.Message = Lang.gen[34].Value;
				if (noTrapsWorldGen)
				{
					progress.Message = Lang.gen[91].Value;
				}
				double num = (double)Main.maxTilesX * 0.05;
				if (noTrapsWorldGen)
				{
					num = (((tenthAnniversaryWorldGen || notTheBees) && remixWorldGen) ? (num * 5.0) : ((!tenthAnniversaryWorldGen && !notTheBees) ? (num * 100.0) : (num * 2.0)));
				}
				else if (getGoodWorldGen)
				{
					num *= 1.5;
				}
				if (Main.starGame)
				{
					num *= Main.starGameMath(0.2);
				}
				int num2 = 1150;
				if (skyblockWorldGen)
				{
					num /= 5.0;
					num2 = 100;
				}
				int type = -1;
				for (int i = 0; (double)i < num; i++)
				{
					progress.Set((double)i / num / 2.0);
					for (int j = 0; j < num2; j++)
					{
						if (noTrapsWorldGen)
						{
							int num3 = genRand.Next(50, Main.maxTilesX - 50);
							int num4 = genRand.Next(50, Main.maxTilesY - 50);
							if (remixWorldGen)
							{
								num4 = genRand.Next(50, Main.maxTilesY - 210);
							}
							if (((double)num4 > Main.worldSurface || Main.tile[num3, num4].wall > 0) && placeTrap(num3, num4, type))
							{
								break;
							}
						}
						else
						{
							int num5 = genRand.Next(200, Main.maxTilesX - 200);
							int num6 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 210);
							while (oceanDepths(num5, num6))
							{
								num5 = genRand.Next(200, Main.maxTilesX - 200);
								num6 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 210);
							}
							if (Main.tile[num5, num6].wall == 0 && placeTrap(num5, num6, type))
							{
								break;
							}
						}
					}
				}
				if (noTrapsWorldGen)
				{
					num = Main.maxTilesX * 3;
					if (tenthAnniversaryWorldGen)
					{
						num = Main.maxTilesX / 3;
					}
					if (Main.starGame)
					{
						num *= Main.starGameMath(0.2);
					}
					for (int k = 0; (double)k < num; k++)
					{
						if (Main.remixWorld)
						{
							placeTNTBarrel(genRand.Next(50, Main.maxTilesX - 50), genRand.Next((int)Main.worldSurface, (int)((double)(Main.maxTilesY - 350) + Main.rockLayer) / 2));
						}
						else
						{
							placeTNTBarrel(genRand.Next(50, Main.maxTilesX - 50), genRand.Next((int)Main.rockLayer, Main.maxTilesY - 200));
						}
					}
				}
				num = (double)Main.maxTilesX * 0.003;
				if (noTrapsWorldGen)
				{
					num *= 5.0;
				}
				else if (getGoodWorldGen)
				{
					num *= 1.5;
				}
				for (int l = 0; (double)l < num; l++)
				{
					progress.Set((double)l / num / 2.0 + 0.5);
					for (int m = 0; m < 20000; m++)
					{
						int num7 = genRand.Next((int)((double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.85));
						int num8 = genRand.Next((int)Main.worldSurface + 20, Main.maxTilesY - 210);
						if (Main.tile[num7, num8].wall == 187 && PlaceSandTrap(num7, num8))
						{
							break;
						}
					}
				}
				if (drunkWorldGen && !noTrapsWorldGen && !notTheBees && !getGoodWorldGen)
				{
					for (int n = 0; n < 8; n++)
					{
						progress.Message = Lang.gen[34].Value;
						num = 100.0;
						for (int num9 = 0; (double)num9 < num; num9++)
						{
							progress.Set((double)num9 / num);
							Thread.Sleep(10);
						}
					}
				}
				if (noTrapsWorldGen)
				{
					SetBoulderSolidity(solid: true);
				}
				placingTraps = false;
				Main.tileSolid[379] = true;
			}
		});
		AddGenerationPass(GenPassNameID.Piles, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denySomeGeneration)
			{
				progress.Message = Lang.gen[89].Value;
				progress.Set(0.0);
				Main.tileSolid[379] = false;
				Main.tileSolid[229] = false;
				Main.tileSolid[190] = false;
				Main.tileSolid[196] = false;
				Main.tileSolid[189] = false;
				Main.tileSolid[717] = false;
				Main.tileSolid[718] = false;
				Main.tileSolid[719] = false;
				Main.tileSolid[202] = false;
				Main.tileSolid[460] = false;
				Main.tileSolid[484] = false;
				if (noTrapsWorldGen)
				{
					SetBoulderSolidity(solid: false);
				}
				float num = 7f;
				float num2 = 1f / num;
				float num3 = (float)Main.maxTilesX * 0.06f;
				for (int i = 0; (float)i < num3; i++)
				{
					if (progress != null)
					{
						float num4 = (float)i / num3;
						progress.Set(num4 * num2);
					}
					int num5 = GetPileGenerationAttempts();
					bool flag = false;
					while (!flag && num5 > 0)
					{
						num5--;
						int num6 = genRand.Next(25, Main.maxTilesX - 25);
						int j = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 300);
						while (oceanDepths(num6, j))
						{
							num6 = genRand.Next(25, Main.maxTilesX - 25);
							j = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 300);
						}
						if (!Main.tile[num6, j].active())
						{
							int num7 = 186;
							for (; !Main.tile[num6, j + 1].active() && j < Main.maxTilesY - 5; j++)
							{
							}
							Tile tile = Main.tile[num6, j];
							Tile tile2 = Main.tile[num6, j + 1];
							if (tile2.active())
							{
								int num8 = genRand.Next(22);
								if (num8 >= 16 && num8 <= 22)
								{
									num8 = genRand.Next(22);
								}
								if ((tile2.type == 0 || tile2.type == 1 || Main.tileMoss[tile2.type]) && genRand.Next(5) == 0)
								{
									num8 = genRand.Next(23, 29);
									num7 = 187;
								}
								if (j > Main.maxTilesY - 300 || Main.wallDungeon[tile.wall] || tile2.type == 30 || tile2.type == 19 || tile2.type == 25 || tile2.type == 203)
								{
									num8 = genRand.Next(7);
									num7 = 186;
								}
								if (tile2.type == 147 || tile2.type == 161 || tile2.type == 162)
								{
									num8 = genRand.Next(26, 32);
									num7 = 186;
								}
								if (tile2.type == 60)
								{
									num7 = 187;
									num8 = genRand.Next(6);
								}
								if ((tile2.type == 57 || tile2.type == 58) && genRand.Next(3) < 2)
								{
									num7 = 187;
									num8 = genRand.Next(6, 9);
								}
								if (tile2.type == 226)
								{
									num7 = 187;
									num8 = genRand.Next(18, 23);
								}
								if (tile2.type == 70)
								{
									num8 = genRand.Next(32, 35);
									num7 = 186;
								}
								if (tile2.type == 396 || tile2.type == 397 || tile2.type == 404)
								{
									num8 = genRand.Next(29, 35);
									num7 = 187;
								}
								if (tile2.type == 368)
								{
									num8 = genRand.Next(35, 41);
									num7 = 187;
								}
								if (tile2.type == 367)
								{
									num8 = genRand.Next(41, 47);
									num7 = 187;
								}
								if (num7 == 186 && num8 >= 7 && num8 <= 15 && genRand.Next(75) == 0)
								{
									num7 = 187;
									num8 = 17;
								}
								if (Main.wallDungeon[tile.wall] && genRand.Next(3) != 0)
								{
									flag = true;
								}
								else
								{
									if (!tile.anyShimmer())
									{
										PlaceTile(num6, j, num7, mute: true, forced: false, -1, num8);
									}
									if (Main.tile[num6, j].type == 186 || Main.tile[num6, j].type == 187)
									{
										flag = true;
									}
									if (flag && num7 == 186 && num8 <= 7)
									{
										int num9 = genRand.Next(1, 5);
										for (int k = 0; k < num9; k++)
										{
											int num10 = num6 + genRand.Next(-10, 11);
											int l = j - genRand.Next(5);
											if (!Main.tile[num10, l].active())
											{
												for (; !Main.tile[num10, l + 1].active() && l < Main.maxTilesY - 5; l++)
												{
												}
												int pileStyle = genRand.Next(12, 36);
												PlaceSmallPile(num10, l, pileStyle, 0, 185);
											}
										}
									}
								}
							}
						}
					}
				}
				num3 = (float)Main.maxTilesX * 0.01f;
				for (int m = 0; (float)m < num3; m++)
				{
					if (progress != null)
					{
						float num11 = (float)m / num3;
						progress.Set(num2 + num11 * num2);
					}
					int num12 = GetPileGenerationAttempts();
					bool flag2 = false;
					while (!flag2 && num12 > 0)
					{
						num12--;
						int num13 = genRand.Next(25, Main.maxTilesX - 25);
						int n = genRand.Next(Main.maxTilesY - 300, Main.maxTilesY - 10);
						if (!Main.tile[num13, n].active())
						{
							int num14 = 186;
							for (; !Main.tile[num13, n + 1].active() && n < Main.maxTilesY - 5; n++)
							{
							}
							Tile tile3 = Main.tile[num13, n];
							Tile tile4 = Main.tile[num13, n + 1];
							if (tile4.active())
							{
								int num15 = genRand.Next(22);
								if (num15 >= 16 && num15 <= 22)
								{
									num15 = genRand.Next(22);
								}
								if (n > Main.maxTilesY - 300 || Main.wallDungeon[tile3.wall] || tile4.type == 30 || tile4.type == 19)
								{
									num15 = genRand.Next(7);
								}
								if ((tile4.type == 57 || tile4.type == 58) && genRand.Next(3) < 2)
								{
									num14 = 187;
									num15 = genRand.Next(6, 9);
								}
								if (tile4.type == 147 || tile4.type == 161 || tile4.type == 162)
								{
									num15 = genRand.Next(26, 32);
								}
								PlaceTile(num13, n, num14, mute: true, forced: false, -1, num15);
								if (Main.tile[num13, n].type == 186 || Main.tile[num13, n].type == 187)
								{
									flag2 = true;
								}
								if (flag2 && num14 == 186 && num15 <= 7)
								{
									int num16 = genRand.Next(1, 5);
									for (int num17 = 0; num17 < num16; num17++)
									{
										int num18 = num13 + genRand.Next(-10, 11);
										int num19 = n - genRand.Next(5);
										if (!Main.tile[num18, num19].active())
										{
											for (; !Main.tile[num18, num19 + 1].active() && num19 < Main.maxTilesY - 5; num19++)
											{
											}
											int pileStyle2 = genRand.Next(12, 36);
											PlaceSmallPile(num18, num19, pileStyle2, 0, 185);
										}
									}
								}
							}
						}
					}
				}
				num3 = (float)Main.maxTilesX * 0.03f;
				for (int num20 = 0; (float)num20 < num3; num20++)
				{
					if (progress != null)
					{
						float num21 = (float)num20 / num3;
						progress.Set(num2 * 2f + num21 * num2);
					}
					int num22 = GetPileGenerationAttempts();
					bool flag3 = false;
					while (!flag3 && num22 > 0)
					{
						num22--;
						int num23 = 186;
						int num24 = genRand.Next(25, Main.maxTilesX - 25);
						int num25 = genRand.Next(10, (int)Main.worldSurface);
						while (oceanDepths(num24, num25))
						{
							num24 = genRand.Next(25, Main.maxTilesX - 25);
							num25 = genRand.Next(10, (int)Main.worldSurface);
						}
						if (!Main.tile[num24, num25].active())
						{
							for (; !Main.tile[num24, num25 + 1].active() && num25 < Main.maxTilesY - 5; num25++)
							{
							}
							Tile tile5 = Main.tile[num24, num25];
							Tile tile6 = Main.tile[num24, num25 + 1];
							if (tile6.active())
							{
								int num26 = genRand.Next(7, 13);
								if (num25 > Main.maxTilesY - 300 || Main.wallDungeon[tile5.wall] || tile6.type == 30 || tile6.type == 19 || tile6.type == 25 || tile6.type == 204 || tile6.type == 234 || tile6.type == 112 || (tile6.type >= 0 && Main.tileDungeon[tile6.type]))
								{
									num26 = -1;
								}
								if (tile6.type == 147 || tile6.type == 161 || tile6.type == 162)
								{
									num26 = genRand.Next(26, 32);
								}
								if (tile6.type == 53)
								{
									num23 = 187;
									num26 = genRand.Next(52, 55);
								}
								if (tile6.type == 2 || (Main.tile[num24 - 1, num25 + 1].active() && Main.tile[num24 - 1, num25 + 1].type == 2) || (Main.tile[num24 + 1, num25 + 1].active() && Main.tile[num24 + 1, num25 + 1].type == 2))
								{
									num23 = 187;
									num26 = genRand.Next(14, 17);
								}
								if (tile6.type == 151 || tile6.type == 274)
								{
									num23 = 186;
									num26 = genRand.Next(7);
								}
								if (num26 >= 0)
								{
									PlaceTile(num24, num25, num23, mute: true, forced: false, -1, num26);
								}
								if (Main.tile[num24, num25].type == num23)
								{
									flag3 = true;
								}
							}
						}
					}
				}
				num3 = (float)Main.maxTilesX * 0.0035f;
				for (int num27 = 0; (float)num27 < num3; num27++)
				{
					if (progress != null)
					{
						float num28 = (float)num27 / num3;
						progress.Set(num2 * 3f + num28 * num2);
					}
					int num29 = GetPileGenerationAttempts();
					bool flag4 = false;
					while (!flag4 && num29 > 0)
					{
						num29--;
						int num30 = genRand.Next(25, Main.maxTilesX - 25);
						int num31 = genRand.Next(10, (int)Main.worldSurface);
						if (!Main.tile[num30, num31].active() && Main.tile[num30, num31].wall > 0)
						{
							int num32 = 186;
							for (; !Main.tile[num30, num31 + 1].active() && num31 < Main.maxTilesY - 5; num31++)
							{
							}
							Tile tile7 = Main.tile[num30, num31];
							Tile tile8 = Main.tile[num30, num31 + 1];
							if (tile8.active())
							{
								int num33 = genRand.Next(7, 13);
								if (num31 > Main.maxTilesY - 300 || Main.wallDungeon[tile7.wall] || tile8.type == 30 || tile8.type == 19 || (tile8.type >= 0 && Main.tileDungeon[tile8.type]))
								{
									num33 = -1;
								}
								if (tile8.type == 25)
								{
									num33 = genRand.Next(7);
								}
								if (tile8.type == 147 || tile8.type == 161 || tile8.type == 162)
								{
									num33 = genRand.Next(26, 32);
								}
								if (tile8.type == 2 || (Main.tile[num30 - 1, num31 + 1].active() && Main.tile[num30 - 1, num31 + 1].type == 2) || (Main.tile[num30 + 1, num31 + 1].active() && Main.tile[num30 + 1, num31 + 1].type == 2))
								{
									num32 = 187;
									num33 = genRand.Next(14, 17);
								}
								if (tile8.type == 151 || tile8.type == 274)
								{
									num32 = 186;
									num33 = genRand.Next(7);
								}
								if (num33 >= 0)
								{
									PlaceTile(num30, num31, num32, mute: true, forced: false, -1, num33);
								}
								if (Main.tile[num30, num31].type == num32)
								{
									flag4 = true;
								}
								if (flag4 && num33 <= 7)
								{
									int num34 = genRand.Next(1, 5);
									for (int num35 = 0; num35 < num34; num35++)
									{
										int num36 = num30 + genRand.Next(-10, 11);
										int num37 = num31 - genRand.Next(5);
										if (!Main.tile[num36, num37].active())
										{
											for (; !Main.tile[num36, num37 + 1].active() && num37 < Main.maxTilesY - 5; num37++)
											{
											}
											int pileStyle3 = genRand.Next(12, 36);
											PlaceSmallPile(num36, num37, pileStyle3, 0, 185);
										}
									}
								}
							}
						}
					}
				}
				num3 = (float)Main.maxTilesX * 0.6f;
				for (int num38 = 0; (float)num38 < num3; num38++)
				{
					if (progress != null)
					{
						float num39 = (float)num38 / num3;
						progress.Set(num2 * 4f + num39 * num2);
					}
					int num40 = GetPileGenerationAttempts();
					bool flag5 = false;
					while (!flag5 && num40 > 0)
					{
						num40--;
						int num41 = genRand.Next(25, Main.maxTilesX - 25);
						int num42 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 20);
						if (Main.tile[num41, num42].wall == 87 && genRand.Next(2) == 0)
						{
							num41 = genRand.Next(25, Main.maxTilesX - 25);
							num42 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 20);
						}
						while (oceanDepths(num41, num42))
						{
							num41 = genRand.Next(25, Main.maxTilesX - 25);
							num42 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 20);
						}
						if (!Main.tile[num41, num42].active())
						{
							for (; !Main.tile[num41, num42 + 1].active() && num42 < Main.maxTilesY - 5; num42++)
							{
							}
							Tile tile9 = Main.tile[num41, num42];
							Tile tile10 = Main.tile[num41, num42 + 1];
							if (tile10.active())
							{
								int num43 = genRand.Next(2);
								int num44 = genRand.Next(36);
								if (num44 >= 28 && num44 <= 35)
								{
									num44 = genRand.Next(36);
								}
								if (num43 == 1)
								{
									num44 = genRand.Next(25);
									if (num44 >= 16 && num44 <= 24)
									{
										num44 = genRand.Next(25);
									}
								}
								if (num42 > Main.maxTilesY - 300)
								{
									if (num43 == 0)
									{
										num44 = genRand.Next(12, 28);
									}
									if (num43 == 1)
									{
										num44 = genRand.Next(6, 16);
									}
								}
								if (Main.wallDungeon[tile9.wall] || tile9.wall == 87 || tile10.type == 30 || tile10.type == 19 || tile10.type == 25 || tile10.type == 203)
								{
									if (num43 == 0 && num44 < 12)
									{
										num44 += 12;
									}
									if (num43 == 1 && num44 < 6)
									{
										num44 += 6;
									}
									if (num43 == 1 && num44 >= 17)
									{
										num44 -= 10;
									}
								}
								if (tile10.type == 147 || tile10.type == 161 || tile10.type == 162)
								{
									if (num43 == 0 && num44 < 12)
									{
										num44 += 36;
									}
									if (num43 == 1 && num44 >= 20)
									{
										num44 += 6;
									}
									if (num43 == 1 && num44 < 6)
									{
										num44 += 25;
									}
								}
								if (tile9.liquid <= 0 && (tile10.type == 53 || tile10.type == 397 || tile10.type == 396))
								{
									if (num43 == 0)
									{
										num44 = genRand.Next(73, 78);
									}
									if (num43 == 1)
									{
										num44 = genRand.Next(62, 65);
									}
								}
								if (tile10.type == 151 || tile10.type == 274)
								{
									if (num43 == 0)
									{
										num44 = genRand.Next(12, 28);
									}
									if (num43 == 1)
									{
										num44 = genRand.Next(12, 19);
									}
								}
								if (tile10.type == 368)
								{
									if (num43 == 0)
									{
										num44 = genRand.Next(60, 66);
									}
									if (num43 == 1)
									{
										num44 = genRand.Next(47, 53);
									}
								}
								if (tile10.type == 367)
								{
									if (num43 == 0)
									{
										num44 = genRand.Next(66, 72);
									}
									if (num43 == 1)
									{
										num44 = genRand.Next(53, 59);
									}
								}
								if (tile10.type >= 0 && Main.tileDungeon[tile10.type])
								{
									flag5 = false;
								}
								else if (Main.wallDungeon[tile9.wall] && genRand.Next(3) != 0)
								{
									flag5 = true;
								}
								else if (!tile9.anyShimmer())
								{
									flag5 = PlaceSmallPile(num41, num42, num44, num43, 185);
								}
								if (flag5 && num43 == 1 && num44 >= 6 && num44 <= 15)
								{
									int num45 = genRand.Next(1, 5);
									for (int num46 = 0; num46 < num45; num46++)
									{
										int num47 = num41 + genRand.Next(-10, 11);
										int num48 = num42 - genRand.Next(5);
										if (!Main.tile[num47, num48].active())
										{
											for (; !Main.tile[num47, num48 + 1].active() && num48 < Main.maxTilesY - 5; num48++)
											{
											}
											int pileStyle4 = genRand.Next(12, 36);
											PlaceSmallPile(num47, num48, pileStyle4, 0, 185);
										}
									}
								}
							}
						}
					}
				}
				num3 = (float)Main.maxTilesX * 0.02f;
				for (int num49 = 0; (float)num49 < num3; num49++)
				{
					if (progress != null)
					{
						float num50 = (float)num49 / num3;
						progress.Set(num2 * 5f + num50 * num2);
					}
					int num51 = GetPileGenerationAttempts();
					bool flag6 = false;
					while (!flag6 && num51 > 0)
					{
						num51--;
						int num52 = genRand.Next(25, Main.maxTilesX - 25);
						int num53 = genRand.Next(15, (int)Main.worldSurface);
						while (oceanDepths(num52, num53))
						{
							num52 = genRand.Next(25, Main.maxTilesX - 25);
							num53 = genRand.Next(15, (int)Main.worldSurface);
						}
						if (!Main.tile[num52, num53].active())
						{
							for (; !Main.tile[num52, num53 + 1].active() && num53 < Main.maxTilesY - 5; num53++)
							{
							}
							Tile tile11 = Main.tile[num52, num53];
							Tile tile12 = Main.tile[num52, num53 + 1];
							if (tile12.active())
							{
								int num54 = genRand.Next(2);
								int num55 = genRand.Next(11);
								if (num54 == 1)
								{
									num55 = genRand.Next(5);
								}
								if (tile12.type == 147 || tile12.type == 161 || tile12.type == 162)
								{
									if (num54 == 0 && num55 < 12)
									{
										num55 += 36;
									}
									if (num54 == 1 && num55 >= 20)
									{
										num55 += 6;
									}
									if (num54 == 1 && num55 < 6)
									{
										num55 += 25;
									}
								}
								if (tile11.liquid <= 0 && (tile12.type == 53 || tile12.type == 397 || tile12.type == 396))
								{
									if (num54 == 0)
									{
										num55 = genRand.Next(73, 77);
									}
									if (num54 == 1)
									{
										num55 = genRand.Next(62, 65);
									}
								}
								if (tile12.type == 2 && num54 == 1)
								{
									num55 = genRand.Next(38, 41);
								}
								if (tile12.type == 151 || tile12.type == 274)
								{
									if (num54 == 0)
									{
										num55 = genRand.Next(12, 28);
									}
									if (num54 == 1)
									{
										num55 = genRand.Next(12, 19);
									}
								}
								if (!Main.wallDungeon[tile11.wall] && tile12.type != 30 && tile12.type != 19 && tile12.type != 41 && tile12.type != 43 && tile12.type != 44 && tile12.type != 481 && tile12.type != 482 && tile12.type != 483 && tile12.type != 45 && tile12.type != 46 && tile12.type != 47 && tile12.type != 175 && tile12.type != 176 && tile12.type != 177 && tile12.type != 25 && tile12.type != 203 && (tile12.type < 0 || !Main.tileDungeon[tile12.type]))
								{
									flag6 = PlaceSmallPile(num52, num53, num55, num54, 185);
								}
							}
						}
					}
				}
				num3 = (float)Main.maxTilesX * 0.15f;
				for (int num56 = 0; (float)num56 < num3; num56++)
				{
					if (progress != null)
					{
						float num57 = (float)num56 / num3;
						progress.Set(num2 * 6f + num57 * num2);
					}
					int num58 = GetPileGenerationAttempts();
					bool flag7 = false;
					while (!flag7 && num58 > 0)
					{
						num58--;
						int num59 = genRand.Next(25, Main.maxTilesX - 25);
						int num60 = genRand.Next(15, (int)Main.worldSurface);
						if (!Main.tile[num59, num60].active() && (Main.tile[num59, num60].wall == 2 || Main.tile[num59, num60].wall == 40))
						{
							for (; !Main.tile[num59, num60 + 1].active() && num60 < Main.maxTilesY - 5; num60++)
							{
							}
							Tile tile13 = Main.tile[num59, num60];
							Tile tile14 = Main.tile[num59, num60 + 1];
							if (tile14.active())
							{
								int num61 = genRand.Next(2);
								int num62 = genRand.Next(11);
								if (num61 == 1)
								{
									num62 = genRand.Next(5);
								}
								if (tile14.type == 147 || tile14.type == 161 || tile14.type == 162)
								{
									if (num61 == 0 && num62 < 12)
									{
										num62 += 36;
									}
									if (num61 == 1 && num62 >= 20)
									{
										num62 += 6;
									}
									if (num61 == 1 && num62 < 6)
									{
										num62 += 25;
									}
								}
								if (tile13.liquid <= 0 && (tile14.type == 53 || tile14.type == 397 || tile14.type == 396))
								{
									if (num61 == 0)
									{
										num62 = genRand.Next(73, 77);
									}
									if (num61 == 1)
									{
										num62 = genRand.Next(62, 65);
									}
								}
								if (tile14.type == 2 && num61 == 1)
								{
									num62 = genRand.Next(38, 41);
								}
								if (tile14.type == 151 || tile14.type == 274)
								{
									if (num61 == 0)
									{
										num62 = genRand.Next(12, 28);
									}
									if (num61 == 1)
									{
										num62 = genRand.Next(12, 19);
									}
								}
								if ((tile13.liquid != byte.MaxValue || tile14.type != 53 || tile13.wall != 0) && !Main.wallDungeon[tile13.wall] && tile14.type != 30 && tile14.type != 19 && tile14.type != 41 && tile14.type != 43 && tile14.type != 44 && tile14.type != 481 && tile14.type != 482 && tile14.type != 483 && tile14.type != 45 && tile14.type != 46 && tile14.type != 47 && tile14.type != 175 && tile14.type != 176 && tile14.type != 177 && tile14.type != 25 && tile14.type != 203 && (tile14.type < 0 || !Main.tileDungeon[tile14.type]))
								{
									flag7 = PlaceSmallPile(num59, num60, num62, num61, 185);
								}
							}
						}
					}
				}
				progress.Set(1.0);
				Main.tileSolid[190] = true;
				Main.tileSolid[192] = true;
				Main.tileSolid[196] = true;
				Main.tileSolid[189] = true;
				Main.tileSolid[717] = true;
				Main.tileSolid[718] = true;
				Main.tileSolid[719] = true;
				Main.tileSolid[202] = true;
				Main.tileSolid[225] = true;
				Main.tileSolid[460] = true;
				Main.tileSolid[379] = true;
				SetBoulderSolidity(solid: true);
			}
		});
		AddGenerationPass(GenPassNameID.SpawnPoint, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (skyblockWorldGen)
			{
				int spawnTileX = Main.spawnTileX;
				int i = Main.spawnTileY;
				int num;
				for (num = 20; !SolidTile3(spawnTileX, i) && i < Main.maxTilesY - 1 - num; i++)
				{
				}
				while (SolidTile3(spawnTileX, i) && i > num)
				{
					i--;
				}
				i++;
				if (Math.Abs(i - Main.spawnTileY) <= num)
				{
					Main.spawnTileX = spawnTileX;
					Main.spawnTileY = i;
				}
			}
			else
			{
				Main.tileSolid[379] = false;
				progress.Set(1.0);
				int num2 = 5;
				bool flag = true;
				int num3 = Main.maxTilesX / 2;
				if (SecretSeed.noSurface.Enabled)
				{
					int num4 = Main.maxTilesY / 2;
					Main.spawnTileX = num3;
					Main.spawnTileY = num4;
					int num5 = 300;
					int num6 = 200;
					bool flag2 = false;
					int num7 = 1000;
					while (true)
					{
						num7--;
						if (num7 <= 0)
						{
							break;
						}
						int num8 = num3 - num5 + genRand.Next(num5 * 2);
						int num9 = num4 - num6 + genRand.Next(num6 * 2);
						if (InWorld(num8, num9, 10))
						{
							Tile tile = Main.tile[num8, num9];
							if (!tile.active() && tile.liquid <= 0 && Player.Spawn_IsAreaValidSpawn(num8, num9, generatingSpawn: true))
							{
								Main.spawnTileX = num8;
								Main.spawnTileY = num9;
								flag2 = true;
								break;
							}
						}
					}
					if (!flag2)
					{
						Main.spawnTileX = num3;
						Main.spawnTileY = num4;
						Player.Spawn_ForceClearArea(num3, num4);
					}
				}
				else
				{
					if (SpecialSeedFeatures.SpawnOnBeach)
					{
						int num10 = GenVars.beachBordersWidth + 15;
						bool flag3 = GenVars.CurrentDungeonGenVars.dungeonSide <= DungeonSide.Left;
						num3 = (SpecialSeedFeatures.SpawnOnBeachOnDungeonSide ? ((!flag3) ? (Main.maxTilesX - num10) : num10) : ((genRand.Next(2) != 0) ? (Main.maxTilesX - num10) : num10));
					}
					while (flag)
					{
						int num11 = num3 + genRand.Next(-num2, num2 + 1);
						for (int j = 0; j < Main.maxTilesY; j++)
						{
							if (Main.tile[num11, j].active() && Main.tile[num11, j].type != 379)
							{
								Main.spawnTileX = num11;
								Main.spawnTileY = j;
								break;
							}
						}
						flag = false;
						num2++;
						if ((double)Main.spawnTileY > Main.worldSurface)
						{
							flag = true;
						}
						if (Main.tile[Main.spawnTileX, Main.spawnTileY - 1].liquid > 0 || Main.tile[Main.spawnTileX, Main.spawnTileY - 2].liquid > 0 || Main.tile[Main.spawnTileX, Main.spawnTileY - 3].liquid > 0)
						{
							flag = true;
						}
						if (IsTileNearby(Main.spawnTileX, Main.spawnTileY, 379, 10))
						{
							flag = true;
						}
					}
					int num12 = 10;
					while ((double)Main.spawnTileY > Main.worldSurface)
					{
						int num13 = genRand.Next(num3 - num12, num3 + num12);
						for (int k = 0; k < Main.maxTilesY; k++)
						{
							if (Main.tile[num13, k].active() && Main.tile[num13, k].type != 379)
							{
								Main.spawnTileX = num13;
								Main.spawnTileY = k;
								break;
							}
						}
						num12++;
					}
				}
				if (remixWorldGen)
				{
					Main.spawnTileX = Main.maxTilesX / 2;
					int num14 = Main.maxTilesY - 10;
					while (SolidTile(Main.spawnTileX, num14))
					{
						num14--;
					}
					Main.spawnTileY = num14 + 1;
				}
				Main.tileSolid[379] = true;
			}
		});
		AddGenerationPass(GenPassNameID.SurfaceDirtWallsToGrassWalls, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				maxTileCount = 3500;
				progress.Set(1.0);
				for (int i = 50; i < Main.maxTilesX - 50; i++)
				{
					for (int j = 0; (double)j < Main.worldSurface - 10.0; j++)
					{
						if (genRand.Next(4) == 0)
						{
							bool flag = false;
							int num = -1;
							int num2 = -1;
							if (Main.tile[i, j].active() && Main.tile[i, j].type == 2 && (Main.tile[i, j].wall == 2 || Main.tile[i, j].wall == 63))
							{
								for (int k = i - 1; k <= i + 1; k++)
								{
									for (int l = j - 1; l <= j + 1; l++)
									{
										if (Main.tile[k, l].wall == 0 && !SolidTile(k, l))
										{
											flag = true;
										}
									}
								}
								if (flag)
								{
									for (int m = i - 1; m <= i + 1; m++)
									{
										for (int n = j - 1; n <= j + 1; n++)
										{
											if ((Main.tile[m, n].wall == 2 || Main.tile[m, n].wall == 15) && !SolidTile(m, n))
											{
												num = m;
												num2 = n;
											}
										}
									}
								}
							}
							if (flag && num > -1 && num2 > -1 && countDirtTiles(num, num2) < maxTileCount)
							{
								try
								{
									int maxValue = 3;
									if (getGoodWorldGen)
									{
										maxValue = 10;
									}
									ushort wallType = 63;
									if (dontStarveWorldGen && genRand.Next(maxValue) != 0 && !SecretSeed.Variations.noSpiderCavesActuallyNoSpiderCaves)
									{
										wallType = 62;
									}
									Spread.Wall2(num, num2, wallType);
								}
								catch
								{
								}
							}
						}
					}
				}
				for (int num3 = 5; num3 < Main.maxTilesX - 5; num3++)
				{
					for (int num4 = 10; (double)num4 < Main.worldSurface - 1.0; num4++)
					{
						if (Main.tile[num3, num4].wall == 63 && genRand.Next(10) == 0)
						{
							Main.tile[num3, num4].wall = 65;
						}
						if (Main.tile[num3, num4].active() && Main.tile[num3, num4].type == 0)
						{
							bool flag2 = false;
							for (int num5 = num3 - 1; num5 <= num3 + 1; num5++)
							{
								for (int num6 = num4 - 1; num6 <= num4 + 1; num6++)
								{
									if (Main.tile[num5, num6].wall == 63 || Main.tile[num5, num6].wall == 65)
									{
										flag2 = true;
										break;
									}
								}
							}
							if (flag2)
							{
								SpreadGrass(num3, num4);
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.SpawnStarterNPCs, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Set(1.0);
			if (Main.tenthAnniversaryWorld)
			{
				Point adjustedFloorPosition = GetAdjustedFloorPosition(Main.spawnTileX, Main.spawnTileY);
				int num;
				if (SecretSeed.worldIsInfected.Enabled)
				{
					num = NPC.NewNPC(new EntitySource_WorldGen(), adjustedFloorPosition.X * 16, adjustedFloorPosition.Y * 16, 20);
					if (remixWorldGen)
					{
						NPC.savedTaxCollector = true;
					}
				}
				else if (!remixWorldGen)
				{
					num = ((!notTheBees) ? NPC.NewNPC(new EntitySource_WorldGen(), adjustedFloorPosition.X * 16, adjustedFloorPosition.Y * 16, 22) : NPC.NewNPC(new EntitySource_WorldGen(), adjustedFloorPosition.X * 16, adjustedFloorPosition.Y * 16, 228));
				}
				else
				{
					num = NPC.NewNPC(new EntitySource_WorldGen(), adjustedFloorPosition.X * 16, adjustedFloorPosition.Y * 16, 441);
					NPC.savedTaxCollector = true;
				}
				Main.npc[num].homeTileX = Main.spawnTileX;
				Main.npc[num].homeTileY = Main.spawnTileY;
				Main.npc[num].direction = 1;
				Main.npc[num].homeless = true;
				if (SecretSeed.worldIsInfected.Enabled)
				{
					Main.npc[num].GivenName = Language.GetTextValue("Lilith");
					Main.npc[num].townNpcVariationIndex = 1;
				}
				else if (notTheBees && !remixWorldGen)
				{
					Main.npc[num].GivenName = Language.GetTextValue("SkeletonMerchantNames.Victor");
				}
				else
				{
					Main.npc[num].GivenName = Language.GetTextValue("GuideNames.Andrew");
				}
				if (!skyblockWorldGen)
				{
					BirthdayParty.CelebratingNPCs.Add(num);
					if (dontStarveWorldGen && !remixWorldGen)
					{
						adjustedFloorPosition = GetAdjustedFloorPosition(Main.spawnTileX + 2, Main.spawnTileY);
						num = NPC.NewNPC(new EntitySource_WorldGen(), adjustedFloorPosition.X * 16, adjustedFloorPosition.Y * 16, 124);
						Main.npc[num].homeTileX = adjustedFloorPosition.X;
						Main.npc[num].homeTileY = adjustedFloorPosition.Y;
						Main.npc[num].direction = -1;
						Main.npc[num].homeless = true;
						Main.npc[num].GivenName = Language.GetTextValue("MechanicNames.Korrie");
						BirthdayParty.CelebratingNPCs.Add(num);
					}
					else
					{
						adjustedFloorPosition = GetAdjustedFloorPosition(Main.spawnTileX + 2, Main.spawnTileY);
						num = NPC.NewNPC(new EntitySource_WorldGen(), adjustedFloorPosition.X * 16, adjustedFloorPosition.Y * 16, 178);
						Main.npc[num].homeTileX = adjustedFloorPosition.X;
						Main.npc[num].homeTileY = adjustedFloorPosition.Y;
						Main.npc[num].direction = -1;
						Main.npc[num].homeless = true;
						Main.npc[num].GivenName = Language.GetTextValue("SteampunkerNames.Whitney");
						BirthdayParty.CelebratingNPCs.Add(num);
					}
					if (notTheBees && !remixWorldGen)
					{
						adjustedFloorPosition = GetAdjustedFloorPosition(Main.spawnTileX - 2, Main.spawnTileY);
						num = NPC.NewNPC(new EntitySource_WorldGen(), adjustedFloorPosition.X * 16, adjustedFloorPosition.Y * 16, 17);
						Main.npc[num].homeTileX = adjustedFloorPosition.X;
						Main.npc[num].homeTileY = adjustedFloorPosition.Y;
						Main.npc[num].direction = 1;
						Main.npc[num].homeless = true;
						Main.npc[num].GivenName = Language.GetTextValue("AnglerNames.Charles");
						BirthdayParty.CelebratingNPCs.Add(num);
						NPC.unlockedMerchantSpawn = true;
					}
					else
					{
						adjustedFloorPosition = GetAdjustedFloorPosition(Main.spawnTileX - 2, Main.spawnTileY);
						num = NPC.NewNPC(new EntitySource_WorldGen(), adjustedFloorPosition.X * 16, adjustedFloorPosition.Y * 16, 663);
						Main.npc[num].homeTileX = adjustedFloorPosition.X;
						Main.npc[num].homeTileY = adjustedFloorPosition.Y;
						Main.npc[num].direction = 1;
						Main.npc[num].homeless = true;
						Main.npc[num].GivenName = Language.GetTextValue("PrincessNames.Yorai");
						BirthdayParty.CelebratingNPCs.Add(num);
						NPC.unlockedPrincessSpawn = true;
					}
					if (drunkWorldGen)
					{
						adjustedFloorPosition = GetAdjustedFloorPosition(Main.spawnTileX + 4, Main.spawnTileY);
						num = NPC.NewNPC(new EntitySource_WorldGen(), adjustedFloorPosition.X * 16, adjustedFloorPosition.Y * 16, 227);
						Main.npc[num].homeTileX = adjustedFloorPosition.X;
						Main.npc[num].homeTileY = adjustedFloorPosition.Y;
						Main.npc[num].direction = -1;
						Main.npc[num].homeless = true;
						Main.npc[num].GivenName = Language.GetTextValue("PainterNames.Jim");
						BirthdayParty.CelebratingNPCs.Add(num);
					}
					else
					{
						adjustedFloorPosition = GetAdjustedFloorPosition(Main.spawnTileX + 4, Main.spawnTileY);
						num = NPC.NewNPC(new EntitySource_WorldGen(), adjustedFloorPosition.X * 16, adjustedFloorPosition.Y * 16, 208);
						Main.npc[num].homeTileX = adjustedFloorPosition.X;
						Main.npc[num].homeTileY = adjustedFloorPosition.Y;
						Main.npc[num].direction = -1;
						Main.npc[num].homeless = true;
						Main.npc[num].GivenName = Language.GetTextValue("PartyGirlNames.Amanda");
						BirthdayParty.CelebratingNPCs.Add(num);
						NPC.unlockedPartyGirlSpawn = true;
					}
					adjustedFloorPosition = GetAdjustedFloorPosition(Main.spawnTileX - 4, Main.spawnTileY);
					if (Main.remixWorld)
					{
						num = NPC.NewNPC(new EntitySource_WorldGen(), adjustedFloorPosition.X * 16, adjustedFloorPosition.Y * 16, 681);
						Main.npc[num].GivenName = Language.GetTextValue("SlimeNames_Rainbow.Slimestar");
						NPC.unlockedSlimeRainbowSpawn = true;
					}
					else if (Main.drunkWorld)
					{
						num = NPC.NewNPC(new EntitySource_WorldGen(), adjustedFloorPosition.X * 16, adjustedFloorPosition.Y * 16, 680);
						Main.npc[num].GivenName = Language.GetTextValue("SlimeNames_Purple.Slimefors");
						NPC.unlockedSlimePurpleSpawn = true;
					}
					else
					{
						num = NPC.NewNPC(new EntitySource_WorldGen(), adjustedFloorPosition.X * 16, adjustedFloorPosition.Y * 16, 656);
						NPC.boughtBunny = true;
						Main.npc[num].townNpcVariationIndex = 1;
					}
					Main.npc[num].homeTileX = adjustedFloorPosition.X;
					Main.npc[num].homeTileY = adjustedFloorPosition.Y;
					Main.npc[num].direction = 1;
					Main.npc[num].homeless = true;
				}
			}
			else if (SecretSeed.worldIsInfected.Enabled)
			{
				int num2 = NPC.NewNPC(new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 20);
				Main.npc[num2].homeTileX = Main.spawnTileX;
				Main.npc[num2].homeTileY = Main.spawnTileY;
				Main.npc[num2].direction = 1;
				Main.npc[num2].homeless = true;
				Main.npc[num2].townNpcVariationIndex = 1;
				if (remixWorldGen)
				{
					NPC.savedTaxCollector = true;
				}
			}
			else if (Main.vampireSeed)
			{
				int num3 = NPC.NewNPC(new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 633);
				Main.npc[num3].homeTileX = Main.spawnTileX;
				Main.npc[num3].homeTileY = Main.spawnTileY;
				Main.npc[num3].direction = 1;
				Main.npc[num3].homeless = true;
			}
			else if (remixWorldGen)
			{
				int num4 = NPC.NewNPC(new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 441);
				Main.npc[num4].homeTileX = Main.spawnTileX;
				Main.npc[num4].homeTileY = Main.spawnTileY;
				Main.npc[num4].direction = 1;
				Main.npc[num4].homeless = true;
				NPC.savedTaxCollector = true;
			}
			else if (drunkWorldGen && dontStarveWorldGen)
			{
				int num5 = NPC.NewNPC(new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 124);
				Main.npc[num5].homeTileX = Main.spawnTileX;
				Main.npc[num5].homeTileY = Main.spawnTileY;
				Main.npc[num5].direction = 1;
				Main.npc[num5].homeless = true;
				NPC.savedMech = true;
			}
			else if (notTheBees && !dontStarveWorldGen)
			{
				int num6 = NPC.NewNPC(new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 17);
				Main.npc[num6].homeTileX = Main.spawnTileX;
				Main.npc[num6].homeTileY = Main.spawnTileY;
				Main.npc[num6].direction = 1;
				Main.npc[num6].homeless = true;
				NPC.unlockedMerchantSpawn = true;
			}
			else if (getGoodWorldGen)
			{
				int num7 = NPC.NewNPC(new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 38);
				Main.npc[num7].homeTileX = Main.spawnTileX;
				Main.npc[num7].homeTileY = Main.spawnTileY;
				Main.npc[num7].direction = 1;
				Main.npc[num7].homeless = true;
				NPC.unlockedDemolitionistSpawn = true;
			}
			else if (drunkWorldGen)
			{
				int num8 = NPC.NewNPC(new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 208);
				Main.npc[num8].homeTileX = Main.spawnTileX;
				Main.npc[num8].homeTileY = Main.spawnTileY;
				Main.npc[num8].direction = 1;
				Main.npc[num8].homeless = true;
				NPC.unlockedPartyGirlSpawn = true;
			}
			else
			{
				int num9 = NPC.NewNPC(new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 22);
				Main.npc[num9].homeTileX = Main.spawnTileX;
				Main.npc[num9].homeTileY = Main.spawnTileY;
				Main.npc[num9].direction = 1;
				Main.npc[num9].homeless = true;
			}
		});
		AddGenerationPass(GenPassNameID.SunflowersPart2, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denySomeGeneration)
			{
				progress.Message = Lang.gen[39].Value;
				double num = (double)Main.maxTilesX * 0.002;
				for (int i = 0; (double)i < num; i++)
				{
					progress.Set((double)i / num);
					int num2 = 0;
					int num3 = 0;
					_ = Main.maxTilesX / 2;
					int num4 = genRand.Next(Main.maxTilesX);
					num2 = num4 - genRand.Next(10) - 7;
					num3 = num4 + genRand.Next(10) + 7;
					if (num2 < 0)
					{
						num2 = 0;
					}
					if (num3 > Main.maxTilesX - 1)
					{
						num3 = Main.maxTilesX - 1;
					}
					int num5 = 1;
					int num6 = (int)Main.worldSurface - 1;
					for (int j = num2; j < num3; j++)
					{
						for (int k = num5; k < num6; k++)
						{
							if (Main.tile[j, k].type == 2 && Main.tile[j, k].active() && !Main.tile[j, k - 1].active())
							{
								PlaceTile(j, k - 1, 27, mute: true);
							}
							if (Main.tile[j, k].active())
							{
								break;
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.Trees, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denySomeGeneration)
			{
				progress.Message = Lang.gen[40].Value;
				if (!drunkWorldGen && !Main.tenthAnniversaryWorld)
				{
					for (int i = 0; (double)i < (double)Main.maxTilesX * 0.003; i++)
					{
						progress.Set((double)i / ((double)Main.maxTilesX * 0.003));
						int num = genRand.Next(50, Main.maxTilesX - 50);
						int num2 = genRand.Next(25, 50);
						for (int j = num - num2; j < num + num2; j++)
						{
							for (int k = 20; (double)k < Main.worldSurface; k++)
							{
								GrowEpicTree(j, k);
							}
						}
					}
				}
				AddTrees();
			}
		});
		AddGenerationPass(GenPassNameID.AlchemyHerbs, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				double num = (double)Main.maxTilesX * 1.7;
				if (remixWorldGen)
				{
					num *= 5.0;
				}
				progress.Message = Lang.gen[41].Value;
				for (int i = 0; (double)i < num; i++)
				{
					progress.Set((double)i / num);
					PlantAlch();
				}
			}
		});
		AddGenerationPass(GenPassNameID.DyePlants, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Set(1.0);
				for (int i = 0; i < Main.maxTilesX; i++)
				{
					plantDye(genRand.Next(100, Main.maxTilesX - 100), genRand.Next(100, Main.UnderworldLayer));
				}
				MatureTheHerbPlants();
				GrowGlowTulips();
				PlaceChilletEggs();
			}
		});
		AddGenerationPass(GenPassNameID.WebsInSpiderCavesAndHoneyPlusSpeleothemsInBeehives, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denySomeGeneration)
			{
				progress.Set(1.0);
				for (int i = 100; i < Main.maxTilesX - 100; i++)
				{
					int num = (int)Main.worldSurface;
					if (dontStarveWorldGen)
					{
						num = 50;
					}
					for (int j = num; j < Main.maxTilesY - 100; j++)
					{
						if (Main.tile[i, j].wall == 86)
						{
							if (Main.tile[i, j].liquid > 0)
							{
								Main.tile[i, j].honey(honey: true);
							}
							if (genRand.Next(3) == 0)
							{
								PlaceTight(i, j);
							}
						}
						if (Main.tile[i, j].wall == 62)
						{
							if (SecretSeed.Variations.noSpiderCavesILiedMoreSpiderCaves)
							{
								if (Main.tile[i, j].liquid > 0)
								{
									Main.tile[i, j].honey(honey: true);
								}
							}
							else
							{
								Main.tile[i, j].liquid = 0;
								Main.tile[i, j].lava(lava: false);
							}
						}
						if (Main.tile[i, j].wall == 62 && !Main.tile[i, j].active() && genRand.Next(10) != 0)
						{
							int num2 = genRand.Next(2, 5);
							int num3 = i - num2;
							int num4 = i + num2;
							int num5 = j - num2;
							int num6 = j + num2;
							bool flag = false;
							for (int k = num3; k <= num4; k++)
							{
								for (int l = num5; l <= num6; l++)
								{
									if (SolidTile(k, l))
									{
										flag = true;
										break;
									}
								}
							}
							if (flag)
							{
								PlaceTile(i, j, 51, mute: true);
								TileFrame(i, j);
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.GrassPlantsEvilPlantsAndPumpkinsOnSurface, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denySomeGeneration)
			{
				progress.Message = Lang.gen[42].Value;
				if (SecretSeed.halloweenGen.Enabled || SecretSeed.endlessHalloween.Enabled)
				{
					for (int i = 40; i < Main.maxTilesX - 40; i++)
					{
						for (int j = 50; (double)j < Main.worldSurface; j++)
						{
							if (Main.tile[i, j].active() && Main.tile[i, j].type == 2 && genRand.Next(15) == 0)
							{
								PlacePumpkin(i, j - 1);
								int num = genRand.Next(5);
								for (int k = 0; k < num; k++)
								{
									GrowPumpkin(i, j - 1, 254);
								}
							}
						}
					}
				}
				for (int l = 0; l < Main.maxTilesX; l++)
				{
					progress.Set((double)l / (double)Main.maxTilesX);
					for (int m = 1; m < Main.maxTilesY; m++)
					{
						if (Main.tile[l, m].type == 2 && Main.tile[l, m].nactive())
						{
							if (!Main.tile[l, m - 1].active())
							{
								PlaceTile(l, m - 1, 3, mute: true);
								Main.tile[l, m - 1].CopyPaintAndCoating(Main.tile[l, m]);
							}
						}
						else if (Main.tile[l, m].type == 23 && Main.tile[l, m].nactive())
						{
							if (!Main.tile[l, m - 1].active())
							{
								PlaceTile(l, m - 1, 24, mute: true);
							}
						}
						else if (Main.tile[l, m].type == 199 && Main.tile[l, m].nactive())
						{
							if (!Main.tile[l, m - 1].active())
							{
								PlaceTile(l, m - 1, 201, mute: true);
							}
						}
						else if (Main.tile[l, m].type == 633 && Main.tile[l, m].nactive() && !Main.tile[l, m - 1].active())
						{
							PlaceTile(l, m - 1, 637, mute: true);
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.GlowingMushroomPlantsUndergroundAndJunglePlants, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denySomeGeneration)
			{
				progress.Set(1.0);
				for (int i = 5; i < Main.maxTilesX - 5; i++)
				{
					for (int j = 5; j < Main.maxTilesY - 5; j++)
					{
						if (Main.tile[i, j].active())
						{
							if (j >= (int)Main.worldSurface && Main.tile[i, j].type == 70 && !Main.tile[i, j - 1].active())
							{
								TryGrowingTreeByType(5, i, j);
								if (!Main.tile[i, j - 1].active())
								{
									TryGrowingTreeByType(5, i, j);
									if (!Main.tile[i, j - 1].active())
									{
										TryGrowingTreeByType(5, i, j);
										if (!Main.tile[i, j - 1].active())
										{
											PlaceTile(i, j - 1, 71, mute: true);
										}
									}
								}
							}
							if (!Main.tile[i, j - 1].active())
							{
								if (Main.tile[i, j].type == 60)
								{
									PlaceTile(i, j - 1, 61, mute: true);
								}
								else if (Main.tile[i, j].type == 226 && genRand.Next(5) == 0 && !TooManyJunglePlantsNearby(i, j - 1))
								{
									PlaceTile(i, j - 1, 61, mute: true);
								}
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.JunglePlantsPart2, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denySomeGeneration)
			{
				progress.Set(1.0);
				for (int i = 0; i < Main.maxTilesX * 100; i++)
				{
					int num = genRand.Next(40, Main.maxTilesX / 2 - 40);
					if (GenVars.CurrentDungeonGenVars.dungeonSide <= DungeonSide.Left)
					{
						num += Main.maxTilesX / 2;
					}
					int j;
					for (j = genRand.Next(Main.maxTilesY - 300); !Main.tile[num, j].active() && j < Main.maxTilesY - 300; j++)
					{
					}
					if (Main.tile[num, j].active() && Main.tile[num, j].type == 60)
					{
						j--;
						PlaceJunglePlant(num, j, 233, genRand.Next(8), 0, inheritPaint: true);
						if (Main.tile[num, j].type != 233)
						{
							PlaceJunglePlant(num, j, 233, genRand.Next(12), 1, inheritPaint: true);
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.Vines, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denySomeGeneration)
			{
				progress.Message = Lang.gen[43].Value;
				for (int i = 5; i < Main.maxTilesX - 5; i++)
				{
					progress.Set((double)i / (double)Main.maxTilesX);
					int num = 0;
					ushort type = 52;
					int num2 = (int)Main.worldSurface;
					if (remixWorldGen)
					{
						num2 = Main.maxTilesY - 200;
					}
					for (int j = 0; j < num2; j++)
					{
						if (num > 0 && !Main.tile[i, j].active())
						{
							Main.tile[i, j].active(active: true);
							Main.tile[i, j].type = type;
							Main.tile[i, j].ClearSlope();
							Main.tile[i, j].CopyPaintAndCoating(Main.tile[i, j - 1]);
							num--;
						}
						else
						{
							num = 0;
						}
						if (Main.tile[i, j].active() && !Main.tile[i, j].bottomSlope() && (Main.tile[i, j].type == 2 || (Main.tile[i, j].type == 192 && genRand.Next(4) == 0)) && GrowMoreVines(i, j))
						{
							type = 52;
							if (Main.tile[i, j].wall == 68 || Main.tile[i, j].wall == 65 || Main.tile[i, j].wall == 66 || Main.tile[i, j].wall == 63)
							{
								type = 382;
							}
							else if (Main.tile[i, j + 1].wall == 68 || Main.tile[i, j + 1].wall == 65 || Main.tile[i, j + 1].wall == 66 || Main.tile[i, j + 1].wall == 63)
							{
								type = 382;
							}
							if (remixWorldGen && genRand.Next(5) == 0)
							{
								type = 382;
							}
							if (genRand.Next(5) < 3)
							{
								num = genRand.Next(1, 10);
							}
						}
					}
					num = 0;
					for (int k = 5; k < Main.maxTilesY - 5; k++)
					{
						if (num > 0 && !Main.tile[i, k].active())
						{
							Main.tile[i, k].active(active: true);
							Main.tile[i, k].type = 62;
							Main.tile[i, k].ClearSlope();
							num--;
						}
						else
						{
							num = 0;
						}
						if (Main.tile[i, k].active() && (Main.tile[i, k].type == 60 || Main.tile[i, k].type == 226) && !Main.tile[i, k].bottomSlope() && GrowMoreVines(i, k))
						{
							if (notTheBees && k < Main.maxTilesY - 10 && Main.tile[i, k - 1].active() && !Main.tile[i, k - 1].bottomSlope() && Main.tile[i + 1, k - 1].active() && !Main.tile[i + 1, k - 1].bottomSlope() && (Main.tile[i, k - 1].type == 60 || Main.tile[i, k - 1].type == 444 || Main.tile[i, k - 1].type == 230))
							{
								bool flag = true;
								for (int l = i; l < i + 2; l++)
								{
									for (int m = k + 1; m < k + 3; m++)
									{
										if (Main.tile[l, m].active() && (!Main.tileCut[Main.tile[l, m].type] || Main.tile[l, m].type == 444))
										{
											flag = false;
											break;
										}
										if (Main.tile[l, m].liquid > 0 || Main.wallHouse[Main.tile[l, m].wall])
										{
											flag = false;
											break;
										}
									}
									if (!flag)
									{
										break;
									}
								}
								if (flag && CountNearBlocksTypes(i, k, genRand.Next(3, 10), 1, 444) > 0)
								{
									flag = false;
								}
								if (flag)
								{
									for (int n = i; n < i + 2; n++)
									{
										for (int num3 = k + 1; num3 < k + 3; num3++)
										{
											KillTile(n, num3);
										}
									}
									for (int num4 = i; num4 < i + 2; num4++)
									{
										for (int num5 = k + 1; num5 < k + 3; num5++)
										{
											Main.tile[num4, num5].active(active: true);
											Main.tile[num4, num5].type = 444;
											Main.tile[num4, num5].frameX = (short)((num4 - i) * 18);
											Main.tile[num4, num5].frameY = (short)((num5 - k - 1) * 18);
										}
									}
									continue;
								}
							}
							else if (i < Main.maxTilesX - 1 && k < Main.maxTilesY - 2 && Main.tile[i + 1, k].active() && Main.tile[i + 1, k].type == 60 && !Main.tile[i + 1, k].bottomSlope() && genRand.Next(40) == 0)
							{
								bool flag2 = true;
								for (int num6 = i; num6 < i + 2; num6++)
								{
									for (int num7 = k + 1; num7 < k + 3; num7++)
									{
										if (Main.tile[num6, num7].active() && (!Main.tileCut[Main.tile[num6, num7].type] || Main.tile[num6, num7].type == 444))
										{
											flag2 = false;
											break;
										}
										if (Main.tile[num6, num7].liquid > 0 || Main.wallHouse[Main.tile[num6, num7].wall])
										{
											flag2 = false;
											break;
										}
									}
									if (!flag2)
									{
										break;
									}
								}
								if (flag2 && CountNearBlocksTypes(i, k, 20, 1, 444) > 0)
								{
									flag2 = false;
								}
								if (flag2)
								{
									for (int num8 = i; num8 < i + 2; num8++)
									{
										for (int num9 = k + 1; num9 < k + 3; num9++)
										{
											KillTile(num8, num9);
										}
									}
									for (int num10 = i; num10 < i + 2; num10++)
									{
										for (int num11 = k + 1; num11 < k + 3; num11++)
										{
											Main.tile[num10, num11].active(active: true);
											Main.tile[num10, num11].type = 444;
											Main.tile[num10, num11].frameX = (short)((num10 - i) * 18);
											Main.tile[num10, num11].frameY = (short)((num11 - k - 1) * 18);
										}
									}
									continue;
								}
							}
							bool flag3 = true;
							if (Main.tile[i, k].type == 226 && TooManyJungleVinesNearby(i, k))
							{
								flag3 = false;
							}
							if (flag3 && genRand.Next(5) < 3)
							{
								num = genRand.Next(1, 10);
							}
						}
					}
					num = 0;
					for (int num12 = 0; num12 < Main.maxTilesY; num12++)
					{
						if (num > 0 && !Main.tile[i, num12].active())
						{
							Main.tile[i, num12].active(active: true);
							Main.tile[i, num12].type = 528;
							Main.tile[i, num12].ClearSlope();
							num--;
						}
						else
						{
							num = 0;
						}
						if (Main.tile[i, num12].active() && Main.tile[i, num12].type == 70 && genRand.Next(5) == 0 && !Main.tile[i, num12].bottomSlope() && GrowMoreVines(i, num12) && genRand.Next(5) < 3)
						{
							num = genRand.Next(1, 10);
						}
					}
					num = 0;
					for (int num13 = 0; num13 < Main.maxTilesY; num13++)
					{
						if (num > 0 && !Main.tile[i, num13].active())
						{
							Main.tile[i, num13].active(active: true);
							Main.tile[i, num13].type = 636;
							Main.tile[i, num13].ClearSlope();
							num--;
						}
						else
						{
							num = 0;
						}
						if (Main.tile[i, num13].active() && !Main.tile[i, num13].bottomSlope() && Main.tile[i, num13].type == 23 && GrowMoreVines(i, num13) && genRand.Next(5) < 3)
						{
							num = genRand.Next(1, 10);
						}
					}
					num = 0;
					for (int num14 = 0; num14 < Main.maxTilesY; num14++)
					{
						if (num > 0 && !Main.tile[i, num14].active())
						{
							Main.tile[i, num14].active(active: true);
							Main.tile[i, num14].type = 205;
							Main.tile[i, num14].ClearSlope();
							num--;
						}
						else
						{
							num = 0;
						}
						if (Main.tile[i, num14].active() && !Main.tile[i, num14].bottomSlope() && Main.tile[i, num14].type == 199 && GrowMoreVines(i, num14) && genRand.Next(5) < 3)
						{
							num = genRand.Next(1, 10);
						}
					}
					num = 0;
					for (int num15 = 0; num15 < Main.maxTilesY; num15++)
					{
						if (num > 0 && !Main.tile[i, num15].active())
						{
							Main.tile[i, num15].active(active: true);
							Main.tile[i, num15].type = 638;
							Main.tile[i, num15].ClearSlope();
							num--;
						}
						else
						{
							num = 0;
						}
						if (Main.tile[i, num15].active() && !Main.tile[i, num15].bottomSlope() && Main.tile[i, num15].type == 633 && GrowMoreVines(i, num15) && genRand.Next(5) < 3)
						{
							num = genRand.Next(1, 10);
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.Flowers, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denySomeGeneration)
			{
				progress.Message = Lang.gen[44].Value;
				int num = (int)((double)Main.maxTilesX * 0.004);
				if (remixWorldGen)
				{
					num *= 6;
				}
				for (int i = 0; i < num; i++)
				{
					progress.Set((double)i / (double)num);
					int num2 = genRand.Next(100, Main.maxTilesX - 100);
					int num3 = genRand.Next(15, 30);
					int num4 = genRand.Next(15, 30);
					if (remixWorldGen)
					{
						num3 = genRand.Next(15, 45);
						num4 = genRand.Next(15, 45);
						int num5 = genRand.Next((int)Main.rockLayer, Main.maxTilesY - 350);
						if (GenVars.logX >= 0)
						{
							num2 = GenVars.logX;
							num5 = GenVars.logY;
							GenVars.logX = -1;
						}
						int num6 = genRand.NextFromList<int>(21, 24, 27, 30, 33, 36, 39, 42);
						for (int j = num2 - num3; j < num2 + num3; j++)
						{
							for (int k = num5 - num4; k < num5 + num4; k++)
							{
								Tile tile = Main.tile[j, k];
								Tile tile2 = Main.tile[j, k + 1];
								Tile tile3 = Main.tile[j, k + 2];
								if ((!tile.active() || tile.type != 488) && (!tile.active() || !Main.tileSolid[tile.type]))
								{
									if (tile.active() && tile.type == 3)
									{
										tile.frameX = (short)((num6 + genRand.Next(3)) * 18);
										if (genRand.Next(3) != 0)
										{
											tile.type = 73;
										}
									}
									else if (tile2.wall == 0 && tile2.active() && (tile2.type == 2 || ((tile2.type == 40 || tile2.type == 1 || TileID.Sets.Ore[tile2.type]) && !tile.active())) && (!tile.active() || tile.type == 185 || tile.type == 186 || tile.type == 187 || (tile.type == 5 && (double)j < (double)Main.maxTilesX * 0.48) || (double)j > (double)Main.maxTilesX * 0.52))
									{
										if (tile2.type == 40 || tile2.type == 1 || TileID.Sets.Ore[tile2.type])
										{
											tile2.type = 2;
											if (tile3.type == 40 || tile3.type == 1 || TileID.Sets.Ore[tile3.type])
											{
												tile3.type = 2;
											}
										}
										KillTile(j, k);
										if (genRand.Next(2) == 0)
										{
											tile2.slope(0);
											tile2.halfBrick(halfBrick: false);
										}
										PlaceTile(j, k, 3);
										if (tile.active() && tile.type == 3)
										{
											tile.frameX = (short)((num6 + genRand.Next(3)) * 18);
											if (genRand.Next(3) != 0)
											{
												tile.type = 73;
											}
										}
										if (tile3.type == 40 || tile3.type == 1 || TileID.Sets.Ore[tile3.type])
										{
											tile3.type = 0;
										}
									}
								}
							}
						}
					}
					else
					{
						for (int l = num4; (double)l < Main.worldSurface - (double)num4 - 1.0; l++)
						{
							if (Main.tile[num2, l].active())
							{
								if (GenVars.logX >= 0)
								{
									num2 = GenVars.logX;
									l = GenVars.logY;
									GenVars.logX = -1;
								}
								int num7 = genRand.NextFromList<int>(21, 24, 27, 30, 33, 36, 39, 42);
								for (int m = num2 - num3; m < num2 + num3; m++)
								{
									for (int n = l - num4; n < l + num4; n++)
									{
										if (InWorld(m, n, 5))
										{
											Tile tile4 = Main.tile[m, n];
											Tile tile5 = Main.tile[m, n + 1];
											Tile tile6 = Main.tile[m, n + 2];
											if ((!tile4.active() || tile4.type != 488) && (!tile4.active() || !Main.tileSolid[tile4.type]))
											{
												if (tile4.active() && tile4.type == 3)
												{
													tile4.frameX = (short)((num7 + genRand.Next(3)) * 18);
													if (genRand.Next(3) != 0)
													{
														tile4.type = 73;
													}
												}
												else if (tile5.wall == 0 && tile5.active() && (tile5.type == 2 || ((tile5.type == 40 || tile5.type == 1 || TileID.Sets.Ore[tile5.type]) && !tile4.active())) && (!tile4.active() || tile4.type == 185 || tile4.type == 186 || tile4.type == 187 || (tile4.type == 5 && (double)m < (double)Main.maxTilesX * 0.48) || (double)m > (double)Main.maxTilesX * 0.52))
												{
													if (tile5.type == 40 || tile5.type == 1 || TileID.Sets.Ore[tile5.type])
													{
														tile5.type = 2;
														if (tile6.type == 40 || tile6.type == 1 || TileID.Sets.Ore[tile6.type])
														{
															tile6.type = 2;
														}
													}
													KillTile(m, n);
													if (genRand.Next(2) == 0)
													{
														tile5.slope(0);
														tile5.halfBrick(halfBrick: false);
													}
													PlaceTile(m, n, 3);
													if (tile4.active() && tile4.type == 3)
													{
														tile4.frameX = (short)((num7 + genRand.Next(3)) * 18);
														if (genRand.Next(3) != 0)
														{
															tile4.type = 73;
														}
													}
													if (tile6.type == 40 || tile6.type == 1 || TileID.Sets.Ore[tile6.type])
													{
														tile6.type = 0;
													}
												}
											}
										}
									}
								}
								break;
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.Mushrooms, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denySomeGeneration)
			{
				progress.Message = Lang.gen[45].Value;
				int num = (int)((double)Main.maxTilesX * 0.002);
				if (remixWorldGen)
				{
					num *= 9;
				}
				for (int i = 0; i < num; i++)
				{
					progress.Set((double)i / (double)num);
					int num2 = genRand.Next(20, Main.maxTilesX - 20);
					int num3 = genRand.Next(4, 10);
					int num4 = genRand.Next(15, 30);
					if (remixWorldGen)
					{
						num3 = genRand.Next(8, 17);
						num4 = genRand.Next(8, 17);
						int num5 = genRand.Next((int)Main.rockLayer, Main.maxTilesY - 350);
						if (Main.tile[num2, num5].active())
						{
							for (int j = num2 - num3; j < num2 + num3; j++)
							{
								for (int k = num5 - num4; k < num5 + num4; k++)
								{
									if (j < 10)
									{
										break;
									}
									if (k < 0)
									{
										break;
									}
									if (j > Main.maxTilesX - 10)
									{
										break;
									}
									if (k > Main.maxTilesY - 10)
									{
										break;
									}
									if (Main.tile[j, k].type == 3 || Main.tile[j, k].type == 24)
									{
										Main.tile[j, k].frameX = 144;
									}
									else if (Main.tile[j, k].type == 201)
									{
										Main.tile[j, k].frameX = 270;
									}
								}
							}
						}
					}
					else
					{
						for (int l = 1; (double)l < Main.worldSurface - 1.0; l++)
						{
							if (Main.tile[num2, l].active())
							{
								for (int m = num2 - num3; m < num2 + num3; m++)
								{
									for (int n = l - num4; n < l + num4; n++)
									{
										if (m < 10)
										{
											break;
										}
										if (n < 0)
										{
											break;
										}
										if (m > Main.maxTilesX - 10)
										{
											break;
										}
										if (n > Main.maxTilesY - 10)
										{
											break;
										}
										if (Main.tile[m, n].type == 3 || Main.tile[m, n].type == 24)
										{
											Main.tile[m, n].frameX = 144;
										}
										else if (Main.tile[m, n].type == 201)
										{
											Main.tile[m, n].frameX = 270;
										}
									}
								}
								break;
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.ExposedGemsInIceBiome, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Set(1.0);
				for (int i = 0; (double)i < (double)Main.maxTilesX * 0.25; i++)
				{
					int num = ((!remixWorldGen) ? genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, GenVars.lavaLine) : genRand.Next((int)Main.worldSurface, Main.maxTilesY - 300));
					int num2 = genRand.Next(GenVars.snowMinX[num], GenVars.snowMaxX[num]);
					if (Main.tile[num2, num].active() && (Main.tile[num2, num].type == 147 || Main.tile[num2, num].type == 161 || Main.tile[num2, num].type == 162 || Main.tile[num2, num].type == 224))
					{
						int num3 = genRand.Next(1, 4);
						int num4 = genRand.Next(1, 4);
						int num5 = genRand.Next(1, 4);
						int num6 = genRand.Next(1, 4);
						int num7 = genRand.Next(12);
						int num8 = 0;
						num8 = ((num7 >= 3) ? ((num7 < 6) ? 1 : ((num7 < 8) ? 2 : ((num7 < 10) ? 3 : ((num7 >= 11) ? 5 : 4)))) : 0);
						for (int j = num2 - num3; j < num2 + num4; j++)
						{
							for (int k = num - num5; k < num + num6; k++)
							{
								if (InWorld(j, k, 40) && !Main.tile[j, k].active())
								{
									PlaceTile(j, k, 178, mute: true, forced: false, -1, num8);
								}
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.ExposedGemsUnderground, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Set(1.0);
				for (int i = 0; i < Main.maxTilesX; i++)
				{
					int num = genRand.Next(20, Main.maxTilesX - 20);
					int num2 = genRand.Next((int)Main.rockLayer, Main.maxTilesY - 300);
					if (!Main.tile[num, num2].active() && !Main.tile[num, num2].anyLava() && !Main.wallDungeon[Main.tile[num, num2].wall] && Main.tile[num, num2].wall != 27)
					{
						int num3 = genRand.Next(12);
						int num4 = 0;
						num4 = ((num3 >= 3) ? ((num3 < 6) ? 1 : ((num3 < 8) ? 2 : ((num3 < 10) ? 3 : ((num3 >= 11) ? 5 : 4)))) : 0);
						PlaceTile(num, num2, 178, mute: true, forced: false, -1, num4);
					}
				}
				for (int j = 0; j < Main.maxTilesX; j++)
				{
					int num5 = genRand.Next(20, Main.maxTilesX - 20);
					int num6 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 300);
					if (!Main.tile[num5, num6].active() && !Main.tile[num5, num6].anyLava() && (Main.tile[num5, num6].wall == 216 || Main.tile[num5, num6].wall == 187))
					{
						int num7 = genRand.Next(1, 4);
						int num8 = genRand.Next(1, 4);
						int num9 = genRand.Next(1, 4);
						int num10 = genRand.Next(1, 4);
						for (int k = num5 - num7; k < num5 + num8; k++)
						{
							for (int l = num6 - num9; l < num6 + num10; l++)
							{
								if (!Main.tile[k, l].active())
								{
									PlaceTile(k, l, 178, mute: true, forced: false, -1, 6);
								}
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.LongMoss, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denySomeGeneration)
			{
				progress.Message = Language.GetTextValue("WorldGeneration.LongMoss");
				progress.Set(0.0);
				int num = Main.maxTilesX - 5;
				for (int i = 5; i < num; i++)
				{
					if (progress != null)
					{
						float num2 = (float)i / (float)num;
						progress.Set(num2);
					}
					for (int j = 5; j < Main.maxTilesY - 5; j++)
					{
						if (Main.tile[i, j].active() && Main.tileMoss[Main.tile[i, j].type])
						{
							for (int k = 0; k < 4; k++)
							{
								int num3 = i;
								int num4 = j;
								switch (k)
								{
								case 0:
									num3--;
									break;
								case 1:
									num3++;
									break;
								case 2:
									num4--;
									break;
								case 3:
									num4++;
									break;
								}
								if (!Main.tile[num3, num4].active())
								{
									PlaceTile(num3, num4, 184, mute: true);
								}
							}
						}
					}
				}
				progress.Set(1.0);
			}
		});
		AddGenerationPass(GenPassNameID.DirtWallsIntoMudWallsInJungleAndJungleMinMax, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Set(1.0);
				int num = 0;
				int num2 = 0;
				bool flag = false;
				for (int i = 5; i < Main.maxTilesX - 5; i++)
				{
					for (int j = 0; (double)j < Main.worldSurface + 20.0; j++)
					{
						if (Main.tile[i, j].active() && Main.tile[i, j].type == 60)
						{
							num = i;
							flag = true;
							break;
						}
					}
					if (flag)
					{
						break;
					}
				}
				flag = false;
				for (int num3 = Main.maxTilesX - 5; num3 > 5; num3--)
				{
					for (int k = 0; (double)k < Main.worldSurface + 20.0; k++)
					{
						if (Main.tile[num3, k].active() && Main.tile[num3, k].type == 60)
						{
							num2 = num3;
							flag = true;
							break;
						}
					}
					if (flag)
					{
						break;
					}
				}
				GenVars.jungleMinX = num;
				GenVars.jungleMaxX = num2;
				for (int l = num; l <= num2; l++)
				{
					for (int m = 0; (double)m < Main.worldSurface + 20.0; m++)
					{
						if (((l >= num + 2 && l <= num2 - 2) || genRand.Next(2) != 0) && ((l >= num + 3 && l <= num2 - 3) || genRand.Next(3) != 0) && (Main.tile[l, m].wall == 2 || Main.tile[l, m].wall == 59))
						{
							Main.tile[l, m].wall = 15;
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.BeeLarvaInBeehives, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				Main.tileSolid[229] = true;
				progress.Set(1.0);
				for (int i = 0; i < GenVars.numLarva; i++)
				{
					int num = GenVars.larvaX[i];
					int num2 = GenVars.larvaY[i];
					for (int j = num - 1; j <= num + 1; j++)
					{
						for (int k = num2 - 2; k <= num2 + 1; k++)
						{
							if (k != num2 + 1)
							{
								Main.tile[j, k].active(active: false);
							}
							else
							{
								Main.tile[j, k].active(active: true);
								Main.tile[j, k].type = 225;
								Main.tile[j, k].slope(0);
								Main.tile[j, k].halfBrick(halfBrick: false);
							}
						}
					}
					PlaceTile(num, num2, 231, mute: true);
				}
				Main.tileSolid[232] = true;
				Main.tileSolid[162] = true;
			}
		});
		AddGenerationPass(GenPassNameID.SettleLiquidsPart2AndNotTheBees, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				if (getGoodWorldGen)
				{
					Main.tileSolid[56] = true;
				}
				progress.Message = Lang.gen[27].Value;
				if (SecretSeed.extraLiquid.Enabled)
				{
					progress.Message = Language.GetTextValue("WorldGeneration.WaterFeatures");
				}
				if (notTheBees)
				{
					NotTheBees();
				}
				Liquid.worldGenTilesIgnoreWater(ignoreSolids: true);
				Liquid.QuickWater(3);
				WaterCheck();
				int num = 0;
				Liquid.quickSettle = true;
				int num2 = 10;
				while (num < num2)
				{
					int num3 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;
					num++;
					double num4 = 0.0;
					int num5 = num3 * 5;
					while (Liquid.numLiquid > 0)
					{
						num5--;
						if (num5 < 0)
						{
							break;
						}
						double num6 = (double)(num3 - (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer)) / (double)num3;
						if (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer > num3)
						{
							num3 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;
						}
						if (num6 > num4)
						{
							num4 = num6;
						}
						else
						{
							num6 = num4;
						}
						if (num == 1)
						{
							progress.Set(num6 / 3.0 + 0.33);
						}
						Liquid.UpdateLiquid();
					}
					WaterCheck();
					progress.Set((double)num / (double)num2 / 3.0 + 0.66);
				}
				ClearPendingLiquid();
				Liquid.quickSettle = false;
				Liquid.worldGenTilesIgnoreWater(ignoreSolids: false);
				Main.tileSolid[484] = false;
			}
		});
		AddGenerationPass(GenPassNameID.CactusPalmTreesAndCoral, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration && !SecretSeed.noSurface.Enabled)
			{
				progress.Message = Lang.gen[38].Value;
				int num = 8;
				if (remixWorldGen)
				{
					num = 2;
				}
				int num2 = 400;
				int num3 = genRand.Next(3, 13);
				int num4 = genRand.Next(3, 13);
				int num5 = genRand.Next(2, 6);
				int num6 = genRand.Next(2, 6);
				int num7 = 380;
				for (int i = 0; i < GenVars.numOasis; i++)
				{
					int num8 = (int)((double)GenVars.oasisWidth[i] * 1.5);
					for (int j = GenVars.oasisPosition[i].X - num8; j <= GenVars.oasisPosition[i].X + num8; j++)
					{
						for (int k = GenVars.oasisPosition[i].Y - GenVars.oasisHeight; k <= GenVars.oasisPosition[i].Y + GenVars.oasisHeight; k++)
						{
							double num9 = 1.0;
							int num10 = 8;
							for (int l = j - num10; l <= j + num10; l++)
							{
								for (int m = k - num10; m <= k + num10; m++)
								{
									if (InWorld(l, m) && Main.tile[l, m] != null && Main.tile[l, m].active() && Main.tile[l, m].type == 323)
									{
										num9 = 0.13;
									}
								}
							}
							if (genRand.NextDouble() < num9)
							{
								TryGrowingTreeByType(323, j, k);
							}
							if (PlantSeaOat(j, k))
							{
								if (genRand.Next(2) == 0)
								{
									GrowSeaOat(j, k);
								}
								if (genRand.Next(2) == 0)
								{
									GrowSeaOat(j, k);
								}
							}
							PlaceOasisPlant(j, k, 530);
						}
					}
				}
				for (int n = 0; n < 3; n++)
				{
					progress.Set((double)n / 3.0);
					int num11;
					int num12;
					bool flag;
					int maxValue;
					switch (n)
					{
					default:
						num11 = 5;
						num12 = num7;
						flag = false;
						maxValue = num3;
						break;
					case 1:
						num11 = num2;
						num12 = Main.maxTilesX - num2;
						flag = true;
						maxValue = num;
						break;
					case 2:
						num11 = Main.maxTilesX - num7;
						num12 = Main.maxTilesX - 5;
						flag = false;
						maxValue = num4;
						break;
					}
					double num13 = Main.worldSurface - 1.0;
					if (remixWorldGen)
					{
						num13 = Main.maxTilesY - 50;
					}
					for (int num14 = num11; num14 < num12; num14++)
					{
						if (genRand.Next(maxValue) == 0)
						{
							for (int num15 = 0; (double)num15 < num13; num15++)
							{
								Tile tile = Main.tile[num14, num15];
								if (tile.active() && (tile.type == 53 || tile.type == 112 || tile.type == 234))
								{
									Tile tile2 = Main.tile[num14, num15 - 1];
									if (!tile2.active() && tile2.wall == 0)
									{
										if (flag)
										{
											if (remixWorldGen)
											{
												if ((double)num15 > Main.worldSurface)
												{
													if (SolidTile(num14, num15) && Main.tile[num14, num15 + 1].active() && Main.tile[num14, num15 + 1].type == 53 && Main.tile[num14, num15 + 2].active() && Main.tile[num14, num15 + 2].type == 53)
													{
														int maxValue2 = 3;
														TryGrowingTreeByType(323, num14, num15);
														if (!Main.tile[num14, num15 - 1].active() && genRand.Next(maxValue2) == 0)
														{
															PlantCactus(num14, num15);
														}
													}
												}
												else
												{
													int num16 = 0;
													for (int num17 = num14 - cactusWaterWidth; num17 < num14 + cactusWaterWidth; num17++)
													{
														for (int num18 = num15 - cactusWaterHeight; num18 < num15 + cactusWaterHeight; num18++)
														{
															num16 += Main.tile[num17, num18].liquid;
														}
													}
													if (num16 / 255 > cactusWaterLimit)
													{
														int maxValue3 = 4;
														if (genRand.Next(maxValue3) == 0)
														{
															TryGrowingTreeByType(323, num14, num15);
														}
													}
													else
													{
														PlantCactus(num14, num15);
													}
												}
											}
											else
											{
												int num19 = 0;
												for (int num20 = num14 - cactusWaterWidth; num20 < num14 + cactusWaterWidth; num20++)
												{
													for (int num21 = num15 - cactusWaterHeight; num21 < num15 + cactusWaterHeight; num21++)
													{
														if (InWorld(num20, num21))
														{
															num19 += Main.tile[num20, num21].liquid;
														}
													}
												}
												if (num19 / 255 > cactusWaterLimit)
												{
													int maxValue4 = 4;
													if (genRand.Next(maxValue4) == 0)
													{
														TryGrowingTreeByType(323, num14, num15);
													}
												}
												else
												{
													PlantCactus(num14, num15);
												}
											}
										}
										else
										{
											if (Main.tile[num14, num15 - 2].liquid == byte.MaxValue && Main.tile[num14, num15 - 3].liquid == byte.MaxValue && Main.tile[num14, num15 - 4].liquid == byte.MaxValue)
											{
												if (genRand.Next(2) == 0)
												{
													PlaceTile(num14, num15 - 1, 81, mute: true);
												}
												else
												{
													PlaceTile(num14, num15 - 1, 324, mute: true, forced: false, -1, RollRandomSeaShellStyle());
												}
												break;
											}
											if (Main.tile[num14, num15 - 2].liquid == 0 && (double)num15 < Main.worldSurface)
											{
												PlaceTile(num14, num15 - 1, 324, mute: true, forced: false, -1, RollRandomSeaShellStyle());
												break;
											}
										}
									}
								}
							}
						}
						else
						{
							for (int num22 = 0; (double)num22 < num13; num22++)
							{
								if (PlantSeaOat(num14, num22))
								{
									if (genRand.Next(2) == 0)
									{
										GrowSeaOat(num14, num22);
									}
									if (genRand.Next(2) == 0)
									{
										GrowSeaOat(num14, num22);
									}
								}
								PlaceOasisPlant(num14, num22, 530);
							}
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.TileCleanup, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denySomeGeneration)
			{
				Main.tileSolid[379] = false;
				progress.Message = Lang.gen[84].Value;
				for (int i = 0; i < Main.maxTilesX; i++)
				{
					for (int j = 0; j < Main.maxTilesY; j++)
					{
						Tile tile = Main.tile[i, j];
						if (!tile.active() || !TileID.Sets.SaveSlopes[tile.type])
						{
							tile.ClearSlope();
						}
					}
				}
				for (int k = 40; k < Main.maxTilesX - 40; k++)
				{
					progress.Set((double)(k - 40) / (double)(Main.maxTilesX - 80));
					for (int l = 40; l < Main.maxTilesY - 40; l++)
					{
						if (Main.tile[k, l].active() && Main.tile[k, l].topSlope() && ((Main.tile[k, l].leftSlope() && Main.tile[k + 1, l].active() && Main.tile[k + 1, l].halfBrick()) || (Main.tile[k, l].rightSlope() && Main.tile[k - 1, l].active() && Main.tile[k - 1, l].halfBrick())))
						{
							Main.tile[k, l].slope(0);
							Main.tile[k, l].halfBrick(halfBrick: true);
						}
						if (Main.tile[k, l].active() && Main.tile[k, l].liquid > 0 && TileID.Sets.SlowlyDiesInWater[Main.tile[k, l].type])
						{
							KillTile(k, l);
						}
						if (!Main.tile[k, l].active() && Main.tile[k, l].liquid == 0 && genRand.Next(3) != 0 && SolidTile(k, l - 1))
						{
							int num = genRand.Next(15, 21);
							for (int num2 = l - 2; num2 >= l - num; num2--)
							{
								if (Main.tile[k, num2].liquid >= 128 && !Main.tile[k, num2].shimmer())
								{
									int num3 = 373;
									if (Main.tile[k, num2].lava())
									{
										num3 = 374;
									}
									else if (Main.tile[k, num2].honey())
									{
										num3 = 375;
									}
									else if (Main.tile[k, num2].shimmer())
									{
										num3 = 709;
									}
									int maxValue = l - num2;
									if (genRand.Next(maxValue) <= 1)
									{
										if (Main.tile[k, l].wall == 86)
										{
											num3 = 375;
										}
										Main.tile[k, l].type = (ushort)num3;
										Main.tile[k, l].frameX = 0;
										Main.tile[k, l].frameY = 0;
										Main.tile[k, l].active(active: true);
										break;
									}
								}
							}
							if (!Main.tile[k, l].active())
							{
								num = genRand.Next(3, 11);
								for (int m = l + 1; m <= l + num; m++)
								{
									if (Main.tile[k, m].liquid >= 200 && !Main.tile[k, m].shimmer())
									{
										int num4 = 373;
										if (Main.tile[k, m].lava())
										{
											num4 = 374;
										}
										else if (Main.tile[k, m].honey())
										{
											num4 = 375;
										}
										else if (Main.tile[k, m].shimmer())
										{
											num4 = 709;
										}
										int num5 = m - l;
										if (genRand.Next(num5 * 3) <= 1)
										{
											Main.tile[k, l].type = (ushort)num4;
											Main.tile[k, l].frameX = 0;
											Main.tile[k, l].frameY = 0;
											Main.tile[k, l].active(active: true);
											break;
										}
									}
								}
							}
							if (!Main.tile[k, l].active() && genRand.Next(4) == 0)
							{
								Tile tile2 = Main.tile[k, l - 1];
								if (TileID.Sets.Conversion.Sandstone[tile2.type] || TileID.Sets.Conversion.HardenedSand[tile2.type])
								{
									Main.tile[k, l].type = 461;
									Main.tile[k, l].frameX = 0;
									Main.tile[k, l].frameY = 0;
									Main.tile[k, l].active(active: true);
								}
							}
						}
						if (Main.tile[k, l].wall == 13 || Main.tile[k, l].wall == 14)
						{
							Main.tile[k, l].liquid = 0;
						}
						if (Main.tile[k, l].wall == 87)
						{
							if (SecretSeed.extraLiquid.Enabled)
							{
								if (Main.tile[k, l].liquid > 0)
								{
									Main.tile[k, l].liquidType(0);
								}
								if (Main.tile[k, l].type == 374 || Main.tile[k, l].type == 709 || Main.tile[k, l].type == 375)
								{
									Main.tile[k, l].type = 373;
								}
							}
							else
							{
								Main.tile[k, l].liquid = 0;
							}
						}
						if (Main.tile[k, l].active())
						{
							if (Main.tile[k, l].type == 137)
							{
								int num6 = Main.tile[k, l].frameY / 18;
								if (num6 <= 2 || num6 == 5)
								{
									int num7 = -1;
									if (Main.tile[k, l].frameX >= 18)
									{
										num7 = 1;
									}
									if (Main.tile[k + num7, l].halfBrick() || Main.tile[k + num7, l].slope() != 0)
									{
										Main.tile[k + num7, l].active(active: false);
									}
								}
							}
							else if (Main.tile[k, l].type == 162 && Main.tile[k, l + 1].liquid == 0 && CanKillTile(k, l))
							{
								Main.tile[k, l].active(active: false);
							}
							if (Main.tile[k, l].type == 31)
							{
								int num8 = Main.tile[k, l].frameX / 18;
								int num9 = 0;
								int num10 = k;
								num9 += num8 / 2;
								num9 = ((!drunkWorldGen) ? (crimson ? 1 : 0) : ((Main.tile[k, l].wall == 83) ? 1 : 0));
								num8 %= 2;
								num10 -= num8;
								int num11 = Main.tile[k, l].frameY / 18;
								int num12 = 0;
								int num13 = l;
								num12 += num11 / 2;
								num11 %= 2;
								num13 -= num11;
								for (int n = 0; n < 2; n++)
								{
									for (int num14 = 0; num14 < 2; num14++)
									{
										int num15 = num10 + n;
										int num16 = num13 + num14;
										Main.tile[num15, num16].active(active: true);
										Main.tile[num15, num16].slope(0);
										Main.tile[num15, num16].halfBrick(halfBrick: false);
										Main.tile[num15, num16].type = 31;
										Main.tile[num15, num16].frameX = (short)(n * 18 + 36 * num9);
										Main.tile[num15, num16].frameY = (short)(num14 * 18 + 36 * num12);
									}
								}
							}
							if (Main.tile[k, l].type == 12)
							{
								int num17 = Main.tile[k, l].frameX / 18;
								int num18 = 0;
								int num19 = k;
								num18 += num17 / 2;
								num17 %= 2;
								num19 -= num17;
								int num20 = Main.tile[k, l].frameY / 18;
								int num21 = 0;
								int num22 = l;
								num21 += num20 / 2;
								num20 %= 2;
								num22 -= num20;
								for (int num23 = 0; num23 < 2; num23++)
								{
									for (int num24 = 0; num24 < 2; num24++)
									{
										int num25 = num19 + num23;
										int num26 = num22 + num24;
										Main.tile[num25, num26].active(active: true);
										Main.tile[num25, num26].slope(0);
										Main.tile[num25, num26].halfBrick(halfBrick: false);
										Main.tile[num25, num26].type = 12;
										Main.tile[num25, num26].frameX = (short)(num23 * 18 + 36 * num18);
										Main.tile[num25, num26].frameY = (short)(num24 * 18 + 36 * num21);
									}
									if (!Main.tile[num19 + num23, num22 + 2].active())
									{
										Main.tile[num19 + num23, num22 + 2].active(active: true);
										Main.tile[num19 + num23, num22 + 2].type = WallID.Sets.WallTypeToTerrainTileType[Main.tile[num19 + num23, num22 + 2].wall];
									}
									Main.tile[num19 + num23, num22 + 2].slope(0);
									Main.tile[num19 + num23, num22 + 2].halfBrick(halfBrick: false);
								}
							}
							if (Main.tile[k, l].type == 639)
							{
								int num27 = Main.tile[k, l].frameX / 18;
								int num28 = 0;
								int num29 = k;
								num28 += num27 / 2;
								num27 %= 2;
								num29 -= num27;
								int num30 = Main.tile[k, l].frameY / 18;
								int num31 = 0;
								int num32 = l;
								num31 += num30 / 2;
								num30 %= 2;
								num32 -= num30;
								for (int num33 = 0; num33 < 2; num33++)
								{
									for (int num34 = 0; num34 < 2; num34++)
									{
										int num35 = num29 + num33;
										int num36 = num32 + num34;
										Main.tile[num35, num36].active(active: true);
										Main.tile[num35, num36].slope(0);
										Main.tile[num35, num36].halfBrick(halfBrick: false);
										Main.tile[num35, num36].type = 639;
										Main.tile[num35, num36].frameX = (short)(num33 * 18 + 36 * num28);
										Main.tile[num35, num36].frameY = (short)(num34 * 18 + 36 * num31);
									}
									if (!Main.tile[num29 + num33, num32 + 2].active())
									{
										Main.tile[num29 + num33, num32 + 2].active(active: true);
										Main.tile[num29 + num33, num32 + 2].type = WallID.Sets.WallTypeToTerrainTileType[Main.tile[num29 + num33, num32 + 2].wall];
									}
									Main.tile[num29 + num33, num32 + 2].slope(0);
									Main.tile[num29 + num33, num32 + 2].halfBrick(halfBrick: false);
								}
							}
							if (TileID.Sets.BasicChest[Main.tile[k, l].type])
							{
								int num37 = Main.tile[k, l].frameX / 18;
								int num38 = 0;
								ushort type = 21;
								int num39 = k;
								int num40 = l - Main.tile[k, l].frameY / 18;
								if (Main.tile[k, l].type == 467)
								{
									type = 467;
								}
								while (num37 >= 2)
								{
									num38++;
									num37 -= 2;
								}
								num39 -= num37;
								int num41 = Chest.FindChest(num39, num40);
								if (num41 != -1)
								{
									switch (Main.chest[num41].item[0].type)
									{
									case 1156:
										num38 = 23;
										break;
									case 1571:
										num38 = 24;
										break;
									case 1569:
										num38 = 25;
										break;
									case 1260:
										num38 = 26;
										break;
									case 1572:
										num38 = 27;
										break;
									}
								}
								for (int num42 = 0; num42 < 2; num42++)
								{
									for (int num43 = 0; num43 < 2; num43++)
									{
										int num44 = num39 + num42;
										int num45 = num40 + num43;
										Main.tile[num44, num45].active(active: true);
										Main.tile[num44, num45].slope(0);
										Main.tile[num44, num45].halfBrick(halfBrick: false);
										Main.tile[num44, num45].type = type;
										Main.tile[num44, num45].frameX = (short)(num42 * 18 + 36 * num38);
										Main.tile[num44, num45].frameY = (short)(num43 * 18);
									}
									if (!Main.tile[num39 + num42, num40 + 2].active())
									{
										Main.tile[num39 + num42, num40 + 2].active(active: true);
										Main.tile[num39 + num42, num40 + 2].type = WallID.Sets.WallTypeToTerrainTileType[Main.tile[num39 + num42, num40 + 2].wall];
									}
									Main.tile[num39 + num42, num40 + 2].slope(0);
									Main.tile[num39 + num42, num40 + 2].halfBrick(halfBrick: false);
								}
							}
							if (Main.tile[k, l].type == 28)
							{
								int num46 = Main.tile[k, l].frameX / 18;
								int num47 = 0;
								int num48 = k;
								while (num46 >= 2)
								{
									num47++;
									num46 -= 2;
								}
								num48 -= num46;
								int num49 = Main.tile[k, l].frameY / 18;
								int num50 = 0;
								int num51 = l;
								while (num49 >= 2)
								{
									num50++;
									num49 -= 2;
								}
								num51 -= num49;
								for (int num52 = 0; num52 < 2; num52++)
								{
									for (int num53 = 0; num53 < 2; num53++)
									{
										int num54 = num48 + num52;
										int num55 = num51 + num53;
										Main.tile[num54, num55].active(active: true);
										Main.tile[num54, num55].slope(0);
										Main.tile[num54, num55].halfBrick(halfBrick: false);
										Main.tile[num54, num55].type = 28;
										Main.tile[num54, num55].frameX = (short)(num52 * 18 + 36 * num47);
										Main.tile[num54, num55].frameY = (short)(num53 * 18 + 36 * num50);
									}
									if (!Main.tile[num48 + num52, num51 + 2].active())
									{
										Main.tile[num48 + num52, num51 + 2].active(active: true);
										Main.tile[num48 + num52, num51 + 2].type = WallID.Sets.WallTypeToTerrainTileType[Main.tile[num48 + num52, num51 + 2].wall];
									}
									Main.tile[num48 + num52, num51 + 2].slope(0);
									Main.tile[num48 + num52, num51 + 2].halfBrick(halfBrick: false);
								}
							}
							if (Main.tile[k, l].type == 26)
							{
								int num56 = Main.tile[k, l].frameX / 18;
								int num57 = 0;
								int num58 = k;
								int num59 = l - Main.tile[k, l].frameY / 18;
								while (num56 >= 3)
								{
									num57++;
									num56 -= 3;
								}
								num58 -= num56;
								num57 = (drunkWorldGen ? ((Main.tile[k, l].wall == 83) ? 1 : 0) : (crimson ? 1 : 0));
								for (int num60 = 0; num60 < 3; num60++)
								{
									for (int num61 = 0; num61 < 2; num61++)
									{
										int num62 = num58 + num60;
										int num63 = num59 + num61;
										Main.tile[num62, num63].active(active: true);
										Main.tile[num62, num63].slope(0);
										Main.tile[num62, num63].halfBrick(halfBrick: false);
										Main.tile[num62, num63].type = 26;
										Main.tile[num62, num63].frameX = (short)(num60 * 18 + 54 * num57);
										Main.tile[num62, num63].frameY = (short)(num61 * 18);
									}
									if (!Main.tile[num58 + num60, num59 + 2].active())
									{
										Main.tile[num58 + num60, num59 + 2].active(active: true);
										Main.tile[num58 + num60, num59 + 2].type = WallID.Sets.WallTypeToTerrainTileType[Main.tile[num58 + num60, num59 + 2].wall];
									}
									if ((!Main.tileSolid[Main.tile[num58 + num60, num59 + 2].type] || Main.tileSolidTop[Main.tile[num58 + num60, num59 + 2].type]) && !TileID.Sets.Platforms[Main.tile[num58 + num60, num59 + 2].type])
									{
										Main.tile[num58 + num60, num59 + 2].type = WallID.Sets.WallTypeToTerrainTileType[Main.tile[num58 + num60, num59 + 2].wall];
									}
									Main.tile[num58 + num60, num59 + 2].slope(0);
									Main.tile[num58 + num60, num59 + 2].halfBrick(halfBrick: false);
									if (Main.tile[num58 + num60, num59 + 3].type == 28 && Main.tile[num58 + num60, num59 + 3].frameY % 36 >= 18)
									{
										Main.tile[num58 + num60, num59 + 3].type = 0;
										Main.tile[num58 + num60, num59 + 3].active(active: false);
									}
								}
								for (int num64 = 0; num64 < 3; num64++)
								{
									if ((Main.tile[num58 - 1, num59 + num64].type == 28 || Main.tile[num58 - 1, num59 + num64].type == 12 || Main.tile[num58 - 1, num59 + num64].type == 639) && Main.tile[num58 - 1, num59 + num64].frameX % 36 < 18)
									{
										Main.tile[num58 - 1, num59 + num64].type = 0;
										Main.tile[num58 - 1, num59 + num64].active(active: false);
									}
									if ((Main.tile[num58 + 3, num59 + num64].type == 28 || Main.tile[num58 + 3, num59 + num64].type == 12 || Main.tile[num58 - 1, num59 + num64].type == 639) && Main.tile[num58 + 3, num59 + num64].frameX % 36 >= 18)
									{
										Main.tile[num58 + 3, num59 + num64].type = 0;
										Main.tile[num58 + 3, num59 + num64].active(active: false);
									}
								}
							}
							if (Main.tile[k, l].type == 237 && Main.tile[k, l + 1].type == 232)
							{
								Main.tile[k, l + 1].type = 226;
							}
						}
					}
				}
				Main.tileSolid[379] = true;
			}
		});
		AddGenerationPass(GenPassNameID.LihzahrdAltar, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Set(1.0);
				for (int i = 0; i < 3; i++)
				{
					for (int j = 0; j < 2; j++)
					{
						int num = GenVars.lAltarX + i;
						int num2 = GenVars.lAltarY + j;
						Main.tile[num, num2].active(active: true);
						Main.tile[num, num2].type = 237;
						Main.tile[num, num2].frameX = (short)(i * 18);
						Main.tile[num, num2].frameY = (short)(j * 18);
					}
					Main.tile[GenVars.lAltarX + i, GenVars.lAltarY + 2].active(active: true);
					Main.tile[GenVars.lAltarX + i, GenVars.lAltarY + 2].slope(0);
					Main.tile[GenVars.lAltarX + i, GenVars.lAltarY + 2].halfBrick(halfBrick: false);
					Main.tile[GenVars.lAltarX + i, GenVars.lAltarY + 2].type = 226;
				}
				for (int k = 0; k < 3; k++)
				{
					for (int l = 0; l < 2; l++)
					{
						int i2 = GenVars.lAltarX + k;
						int j2 = GenVars.lAltarY + l;
						SquareTileFrame(i2, j2);
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.MicroBiomes, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[76].Value;
				_ = (double)(Main.maxTilesX * Main.maxTilesY) / 5040000.0;
				double num = 10.0;
				float num2 = 0f;
				float num3 = 1f / (float)num;
				int num4 = 3000;
				if (!SecretSeed.Variations.actuallyNoTrapsForRealIMeanIt)
				{
					if (getGoodWorldGen || noTrapsWorldGen)
					{
						num *= 3.0;
					}
					DeadMansChestBiome deadMansChestBiome = GenVars.configuration.CreateBiome<DeadMansChestBiome>();
					List<int> possibleChestsToTrapify = deadMansChestBiome.GetPossibleChestsToTrapify(GenVars.structures);
					int random = passConfig.Get<WorldGenRange>("DeadManChests").GetRandom(genRand);
					int num5 = 0;
					while (num5 < random && possibleChestsToTrapify.Count > 0)
					{
						float num6 = (float)num5 / (float)random;
						progress.Set(num2 + num6 * num3);
						num4--;
						if (num4 <= 0)
						{
							break;
						}
						int num7 = possibleChestsToTrapify[genRand.Next(possibleChestsToTrapify.Count)];
						Point origin = new Point(Main.chest[num7].x, Main.chest[num7].y);
						deadMansChestBiome.Place(origin, GenVars.structures);
						num5++;
						possibleChestsToTrapify.Remove(num7);
					}
				}
				progress.Set(num3);
				if (!notTheBees || remixWorldGen)
				{
					num2 = 1f / (float)num;
					ThinIceBiome thinIceBiome = GenVars.configuration.CreateBiome<ThinIceBiome>();
					int random2 = passConfig.Get<WorldGenRange>("ThinIcePatchCount").GetRandom(genRand);
					int num8 = 0;
					int num9 = 1000;
					int num10 = 0;
					while (num10 < random2)
					{
						float num11 = (float)num10 / (float)random2;
						progress.Set(num2 + num11 * num3);
						Point origin2 = RandomWorldPoint((int)Main.worldSurface + 20, 50, 200, 50);
						bool flag = true;
						if (SecretSeed.dualDungeons.Enabled && DungeonUtils.InAnyPotentialDungeonBounds(origin2.X, origin2.Y))
						{
							flag = false;
						}
						if (flag && thinIceBiome.Place(origin2, GenVars.structures))
						{
							num10++;
							num8 = 0;
						}
						else
						{
							num8++;
							if (num8 > num9)
							{
								num10++;
								num8 = 0;
							}
						}
					}
				}
				progress.Set(0.1);
				progress.Set(num3 * 2f);
				if (!SecretSeed.Variations.noSurfaceNoSwordShrines)
				{
					num2 = 2f / (float)num;
					EnchantedSwordBiome enchantedSwordBiome = GenVars.configuration.CreateBiome<EnchantedSwordBiome>();
					int num12 = passConfig.Get<WorldGenRange>("SwordShrineAttempts").GetRandom(genRand);
					double num13 = passConfig.Get<double>("SwordShrinePlacementChance");
					if (tenthAnniversaryWorldGen)
					{
						num12 *= 2;
						num13 /= 2.0;
					}
					if (SecretSeed.errorWorld.Enabled && 6 / SecretSeed.Variations.errorWorldAdjustment(1.0) > 1)
					{
						num12 *= 6 / SecretSeed.Variations.errorWorldAdjustment(1.0);
						num13 /= (double)(6 / SecretSeed.Variations.errorWorldAdjustment(1.0));
					}
					Point origin3 = default(Point);
					for (int i = 0; i < num12; i++)
					{
						float num14 = (float)i / (float)num12;
						progress.Set(num2 + num14 * num3);
						if ((i == 0 && tenthAnniversaryWorldGen) || !(genRand.NextDouble() < num13))
						{
							int num15 = 0;
							while (num15++ <= Main.maxTilesX)
							{
								origin3.Y = (int)GenVars.worldSurface + genRand.Next(50, 100);
								if (SecretSeed.errorWorld.Enabled && (genRand.Next(3) != 0 || SecretSeed.noSurface.Enabled))
								{
									origin3.Y = genRand.Next((int)GenVars.worldSurface + genRand.Next(50, 100), Main.UnderworldLayer - 100);
								}
								if (genRand.Next(2) == 0)
								{
									origin3.X = genRand.Next(50, (int)((double)Main.maxTilesX * 0.3));
								}
								else
								{
									origin3.X = genRand.Next((int)((double)Main.maxTilesX * 0.7), Main.maxTilesX - 50);
								}
								if (SecretSeed.dualDungeons.Enabled)
								{
									DungeonUtils.InAnyPotentialDungeonBounds(origin3.X, origin3.Y);
								}
								if (enchantedSwordBiome.Place(origin3, GenVars.structures))
								{
									break;
								}
							}
						}
					}
				}
				progress.Set(0.2);
				progress.Set(num3 * 3f);
				if (!notTheBees || remixWorldGen)
				{
					num2 = 3f / (float)num;
					CampsiteBiome campsiteBiome = GenVars.configuration.CreateBiome<CampsiteBiome>();
					int random3 = passConfig.Get<WorldGenRange>("CampsiteCount").GetRandom(genRand);
					num4 = 1000;
					int num16 = 0;
					while (num16 < random3)
					{
						float num17 = (float)num16 / (float)random3;
						progress.Set(num2 + num17 * num3);
						num4--;
						if (num4 <= 0)
						{
							break;
						}
						int top = (int)Main.worldSurface;
						if (SecretSeed.noSurface.Enabled)
						{
							top = (int)Main.rockLayer / 4;
						}
						Point origin4 = RandomWorldPoint(top, beachDistance, 200, beachDistance);
						bool flag2 = true;
						if (SecretSeed.dualDungeons.Enabled && DungeonUtils.InAnyPotentialDungeonBounds(origin4.X, origin4.Y))
						{
							flag2 = false;
						}
						if (flag2 && campsiteBiome.Place(origin4, GenVars.structures))
						{
							num16++;
						}
					}
				}
				progress.Set(num3 * 4f);
				if (!SecretSeed.Variations.actuallyNoTrapsForRealIMeanIt)
				{
					num2 = 4f / (float)num;
					if (!notTheBees || remixWorldGen)
					{
						MiningExplosivesBiome miningExplosivesBiome = GenVars.configuration.CreateBiome<MiningExplosivesBiome>();
						int num18 = passConfig.Get<WorldGenRange>("ExplosiveTrapCount").GetRandom(genRand);
						if ((getGoodWorldGen || noTrapsWorldGen) && !notTheBees)
						{
							num18 = (int)((double)num18 * 1.5);
						}
						num4 = 3000;
						int num19 = 0;
						while (num19 < num18)
						{
							float num20 = (float)num19 / (float)num18;
							progress.Set(num2 + num20 * num3);
							num4--;
							if (num4 <= 0)
							{
								break;
							}
							int top2 = (int)GenVars.rockLayer;
							int bottom = 200;
							if (remixWorldGen)
							{
								top2 = (int)Main.worldSurface;
								bottom = (int)GenVars.rockLayer;
							}
							Point origin5 = RandomWorldPoint(top2, beachDistance, bottom, beachDistance);
							bool flag3 = true;
							if (SecretSeed.dualDungeons.Enabled && DungeonUtils.InAnyPotentialDungeonBounds(origin5.X, origin5.Y))
							{
								flag3 = false;
							}
							if (flag3 && miningExplosivesBiome.Place(origin5, GenVars.structures))
							{
								num19++;
							}
						}
					}
				}
				progress.Set(0.3);
				progress.Set(num3 * 5f);
				num2 = 5f / (float)num;
				MahoganyTreeBiome mahoganyTreeBiome = GenVars.configuration.CreateBiome<MahoganyTreeBiome>();
				int random4 = passConfig.Get<WorldGenRange>("LivingTreeCount").GetRandom(genRand);
				int num21 = 0;
				int num22 = 0;
				while (num21 < random4 && num22 < 20000)
				{
					float num23 = (float)num21 / (float)random4;
					progress.Set(num2 + num23 * num3);
					Point origin6 = RandomWorldPoint((int)Main.worldSurface + 50, 50, 500, 50);
					bool flag4 = true;
					if (SecretSeed.dualDungeons.Enabled && DungeonUtils.InAnyPotentialDungeonBounds(origin6.X, origin6.Y))
					{
						flag4 = false;
					}
					if (flag4 && mahoganyTreeBiome.Place(origin6, GenVars.structures))
					{
						num21++;
					}
					num22++;
				}
				progress.Set(0.4);
				progress.Set(num3 * 6f);
				progress.Set(num3 * 7f);
				num2 = 7f / (float)num;
				TrackGenerator trackGenerator = new TrackGenerator();
				int num24 = passConfig.Get<WorldGenRange>("LongTrackCount").GetRandom(genRand);
				WorldGenRange worldGenRange = passConfig.Get<WorldGenRange>("LongTrackLength");
				int num25 = Main.maxTilesX / 2;
				if (SecretSeed.errorWorld.Enabled)
				{
					num25 /= 2;
				}
				if (SecretSeed.dualDungeons.Enabled)
				{
					num24 /= 2;
				}
				int num26 = 0;
				int num27 = 0;
				while (num27 < num24)
				{
					float num28 = (float)num27 / (float)num24;
					progress.Set(num2 + num28 * num3);
					Point origin7 = RandomWorldPoint((int)Main.worldSurface, 10, 200, 10);
					bool flag5 = true;
					if (SecretSeed.dualDungeons.Enabled && DungeonUtils.InAnyPotentialDungeonBounds(origin7.X, origin7.Y))
					{
						flag5 = false;
					}
					if (flag5 && trackGenerator.Place(origin7, worldGenRange.ScaledMinimum, worldGenRange.ScaledMaximum))
					{
						num27++;
						num26 = 0;
					}
					else
					{
						num26++;
						if (num26 > num25)
						{
							num27++;
							num26 = 0;
						}
					}
				}
				progress.Set(num3 * 8f);
				num2 = 8f / (float)num;
				num24 = passConfig.Get<WorldGenRange>("StandardTrackCount").GetRandom(genRand);
				worldGenRange = passConfig.Get<WorldGenRange>("StandardTrackLength");
				num26 = 0;
				if (SecretSeed.errorWorld.Enabled)
				{
					num24 = (int)((double)num24 * 1.5);
				}
				if (SecretSeed.dualDungeons.Enabled)
				{
					num24 /= 2;
				}
				int num29 = 0;
				while (num29 < num24)
				{
					float num30 = (float)num29 / (float)num24;
					progress.Set(num2 + num30 * num3);
					Point origin8 = RandomWorldPoint((int)Main.worldSurface, 10, 200, 10);
					bool flag6 = true;
					if (SecretSeed.dualDungeons.Enabled && DungeonUtils.InAnyPotentialDungeonBounds(origin8.X, origin8.Y))
					{
						flag6 = false;
					}
					if (flag6 && trackGenerator.Place(origin8, worldGenRange.ScaledMinimum, worldGenRange.ScaledMaximum))
					{
						num29++;
						num26 = 0;
					}
					else
					{
						num26++;
						if (num26 > num25)
						{
							num29++;
							num26 = 0;
						}
					}
				}
				progress.Set(num3 * 9f);
				if (!SecretSeed.Variations.actuallyNoTrapsForRealIMeanIt)
				{
					num2 = 9f / (float)num;
					if (!notTheBees)
					{
						double num31 = (double)Main.maxTilesX * 0.02;
						if (noTrapsWorldGen)
						{
							num *= 5.0;
						}
						else if (getGoodWorldGen)
						{
							num *= 2.0;
						}
						for (int j = 0; (double)j < num31; j++)
						{
							float num32 = (float)j / (float)num31;
							progress.Set(num2 + num32 * num3);
							for (int k = 0; k < 10150; k++)
							{
								int x = genRand.Next(200, Main.maxTilesX - 200);
								int y = genRand.Next(GenVars.lavaLine - 100, Main.maxTilesY - 210);
								bool flag7 = true;
								if (SecretSeed.dualDungeons.Enabled && DungeonUtils.InAnyPotentialDungeonBounds(x, y))
								{
									flag7 = false;
								}
								if (flag7 && placeLavaTrap(x, y))
								{
									break;
								}
							}
						}
					}
				}
				progress.Set(1.0);
			}
		});
		AddGenerationPass(GenPassNameID.LilypadsCattailsBambooAndSeaweed, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!Skyblock.denyAllGeneration)
			{
				progress.Message = Lang.gen[88].Value;
				int num = (int)Main.worldSurface;
				if (remixWorldGen)
				{
					num = Main.maxTilesY - 200;
				}
				for (int i = 20; i < Main.maxTilesX - 20; i++)
				{
					progress.Set((double)i / (double)Main.maxTilesX);
					for (int j = 1; j < num; j++)
					{
						if (genRand.Next(5) == 0 && Main.tile[i, j].liquid > 0)
						{
							if (!Main.tile[i, j].active())
							{
								if (genRand.Next(2) == 0)
								{
									PlaceLilyPad(i, j);
								}
								else
								{
									Point point = PlaceCatTail(i, j);
									if (InWorld(point.X, point.Y))
									{
										int num2 = genRand.Next(14);
										for (int k = 0; k < num2; k++)
										{
											GrowCatTail(point.X, point.Y);
										}
										SquareTileFrame(point.X, point.Y);
									}
								}
							}
							if ((!Main.tile[i, j].active() || Main.tile[i, j].type == 61 || Main.tile[i, j].type == 74) && PlaceBamboo(i, j))
							{
								int num3 = genRand.Next(10, 20);
								for (int l = 0; l < num3 && PlaceBamboo(i, j - l); l++)
								{
								}
							}
						}
					}
					int num4 = Main.UnderworldLayer;
					while ((double)num4 > Main.worldSurface)
					{
						if (Main.tile[i, num4].active())
						{
							if (Main.tile[i, num4].type == 53 && genRand.Next(3) != 0)
							{
								GrowCheckSeaweed(i, num4);
							}
							else if (Main.tile[i, num4].type == 549)
							{
								GrowCheckSeaweed(i, num4);
							}
						}
						num4--;
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.SpeleothemsAndGemTrees, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Language.GetTextValue("WorldGeneration.Speleothems");
			progress.Set(0.0);
			int num = Main.maxTilesX - 20;
			for (int i = 20; i < Main.maxTilesX - 20; i++)
			{
				if (progress != null)
				{
					float num2 = (float)i / (float)num;
					progress.Set(num2);
				}
				for (int j = (int)Main.worldSurface; j < Main.maxTilesY - 20; j++)
				{
					if ((Main.tenthAnniversaryWorld || drunkWorldGen || genRand.Next(5) == 0) && Main.tile[i, j - 1].liquid == 0)
					{
						int num3 = genRand.Next(7);
						int treeTileType = 0;
						switch (num3)
						{
						case 0:
							treeTileType = 583;
							break;
						case 1:
							treeTileType = 584;
							break;
						case 2:
							treeTileType = 585;
							break;
						case 3:
							treeTileType = 586;
							break;
						case 4:
							treeTileType = 587;
							break;
						case 5:
							treeTileType = 588;
							break;
						case 6:
							treeTileType = 589;
							break;
						}
						TryGrowingTreeByType(treeTileType, i, j);
					}
					if (!oceanDepths(i, j) && !Main.tile[i, j].active() && genRand.Next(5) == 0)
					{
						if ((Main.tile[i, j - 1].type == 1 || Main.tile[i, j - 1].type == 147 || Main.tile[i, j - 1].type == 161 || Main.tile[i, j - 1].type == 25 || Main.tile[i, j - 1].type == 203 || Main.tileStone[Main.tile[i, j - 1].type] || Main.tileMoss[Main.tile[i, j - 1].type]) && !Main.tile[i, j].active() && !Main.tile[i, j + 1].active())
						{
							Main.tile[i, j - 1].slope(0);
						}
						if ((Main.tile[i, j + 1].type == 1 || Main.tile[i, j + 1].type == 147 || Main.tile[i, j + 1].type == 161 || Main.tile[i, j + 1].type == 25 || Main.tile[i, j + 1].type == 203 || Main.tileStone[Main.tile[i, j + 1].type] || Main.tileMoss[Main.tile[i, j + 1].type]) && !Main.tile[i, j].active() && !Main.tile[i, j - 1].active())
						{
							Main.tile[i, j + 1].slope(0);
						}
						PlaceTight(i, j);
					}
				}
				for (int k = 5; k < (int)Main.worldSurface; k++)
				{
					if (Main.tile[i, k - 1].active() && (Main.tile[i, k - 1].type == 147 || Main.tile[i, k - 1].type == 161) && genRand.Next(5) == 0)
					{
						if (!Main.tile[i, k].active() && !Main.tile[i, k + 1].active())
						{
							Main.tile[i, k - 1].slope(0);
						}
						PlaceTight(i, k);
					}
					if (Main.tile[i, k - 1].active() && (Main.tile[i, k - 1].type == 25 || Main.tile[i, k - 1].type == 203) && genRand.Next(5) == 0)
					{
						if (!Main.tile[i, k].active() && !Main.tile[i, k + 1].active())
						{
							Main.tile[i, k - 1].slope(0);
						}
						PlaceTight(i, k);
					}
					if (Main.tile[i, k + 1].active() && (Main.tile[i, k + 1].type == 25 || Main.tile[i, k + 1].type == 203) && genRand.Next(5) == 0)
					{
						if (!Main.tile[i, k].active() && !Main.tile[i, k - 1].active())
						{
							Main.tile[i, k + 1].slope(0);
						}
						PlaceTight(i, k);
					}
				}
			}
			progress.Set(1.0);
		});
		AddGenerationPass(GenPassNameID.BrokenTrapCleanup, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!noTrapsWorldGen || tenthAnniversaryWorldGen || notTheBees)
			{
				progress.Message = Lang.gen[82].Value;
				List<Point> list = new List<Point>();
				int num = 50;
				for (int i = num; i < Main.maxTilesX - num; i++)
				{
					double value = (double)(i - num) / (double)(Main.maxTilesX - num * 2);
					progress.Set(value);
					for (int j = 50; j < Main.maxTilesY - 50; j++)
					{
						if (Main.tile[i, j].wire() && !list.Contains(new Point(i, j)))
						{
							ClearBrokenTraps(new Point(i, j), list);
						}
					}
				}
			}
		});
		AddGenerationPass(GenPassNameID.FinalCleanup, delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			Main.tileSolid[484] = false;
			FillWallHolesInArea(new Rectangle(0, 0, Main.maxTilesX, (int)Main.worldSurface));
			progress.Message = Lang.gen[86].Value;
			if (SecretSeed.Variations.surfaceIsDesertNormalFunction)
			{
				SecretSeed.DoSurfaceIsDesert();
			}
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				progress.Set((double)i / (double)Main.maxTilesX);
				for (int j = 0; j < Main.maxTilesY; j++)
				{
					if (Main.tile[i, j].active() && !SolidTile(i, j + 1) && (Main.tile[i, j].type == 53 || Main.tile[i, j].type == 112 || Main.tile[i, j].type == 234 || Main.tile[i, j].type == 224 || Main.tile[i, j].type == 123))
					{
						if ((double)j < Main.worldSurface + 10.0 && !Main.tile[i, j + 1].active() && Main.tile[i, j + 1].wall != 191 && !oceanDepths(i, j))
						{
							int num = 10;
							int num2 = j + 1;
							for (int k = num2; k < num2 + 10; k++)
							{
								if (Main.tile[i, k].active() && Main.tile[i, k].type == 314)
								{
									num = 0;
									break;
								}
							}
							while (!Main.tile[i, num2].active() && num > 0 && num2 < Main.maxTilesY - 50)
							{
								Main.tile[i, num2 - 1].slope(0);
								Main.tile[i, num2 - 1].halfBrick(halfBrick: false);
								Main.tile[i, num2].active(active: true);
								Main.tile[i, num2].type = Main.tile[i, j].type;
								Main.tile[i, num2].slope(0);
								Main.tile[i, num2].halfBrick(halfBrick: false);
								num2++;
								num--;
							}
							if (num == 0 && !Main.tile[i, num2].active())
							{
								switch (Main.tile[i, j].type)
								{
								case 53:
									Main.tile[i, num2].type = 397;
									Main.tile[i, num2].active(active: true);
									break;
								case 112:
									Main.tile[i, num2].type = 398;
									Main.tile[i, num2].active(active: true);
									break;
								case 234:
									Main.tile[i, num2].type = 399;
									Main.tile[i, num2].active(active: true);
									break;
								case 224:
									Main.tile[i, num2].type = 147;
									Main.tile[i, num2].active(active: true);
									break;
								case 123:
									Main.tile[i, num2].type = 1;
									Main.tile[i, num2].active(active: true);
									break;
								}
							}
							else if (Main.tile[i, num2].active() && Main.tileSolid[Main.tile[i, num2].type] && !Main.tileSolidTop[Main.tile[i, num2].type])
							{
								Main.tile[i, num2].slope(0);
								Main.tile[i, num2].halfBrick(halfBrick: false);
							}
						}
						else if (Main.tileSolid[Main.tile[i, j + 1].type] && !Main.tileSolidTop[Main.tile[i, j + 1].type] && (Main.tile[i, j + 1].topSlope() || Main.tile[i, j + 1].halfBrick()))
						{
							Main.tile[i, j + 1].slope(0);
							Main.tile[i, j + 1].halfBrick(halfBrick: false);
						}
						else
						{
							switch (Main.tile[i, j].type)
							{
							case 53:
								Main.tile[i, j].type = 397;
								break;
							case 112:
								Main.tile[i, j].type = 398;
								break;
							case 234:
								Main.tile[i, j].type = 399;
								break;
							case 224:
								Main.tile[i, j].type = 147;
								break;
							case 123:
								Main.tile[i, j].type = 1;
								break;
							}
						}
						if (Main.tile[i, j - 1].type == 323)
						{
							TileFrame(i, j - 1);
						}
					}
					if ((Main.tile[i, j].wall == 187 || Main.tile[i, j].wall == 216) && Main.tile[i, j].liquid > 0 && !remixWorldGen && !Main.dualDungeonsSeed)
					{
						Main.tile[i, j].liquid = byte.MaxValue;
						Main.tile[i, j].lava(lava: true);
					}
					if (Main.tile[i, j].type == 137)
					{
						Main.tile[i, j].slope(0);
						Main.tile[i, j].halfBrick(halfBrick: false);
					}
					if (Main.tile[i, j].active() && TileID.Sets.Boulders[Main.tile[i, j].type])
					{
						int num3 = Main.tile[i, j].frameX / 18;
						int num4 = i;
						num4 -= num3;
						int num5 = Main.tile[i, j].frameY / 18;
						int num6 = j;
						num6 -= num5;
						bool flag = false;
						for (int l = 0; l < 2; l++)
						{
							Tile tile = Main.tile[num4 + l, num6 - 1];
							if (tile != null && tile.active() && tile.type == 26)
							{
								flag = true;
								break;
							}
							for (int m = 0; m < 2; m++)
							{
								int num7 = num4 + l;
								int num8 = num6 + m;
								Main.tile[num7, num8].active(active: true);
								Main.tile[num7, num8].slope(0);
								Main.tile[num7, num8].halfBrick(halfBrick: false);
								Main.tile[num7, num8].type = Main.tile[i, j].type;
								Main.tile[num7, num8].frameX = (short)(l * 18);
								Main.tile[num7, num8].frameY = (short)(m * 18);
							}
						}
						if (flag)
						{
							ushort type = 0;
							if (Main.tile[i, j].type == 484)
							{
								type = 397;
							}
							for (int n = 0; n < 2; n++)
							{
								for (int num9 = 0; num9 < 2; num9++)
								{
									int num10 = num4 + n;
									int num11 = num6 + num9;
									Main.tile[num10, num11].active(active: true);
									Main.tile[num10, num11].slope(0);
									Main.tile[num10, num11].halfBrick(halfBrick: false);
									Main.tile[num10, num11].type = type;
									Main.tile[num10, num11].frameX = 0;
									Main.tile[num10, num11].frameY = 0;
								}
							}
						}
					}
					if (Main.tile[i, j].type == 323 && Main.tile[i, j].liquid > 0)
					{
						KillTile(i, j);
					}
					if (Main.wallDungeon[Main.tile[i, j].wall])
					{
						Main.tile[i, j].liquidType(0);
						if (Main.tile[i, j].type == 374)
						{
							Main.tile[i, j].type = 373;
						}
						if (Main.tile[i, j].active() && Main.tile[i, j].type == 56)
						{
							KillTile(i, j);
							Main.tile[i, j].liquidType(0);
							Main.tile[i, j].liquid = byte.MaxValue;
						}
					}
					if (Main.tile[i, j].active() && Main.tile[i, j].type == 314 && !SecretSeed.extraLiquid.Enabled)
					{
						int num12 = 15;
						int num13 = 1;
						int num14 = j;
						while (j - num14 < num12)
						{
							Main.tile[i, num14].liquid = 0;
							num14--;
						}
						for (num14 = j; num14 - j < num13; num14++)
						{
							Main.tile[i, num14].liquid = 0;
						}
					}
					if (Main.tile[i, j].active() && Main.tile[i, j].type == 332 && !Main.tile[i, j + 1].active())
					{
						Main.tile[i, j + 1].ClearEverything();
						Main.tile[i, j + 1].active(active: true);
						Main.tile[i, j + 1].type = 332;
					}
					if (i > beachDistance && i < Main.maxTilesX - beachDistance && (double)j < Main.worldSurface && Main.tile[i, j].liquid > 0 && Main.tile[i, j].liquid < byte.MaxValue && Main.tile[i - 1, j].liquid < byte.MaxValue && Main.tile[i + 1, j].liquid < byte.MaxValue && Main.tile[i, j + 1].liquid < byte.MaxValue && (!Main.tile[i - 1, j].active() || !TileID.Sets.Clouds[Main.tile[i - 1, j].type]) && (!Main.tile[i + 1, j].active() || !TileID.Sets.Clouds[Main.tile[i + 1, j].type]) && (!Main.tile[i, j + 1].active() || !TileID.Sets.Clouds[Main.tile[i, j + 1].type]))
					{
						Main.tile[i, j].liquid = 0;
					}
					if (Main.tile[i, j].active() && Main.tile[i, j].type >= 0 && TileID.Sets.Paintings[Main.tile[i, j].type])
					{
						Tile tile2 = Main.tile[i, j];
						if (tile2.wall <= 0 && InWorld(i, j, 2))
						{
							Tile tile3 = Main.tile[i - 1, j];
							Tile tile4 = Main.tile[i + 1, j];
							Tile tile5 = Main.tile[i, j - 1];
							Tile tile6 = Main.tile[i, j + 1];
							ushort num15 = 0;
							if (num15 == 0 && tile3.wall > 0)
							{
								num15 = tile3.wall;
							}
							if (num15 == 0 && tile4.wall > 0)
							{
								num15 = tile4.wall;
							}
							if (num15 == 0 && tile5.wall > 0)
							{
								num15 = tile5.wall;
							}
							if (num15 == 0 && tile6.wall > 0)
							{
								num15 = tile6.wall;
							}
							if (num15 != 0)
							{
								tile2.wall = num15;
							}
						}
					}
					TileFrame(i, j);
				}
			}
			int num16 = 0;
			int num17 = 3;
			num17 = GetWorldSize() switch
			{
				1 => 6, 
				2 => 9, 
				_ => 3, 
			};
			if (tenthAnniversaryWorldGen)
			{
				num17 *= 5;
			}
			int num18 = 50;
			int minValue = num18;
			int minValue2 = num18;
			int maxValue = Main.maxTilesX - num18;
			int maxValue2 = Main.maxTilesY - 200;
			int num19 = 3000;
			while (num16 < num17)
			{
				num19--;
				if (num19 <= 0)
				{
					break;
				}
				int num20 = genRand.Next(minValue, maxValue);
				int num21 = genRand.Next(minValue2, maxValue2);
				Tile tile7 = Main.tile[num20, num21];
				if (tile7.active() && tile7.type >= 0 && tile7.type < TileID.Count)
				{
					bool flag2 = TileID.Sets.Dirt[tile7.type];
					if (notTheBees)
					{
						flag2 = flag2 || TileID.Sets.Mud[tile7.type];
					}
					if (flag2)
					{
						num16++;
						tile7.ClearTile();
						tile7.active(active: true);
						tile7.type = 668;
					}
				}
			}
			if (noTrapsWorldGen)
			{
				FinishNoTraps();
			}
			if (Main.tenthAnniversaryWorld)
			{
				FinishTenthAnniversaryWorld();
			}
			if (drunkWorldGen)
			{
				FinishDrunkGen();
			}
			if (notTheBees)
			{
				NotTheBees();
				FinishNotTheBees();
			}
			if (getGoodWorldGen)
			{
				FinishGetGoodWorld();
			}
			if (remixWorldGen)
			{
				FinishRemixWorld();
			}
			if (SpecialSeedFeatures.ShimmerSpawnHalfOfWorld)
			{
				int num22 = Main.maxTilesX / 2;
				ShimmerifySideOfWorld(Main.spawnTileX <= num22);
			}
			if (SpecialSeedFeatures.RainbowSandAndBlackSandWalls)
			{
				PaintTheSandRainbowAndSandWallsBlack();
			}
			Point originalSpawnPoint = new Point(Main.spawnTileX, Main.spawnTileY);
			if (Main.vampireSeed)
			{
				if (!GenVars.worldSpawnHasBeenRandomized)
				{
					RandomizeWorldSpawn();
					PlaceTorchesAroundSpawn();
				}
				PutMonsterVanityInChests();
			}
			SecretSeed.FinalizeSecretSeeds();
			if (Main.tenthAnniversaryWorld)
			{
				FinishTenthAnniversaryWorldPaintTreesAndMushrooms();
			}
			ShimmerCleanUp();
			for (int num23 = 0; num23 < Main.maxTilesY; num23++)
			{
				for (int num24 = 0; num24 < Main.maxTilesX; num24++)
				{
					Tile tile8 = Main.tile[num24, num23];
					if (tile8.liquid > 0)
					{
						Liquid.LiquidCheck(num24, num23, tile8.liquidType(), createMergeTilesDuringGen: true);
					}
				}
			}
			ExtraSpawnPointManager.PrepareExtraSpawns();
			TownNPCPositionsCleanup(originalSpawnPoint);
			notTheBees = false;
			getGoodWorldGen = false;
			Main.AnglerQuestSwap();
			progress.Message = Lang.gen[87].Value;
		});
	}

	public static void DisablePassesForSpecialSeeds(List<GenPass> passes)
	{
		bool enabled = SecretSeed.dualDungeons.Enabled;
		if (!enabled)
		{
			return;
		}
		for (int i = 0; i < passes.Count; i++)
		{
			GenPass genPass = passes[i];
			string name = genPass.Name;
			if (enabled && (name == GenPassNameID.IceBiome || name == GenPassNameID.DesertBiome || name == GenPassNameID.Jungle || name == GenPassNameID.JungleShrines || name == GenPassNameID.ChestsInJungleShrines || name == GenPassNameID.Beehives || name == GenPassNameID.BeeLarvaInBeehives || name == GenPassNameID.LihzahrdTemple || name == GenPassNameID.LihzahrdTemplePart2 || name == GenPassNameID.LihzahrdAltar || name == GenPassNameID.CorruptionAndCrimson || name == GenPassNameID.Shimmer))
			{
				genPass.Disable();
			}
		}
	}

	public static void RestoreTemporaryStateChanges()
	{
		if (tileSolidBackup != null)
		{
			Array.Copy(tileSolidBackup, Main.tileSolid, Main.tileSolid.Length);
		}
	}

	public static void Finish()
	{
		Main.WorldFileMetadata = FileMetadata.FromCurrentSettings(FileType.World);
		Main.NotifyOfEvent(GameNotificationType.WorldGen);
		drunkWorldGenText = false;
	}

	private static void GenerateSkyBlockWorld(GenerationProgress progress)
	{
		bool flag = false;
		int num = Main.maxTilesX / 420;
		bool flag2 = false;
		int num2 = 0;
		int num3 = 7;
		if (flag || SecretSeed.extraLiquid.Enabled || SecretSeed.noInfection.Enabled || SecretSeed.surfaceIsDesert.Enabled || SecretSeed.worldIsFrozen.Enabled || SecretSeed.hallowOnTheSurface.Enabled || SecretSeed.worldIsInfected.Enabled || SecretSeed.surfaceIsMushrooms.Enabled)
		{
			flag2 = true;
			num3 += num;
		}
		float num4 = 1f / (float)num3;
		progress.Set(0.0);
		for (int i = 0; i < Main.maxTilesX; i++)
		{
			for (int j = 0; j < Main.maxTilesY; j++)
			{
				Main.tile[i, j].active(active: false);
				Main.tile[i, j].type = 0;
			}
		}
		progress.Set((float)num2++ * num4);
		int num5;
		int num6;
		if (SecretSeed.randomSpawn.Enabled || Main.vampireSeed)
		{
			num5 = genRand.Next((int)((double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.8));
			num6 = genRand.Next((int)(Main.worldSurface + 200.0), Main.maxTilesY - 400);
		}
		else if (remixWorldGen)
		{
			num5 = genRand.Next((int)((double)Main.maxTilesX * 0.45), (int)((double)Main.maxTilesX * 0.55));
			num6 = genRand.Next(Main.UnderworldLayer + 80, Main.UnderworldLayer + 120);
		}
		else if (SecretSeed.noSurface.Enabled)
		{
			num5 = genRand.Next((int)((double)Main.maxTilesX * 0.45), (int)((double)Main.maxTilesX * 0.55));
			num6 = genRand.Next((int)(Main.rockLayer * 0.3), (int)(Main.rockLayer * 0.8));
		}
		else if (SecretSeed.surfaceIsInSpace.Enabled)
		{
			num5 = genRand.Next((int)((double)Main.maxTilesX * 0.45), (int)((double)Main.maxTilesX * 0.55));
			int num7 = (int)((double)Main.maxTilesY * 0.05);
			if (num7 < 100)
			{
				num7 = 100;
			}
			int num8 = (int)((double)Main.maxTilesY * 0.08);
			if (num8 < 130)
			{
				num8 = 130;
			}
			num6 = genRand.Next(num7, num8);
		}
		else
		{
			num5 = genRand.Next((int)((double)Main.maxTilesX * 0.45), (int)((double)Main.maxTilesX * 0.55));
			num6 = genRand.Next((int)(Main.worldSurface * 0.6), (int)(Main.worldSurface * 0.8));
		}
		progress.Set((float)num2++ * num4);
		SkyblockIsland(num5, num6, 0);
		progress.Set((float)num2++ * num4);
		bool forceProximityCheck = false;
		if (SecretSeed.teamBasedSpawns.Enabled)
		{
			forceProximityCheck = true;
			for (int k = 1; k < PlayerTeamID.Count; k++)
			{
				float num9 = (float)k / (float)PlayerTeamID.Count;
				float num10 = num9;
				float num11 = 0.1f;
				float num12 = 0.1f;
				num10 = ((!(num9 < 0.5f)) ? Utils.Remap(num9, 0.5f, 1f, 0.5f + num11, 1f - num12) : Utils.Remap(num9, 0f, 0.5f, num12, 0.5f - num11));
				SkyblockIsland((int)((float)Main.maxTilesX * num10), num6 + genRand.Next(-30, 30), 0);
			}
		}
		progress.Set((float)num2++ * num4);
		int num14;
		if (flag || Skyblock.spawnShimmerPool)
		{
			bool flag3 = false;
			for (int num13 = 200; num13 > 0; num13--)
			{
				num14 = num6 + genRand.Next(-50, 50);
				if (num13 < 25)
				{
					num14 = 90 + genRand.Next(30);
				}
				int num15 = ((num5 >= Main.maxTilesX / 2) ? genRand.Next(beachDistance + 200, (int)((float)Main.maxTilesX * 0.3f)) : genRand.Next((int)((float)Main.maxTilesX * 0.7f), Main.maxTilesX - beachDistance - 200));
				num15 = (int)MathHelper.Clamp(num15, beachDistance + 200, Main.maxTilesX - beachDistance - 200);
				num14 = (int)MathHelper.Clamp(num14, 80f, Main.maxTilesY - 80);
				if (num13 < 100)
				{
					float num16 = genRand.NextFloat();
					float num17 = 0.1f;
					float num18 = 0.05f;
					num16 = ((!(num16 < 0.5f)) ? Utils.Remap(num16, 0.5f, 1f, 0.5f + num17, 1f - num18) : Utils.Remap(num16, 0f, 0.5f, num18, 0.5f - num17));
					num15 = (int)((float)Main.maxTilesX * num16);
				}
				if (SkyblockIsland(num15, num14, 1, forceProximityCheck))
				{
					flag3 = true;
					break;
				}
			}
			if (!flag3)
			{
				int num19 = 0;
				num19 = ((num5 >= Main.maxTilesX / 2) ? genRand.Next(beachDistance + 200, (int)((float)Main.maxTilesX * 0.3f)) : genRand.Next((int)((float)Main.maxTilesX * 0.7f), Main.maxTilesX - beachDistance - 200));
				int j2 = 90;
				SkyblockIsland(num19, j2, 1);
			}
			progress.Set((float)num2++ * num4);
		}
		for (num14 = num6; (!Main.tile[num5, num14].active() || Main.tile[num5, num14].type != 0) && num14 < Main.maxTilesY - 1; num14++)
		{
		}
		if (num14 > Main.maxTilesY - 10)
		{
			for (num14 = 0; !Main.tile[num5, num14].active() && num14 < Main.maxTilesY; num14++)
			{
			}
		}
		if (num14 > Main.maxTilesY - 10)
		{
			num14 = num6;
		}
		Main.spawnTileX = num5;
		Main.spawnTileY = num14;
		progress.Set((float)num2++ * num4);
		int num20 = 0;
		int num21 = (int)Main.worldSurface;
		if (num21 < 200)
		{
			num21 = (int)(200.0 + Main.rockLayer / 2.0) / 2;
		}
		if (flag2)
		{
			for (int l = 0; l < num; l++)
			{
				if (flag || SecretSeed.extraLiquid.Enabled)
				{
					switch (l)
					{
					case 0:
						SkyblockIsland(genRand.Next(beachDistance, Main.maxTilesX - beachDistance), genRand.Next(100, num21 - 50), 9);
						break;
					case 1:
						SkyblockIsland(genRand.Next(beachDistance, Main.maxTilesX - beachDistance), genRand.Next(num21 + 200, Main.maxTilesY - 70), 10);
						break;
					default:
					{
						if (notTheBees && l == 2)
						{
							SkyblockIsland(genRand.Next(beachDistance, Main.maxTilesX - beachDistance), genRand.Next(100, Main.UnderworldLayer - 100), 11);
							break;
						}
						if (tenthAnniversaryWorldGen && drunkWorldGen && l == 3)
						{
							SkyblockIsland(genRand.Next(beachDistance, Main.maxTilesX - beachDistance), genRand.Next(num21 + 200, Main.UnderworldLayer - 100), 11);
							break;
						}
						num20 = genRand.Next(4);
						while ((num20 == 2 && !notTheBees) || (num20 == 3 && (!tenthAnniversaryWorldGen || !drunkWorldGen)))
						{
							num20 = genRand.Next(4);
						}
						int num22 = genRand.Next(100, Main.UnderworldLayer - 100);
						if (num20 <= 1)
						{
							num20 = (((double)num22 > (Main.rockLayer + (double)Main.UnderworldLayer) / 2.0) ? 1 : 0);
						}
						SkyblockIsland(genRand.Next(beachDistance, Main.maxTilesX - beachDistance), num22, 9 + num20);
						break;
					}
					}
				}
				if (flag || SecretSeed.noInfection.Enabled)
				{
					if (l == 0)
					{
						SkyblockIsland(genRand.Next(beachDistance, Main.maxTilesX - beachDistance), genRand.Next(100, num21 - 50), 4);
					}
					else if (l <= num / 5 + 1)
					{
						SkyblockIsland(genRand.Next(beachDistance, Main.maxTilesX - beachDistance), genRand.Next(Main.UnderworldLayer + 30, Main.maxTilesY - 70), 4);
					}
					else
					{
						SkyblockIsland(genRand.Next(beachDistance, Main.maxTilesX - beachDistance), genRand.Next(100, Main.maxTilesY - 100), 4);
					}
				}
				if (flag || SecretSeed.surfaceIsDesert.Enabled)
				{
					if (l == 0)
					{
						SkyblockIsland(genRand.Next(beachDistance, Main.maxTilesX - beachDistance), genRand.Next(100, num21 - 50), 3);
					}
					else
					{
						SkyblockIsland(genRand.Next(beachDistance, Main.maxTilesX - beachDistance), genRand.Next(100, Main.UnderworldLayer - 100), 3);
					}
				}
				if (flag || SecretSeed.worldIsFrozen.Enabled)
				{
					if (l == 0)
					{
						SkyblockIsland(genRand.Next(beachDistance, Main.maxTilesX - beachDistance), genRand.Next(100, num21 - 50), 2);
					}
					else
					{
						SkyblockIsland(genRand.Next(beachDistance, Main.maxTilesX - beachDistance), genRand.Next(100, Main.UnderworldLayer - 100), 2);
					}
				}
				if (flag || SecretSeed.hallowOnTheSurface.Enabled)
				{
					if (l == 0)
					{
						SkyblockIsland(genRand.Next(beachDistance, Main.maxTilesX - beachDistance), genRand.Next(100, num21 - 50), 5);
					}
					else
					{
						SkyblockIsland(genRand.Next(beachDistance, Main.maxTilesX - beachDistance), genRand.Next(100, Main.UnderworldLayer - 100), 5);
					}
				}
				if (flag || SecretSeed.worldIsInfected.Enabled)
				{
					if (l == 0)
					{
						if (Main.drunkWorld)
						{
							SkyblockIsland(genRand.Next(beachDistance, Main.maxTilesX - beachDistance), genRand.Next(100, num21 - 50), genRand.Next(6, 8));
						}
						else if (crimson)
						{
							SkyblockIsland(genRand.Next(beachDistance, Main.maxTilesX - beachDistance), genRand.Next(100, num21 - 50), 7);
						}
						else
						{
							SkyblockIsland(genRand.Next(beachDistance, Main.maxTilesX - beachDistance), genRand.Next(100, num21 - 50), 6);
						}
					}
					else if (Main.drunkWorld)
					{
						SkyblockIsland(genRand.Next(beachDistance, Main.maxTilesX - beachDistance), genRand.Next(100, Main.UnderworldLayer - 100), genRand.Next(6, 8));
					}
					else if (crimson)
					{
						SkyblockIsland(genRand.Next(beachDistance, Main.maxTilesX - beachDistance), genRand.Next(100, Main.UnderworldLayer - 100), 7);
					}
					else
					{
						SkyblockIsland(genRand.Next(beachDistance, Main.maxTilesX - beachDistance), genRand.Next(100, Main.UnderworldLayer - 100), 6);
					}
				}
				if (flag || SecretSeed.surfaceIsMushrooms.Enabled)
				{
					SkyblockIsland(genRand.Next(beachDistance, Main.maxTilesX - beachDistance), genRand.Next(num21 + 200, Main.UnderworldLayer - 100), 8);
				}
				progress.Set((float)num2++ * num4);
			}
		}
		Main.dungeonX = -1;
		Main.dungeonY = -1;
		if (SecretSeed.extraLivingTrees.Enabled)
		{
			int num23 = genRand.Next(40, 80);
			if (genRand.Next(2) == 0)
			{
				num23 *= -1;
			}
			int num15 = num5 + num23;
			num14 = num6;
			GrowLivingTree(num15, num14);
		}
		if (SecretSeed.pooEverywhere.Enabled)
		{
			SecretSeed.DoPooEverywhere();
		}
		if (SecretSeed.errorWorld.Enabled)
		{
			SecretSeed.DoErrorWorldShuffleBlocks();
		}
		GenVars.worldSpawnHasBeenRandomized = true;
		if ((double)num6 > Main.worldSurface && num6 < Main.UnderworldLayer)
		{
			PlaceTorchesAroundSpawn();
		}
	}

	public static bool SkyblockIsland(int i, int j, int islandStyle, bool forceProximityCheck = false)
	{
		LandmassData item = new LandmassData
		{
			DataType = LandmassDataType.SkyblockIsland,
			Position = new Vector2(i, j),
			Style = islandStyle
		};
		if (forceProximityCheck || islandStyle > 1)
		{
			for (int k = i - 200; k <= i + 200; k++)
			{
				for (int l = j - 100; l <= j + 100; l++)
				{
					if (InWorld(k, l) && Main.tile[k, l].active())
					{
						return false;
					}
				}
			}
		}
		double num = genRand.Next(220, 250);
		float num2 = 4.5f;
		float num3 = 4f;
		int num4 = 0;
		int num5 = -1;
		int num6 = -1;
		int num7 = 189;
		int num8 = 189;
		int num9 = 196;
		int num10 = 73;
		int num11 = 56;
		if (islandStyle <= 1)
		{
			if (j > Main.UnderworldLayer)
			{
				num4 = 57;
			}
			else if (notTheBees && islandStyle == 0)
			{
				num4 = 59;
				num7 = 225;
				num10 = 86;
			}
		}
		switch (islandStyle)
		{
		case 1:
			num = genRand.Next(145, 156);
			num2 = 2.25f;
			num3 = 1.75f;
			break;
		default:
			num = genRand.Next(145, 156);
			num2 = 2.5f;
			num3 = 2.5f;
			break;
		case 0:
			break;
		}
		if (islandStyle == 2)
		{
			num4 = ((!((double)j > Main.worldSurface)) ? 147 : 161);
			num9 = 460;
		}
		if (islandStyle == 3)
		{
			num4 = 53;
			num9 = 189;
		}
		if (islandStyle == 4)
		{
			if (j > Main.UnderworldLayer)
			{
				num4 = 57;
				num6 = 633;
				num9 = 717;
			}
			else if ((double)j > Main.worldSurface)
			{
				num4 = 1;
			}
			else
			{
				num6 = 2;
			}
		}
		if (islandStyle == 5)
		{
			if ((double)j > Main.worldSurface)
			{
				num4 = 117;
			}
			else
			{
				num6 = 109;
			}
		}
		if (islandStyle == 6)
		{
			if ((double)j > Main.worldSurface)
			{
				num4 = 25;
			}
			else
			{
				num6 = 23;
			}
		}
		if (islandStyle == 7)
		{
			if ((double)j > Main.worldSurface)
			{
				num4 = 203;
			}
			else
			{
				num6 = 199;
			}
		}
		if (islandStyle == 8)
		{
			num4 = 59;
			num6 = 70;
		}
		if (islandStyle == 9)
		{
			num5 = 0;
			num7 = 196;
			num8 = 196;
			num9 = 189;
		}
		if (islandStyle == 10)
		{
			num5 = 1;
			num9 = 189;
			num7 = 717;
		}
		if (islandStyle == 11)
		{
			num5 = 2;
			num9 = 189;
		}
		if (islandStyle == 12)
		{
			num5 = 3;
			num9 = 189;
		}
		if (num9 == 196 && (double)j > (Main.rockLayer + (double)Main.UnderworldLayer) / 2.0)
		{
			num9 = 717;
		}
		double num12 = num;
		double num13 = genRand.Next(20, 30);
		double num14 = num;
		int num15 = i;
		int num16 = i;
		int num17 = j;
		int num18 = j;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
		{
			vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		}
		vector2D2.Y = (double)genRand.Next(-20, -10) * 0.02;
		while (num > 0.0 && num13 > 0.0)
		{
			num -= (double)genRand.Next(4);
			num13 -= 1.0;
			int num19 = (int)(vector2D.X - num * 0.5);
			int num20 = (int)(vector2D.X + num * 0.5);
			int num21 = (int)(vector2D.Y - num * 0.5);
			int num22 = (int)(vector2D.Y + num * 0.5);
			if (num19 < 0)
			{
				num19 = 0;
			}
			if (num20 > Main.maxTilesX)
			{
				num20 = Main.maxTilesX;
			}
			if (num21 < 0)
			{
				num21 = 0;
			}
			if (num22 > Main.maxTilesY)
			{
				num22 = Main.maxTilesY;
			}
			num12 = num * (double)genRand.Next(80, 120) * 0.01;
			double num23 = vector2D.Y + 1.0;
			for (int m = num19; m < num20; m++)
			{
				if (genRand.Next(2) == 0)
				{
					num23 += (double)genRand.Next(-1, 2);
				}
				if (num23 < vector2D.Y)
				{
					num23 = vector2D.Y;
				}
				if (num23 > vector2D.Y + 2.0)
				{
					num23 = vector2D.Y + 2.0;
				}
				for (int n = num21; n < num22; n++)
				{
					if (!InWorld(m, n, 5) || !((double)n > num23 + 1.0))
					{
						continue;
					}
					double num24 = Math.Abs((double)m - vector2D.X);
					double num25 = Math.Abs((double)n - vector2D.Y) * (double)num2;
					if (Math.Sqrt(num24 * num24 + num25 * num25) < num12 * 0.4)
					{
						if (m < num15)
						{
							num15 = m;
						}
						if (m > num16)
						{
							num16 = m;
						}
						if (n < num17)
						{
							num17 = n;
						}
						if (n > num18)
						{
							num18 = n;
						}
						Main.tile[m, n].active(active: true);
						Main.tile[m, n].type = (ushort)num7;
						SquareTileFrame(m, n);
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-20, 21) * 0.05;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			if (vector2D2.Y > 0.2)
			{
				vector2D2.Y = -0.2;
			}
			if (vector2D2.Y < -0.2)
			{
				vector2D2.Y = -0.2;
			}
		}
		int num26 = num15;
		num26 += genRand.Next(5);
		while (num26 < num16)
		{
			int num27 = num18 + 10;
			while (!Main.tile[num26, num27].active())
			{
				num27--;
				if (num27 <= 0)
				{
					break;
				}
			}
			if (num27 <= 0)
			{
				num26 += genRand.Next(5);
				num27 = num18;
				continue;
			}
			num27 += genRand.Next(-3, 4);
			int num28 = genRand.Next(4, 8);
			int num29 = num7;
			if (genRand.Next(4) == 0)
			{
				num29 = num9;
			}
			for (int num30 = num26 - num28; num30 <= num26 + num28; num30++)
			{
				for (int num31 = num27 - num28; num31 <= num27 + num28; num31++)
				{
					if (InWorld(num30, num31, 5) && num31 > num17)
					{
						double num32 = Math.Abs(num30 - num26);
						double num33 = Math.Abs(num31 - num27) * 2;
						if (Math.Sqrt(num32 * num32 + num33 * num33) < (double)(num28 + genRand.Next(2)))
						{
							Main.tile[num30, num31].active(active: true);
							Main.tile[num30, num31].type = (ushort)num29;
							SquareTileFrame(num30, num31);
						}
					}
				}
			}
			num26 += genRand.Next(num28, (int)((double)num28 * 1.5));
		}
		num = num14 * 0.800000011920929;
		num12 = num;
		num13 = genRand.Next(10, 15);
		vector2D.X = i;
		vector2D.Y = num17;
		vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
		{
			vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		}
		vector2D2.Y = (double)genRand.Next(-20, -10) * 0.02;
		while (num > 0.0 && num13 > 0.0)
		{
			num -= (double)genRand.Next(4);
			num13 -= 1.0;
			int num19 = (int)(vector2D.X - num * 0.5);
			int num20 = (int)(vector2D.X + num * 0.5);
			int num21 = num17 - 1;
			int num22 = (int)(vector2D.Y + num * 0.5);
			if (num19 < 0)
			{
				num19 = 0;
			}
			if (num20 > Main.maxTilesX)
			{
				num20 = Main.maxTilesX;
			}
			if (num21 < 0)
			{
				num21 = 0;
			}
			if (num22 > Main.maxTilesY)
			{
				num22 = Main.maxTilesY;
			}
			num12 = num * (double)genRand.Next(80, 120) * 0.01;
			double num34 = vector2D.Y + 1.0;
			for (int num35 = num19; num35 < num20; num35++)
			{
				if (genRand.Next(2) == 0)
				{
					num34 += (double)genRand.Next(-1, 2);
				}
				if (num34 < vector2D.Y)
				{
					num34 = vector2D.Y;
				}
				if (num34 > vector2D.Y + 2.0)
				{
					num34 = vector2D.Y + 2.0;
				}
				for (int num36 = num21; num36 < num22; num36++)
				{
					if (!InWorld(num35, num36, 5) || !((double)num36 > num34))
					{
						continue;
					}
					double num37 = Math.Abs((double)num35 - vector2D.X);
					double num38 = Math.Abs((double)num36 - vector2D.Y) * (double)num3;
					if (Math.Sqrt(num37 * num37 + num38 * num38) < num12 * 0.4 && Main.tile[num35, num36].type == num7)
					{
						if (num5 >= 0)
						{
							Main.tile[num35, num36].liquid = byte.MaxValue;
							Main.tile[num35, num36].liquidType(num5);
							Main.tile[num35, num36].active(active: false);
						}
						else
						{
							Main.tile[num35, num36].type = (ushort)num4;
						}
						SquareTileFrame(num35, num36);
					}
				}
			}
			if (num5 >= 0)
			{
				vector2D.X += vector2D2.X;
				vector2D.Y -= 0.5;
			}
			else
			{
				vector2D += vector2D2;
				vector2D2.X += (double)genRand.Next(-20, 21) * 0.05;
			}
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			if (vector2D2.Y > 0.2)
			{
				vector2D2.Y = -0.2;
			}
			if (vector2D2.Y < -0.2)
			{
				vector2D2.Y = -0.2;
			}
		}
		int num39 = num15;
		num39 += genRand.Next(5);
		while (num39 < num16)
		{
			int num40 = num18;
			if (num5 >= 0)
			{
				while (Main.tile[num39, num40].liquid == 0 && num39 < num16)
				{
					num40--;
					if (num40 < num17)
					{
						num40 = num18;
						num39 += genRand.Next(1, 4);
					}
				}
			}
			else
			{
				while ((!Main.tile[num39, num40].active() || Main.tile[num39, num40].type != num4) && num39 < num16)
				{
					num40--;
					if (num40 < num17)
					{
						num40 = num18;
						num39 += genRand.Next(1, 4);
					}
				}
			}
			if (num39 >= num16)
			{
				continue;
			}
			num40 += genRand.Next(0, 4);
			int num41 = genRand.Next(2, 8);
			int num42 = num7;
			for (int num43 = num39 - num41; num43 <= num39 + num41; num43++)
			{
				for (int num44 = num40 - num41; num44 <= num40 + num41; num44++)
				{
					if (!InWorld(num43, num44, 5) || num44 <= num17)
					{
						continue;
					}
					double num45 = Math.Abs(num43 - num39);
					double num46 = Math.Abs(num44 - num40) * 2;
					if (Math.Sqrt(num45 * num45 + num46 * num46) < (double)num41)
					{
						Main.tile[num43, num44].type = (ushort)num42;
						if (num5 >= 0)
						{
							Main.tile[num43, num44].active(active: true);
						}
						SquareTileFrame(num43, num44);
					}
				}
			}
			num39 += genRand.Next(num41, (int)((double)num41 * 1.5));
		}
		if (islandStyle == 1)
		{
			num = genRand.Next(40, 51);
			num12 = num;
			num13 = genRand.Next(3, 5);
			vector2D.X = i;
			vector2D.Y = num17;
			vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
			while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
			{
				vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
			}
			while (num > 0.0 && num13 > 0.0)
			{
				num -= (double)genRand.Next(4);
				num13 -= 1.0;
				int num19 = (int)(vector2D.X - num * 0.5);
				int num20 = (int)(vector2D.X + num * 0.5);
				int num21 = num17 - 1;
				int num22 = (int)(vector2D.Y + num * 0.5);
				if (num19 < 0)
				{
					num19 = 0;
				}
				if (num20 > Main.maxTilesX)
				{
					num20 = Main.maxTilesX;
				}
				if (num21 < 0)
				{
					num21 = 0;
				}
				if (num22 > Main.maxTilesY)
				{
					num22 = Main.maxTilesY;
				}
				num12 = num * (double)genRand.Next(80, 120) * 0.01;
				double num47 = vector2D.Y + 1.0;
				for (int num48 = num19; num48 < num20; num48++)
				{
					if (num47 < vector2D.Y)
					{
						num47 = vector2D.Y;
					}
					if (num47 > vector2D.Y + 2.0)
					{
						num47 = vector2D.Y + 2.0;
					}
					for (int num49 = num21; num49 < num22; num49++)
					{
						if (!InWorld(num48, num49, 5))
						{
							continue;
						}
						if ((double)num49 > num47)
						{
							double num50 = Math.Abs((double)num48 - vector2D.X);
							double num51 = Math.Abs((double)num49 - vector2D.Y) * 1.3;
							double num52 = Math.Sqrt(num50 * num50 + num51 * num51);
							if (num52 < num12 * 0.4)
							{
								if (!Main.tile[num48, num49].anyShimmer())
								{
									Main.tile[num48, num49].type = (ushort)num11;
									Main.tile[num48, num49].active(active: true);
								}
								if (!Main.tile[num48, num49 + 1].anyShimmer())
								{
									Main.tile[num48, num49 + 1].type = (ushort)num11;
									Main.tile[num48, num49 + 1].active(active: true);
								}
								SquareTileFrame(num48, num49);
							}
							if (num52 < num12 * 0.3)
							{
								Main.tile[num48, num49].active(active: false);
								Main.tile[num48, num49].liquid = byte.MaxValue;
								Main.tile[num48, num49].shimmer(shimmer: true);
								if (Main.tile[num48, num49 - 1].active())
								{
									Main.tile[num48, num49 - 1].active(active: false);
									Main.tile[num48, num49 - 1].liquid = byte.MaxValue;
									Main.tile[num48, num49 - 1].shimmer(shimmer: true);
								}
								SquareTileFrame(num48, num49);
							}
						}
						if ((double)num49 > num47 - 5.0 && (double)num49 <= num47)
						{
							Main.tile[num48, num49].active(active: false);
						}
					}
				}
				vector2D.X += vector2D2.X;
				vector2D2.X += (double)genRand.Next(-20, 21) * 0.05;
				if (vector2D2.X > 1.0)
				{
					vector2D2.X = 1.0;
				}
				if (vector2D2.X < -1.0)
				{
					vector2D2.X = -1.0;
				}
			}
		}
		for (int num53 = num15 - 20; num53 <= num16 + 20; num53++)
		{
			for (int num54 = num17 - 20; num54 <= num18 + 20; num54++)
			{
				if (!InWorld(num53, num54, 5))
				{
					continue;
				}
				bool flag = true;
				for (int num55 = num53 - 1; num55 <= num53 + 1; num55++)
				{
					for (int num56 = num54 - 1; num56 <= num54 + 1; num56++)
					{
						if (InWorld(num55, num56) && (!Main.tile[num55, num56].active() || (Main.tile[num55, num56].wall > 0 && Main.tile[num55, num56].wall != num10)))
						{
							flag = false;
						}
					}
				}
				if (flag)
				{
					Main.tile[num53, num54].wall = (ushort)num10;
					SquareWallFrame(num53, num54);
				}
			}
		}
		if (islandStyle == 0 && Skyblock.spawnSolidifier)
		{
			bool flag2 = true;
			int num57 = 10000;
			int num58 = 20;
			while (flag2 && num57 > 0)
			{
				num57--;
				if (num57 % 20 == 0)
				{
					num58++;
				}
				int value = genRand.Next(i - num58, i + num58);
				value = Utils.Clamp(value, num15, num16);
				int num59 = 5;
				int num60 = num59 + 1;
				if (!InWorld(value, num60, num59))
				{
					continue;
				}
				for (; !Main.tile[value, num60].active() && num60 < Main.maxTilesY - 10; num60++)
				{
				}
				if (Main.tile[value, num60].type == num4)
				{
					num60--;
					PlaceTile(value, num60, 220);
					if (Main.tile[value, num60 - 1].type == 220)
					{
						flag2 = false;
					}
				}
			}
		}
		if (islandStyle == 1)
		{
			for (int num61 = 0; num61 < 2; num61++)
			{
				bool flag3 = true;
				int num62 = 10000;
				int num63 = 10;
				while (flag3 && num62 > 0)
				{
					num62--;
					if (num62 % 50 == 0)
					{
						num63++;
					}
					int value2 = genRand.Next(i - num63, i + num63);
					value2 = Utils.Clamp(value2, num15, num16);
					int num64 = num17 - 30;
					if (!InWorld(value2, num64, 5))
					{
						continue;
					}
					for (; !Main.tile[value2, num64].active() && num64 < Main.maxTilesY - 10; num64++)
					{
					}
					if (Main.tile[value2, num64].type != num4 && Main.tile[value2, num64].type != num11)
					{
						continue;
					}
					num64--;
					if (Main.tile[value2, num64].liquid != 0 || Main.tile[value2 + 2, num64 + 1].liquid != 0 || Main.tile[value2 - 1, num64 + 1].liquid != 0)
					{
						continue;
					}
					switch (num61)
					{
					case 0:
						PlaceTile(value2, num64, 658);
						if (Main.tile[value2, num64].type == 658)
						{
							SwitchMonolith(value2, num64);
							flag3 = false;
						}
						break;
					case 1:
						if (num62 <= 2000 || !IsTileNearby(value2, num64, 658, 10))
						{
							PlaceTile(value2, num64, 139, mute: true, forced: false, -1, 87);
							if (Main.tile[value2, num64].type == 139)
							{
								SwitchMB(value2, num64);
								flag3 = false;
							}
						}
						break;
					}
				}
			}
		}
		int num65 = genRand.Next(4);
		for (int num66 = 0; num66 <= num65; num66++)
		{
			int num67 = genRand.Next(num15 - 5, num16 + 5);
			int num68 = num17 - genRand.Next(20, 40);
			int num69 = genRand.Next(4, 8);
			int num70 = num8;
			if (genRand.Next(2) == 0)
			{
				num70 = num9;
			}
			for (int num71 = num67 - num69; num71 <= num67 + num69; num71++)
			{
				for (int num72 = num68 - num69; num72 <= num68 + num69; num72++)
				{
					double num73 = Math.Abs(num71 - num67);
					double num74 = Math.Abs(num72 - num68) * 2;
					if (Math.Sqrt(num73 * num73 + num74 * num74) < (double)(num69 + genRand.Next(-1, 2)) && InWorld(num71, num72))
					{
						Main.tile[num71, num72].active(active: true);
						Main.tile[num71, num72].type = (ushort)num70;
						SquareTileFrame(num71, num72);
					}
				}
			}
		}
		if (num6 > 0)
		{
			int num75 = 0;
			if (num6 == 60 || num6 == 70)
			{
				num75 = 59;
			}
			if (num6 == 633)
			{
				num75 = 57;
			}
			for (int num76 = num15 - 20; num76 <= num16 + 20; num76++)
			{
				for (int num77 = j - 50; num77 <= j + 50; num77++)
				{
					if (InWorld(num76, num77, 5) && Main.tile[num76, num77].active() && Main.tile[num76, num77].type == num75 && !isTileSurroundedBySolidTiles(num76, num77))
					{
						Main.tile[num76, num77].type = (ushort)num6;
					}
				}
			}
		}
		GenVars.landmassData.Add(item);
		return true;
	}

	private static void GenerateUnderworldStartingMound()
	{
		int num = (int)((float)Main.maxTilesX * 0.38f);
		int num2 = (int)((float)Main.maxTilesX * 0.62f);
		int i = num;
		int num3 = Main.maxTilesY - 1;
		int num4 = Main.maxTilesY - 135;
		int num5 = Main.maxTilesY - 160;
		bool flag = false;
		Liquid.QuickWater(-2);
		for (; num3 < Main.maxTilesY - 1 || i < num2; i++)
		{
			if (!flag)
			{
				num3 -= genRand.Next(1, 4);
				if (num3 < num4)
				{
					flag = true;
				}
			}
			else if (i >= num2)
			{
				num3 += genRand.Next(1, 4);
				if (num3 > Main.maxTilesY - 1)
				{
					num3 = Main.maxTilesY - 1;
				}
			}
			else
			{
				if ((i <= Main.maxTilesX / 2 - 5 || i >= Main.maxTilesX / 2 + 5) && genRand.Next(4) == 0)
				{
					if (genRand.Next(3) == 0)
					{
						num3 += genRand.Next(-1, 2);
					}
					else if (genRand.Next(6) == 0)
					{
						num3 += genRand.Next(-2, 3);
					}
					else if (genRand.Next(8) == 0)
					{
						num3 += genRand.Next(-4, 5);
					}
				}
				if (num3 < num5)
				{
					num3 = num5;
				}
				if (num3 > num4)
				{
					num3 = num4;
				}
			}
			for (int num6 = num3; num6 > num3 - 20; num6--)
			{
				Main.tile[i, num6].liquid = 0;
			}
			for (int j = num3; j < Main.maxTilesY; j++)
			{
				Main.tile[i, j] = new Tile();
				Main.tile[i, j].active(active: true);
				Main.tile[i, j].type = 57;
			}
		}
		Liquid.QuickWater(-2);
		for (int k = num; k < num2 + 15; k++)
		{
			for (int l = Main.maxTilesY - 300; l < num4 + 20; l++)
			{
				Main.tile[k, l].liquid = 0;
				if (Main.tile[k, l].type == 57 && Main.tile[k, l].active() && (!Main.tile[k - 1, l - 1].active() || !Main.tile[k, l - 1].active() || !Main.tile[k + 1, l - 1].active() || !Main.tile[k - 1, l].active() || !Main.tile[k + 1, l].active() || !Main.tile[k - 1, l + 1].active() || !Main.tile[k, l + 1].active() || !Main.tile[k + 1, l + 1].active()))
				{
					Main.tile[k, l].type = 633;
				}
			}
		}
		for (int m = num; m < num2 + 15; m++)
		{
			for (int n = Main.maxTilesY - 200; n < num4 + 20; n++)
			{
				if (Main.tile[m, n].type == 633 && Main.tile[m, n].active() && !Main.tile[m, n - 1].active() && genRand.Next(3) == 0)
				{
					TryGrowingTreeByType(634, m, n);
				}
			}
		}
	}

	private static int GetPileGenerationAttempts()
	{
		int num = Main.maxTilesX / 2;
		if (skyblockWorldGen)
		{
			num /= 10;
		}
		return num;
	}

	private static bool isTileSurroundedBySolidTiles(int i, int j)
	{
		for (int k = i - 1; k <= i + 1; k++)
		{
			for (int l = j - 1; l <= j + 1; l++)
			{
				if (!SolidTile3(k, l))
				{
					return false;
				}
			}
		}
		return true;
	}

	public static void LiquidInteractionsCleanup()
	{
		for (int i = 1; i < Main.maxTilesX - 1 - 1; i++)
		{
			for (int j = 1; j < Main.maxTilesY - 1 - 1; j++)
			{
				Tile tile = Main.tile[i, j];
				if (!tile.active() || (tile.type != 56 && tile.type != 659))
				{
					continue;
				}
				tile.liquid = 0;
				tile.liquidType(0);
				Tile tile2 = Main.tile[i - 1, j];
				Tile tile3 = Main.tile[i + 1, j];
				Tile tile4 = Main.tile[i, j - 1];
				Tile tile5 = Main.tile[i, j + 1];
				int num = ((!tile2.active() && tile2.liquid > 0) ? tile2.liquidType() : (-1));
				int num2 = ((!tile3.active() && tile3.liquid > 0) ? tile3.liquidType() : (-1));
				int num3 = ((!tile4.active() && tile4.liquid > 0) ? tile4.liquidType() : (-1));
				int num4 = ((!tile5.active() && tile5.liquid > 0) ? tile5.liquidType() : (-1));
				int num5 = 0;
				int num6 = 0;
				int num7 = 0;
				int num8 = 0;
				if (num == 0)
				{
					num5++;
				}
				if (num2 == 0)
				{
					num5++;
				}
				if (num3 == 0)
				{
					num5++;
				}
				if (num4 == 0)
				{
					num5++;
				}
				if (num == 1)
				{
					num6++;
				}
				if (num2 == 1)
				{
					num6++;
				}
				if (num3 == 1)
				{
					num6++;
				}
				if (num4 == 1)
				{
					num6++;
				}
				if (num == 2)
				{
					num7++;
				}
				if (num2 == 2)
				{
					num7++;
				}
				if (num3 == 2)
				{
					num7++;
				}
				if (num4 == 2)
				{
					num7++;
				}
				if (num == 3)
				{
					num8++;
				}
				if (num2 == 3)
				{
					num8++;
				}
				if (num3 == 3)
				{
					num5++;
				}
				if (num4 == 3)
				{
					num8++;
				}
				if ((num5 > 0 && (num6 > 0 || num7 > 0 || num8 > 0)) || (num6 > 0 && (num5 > 0 || num7 > 0 || num8 > 0)) || (num7 > 0 && (num5 > 0 || num6 > 0 || num8 > 0)) || (num8 > 0 && (num5 > 0 || num6 > 0 || num7 > 0)))
				{
					continue;
				}
				short liquidType = 0;
				if (num5 == 0 && num6 == 0 && num7 == 0 && num8 == 0)
				{
					switch (tile.type)
					{
					case 56:
						liquidType = 1;
						break;
					case 659:
						liquidType = 3;
						break;
					}
				}
				if (num5 > 0)
				{
					liquidType = 0;
				}
				else if (num6 > 0)
				{
					liquidType = 1;
				}
				else if (num7 > 0)
				{
					liquidType = 2;
				}
				else if (num8 > 0)
				{
					liquidType = 3;
				}
				tile.ClearEverything();
				tile.liquid = byte.MaxValue;
				tile.liquidType(liquidType);
			}
		}
	}

	private static int GetRightMostDungeonTile()
	{
		if (GenVars.dungeonGenVars[0] == null)
		{
			return 300;
		}
		DungeonBounds outerPotentialDungeonBounds = GenVars.dungeonGenVars[0].outerPotentialDungeonBounds;
		int result = outerPotentialDungeonBounds.Left;
		for (int i = outerPotentialDungeonBounds.Left; i < outerPotentialDungeonBounds.Right; i++)
		{
			for (int j = outerPotentialDungeonBounds.Top; j < outerPotentialDungeonBounds.Bottom; j++)
			{
				Tile tile = Main.tile[i, j];
				if ((tile.active() && DungeonUtils.IsConsideredDungeonTile(tile.type)) || DungeonUtils.IsConsideredDungeonWall(tile.wall))
				{
					result = i;
					break;
				}
			}
		}
		return result;
	}

	private static int GetLeftMostDungeonTile()
	{
		if (GenVars.dungeonGenVars[0] == null)
		{
			return Main.maxTilesX - 300;
		}
		DungeonBounds outerPotentialDungeonBounds = GenVars.dungeonGenVars[0].outerPotentialDungeonBounds;
		int num = outerPotentialDungeonBounds.Right;
		for (int num2 = num; num2 > outerPotentialDungeonBounds.Left; num2--)
		{
			for (int i = outerPotentialDungeonBounds.Top; i < outerPotentialDungeonBounds.Bottom; i++)
			{
				Tile tile = Main.tile[num2, i];
				if ((tile.active() && DungeonUtils.IsConsideredDungeonTile(tile.type)) || DungeonUtils.IsConsideredDungeonWall(tile.wall))
				{
					num = num2;
					break;
				}
			}
		}
		return num;
	}

	private static void RandomizeWorldSpawn()
	{
		GenVars.worldSpawnHasBeenRandomized = true;
		_ = Main.spawnTileX;
		_ = Main.spawnTileY;
		bool flag = false;
		int num = Main.maxTilesX / 10;
		int num2 = num;
		int num3 = Main.maxTilesX - num2 * 2;
		if (GenVars.CurrentDungeonGenVars.dungeonSide <= DungeonSide.Left)
		{
			num2 = GetRightMostDungeonTile();
			num3 = Main.maxTilesX - num2 - num;
		}
		else
		{
			num2 = num;
			num3 = GetLeftMostDungeonTile() - num2;
		}
		int teleportStartY = (int)Main.worldSurface + 200;
		int teleportRangeY = (int)Main.rockLayer;
		int[] array = new int[36]
		{
			60, 70, 23, 199, 661, 662, 161, 147, 162, 41,
			43, 44, 226, 57, 633, 53, 397, 396, 25, 163,
			112, 398, 400, 203, 200, 234, 399, 401, 117, 164,
			116, 402, 403, 379, 135, 37
		};
		int tilesToAvoidRange = 60;
		for (int i = 0; i < array.Length; i++)
		{
			if (Main.noTrapsWorld && array[i] == 135)
			{
				array[i] = -1;
			}
			if (SecretSeed.errorWorld.Enabled && (array[i] == 57 || array[i] == 70 || array[i] == 161 || array[i] == 53 || array[i] == 397 || array[i] == 396 || array[i] == 163 || array[i] == 200 || array[i] == 135 || array[i] == 379 || array[i] == 37))
			{
				array[i] = -1;
			}
			if (SecretSeed.worldIsFrozen.Enabled)
			{
				if (array[i] == 161 || array[i] == 147 || array[i] == 162)
				{
					array[i] = -1;
				}
				if (SecretSeed.worldIsInfected.Enabled && (array[i] == 163 || array[i] == 200))
				{
					array[i] = -1;
				}
			}
			if (notTheBees)
			{
				if (array[i] == 60)
				{
					array[i] = -1;
				}
				if (SecretSeed.worldIsInfected.Enabled && (array[i] == 661 || array[i] == 662))
				{
					array[i] = -1;
				}
			}
			if (SecretSeed.worldIsInfected.Enabled && (array[i] == 23 || array[i] == 199 || array[i] == 25 || array[i] == 203))
			{
				array[i] = -1;
			}
		}
		Vector2 vector = Utils.CheckForGoodTeleportationSpot(ref flag, num2, num3, teleportStartY, teleportRangeY, new Utils.RandomTeleportationAttemptSettings
		{
			teleporteeSize = new Vector2(20f, 42f),
			teleporteeVelocity = Vector2.Zero,
			teleporteeGravityDirection = 1f,
			avoidLava = true,
			avoidAnyLiquid = true,
			avoidHurtTiles = true,
			avoidWalls = true,
			mostlySolidFloor = true,
			strictRange = true,
			maximumFallDistanceFromOrignalPoint = 100,
			attemptsBeforeGivingUp = 5000,
			tilesToAvoid = array,
			tilesToAvoidRange = tilesToAvoidRange
		});
		if (flag)
		{
			Main.spawnTileX = (int)(vector.X / 16f);
			Main.spawnTileY = (int)(vector.Y / 16f);
		}
	}

	private static void TownNPCPositionsCleanup(Point originalSpawnPoint)
	{
		bool flag = originalSpawnPoint.X != Main.spawnTileX || originalSpawnPoint.Y != Main.spawnTileY;
		for (int i = 0; i < Main.maxNPCs; i++)
		{
			NPC nPC = Main.npc[i];
			if (nPC == null || !nPC.active || !nPC.isLikeATownNPC || nPC.type == 37)
			{
				continue;
			}
			Point p = nPC.Bottom.ToTileCoordinates();
			if (InWorld(p.X, p.Y, 2))
			{
				if (flag)
				{
					int num = p.X - originalSpawnPoint.X;
					p = new Point(Main.spawnTileX + num, Main.spawnTileY);
					nPC.homeTileX = Main.spawnTileX;
					nPC.homeTileY = Main.spawnTileY;
				}
				bool isEmpty = true;
				bool hasFloor = false;
				Scan3By3(p.X, p.Y, out isEmpty, out hasFloor);
				if (!isEmpty)
				{
					Point adjustedFloorPosition = GetAdjustedFloorPosition(p.X, p.Y);
					nPC.Bottom = adjustedFloorPosition.ToWorldCoordinates(8f, 0f);
				}
				else if (flag)
				{
					nPC.Bottom = p.ToWorldCoordinates(8f, 0f);
				}
			}
		}
	}

	private static void OverGrownDungeon()
	{
		int maxTilesX = Main.maxTilesX;
		for (int i = 0; i < maxTilesX; i++)
		{
			int num = genRand.Next(50, Main.maxTilesX / 2);
			if (GenVars.CurrentDungeonGenVars.dungeonSide >= DungeonSide.Right)
			{
				num = genRand.Next(Main.maxTilesX / 2, Main.maxTilesX - 50);
			}
			int num2 = genRand.Next(50, Main.maxTilesY - 50);
			if (!Main.wallDungeon[Main.tile[num, num2].wall])
			{
				continue;
			}
			int num3 = genRand.Next(5, 16);
			for (int j = num - num3; j <= num + num3; j++)
			{
				for (int k = num2 - num3; k <= num2 + num3; k++)
				{
					if (!Main.tile[j, k].active() || !Main.tileDungeon[Main.tile[j, k].type] || (Main.tile[j - 1, k - 1].active() && Main.tile[j, k - 1].active() && Main.tile[j + 1, k - 1].active() && Main.tile[j - 1, k].active() && Main.tile[j + 1, k].active() && Main.tile[j - 1, k + 1].active() && Main.tile[j, k + 1].active() && Main.tile[j + 1, k - 1].active()))
					{
						continue;
					}
					Main.tile[j, k].type = 60;
					Main.tile[j, k].color(0);
					if (!Main.tile[j, k - 1].active() && !GrowTree(j, k))
					{
						PlaceTile(j, k - 1, 61, mute: true);
					}
					if (Main.tile[j, k + 1].active() || genRand.Next(3) == 0)
					{
						continue;
					}
					PlaceTile(j, k + 1, 62);
					if (Main.tile[j, k + 2].active())
					{
						continue;
					}
					PlaceTile(j, k + 2, 62);
					if (!Main.tile[j, k + 3].active())
					{
						PlaceTile(j, k + 3, 62);
						if (!Main.tile[j, k + 4].active() && genRand.Next(4) != 0)
						{
							PlaceTile(j, k + 4, 62);
						}
						if (!Main.tile[j, k + 5].active() && genRand.Next(3) != 0)
						{
							PlaceTile(j, k + 5, 62);
						}
						if (!Main.tile[j, k + 6].active() && genRand.Next(2) != 0)
						{
							PlaceTile(j, k + 6, 62);
						}
					}
				}
			}
		}
	}

	private static void OverGrownDungeonWithRainbowMoss()
	{
		int num = Main.maxTilesX / 2;
		for (int i = 0; i < num; i++)
		{
			int num2 = genRand.Next(50, Main.maxTilesX / 2);
			if (GenVars.CurrentDungeonGenVars.dungeonSide >= DungeonSide.Right)
			{
				num2 = genRand.Next(Main.maxTilesX / 2, Main.maxTilesX - 50);
			}
			int num3 = genRand.Next(50, Main.maxTilesY - 50);
			if (!Main.wallDungeon[Main.tile[num2, num3].wall])
			{
				continue;
			}
			int num4 = genRand.Next(4, 13);
			for (int j = num2 - num4; j <= num2 + num4; j++)
			{
				for (int k = num3 - num4; k <= num3 + num4; k++)
				{
					if (Main.tileDungeon[Main.tile[j, k].type] && (!Main.tile[j - 1, k - 1].active() || !Main.tile[j, k - 1].active() || !Main.tile[j + 1, k - 1].active() || !Main.tile[j - 1, k].active() || !Main.tile[j + 1, k].active() || !Main.tile[j - 1, k + 1].active() || !Main.tile[j, k + 1].active() || !Main.tile[j + 1, k - 1].active()))
					{
						Main.tile[j, k].type = 628;
						Main.tile[j, k].ClearBlockPaintAndCoating();
						if (!Main.tile[j, k - 1].active())
						{
							PlaceTile(j, k - 1, 184, mute: true, forced: false, -1, 10);
						}
						if (!Main.tile[j, k + 1].active())
						{
							PlaceTile(j, k + 1, 184, mute: true, forced: false, -1, 10);
						}
						if (!Main.tile[j - 1, k].active())
						{
							PlaceTile(j - 1, k, 184, mute: true, forced: false, -1, 10);
						}
						if (!Main.tile[j + 1, k].active())
						{
							PlaceTile(j + 1, k, 184, mute: true, forced: false, -1, 10);
						}
					}
				}
			}
		}
	}

	private static void AddSpikeCaves(GenerationProgress progress)
	{
		progress.Message = Language.GetTextValue("WorldGeneration.SpikeCaves");
		progress.Set(0.0);
		maxTileCount = 3500;
		int num = Main.maxTilesX / 2;
		int num2 = 3;
		switch (GetWorldSize())
		{
		case 0:
			num2 = 3;
			break;
		case 1:
			num2 = 5;
			break;
		case 2:
			num2 = 7;
			break;
		}
		num2 += genRand.Next(2);
		int num3 = 500;
		int num4 = 3500;
		SpikePitBiome spikePitBiome = GenVars.configuration.CreateBiome<SpikePitBiome>();
		bool flag = Main.tileSolid[225];
		if (notTheBees)
		{
			Main.tileSolid[225] = true;
		}
		for (int i = 0; i < num2; i++)
		{
			progress.Set((float)i / (float)num2);
			int num5 = 0;
			int x = genRand.Next(200, Main.maxTilesX - 200);
			int y = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 230);
			if (remixWorldGen)
			{
				y = genRand.Next((int)Main.worldSurface, (int)Main.rockLayer);
			}
			int num6 = countTiles(x, y, jungle: false, lavaOk: true);
			while ((num6 >= num4 || num6 < num3) && num5 < num)
			{
				num5++;
				x = genRand.Next(200, Main.maxTilesX - 200);
				y = genRand.Next((int)Main.rockLayer + 30, Main.maxTilesY - 230);
				if (remixWorldGen)
				{
					y = genRand.Next((int)Main.worldSurface, (int)Main.rockLayer);
				}
				num6 = countTiles(x, y, jungle: false, lavaOk: true);
				if (shroomCount > 1)
				{
					num6 = 0;
				}
			}
			if (num5 < num)
			{
				spikePitBiome.Place(new Point(x, y), GenVars.structures);
			}
		}
		if (notTheBees)
		{
			Main.tileSolid[225] = flag;
		}
	}

	private static void ShimmerifySideOfWorld(bool left)
	{
		int num = Main.maxTilesX / 2;
		for (int i = 0; i < Main.maxTilesX; i++)
		{
			if ((left && i >= num) || (!left && i <= num))
			{
				continue;
			}
			for (int j = 0; j < Main.UnderworldLayer; j++)
			{
				Tile tile = Main.tile[i, j];
				if (!Main.wallDungeon[tile.wall])
				{
					if (tile.liquid > 0 && !tile.shimmer() && !tile.honey())
					{
						tile.liquidType(3);
					}
					if (tile.type == 373 || tile.type == 374 || tile.type == 375)
					{
						tile.type = 709;
					}
				}
			}
		}
	}

	private static Point GetAdjustedFloorPosition(int x, int y)
	{
		int num = x - 1;
		int num2 = y - 2;
		bool isEmpty = false;
		bool hasFloor = false;
		while (!isEmpty && num2 > Main.spawnTileY - 10)
		{
			Scan3By3(num, num2, out isEmpty, out hasFloor);
			if (!isEmpty)
			{
				num2--;
			}
		}
		while (!hasFloor && num2 < Main.spawnTileY + 10)
		{
			Scan3By3(num, num2, out isEmpty, out hasFloor);
			if (!hasFloor)
			{
				num2++;
			}
		}
		return new Point(num + 1, num2 + 2);
	}

	private static void Scan3By3(int topLeftX, int topLeftY, out bool isEmpty, out bool hasFloor)
	{
		isEmpty = true;
		hasFloor = false;
		for (int i = 0; i < 3; i++)
		{
			int num = 0;
			while (num < 3)
			{
				int i2 = topLeftX + i;
				int j = topLeftY + num;
				if (!SolidTile(i2, j))
				{
					num++;
					continue;
				}
				goto IL_001e;
			}
			continue;
			IL_001e:
			isEmpty = false;
			break;
		}
		for (int k = 0; k < 3; k++)
		{
			int i3 = topLeftX + k;
			int j2 = topLeftY + 3;
			if (SolidTile(i3, j2))
			{
				hasFloor = true;
				break;
			}
		}
	}

	private static void FinishTenthAnniversaryWorldPaintTreesAndMushrooms()
	{
		PaintTheTrees();
		PaintTheMushrooms();
	}

	private static void FinishTenthAnniversaryWorld()
	{
		if ((remixWorldGen || (!notTheBees && !dontStarveWorldGen)) && !remixWorldGen)
		{
			if (!getGoodWorldGen && !drunkWorldGen)
			{
				ConvertSkyIslands(2, growTrees: true);
			}
			PaintTheDungeon(24, 24);
			if (!Main.onlyShimmerOceanWorldsGeneration && !SecretSeed.noSurface.Enabled)
			{
				PaintTheLivingTrees(12, 12);
			}
			PaintTheTemple(10, 5);
			if (!Main.onlyShimmerOceanWorldsGeneration)
			{
				PaintTheClouds(12, 12);
			}
			PaintTheSand(7, 7);
			if (!Main.onlyShimmerOceanWorldsGeneration)
			{
				PaintThePyramids(12, 12);
			}
		}
		if (!getGoodWorldGen)
		{
			for (int i = 50; i < Main.maxTilesX - 50; i++)
			{
				for (int j = 50; j < Main.maxTilesY - 50; j++)
				{
					Tile tile = Main.tile[i, j];
					if (genRand.Next(4) == 0 && tile.active() && tile.type == 138 && tile.frameX == 0 && tile.frameY == 0)
					{
						Main.tile[i, j].type = 665;
						Main.tile[i, j + 1].type = 665;
						Main.tile[i + 1, j].type = 665;
						Main.tile[i + 1, j + 1].type = 665;
					}
				}
			}
		}
		if (!getGoodWorldGen)
		{
			ImproveAllChestContents();
		}
	}

	private static void PaintTheMushrooms()
	{
		int num = Main.maxTilesY - 20;
		byte b = (byte)genRand.Next(1, 13);
		if (remixWorldGen)
		{
			b = 2;
			num = Main.maxTilesY - 500;
			int num2 = genRand.Next(5, 31);
			if (genRand.Next(2) == 0)
			{
				num2 = genRand.Next(5, 16);
			}
			for (int i = 20; i < Main.maxTilesX - 20; i++)
			{
				if (i % num2 == 0)
				{
					b++;
					if (b > 12)
					{
						b = 1;
					}
				}
				for (int j = Main.maxTilesY - 450; j < Main.maxTilesY - 20; j++)
				{
					Tile tile = Main.tile[i, j];
					if (tile.active() && (tile.type == 70 || tile.type == 578 || tile.type == 190 || tile.type == 71 || tile.type == 528 || (tile.type == 519 && tile.frameY == 90)))
					{
						tile.color(b);
					}
					if (tile.wall == 80 || tile.wall == 74)
					{
						tile.wallColor(b);
					}
				}
			}
		}
		b = (byte)genRand.Next(1, 13);
		int num3 = 0;
		for (int k = 20; k < Main.maxTilesX - 20; k++)
		{
			for (int l = 20; l < num; l++)
			{
				Tile tile2 = Main.tile[k, l];
				if (tile2.active() && (tile2.type == 70 || tile2.type == 578 || tile2.type == 190 || tile2.type == 71 || tile2.type == 528 || (tile2.type == 519 && tile2.frameY == 90)))
				{
					tile2.color(b);
					num3 = 10;
				}
				if (tile2.wall == 80 || tile2.wall == 74)
				{
					tile2.wallColor(b);
					num3 = 10;
				}
			}
			num3--;
			if (num3 == 0)
			{
				b += (byte)genRand.Next(1, 3);
				if (b > 12)
				{
					b = 1;
				}
			}
		}
	}

	private static void PaintTheTrees()
	{
		int num = 20;
		if (remixWorldGen)
		{
			num = (int)Main.worldSurface;
		}
		byte b = (byte)genRand.Next(1, 13);
		bool flag = false;
		for (int i = 20; i < Main.maxTilesX - 20; i++)
		{
			bool flag2 = false;
			for (int j = num; j < Main.maxTilesY - 20; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile.active() && (tile.type == 5 || tile.type == 323 || tile.type == 596 || tile.type == 616))
				{
					tile.color(b);
					flag2 = true;
					flag = true;
				}
			}
			if (flag && !flag2)
			{
				flag = false;
				b++;
				if (b > 12)
				{
					b = 1;
				}
			}
		}
	}

	private static void PaintTheSand(byte tilePaintColor, byte wallPaintColor)
	{
		for (int i = 20; i < Main.maxTilesX - 20; i++)
		{
			for (int j = 20; j < Main.maxTilesY - 20; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile.active() && (tile.type == 53 || tile.type == 396 || tile.type == 397))
				{
					tile.color(tilePaintColor);
					if ((double)j > Main.worldSurface)
					{
						if (Main.tile[i, j - 1].type == 165 || Main.tile[i, j - 1].type == 185 || Main.tile[i, j - 1].type == 186 || Main.tile[i, j - 1].type == 187)
						{
							Main.tile[i, j - 1].color(tilePaintColor);
						}
						if (Main.tile[i, j - 2].type == 165 || Main.tile[i, j - 2].type == 185 || Main.tile[i, j - 2].type == 186 || Main.tile[i, j - 2].type == 187)
						{
							Main.tile[i, j - 2].color(tilePaintColor);
						}
						if (Main.tile[i, j + 1].type == 165)
						{
							Main.tile[i, j + 1].color(tilePaintColor);
						}
						if (Main.tile[i, j + 2].type == 165)
						{
							Main.tile[i, j + 2].color(tilePaintColor);
						}
					}
				}
				if (tile.wall == 187 || tile.wall == 216)
				{
					tile.wallColor(tilePaintColor);
				}
			}
		}
	}

	private static void PaintTheSandRainbowAndSandWallsBlack()
	{
		byte wallColor = 25;
		for (int i = 20; i < Main.maxTilesX - 20; i++)
		{
			for (int j = 20; j < Main.maxTilesY - 20; j++)
			{
				byte rainbowPaintIDForPosition = GetRainbowPaintIDForPosition(i, j, wiggly: true);
				Tile tile = Main.tile[i, j];
				if (tile.active() && (tile.type == 53 || tile.type == 396 || tile.type == 397))
				{
					tile.color(rainbowPaintIDForPosition);
					if ((double)j > Main.worldSurface || tile.wall == 187 || tile.wall == 216)
					{
						if (Main.tile[i, j - 1].type == 165 || Main.tile[i, j - 1].type == 185 || Main.tile[i, j - 1].type == 186 || Main.tile[i, j - 1].type == 187)
						{
							Main.tile[i, j - 1].color(rainbowPaintIDForPosition);
						}
						if (Main.tile[i, j - 2].type == 165 || Main.tile[i, j - 2].type == 185 || Main.tile[i, j - 2].type == 186 || Main.tile[i, j - 2].type == 187)
						{
							Main.tile[i, j - 2].color(rainbowPaintIDForPosition);
						}
						if (Main.tile[i, j + 1].type == 165)
						{
							Main.tile[i, j + 1].color(rainbowPaintIDForPosition);
						}
						if (Main.tile[i, j + 2].type == 165)
						{
							Main.tile[i, j + 2].color(rainbowPaintIDForPosition);
						}
					}
				}
				if (tile.wall == 187 || tile.wall == 216)
				{
					tile.wallColor(wallColor);
				}
			}
		}
	}

	public static byte GetRainbowPaintIDForPosition(int x, int y, bool wiggly = false)
	{
		int num = x;
		int num2 = y;
		if (wiggly)
		{
			num += (int)(Math.Sin((float)(y % 50) / 50f * ((float)Math.PI * 2f)) * 10.0) - 5;
			num2 = 0;
		}
		int num3 = num % 44 + num2 % 44;
		num3 %= 11;
		return (byte)(13 + num3);
	}

	private static void PaintThePurityGrass(byte tilePaintColor, byte wallPaintColor)
	{
		for (int i = 0; i < Main.maxTilesX; i++)
		{
			for (int j = 0; j < Main.maxTilesY; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile.active())
				{
					if (tile.type == 2)
					{
						tile.color(tilePaintColor);
					}
					else if (tile.type == 185 || tile.type == 186 || tile.type == 187)
					{
						Tile tile2 = tile;
						int num = j;
						while (num < Main.maxTilesY - 20 && (tile2.type == 185 || tile2.type == 186 || tile2.type == 187 || tile2.type == 3 || tile2.type == 73))
						{
							tile2 = Main.tile[i, ++num];
						}
						if (tile2.type == 2)
						{
							tile.color(tilePaintColor);
						}
					}
				}
				if (tile.wall == 66 || tile.wall == 63)
				{
					tile.wallColor(wallPaintColor);
				}
			}
		}
	}

	private static void PaintThePyramids(byte tilePaintColor, byte wallPaintColor)
	{
		for (int i = 0; i < Main.maxTilesX; i++)
		{
			for (int j = 0; j < Main.maxTilesY; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile.active() && tile.type == 151)
				{
					tile.color(tilePaintColor);
				}
				if (tile.wall == 34)
				{
					tile.wallColor(wallPaintColor);
				}
			}
		}
	}

	private static void PaintTheTemple(byte tilePaintColor, byte wallPaintColor)
	{
		for (int i = 10; i < Main.maxTilesX - 10; i++)
		{
			for (int j = 10; j < Main.maxTilesY - 10; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile.active())
				{
					bool flag = false;
					if (tile.type == 226)
					{
						flag = true;
					}
					if (tile.type == 61 && Main.tile[i, j + 1].type == 226)
					{
						flag = true;
					}
					if (tile.type == 137)
					{
						int num = tile.frameY / 18;
						if (num >= 1 && num <= 4)
						{
							flag = true;
						}
					}
					if (flag)
					{
						if (notTheBees)
						{
							Main.tile[i, j].color(0);
						}
						else
						{
							tile.color(tilePaintColor);
						}
					}
				}
				if (tile.wall == 87)
				{
					tile.wallColor(wallPaintColor);
				}
			}
		}
	}

	private static void PaintTheClouds(byte tilePaintColor, byte wallPaintColor)
	{
		for (int i = 0; i < Main.maxTilesX; i++)
		{
			for (int j = 0; j < Main.maxTilesY; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile.active() && TileID.Sets.Clouds[tile.type])
				{
					tile.color(tilePaintColor);
				}
				if (tile.wall == 73)
				{
					tile.wallColor(wallPaintColor);
				}
			}
		}
	}

	private static void PaintTheDungeon(byte tilePaintColor, byte wallPaintColor)
	{
		for (int i = 0; i < Main.maxTilesX; i++)
		{
			for (int j = 0; j < Main.maxTilesY; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile.active())
				{
					if (Main.tileDungeon[tile.type] || TileID.Sets.CrackedBricks[tile.type])
					{
						tile.color(tilePaintColor);
					}
					if (tile.type == 19)
					{
						int num = tile.frameY / 18;
						if (num >= 6 && num <= 12)
						{
							tile.color(tilePaintColor);
						}
					}
				}
				if (Main.wallDungeon[tile.wall])
				{
					tile.wallColor(wallPaintColor);
				}
			}
		}
	}

	private static void PaintTheLivingTrees(byte livingTreePaintColor, byte livingTreeWallPaintColor)
	{
		for (int i = 0; i < Main.maxTilesX; i++)
		{
			for (int j = 0; j < Main.maxTilesY; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile.active())
				{
					if (tile.wall == 244)
					{
						tile.color(livingTreePaintColor);
					}
					else if (tile.type == 192 || tile.type == 191)
					{
						tile.color(livingTreePaintColor);
					}
					else if (tile.type == 52 || tile.type == 382)
					{
						int x = i;
						int y = j;
						GetVineTop(i, j, out x, out y);
						if (Main.tile[x, y].type == 192)
						{
							tile.color(livingTreePaintColor);
						}
					}
					else if (tile.type == 187)
					{
						Tile tile2 = tile;
						int num = 0;
						while (tile2.type == 187)
						{
							num++;
							tile2 = Main.tile[i, j + num];
						}
						if (tile2.type == 192)
						{
							tile.color(livingTreePaintColor);
						}
					}
				}
				if (tile.wall == 244)
				{
					tile.wallColor(livingTreeWallPaintColor);
				}
			}
		}
	}

	private static void ConvertSkyIslands(int convertType, bool growTrees)
	{
		int num = 0;
		for (int i = 20; (double)i < Main.worldSurface; i++)
		{
			for (int j = 20; j < Main.maxTilesX - 20; j++)
			{
				Tile tile = Main.tile[j, i];
				if (tile.active() && TileID.Sets.Clouds[tile.type])
				{
					num = i;
					break;
				}
			}
		}
		for (int k = 20; k <= Main.maxTilesX - 20; k++)
		{
			for (int l = 20; l < num; l++)
			{
				Tile tile2 = Main.tile[k, l];
				Tile tile3 = Main.tile[k, l - 1];
				if (tile2.active() && tile2.type == 2)
				{
					if (tile3.type == 596 || tile3.type == 616)
					{
						KillTile(k, l - 1);
					}
					Convert(k, l, convertType);
					ushort type = tile3.type;
					if ((uint)(type - 82) <= 1u || (uint)(type - 185) <= 2u || type == 227)
					{
						KillTile(k, l - 1);
					}
					if (growTrees && genRand.Next(3) == 0)
					{
						TryGrowingTreeByType(5, k, l);
					}
				}
			}
		}
	}

	private static void ImproveAllChestContents()
	{
		for (int i = 0; i < 8000; i++)
		{
			Chest chest = Main.chest[i];
			if (chest == null)
			{
				continue;
			}
			for (int j = 0; j < chest.maxItems; j++)
			{
				Item item = chest.item[j];
				if (item != null && !item.IsAir)
				{
					GiveItemGoodPrefixes(item);
				}
			}
		}
	}

	private static void GiveItemGoodPrefixes(Item item)
	{
		if (item.accessory)
		{
			PrefixItemFromOptions(item, TenthAnniversaryWorldInfo.GoodPrefixIdsForAccessory);
		}
		if (item.melee)
		{
			PrefixItemFromOptions(item, TenthAnniversaryWorldInfo.GoodPrefixIdsForMeleeWeapon);
		}
		if (PrefixLegacy.ItemSets.GunsBows[item.type])
		{
			PrefixItemFromOptions(item, TenthAnniversaryWorldInfo.GoodPrefixIdsForRangedWeapon);
		}
		if (PrefixLegacy.ItemSets.Magic[item.type])
		{
			PrefixItemFromOptions(item, TenthAnniversaryWorldInfo.GoodPrefixIdsForMagicWeapon);
		}
		if (PrefixLegacy.ItemSets.Summon[item.type])
		{
			PrefixItemFromOptions(item, TenthAnniversaryWorldInfo.GoodPrefixIdsForSummonerWeapon);
		}
	}

	private static void PrefixItemFromOptions(Item item, int[] options)
	{
		byte prefix = item.prefix;
		if (!item.Prefix(-3))
		{
			return;
		}
		List<int> list = new List<int>(options);
		while (list.Count > 0)
		{
			int index = genRand.Next(list.Count);
			int num = list[index];
			item.Prefix(num);
			if (item.prefix == num)
			{
				return;
			}
			list.RemoveAt(index);
		}
		item.Prefix(prefix);
	}

	private static void PutMonsterVanityInChests()
	{
		for (int i = 0; i < 8000; i++)
		{
			Chest chest = Main.chest[i];
			if (chest == null)
			{
				break;
			}
			if (genRand.Next(7) != 0 || chest.item[1].stack == 0)
			{
				continue;
			}
			for (int j = 1; j < chest.maxItems; j++)
			{
				if (chest.item[j].stack == 0)
				{
					switch (genRand.Next(9))
					{
					case 0:
						chest.item[j].SetDefaults(1763);
						chest.item[j + 1].SetDefaults(1765);
						chest.item[j + 2].SetDefaults(1764);
						break;
					case 1:
						chest.item[j].SetDefaults(1752);
						chest.item[j + 1].SetDefaults(1753);
						break;
					case 2:
						chest.item[j].SetDefaults(1766);
						chest.item[j + 1].SetDefaults(1775);
						chest.item[j + 2].SetDefaults(1776);
						break;
					case 3:
						chest.item[j].SetDefaults(1777);
						chest.item[j + 1].SetDefaults(1778);
						break;
					case 4:
						chest.item[j].SetDefaults(1819);
						chest.item[j + 1].SetDefaults(1820);
						break;
					case 5:
						chest.item[j].SetDefaults(1857);
						break;
					case 6:
						chest.item[j].SetDefaults(4740);
						chest.item[j + 1].SetDefaults(4741);
						chest.item[j + 2].SetDefaults(4742);
						break;
					case 7:
						chest.item[j].SetDefaults(4738);
						chest.item[j + 1].SetDefaults(4739);
						break;
					case 8:
						chest.item[j].SetDefaults(4685);
						chest.item[j + 1].SetDefaults(4686);
						break;
					}
					break;
				}
			}
		}
	}

	private static void SpawnGraveyardBiomesEverywhere()
	{
		float num = Main.maxTilesX / 4200;
		if (Main.worldSurface > 150.0)
		{
			for (int i = 0; (float)i < 10f * num; i++)
			{
				int num2 = genRand.Next(beachDistance + 100, Main.maxTilesX - beachDistance - 100);
				while ((double)num2 > (double)Main.maxTilesX * 0.48 && (double)num2 < (double)Main.maxTilesX * 0.52)
				{
					num2 = genRand.Next(beachDistance + 100, Main.maxTilesX - beachDistance - 100);
				}
				int y = genRand.Next(150, (int)Main.worldSurface);
				SpawnGraveyardBiome(num2, y);
			}
		}
		for (int j = 0; (float)j < 30f * num; j++)
		{
			int x = genRand.Next(beachDistance + 100, Main.maxTilesX - beachDistance - 100);
			int y2 = genRand.Next((int)Main.worldSurface + 50, Main.UnderworldLayer - 100);
			SpawnGraveyardBiome(x, y2);
		}
	}

	public static void SpawnGraveyardBiome(int X, int Y)
	{
		int num = 40;
		int distance = 3;
		int num2 = 5000;
		while (Main.tile[X, Y].active())
		{
			Y--;
			if (Y < 100)
			{
				return;
			}
		}
		Y++;
		while (!Main.tile[X, Y].active())
		{
			Y++;
			if (Y > Main.UnderworldLayer - 100)
			{
				return;
			}
		}
		for (int i = X - num; i <= X + num; i++)
		{
			for (int j = Y - num; j <= Y + num; j++)
			{
				if (Main.tile[i, j].active() && (Main.tile[i, j].anyShimmer() || Main.tile[i, j].type == 25 || Main.tile[i, j].type == 203 || Main.tile[i, j].type == 53 || Main.tile[i, j].type == 191 || Main.tile[i, j].type == 383 || Main.tileDungeon[Main.tile[i, j].type] || Main.tile[i, j].type == 226 || Main.tile[i, j].type == 225 || Main.tile[i, j].type == 367 || Main.tile[i, j].type == 368 || Main.tile[i, j].type == 57 || Main.tile[i, j].type == 70 || Main.tile[i, j].type == 189))
				{
					return;
				}
			}
		}
		for (int k = 0; k < num2; k++)
		{
			int num3 = X + genRand.Next(-num, num + 1);
			int num4 = Y + genRand.Next(-num, num + 1);
			if (!InWorld(num3, num4, 50) || Main.tile[num3, num4].active())
			{
				continue;
			}
			while (!Main.tile[num3, num4].active())
			{
				num4++;
				if (!InWorld(num3, num4, 55))
				{
					num4 = Main.maxTilesY - 50;
					break;
				}
			}
			num4--;
			if (Main.tile[num3 + 1, num4].active() || IsTileNearby(num3, num4, 85, distance) || Main.tile[num3, num4].liquid != 0 || !Main.tile[num3, num4 + 1].active() || !Main.tile[num3 + 1, num4 + 1].active() || !Main.tileSolid[Main.tile[num3, num4 + 1].type] || !Main.tileSolid[Main.tile[num3 + 1, num4 + 1].type])
			{
				continue;
			}
			Main.tile[num3, num4 + 1].slope(0);
			Main.tile[num3, num4 + 1].halfBrick(halfBrick: false);
			Main.tile[num3 + 1, num4 + 1].slope(0);
			Main.tile[num3 + 1, num4 + 1].halfBrick(halfBrick: false);
			if (PlaceTile(num3, num4, 85, mute: true, forced: false, -1, genRand.Next(6)))
			{
				int num5 = Sign.ReadSign(num3, num4);
				if (num5 >= 0)
				{
					Sign.TextSign(num5, Language.RandomFromCategory("Epitaph", genRand).Value);
				}
			}
		}
	}

	public static void PlaceTorchesAroundSpawn(int spawnX = -1, int spawnY = -1)
	{
		if (spawnX == -1)
		{
			spawnX = Main.spawnTileX;
		}
		if (spawnY == -1)
		{
			spawnY = Main.spawnTileY;
		}
		int num = 1;
		int distance = 20;
		if (skyblockWorldGen)
		{
			distance = 15;
		}
		int num2 = 2000;
		for (int i = 0; i < num2; i++)
		{
			if (num < 120)
			{
				num++;
			}
			int minValue = spawnX - num;
			int maxValue = spawnX + num;
			int minValue2 = spawnY - num;
			int maxValue2 = spawnY + num;
			int num3 = genRand.Next(minValue, maxValue);
			int num4 = genRand.Next(minValue2, maxValue2);
			int num5 = 200;
			while (num5 > 0 && !InWorld(num3, num4, 50))
			{
				num5--;
				num3 = genRand.Next(minValue, maxValue);
				num4 = genRand.Next(minValue2, maxValue2);
			}
			if (num5 <= 0)
			{
				break;
			}
			int num6 = 1;
			if (genRand.Next(2) == 0)
			{
				num6 *= -1;
			}
			if (!Main.tile[num3, num4].active() && Main.tile[num3, num4].liquid == 0)
			{
				num5 = Main.maxTilesX / 2;
				while (!Main.tile[num3, num4].active())
				{
					num5--;
					if (num5 <= 0)
					{
						break;
					}
					num3 += num6;
					if (!InWorld(num3, num4, 50))
					{
						num3 -= num6;
						break;
					}
				}
				if (num5 <= 0)
				{
					continue;
				}
				num3 -= num6;
				if (!IsTileNearby(num3, num4, 4, distance))
				{
					int style = 0;
					if (IsTileNearby(num3, num4, 60, 25))
					{
						style = 21;
					}
					else if (IsTileNearby(num3, num4, 70, 25))
					{
						style = 22;
					}
					else if (IsTileNearby(num3, num4, 161, 25))
					{
						style = 9;
					}
					else if (IsTileNearby(num3, num4, 147, 25))
					{
						style = 9;
					}
					else if (IsTileNearby(num3, num4, 53, 25))
					{
						style = 16;
					}
					else if (IsTileNearby(num3, num4, 25, 25))
					{
						style = 18;
					}
					else if (IsTileNearby(num3, num4, 203, 25))
					{
						style = 19;
					}
					PlaceTile(num3, num4, 4, mute: true, forced: false, -1, style);
				}
			}
			else
			{
				i--;
			}
		}
	}

	private static void NotTheBees()
	{
		if (skyblockWorldGen)
		{
			return;
		}
		int num = Main.maxTilesX / 7;
		if (!notTheBees)
		{
			return;
		}
		int num2 = (GenVars.lavaLine + Main.maxTilesY - 180) / 2;
		if (remixWorldGen)
		{
			num2 = Main.maxTilesY - 180;
		}
		for (int i = 5; i < Main.maxTilesX - 5; i++)
		{
			for (int j = 5; j < Main.maxTilesY - 180; j++)
			{
				bool flag = oceanDepths(i, j) || ((double)j < (Main.worldSurface + Main.rockLayer * 2.0) / 3.0 + (double)genRand.Next(3) && (i < beachDistance - 50 - genRand.Next(3) || i > Main.maxTilesX - beachDistance + 50 + genRand.Next(3)));
				if (remixWorldGen && (i < num + genRand.Next(3) || i >= Main.maxTilesX - num - genRand.Next(3) || ((double)j > (Main.worldSurface * 2.0 + Main.rockLayer) / 3.0 + (double)genRand.Next(3) && j < Main.maxTilesY - 350 - genRand.Next(3))))
				{
					continue;
				}
				if ((tenthAnniversaryWorldGen || dontStarveWorldGen || (GenVars.CurrentDungeonGenVars.dungeonSide <= DungeonSide.Left && i < Main.maxTilesX / 2) || (GenVars.CurrentDungeonGenVars.dungeonSide >= DungeonSide.Right && i > Main.maxTilesX / 2)) && !remixWorldGen && flag)
				{
					if (Main.tile[i, j].active() && Main.tile[i, j].type == 229)
					{
						Main.tile[i, j].active(active: false);
						Main.tile[i, j].liquidType(0);
						Main.tile[i, j].liquid = byte.MaxValue;
					}
					continue;
				}
				if (!remixWorldGen && (tenthAnniversaryWorldGen || dontStarveWorldGen || drunkWorldGen) && (double)i > (double)Main.maxTilesX * 0.4 - (double)genRand.Next(3) && (double)i < (double)Main.maxTilesX * 0.6 + (double)genRand.Next(3))
				{
					if ((double)j < Main.rockLayer - 1.0)
					{
						if (Main.tile[i, j].type == 0 && (!Main.tile[i - 1, j - 1].active() || !Main.tile[i, j - 1].active() || !Main.tile[i + 1, j - 1].active() || !Main.tile[i - 1, j].active() || !Main.tile[i + 1, j].active() || !Main.tile[i - 1, j + 1].active() || !Main.tile[i, j + 1].active() || !Main.tile[i + 1, j - 1].active()))
						{
							Main.tile[i, j].type = 2;
						}
						if (Main.tile[i, j].wall == 15)
						{
							ushort wall = 65;
							if (genRand.Next(2) == 0)
							{
								wall = 63;
							}
							if (dontStarveWorldGen)
							{
								wall = 63;
							}
							else if (tenthAnniversaryWorldGen)
							{
								wall = 65;
							}
							Main.tile[i, j].wall = wall;
						}
					}
					if (Main.tile[i, j].type == 60)
					{
						Main.tile[i, j].type = 59;
					}
					continue;
				}
				if (Main.tile[i, j].type == 52 || Main.tile[i, j].type == 382)
				{
					Main.tile[i, j].type = 62;
				}
				if ((SolidOrSlopedTile(i, j) || (Main.tile[i, j].active() && TileID.Sets.CrackedBricks[Main.tile[i, j].type])) && (!dontStarveWorldGen || remixWorldGen || (Main.tile[i, j].type != 1 && Main.tile[i, j].type != 147 && Main.tile[i, j].type != 161 && Main.tile[i, j].type != 30 && Main.tile[i, j].type != 321 && Main.tile[i, j].type != 158 && Main.tile[i, j].type != 190 && Main.tile[i, j].type != 162)) && !TileID.Sets.Ore[Main.tile[i, j].type] && Main.tile[i, j].type != 368 && Main.tile[i, j].type != 367 && Main.tile[i, j].type != 123 && Main.tile[i, j].type != 40 && Main.tile[i, j].type != 379 && (Main.tile[i, j].type != 56 || !skyblockWorldGen))
				{
					if (Main.tile[i, j].type == 191 || Main.tile[i, j].type == 383)
					{
						if (!remixWorldGen)
						{
							Main.tile[i, j].type = 383;
						}
					}
					else if (Main.tile[i, j].type == 192 || Main.tile[i, j].type == 384)
					{
						if (!remixWorldGen)
						{
							Main.tile[i, j].type = 384;
						}
					}
					else if (Main.tile[i, j].type != 151 && Main.tile[i, j].type != 662 && Main.tile[i, j].type != 661 && !TileID.Sets.Clouds[Main.tile[i, j].type] && Main.tile[i, j].type != 120 && Main.tile[i, j].type != 158 && Main.tile[i, j].type != 175 && Main.tile[i, j].type != 45 && Main.tile[i, j].type != 119 && (Main.tile[i, j].type < 63 || Main.tile[i, j].type > 68) && Main.tile[i, j].type != 57 && Main.tile[i, j].type != 76 && Main.tile[i, j].type != 75 && Main.tile[i, j].type != 229 && Main.tile[i, j].type != 230 && Main.tile[i, j].type != 407 && Main.tile[i, j].type != 404)
					{
						if (Main.tile[i, j].type == 224)
						{
							if (!dontStarveWorldGen || remixWorldGen)
							{
								Main.tile[i, j].type = 229;
							}
						}
						else if (Main.tile[i, j].type == 53)
						{
							if ((!dontStarveWorldGen || remixWorldGen) && (i < beachDistance + genRand.Next(3) || i > Main.maxTilesX - beachDistance - genRand.Next(3)))
							{
								Main.tile[i, j].type = 229;
							}
						}
						else if ((i <= beachDistance - genRand.Next(3) || i >= Main.maxTilesX - beachDistance + genRand.Next(3) || (Main.tile[i, j].type != 397 && Main.tile[i, j].type != 396)) && Main.tile[i, j].type != 10 && Main.tile[i, j].type != 203 && Main.tile[i, j].type != 25 && Main.tile[i, j].type != 137 && (Main.tile[i, j].type < 0 || !TileID.Sets.Boulders[Main.tile[i, j].type]) && Main.tile[i, j].type != 141)
						{
							if (Main.tileDungeon[Main.tile[i, j].type] || TileID.Sets.CrackedBricks[Main.tile[i, j].type])
							{
								Main.tile[i, j].color(14);
							}
							else if (Main.tile[i, j].type != 226 && Main.tile[i, j].type != 202 && Main.tile[i, j].type != 70 && Main.tile[i, j].type != 48 && Main.tile[i, j].type != 232)
							{
								if (TileID.Sets.Conversion.Grass[Main.tile[i, j].type] || Main.tile[i, j].type == 60 || Main.tile[i, j].type == 70)
								{
									if (j > GenVars.lavaLine + genRand.Next(-2, 3) + 2)
									{
										Main.tile[i, j].type = 70;
									}
									else
									{
										Main.tile[i, j].type = 60;
									}
								}
								else if (Main.tile[i, j].type == 0 || Main.tile[i, j].type == 59)
								{
									Main.tile[i, j].type = 59;
								}
								else if (Main.tile[i, j].type != 633 && Main.tile[i, j].type != 562 && Main.tile[i, j].type != 563 && (!dontStarveWorldGen || remixWorldGen))
								{
									if (j > GenVars.lavaLine + genRand.Next(-2, 3) + 2)
									{
										if (j <= num2 + genRand.Next(3))
										{
											Main.tile[i, j].type = 230;
										}
									}
									else if (!remixWorldGen || (double)j > Main.worldSurface + (double)genRand.Next(-1, 2))
									{
										Main.tile[i, j].type = 225;
									}
								}
							}
						}
					}
				}
				if (!remixWorldGen && j < Main.maxTilesY - 50 && j > 50 && i > beachDistance + 220 && i < Main.maxTilesX - beachDistance - 220)
				{
					if (Main.tile[i, j].active() && Main.tile[i, j].type == 225 && (!Main.tile[i - 1, j - 1].active() || !Main.tile[i, j - 1].active() || !Main.tile[i + 1, j - 1].active() || !Main.tile[i - 1, j].active() || !Main.tile[i + 1, j].active() || !Main.tile[i - 1, j + 1].active() || !Main.tile[i, j + 1].active() || !Main.tile[i + 1, j - 1].active()) && ((double)j < Main.worldSurface || (Main.tile[i - 1, j - 1].wall == 0 && Main.tile[i, j - 1].wall == 0 && Main.tile[i + 1, j - 1].wall == 0 && Main.tile[i - 1, j].wall == 0 && Main.tile[i + 1, j].wall == 0 && Main.tile[i - 1, j + 1].wall == 0 && Main.tile[i, j + 1].wall == 0 && Main.tile[i + 1, j - 1].wall == 0)))
					{
						Main.tile[i, j].type = 60;
						for (int k = 0; k < 8; k++)
						{
							int num3 = i + genRand.Next(-2, 3);
							int num4 = j + genRand.Next(-2, 3);
							if (Main.tile[num3, num4].active() && Main.tile[num3, num4].type == 225 && Main.tile[num3 - 1, num4 - 1].active() && Main.tile[num3, num4 - 1].active() && Main.tile[num3 + 1, num4 - 1].active() && Main.tile[num3 - 1, num4].active() && Main.tile[num3 + 1, num4].active() && Main.tile[num3 - 1, num4 + 1].active() && Main.tile[num3, num4 + 1].active() && Main.tile[num3 + 1, num4 - 1].active())
							{
								Main.tile[num3, num4].type = 59;
							}
						}
					}
					if (Main.tile[i, j].active() && Main.tile[i, j].type == 230 && (!Main.tile[i - 1, j - 1].active() || !Main.tile[i, j - 1].active() || !Main.tile[i + 1, j - 1].active() || !Main.tile[i - 1, j].active() || !Main.tile[i + 1, j].active() || !Main.tile[i - 1, j + 1].active() || !Main.tile[i, j + 1].active() || !Main.tile[i + 1, j - 1].active()) && ((double)j < Main.worldSurface || (Main.tile[i - 1, j - 1].wall == 0 && Main.tile[i, j - 1].wall == 0 && Main.tile[i + 1, j - 1].wall == 0 && Main.tile[i - 1, j].wall == 0 && Main.tile[i + 1, j].wall == 0 && Main.tile[i - 1, j + 1].wall == 0 && Main.tile[i, j + 1].wall == 0 && Main.tile[i + 1, j - 1].wall == 0)))
					{
						Main.tile[i, j].type = 70;
						for (int l = 0; l < 8; l++)
						{
							int num5 = i + genRand.Next(-2, 3);
							int num6 = j + genRand.Next(-2, 3);
							if (Main.tile[num5, num6].active() && Main.tile[num5, num6].type == 230 && Main.tile[num5 - 1, num6 - 1].active() && Main.tile[num5, num6 - 1].active() && Main.tile[num5 + 1, num6 - 1].active() && Main.tile[num5 - 1, num6].active() && Main.tile[num5 + 1, num6].active() && Main.tile[num5 - 1, num6 + 1].active() && Main.tile[num5, num6 + 1].active() && Main.tile[num5 + 1, num6 - 1].active())
							{
								Main.tile[num5, num6].type = 59;
							}
						}
					}
				}
				if (Main.tile[i, j].wall != 15 && Main.tile[i, j].wall != 64 && Main.tile[i, j].wall != 204 && Main.tile[i, j].wall != 205 && Main.tile[i, j].wall != 206 && Main.tile[i, j].wall != 207 && Main.tile[i, j].wall != 87)
				{
					if (Main.wallDungeon[Main.tile[i, j].wall])
					{
						Main.tile[i, j].wallColor(14);
					}
					else if ((remixWorldGen || (!tenthAnniversaryWorldGen && !dontStarveWorldGen && !drunkWorldGen) || !((double)i > (double)Main.maxTilesX * 0.4 - (double)genRand.Next(3)) || !((double)i < (double)Main.maxTilesX * 0.6 + (double)genRand.Next(3))) && (!dontStarveWorldGen || remixWorldGen) && Main.tile[i, j].wall != 23 && Main.tile[i, j].wall != 24 && Main.tile[i, j].wall != 42 && Main.tile[i, j].wall != 10 && Main.tile[i, j].wall != 21 && Main.tile[i, j].wall != 82 && Main.tile[i, j].wall != 187 && Main.tile[i, j].wall != 216 && Main.tile[i, j].wall != 34 && Main.tile[i, j].wall != 244)
					{
						if (Main.tile[i, j].wall == 2)
						{
							Main.tile[i, j].wall = 2;
						}
						else if (Main.tile[i, j].wall == 196)
						{
							Main.tile[i, j].wall = 196;
						}
						else if (Main.tile[i, j].wall == 197)
						{
							Main.tile[i, j].wall = 197;
						}
						else if (Main.tile[i, j].wall == 198)
						{
							Main.tile[i, j].wall = 198;
						}
						else if (Main.tile[i, j].wall == 199)
						{
							Main.tile[i, j].wall = 199;
						}
						else if (Main.tile[i, j].wall == 63)
						{
							Main.tile[i, j].wall = 64;
						}
						else if (Main.tile[i, j].wall != 3 && Main.tile[i, j].wall != 83 && Main.tile[i, j].wall != 73 && Main.tile[i, j].wall != 62 && Main.tile[i, j].wall != 180 && Main.tile[i, j].wall != 178 && Main.tile[i, j].wall != 13 && Main.tile[i, j].wall != 14 && Main.tile[i, j].wall != 312 && Main.tile[i, j].wall != 313 && Main.tile[i, j].wall > 0 && (!remixWorldGen || (double)j > Main.worldSurface + (double)genRand.Next(-1, 2)) && j <= num2 + genRand.Next(3))
						{
							Main.tile[i, j].wall = 86;
						}
					}
				}
				if ((!tenthAnniversaryWorldGen || remixWorldGen || !((double)j < Main.worldSurface)) && (!dontStarveWorldGen || remixWorldGen) && Main.tile[i, j].liquid > 0 && j <= GenVars.lavaLine + 2)
				{
					if ((double)i > (double)Main.maxTilesX * 0.4 && (double)i < (double)Main.maxTilesX * 0.6)
					{
						Main.tile[i, j].honey(honey: false);
					}
					else if ((double)j > Main.rockLayer && (i < beachDistance + 200 || i > Main.maxTilesX - beachDistance - 200))
					{
						Main.tile[i, j].honey(honey: false);
					}
					else if (Main.wallDungeon[Main.tile[i, j].wall])
					{
						Main.tile[i, j].honey(honey: false);
					}
					else if (!skyblockWorldGen)
					{
						Main.tile[i, j].honey(honey: true);
					}
				}
			}
		}
	}

	private static int FindLowestCloud()
	{
		if (SecretSeed.noSurface.Enabled)
		{
			GenVars.lowestCloud = 150;
		}
		if (GenVars.lowestCloud > -1)
		{
			return GenVars.lowestCloud;
		}
		int num = 0;
		for (int i = 20; (double)i < Main.worldSurface; i++)
		{
			for (int j = 20; j < Main.maxTilesX - 20; j++)
			{
				if (Main.tile[j, i].active() && TileID.Sets.Clouds[Main.tile[j, i].type])
				{
					num = i;
					break;
				}
			}
		}
		GenVars.lowestCloud = num;
		return num;
	}

	private static void FinishNotTheBees()
	{
		if (!notTheBees || skyblockWorldGen)
		{
			return;
		}
		Main.tileSolid[379] = false;
		int num = 0;
		for (int i = 20; (double)i < Main.worldSurface; i++)
		{
			for (int j = 20; j < Main.maxTilesX - 20; j++)
			{
				if (Main.tile[j, i].active() && TileID.Sets.Clouds[Main.tile[j, i].type])
				{
					num = i;
					break;
				}
			}
		}
		if (getGoodWorldGen && !tenthAnniversaryWorldGen)
		{
			for (int k = 0; k < Main.maxTilesX / 4; k++)
			{
				int num2 = genRand.Next(20, Main.maxTilesX - 20);
				int num3 = genRand.Next(Main.UnderworldLayer + 10, Main.maxTilesY - 20);
				int num4 = 10000;
				while (Main.tile[num2, num3].wall != 62 && num4 > 0)
				{
					num4--;
					num2 = genRand.Next(20, Main.maxTilesX - 20);
					num3 = genRand.Next(Main.UnderworldLayer + 10, Main.maxTilesY - 20);
				}
				SpiderWallRemover(num2, num3);
			}
			for (int l = 0; l < Main.maxTilesX / 3; l++)
			{
				int num5 = genRand.Next(20, Main.maxTilesX - 20);
				int num6 = genRand.Next((int)Main.worldSurface, Main.UnderworldLayer - 30);
				int num7 = 10000;
				while (Main.tile[num5, num6].wall != 62 && num7 > 0)
				{
					num7--;
					num5 = genRand.Next(20, Main.maxTilesX - 20);
					num6 = genRand.Next((int)Main.worldSurface, Main.UnderworldLayer - 30);
				}
				SpiderWallRemover(num5, num6);
			}
		}
		for (int m = 25; m < Main.maxTilesX - 25; m++)
		{
			for (int n = 25; n < Main.maxTilesY - 25; n++)
			{
				int num8 = (Main.tile[m, n].active() ? Main.tile[m, n].type : (-1));
				if (getGoodWorldGen && !tenthAnniversaryWorldGen && num8 == 76)
				{
					Main.tile[m, n].type = 230;
				}
				if (n < num && num8 == 229)
				{
					Main.tile[m, n].active(active: false);
					Main.tile[m, n].liquid = byte.MaxValue;
					Main.tile[m, n].liquidType(0);
				}
				if ((dontStarveWorldGen || noTrapsWorldGen) && !tenthAnniversaryWorldGen && num8 == 48)
				{
					Main.tile[m, n].type = 232;
				}
				if (num8 == 571)
				{
					TileFrame(m, n);
				}
				int num9 = 20;
				if (remixWorldGen)
				{
					num9 = 10;
				}
				if (num8 == 25 || (remixWorldGen && num8 == 23 && (double)n < Main.worldSurface))
				{
					for (int num10 = m - num9; num10 <= m + num9; num10++)
					{
						for (int num11 = n - num9; num11 <= n + num9; num11++)
						{
							if (Main.tile[num10, num11].active() && Main.tile[num10, num11].type == 60)
							{
								if (Main.tile[num10, num11 + 1].type == 444)
								{
									KillTile(num10, num11 + 1);
								}
								Main.tile[num10, num11].type = 661;
								if (Main.tile[num10, num11 - 1].active() && (Main.tile[num10, num11 - 1].type == 61 || Main.tile[num10, num11 - 1].type == 74))
								{
									Main.tile[num10, num11 - 1].active(active: false);
									PlaceTile(num10, num11 - 1, 24);
								}
							}
							else if (Main.tile[num10, num11 - 1].type == 233 || Main.tile[num10, num11 - 1].type == 82)
							{
								KillTile(num10, num11 - 1);
							}
						}
					}
				}
				else if (num8 == 203 || (remixWorldGen && num8 == 199 && (double)n < Main.worldSurface))
				{
					for (int num12 = m - num9; num12 <= m + num9; num12++)
					{
						for (int num13 = n - num9; num13 <= n + num9; num13++)
						{
							if (Main.tile[num12, num13].active() && Main.tile[num12, num13].type == 60)
							{
								if (Main.tile[num12, num13 + 1].type == 444)
								{
									KillTile(num12, num13 + 1);
								}
								Main.tile[num12, num13].type = 662;
								if (Main.tile[num12, num13 - 1].active() && (Main.tile[num12, num13 - 1].type == 61 || Main.tile[num12, num13 - 1].type == 74))
								{
									Main.tile[num12, num13 - 1].active(active: false);
									PlaceTile(num12, num13 - 1, 201);
								}
								else if (Main.tile[num12, num13 - 1].type == 233 || Main.tile[num12, num13 - 1].type == 82)
								{
									KillTile(num12, num13 - 1);
								}
							}
						}
					}
				}
				if ((num8 == 382 || num8 == 52) && Main.tile[m, n - 1].active() && (Main.tile[m, n - 1].type == 62 || Main.tile[m, n - 1].type == 60 || Main.tile[m, n - 1].type == 384))
				{
					Main.tile[m, n].type = 62;
				}
				if (n > GenVars.lavaLine + genRand.Next(-2, 3) + 2)
				{
					if (!remixWorldGen)
					{
						SpreadGrass(m, n, 59, 70);
					}
				}
				else
				{
					SpreadGrass(m, n, 59, 60);
				}
				int num14 = GenVars.lavaLine + genRand.Next(5);
				int num15 = (int)Main.worldSurface + genRand.Next(-2, 3) + 35;
				int num16 = (num14 + num15) / 2;
				if (n > num15 && n <= num14 && (m < beachDistance + 200 - 20 - genRand.Next(-2, 3) || m > Main.maxTilesX - beachDistance - 200 + 20 + genRand.Next(-2, 3)))
				{
					if (Main.tile[m, n].wall == 86)
					{
						Main.tile[m, n].wall = 0;
					}
					if (Main.tile[m, n].liquid > 0)
					{
						Main.tile[m, n].honey(honey: false);
						Main.tile[m, n].lava(lava: false);
					}
					if (num8 == 59)
					{
						bool flag = false;
						for (int num17 = m - 1; num17 <= m + 1; num17++)
						{
							for (int num18 = n - 1; num18 <= n + 1; num18++)
							{
								if (Main.tile[num17, num18].type == 60)
								{
									flag = true;
								}
							}
						}
						if (!flag)
						{
							if (n < num16)
							{
								Main.tile[m, n].type = 161;
							}
							else
							{
								Main.tile[m, n].type = 147;
							}
						}
					}
					if (num8 == 225 || num8 == 230)
					{
						if (n > num16)
						{
							Main.tile[m, n].type = 161;
						}
						else
						{
							Main.tile[m, n].type = 147;
						}
					}
				}
				if (!remixWorldGen && !dontStarveWorldGen)
				{
					switch (num8)
					{
					case 6:
					case 7:
					case 166:
					case 167:
						if ((double)n > ((double)GenVars.lavaLine + Main.rockLayer * 2.0) / 3.0 + (double)genRand.Next(-2, 3) + 2.0)
						{
							Main.tile[m, n].type = 0;
						}
						break;
					case 40:
					case 123:
						if ((double)n > ((double)GenVars.lavaLine + Main.rockLayer) / 2.0 + (double)genRand.Next(-2, 3) + 2.0)
						{
							Main.tile[m, n].type = 1;
						}
						break;
					}
				}
				if (n <= num || m <= 350 || m >= Main.maxTilesX - 350 || (Main.tile[m, n].liquid != 0 && !Main.tile[m, n].honey()) || (tenthAnniversaryWorldGen && !remixWorldGen))
				{
					continue;
				}
				if (dontStarveWorldGen || remixWorldGen)
				{
					if (genRand.Next(600) == 0)
					{
						PlaceTile(m, n, 231, mute: true);
					}
				}
				else if (noTrapsWorldGen)
				{
					if (genRand.Next(150) == 0)
					{
						PlaceTile(m, n, 231, mute: true);
					}
				}
				else if (genRand.Next(225) == 0)
				{
					PlaceTile(m, n, 231, mute: true);
				}
			}
		}
		if (dontStarveWorldGen && !remixWorldGen && !SecretSeed.Variations.noSpiderCavesActuallyNoSpiderCaves)
		{
			for (int num19 = 50; num19 < Main.maxTilesX - 50; num19++)
			{
				for (int num20 = 50; (double)num20 < Main.worldSurface + (double)genRand.Next(3); num20++)
				{
					bool flag2 = genRand.Next(3) == 0;
					if (getGoodWorldGen)
					{
						flag2 = !flag2;
					}
					if (!flag2)
					{
						continue;
					}
					bool flag3 = false;
					int num21 = -1;
					int num22 = -1;
					if (Main.tile[num19, num20].active() && Main.tile[num19, num20].type == 60 && Main.tile[num19, num20].wall == 15)
					{
						for (int num23 = num19 - 1; num23 <= num19 + 1; num23++)
						{
							for (int num24 = num20 - 1; num24 <= num20 + 1; num24++)
							{
								if (Main.tile[num23, num24].wall == 0 && !SolidTile(num23, num24))
								{
									flag3 = true;
								}
							}
						}
						if (flag3)
						{
							for (int num25 = num19 - 1; num25 <= num19 + 1; num25++)
							{
								for (int num26 = num20 - 1; num26 <= num20 + 1; num26++)
								{
									if (Main.tile[num25, num26].wall == 15 && !SolidTile(num25, num26))
									{
										num21 = num25;
										num22 = num26;
									}
								}
							}
						}
					}
					if (dontStarveWorldGen && Main.tile[num19, num20].active() && Main.tile[num19, num20].type == 2 && Main.tile[num19, num20].wall == 63)
					{
						for (int num27 = num19 - 1; num27 <= num19 + 1; num27++)
						{
							for (int num28 = num20 - 1; num28 <= num20 + 1; num28++)
							{
								if (Main.tile[num27, num28].wall == 0 && !SolidTile(num27, num28))
								{
									flag3 = true;
								}
							}
						}
						if (flag3)
						{
							for (int num29 = num19 - 1; num29 <= num19 + 1; num29++)
							{
								for (int num30 = num20 - 1; num30 <= num20 + 1; num30++)
								{
									if (Main.tile[num29, num30].wall == 63 && !SolidTile(num29, num30))
									{
										num21 = num29;
										num22 = num30;
									}
								}
							}
						}
					}
					if (flag3 && num21 > -1 && num22 > -1)
					{
						try
						{
							Spread.Wall2(num21, num22, 62);
						}
						catch
						{
						}
					}
				}
			}
			for (int num31 = 200; num31 < Main.maxTilesX - 200; num31++)
			{
				for (int num32 = 50; (double)num32 < Main.rockLayer; num32++)
				{
					if (Main.tile[num31, num32].wall == 62)
					{
						Main.tile[num31, num32].liquid = 0;
						Main.tile[num31, num32].lava(lava: false);
					}
					if (Main.tile[num31, num32].wall != 62 || Main.tile[num31, num32].active() || genRand.Next(10) == 0)
					{
						continue;
					}
					int num33 = genRand.Next(2, 5);
					int num34 = num31 - num33;
					int num35 = num31 + num33;
					int num36 = num32 - num33;
					int num37 = num32 + num33;
					bool flag4 = false;
					for (int num38 = num34; num38 <= num35; num38++)
					{
						for (int num39 = num36; num39 <= num37; num39++)
						{
							if (SolidTile(num38, num39))
							{
								flag4 = true;
								break;
							}
						}
					}
					if (flag4)
					{
						PlaceTile(num31, num32, 51, mute: true);
						TileFrame(num31, num32);
					}
				}
			}
		}
		for (int num40 = 20; num40 < num; num40++)
		{
			for (int num41 = 20; num41 <= Main.maxTilesX - 20; num41++)
			{
				Main.tile[num41, num40].honey(honey: false);
				if (Main.tile[num41, num40].type == 375)
				{
					Main.tile[num41, num40].type = 373;
				}
				if (!remixWorldGen)
				{
					if (Main.tile[num41, num40].type == 60)
					{
						Main.tile[num41, num40].type = 2;
						if (genRand.Next(2) == 0)
						{
							TryGrowingTreeByType(616, num41, num40);
						}
						else
						{
							TryGrowingTreeByType(596, num41, num40);
						}
						if (!Main.tile[num41, num40 - 1].active())
						{
							PlaceTile(num41, num40 - 1, 3);
						}
					}
					if (Main.tile[num41, num40].type == 59)
					{
						Main.tile[num41, num40].type = 0;
					}
				}
				else
				{
					TryGrowingTreeByType(5, num41, num40);
				}
			}
		}
		Main.tileSolid[379] = true;
		if (!remixWorldGen)
		{
			OverGrownDungeon();
		}
	}

	private static void FinishGetGoodWorld()
	{
		int num = 0;
		for (int i = 20; (double)i < Main.worldSurface; i++)
		{
			for (int j = 20; j < Main.maxTilesX - 20; j++)
			{
				if (Main.tile[j, i].active() && TileID.Sets.Clouds[Main.tile[j, i].type])
				{
					num = i;
					break;
				}
			}
		}
		byte b = (byte)genRand.Next(13, 25);
		for (int k = 0; k < Main.maxTilesX; k++)
		{
			bool flag = false;
			for (int l = 0; l < Main.maxTilesY; l++)
			{
				if (!Main.tile[k, l].active() || !Main.tileDungeon[Main.tile[k, l].type])
				{
					continue;
				}
				if (Main.tile[k, l].color() == 14)
				{
					flag = true;
					b = 14;
					continue;
				}
				if (Main.tile[k, l].type == 44)
				{
					flag = true;
					b = (byte)genRand.Next(13, 15);
					if (genRand.Next(2) == 0)
					{
						b = (byte)genRand.Next(23, 25);
					}
				}
				if (Main.tile[k, l].type == 43)
				{
					flag = true;
					b = (byte)genRand.Next(15, 19);
				}
				if (Main.tile[k, l].type == 41)
				{
					flag = true;
					b = (byte)genRand.Next(19, 23);
				}
			}
			if (flag)
			{
				break;
			}
		}
		for (int m = 10; m < Main.maxTilesX - 10; m++)
		{
			for (int n = 10; n < Main.maxTilesY - 10; n++)
			{
				if (Main.tile[m, n].active() && (Main.tileDungeon[Main.tile[m, n].type] || TileID.Sets.CrackedBricks[Main.tile[m, n].type]))
				{
					Main.tile[m, n].color(b);
				}
				if (Main.wallDungeon[Main.tile[m, n].wall] && !drunkWorldGen && !notTheBees)
				{
					Main.tile[m, n].wallColor(b);
				}
				if (Main.tile[m, n].active())
				{
					bool flag2 = false;
					if (Main.tile[m, n].type == 226)
					{
						flag2 = true;
					}
					if (Main.tile[m, n].type == 60 && Main.tile[m, n + 1].type == 226)
					{
						flag2 = true;
					}
					if (Main.tile[m, n].type == 137)
					{
						int num2 = Main.tile[m, n].frameY / 18;
						if (num2 >= 1 && num2 <= 4)
						{
							flag2 = true;
						}
					}
					if (flag2 && !notTheBees)
					{
						Main.tile[m, n].color(17);
					}
				}
				if (Main.tile[m, n].wall == 87)
				{
					Main.tile[m, n].wallColor(25);
				}
				if (!Main.tile[m, n].active())
				{
					continue;
				}
				if (!remixWorldGen && Main.tile[m, n].type == 57 && genRand.Next(15) == 0)
				{
					if (Main.tile[m, n - 1].type == 57)
					{
						Main.tile[m, n].active(active: false);
					}
					Main.tile[m, n].liquid = byte.MaxValue;
					Main.tile[m, n].lava(lava: true);
				}
				if (!tenthAnniversaryWorldGen && !notTheBees && n < num && Main.tile[m, n].type == 2)
				{
					if (crimson)
					{
						Main.tile[m, n].type = 199;
					}
					else
					{
						Main.tile[m, n].type = 23;
					}
					if (Main.tile[m, n - 1].type == 3)
					{
						Main.tile[m, n - 1].active(active: false);
					}
					if (Main.tile[m, n - 1].type == 73)
					{
						Main.tile[m, n - 1].active(active: false);
					}
					if (Main.tile[m, n - 1].type == 27)
					{
						KillTile(m, n - 1);
					}
					if (Main.tile[m, n - 1].type == 596)
					{
						KillTile(m, n - 1);
					}
					if (Main.tile[m, n - 1].type == 616)
					{
						KillTile(m, n - 1);
					}
					if (Main.tile[m, n - 1].type == 82)
					{
						KillTile(m, n - 1);
					}
					if (Main.tile[m, n - 1].type == 83)
					{
						KillTile(m, n - 1);
					}
					if (Main.tile[m, n - 1].type == 186)
					{
						KillTile(m, n - 1);
					}
					if (Main.tile[m, n - 1].type == 187)
					{
						KillTile(m, n - 1);
					}
					if (Main.tile[m, n - 1].type == 185)
					{
						KillTile(m, n - 1);
					}
					if (Main.tile[m, n - 1].type == 227)
					{
						KillTile(m, n - 1);
					}
				}
			}
		}
		for (int num3 = 0; num3 < 8000; num3++)
		{
			Chest chest = Main.chest[num3];
			if (chest == null)
			{
				break;
			}
			if (genRand.Next(10) != 0 || chest.item[1].stack == 0)
			{
				continue;
			}
			for (int num4 = 1; num4 < chest.maxItems; num4++)
			{
				if (chest.item[num4].stack == 0)
				{
					chest.item[num4].SetDefaults(678);
					break;
				}
			}
		}
	}

	private static void FinishNoTraps()
	{
		SetBoulderSolidity(solid: false);
		int maxValue = 5;
		if (getGoodWorldGen && !tenthAnniversaryWorldGen)
		{
			maxValue = 2;
		}
		for (int i = 50; i < Main.maxTilesX - 50; i++)
		{
			for (int j = 50; j < Main.maxTilesY - 50; j++)
			{
				Tile tile = Main.tile[i, j];
				if (genRand.Next(maxValue) == 0 && tile.active() && tile.type == 12 && tile.frameX == 0 && tile.frameY == 0)
				{
					Main.tile[i, j].type = 665;
					Main.tile[i, j + 1].type = 665;
					Main.tile[i + 1, j].type = 665;
					Main.tile[i + 1, j + 1].type = 665;
				}
				if (i % 2 != 0 || j % 2 != 0 || !Main.tile[i, j].active() || (Main.tile[i, j].type != 105 && (Main.tile[i, j].type != 467 || (Main.tile[i, j].frameX != 144 && Main.tile[i, j].frameX != 162))))
				{
					continue;
				}
				bool flag = false;
				for (int k = i - 1; k <= i + 1; k++)
				{
					for (int l = j - 1; l <= j + 1; l++)
					{
						if (Main.tile[k, l].wire())
						{
							flag = true;
						}
					}
				}
				if (!flag)
				{
					bool flag2 = false;
					int num = 25;
					int num2 = -1;
					int num3 = -1;
					for (int m = 0; m < num * num; m++)
					{
						num2 = genRand.Next(i - num, i + num + 1);
						num3 = genRand.Next(j - num, j + num + 1);
						if (Main.tile[num2, num3].wire())
						{
							flag2 = true;
							break;
						}
					}
					if (flag2)
					{
						int num4 = i;
						int num5 = j;
						Main.tile[num4, num5].wire(wire: true);
						while (num4 != num2)
						{
							if (num4 < num2)
							{
								num4++;
							}
							if (num4 > num2)
							{
								num4--;
							}
							Main.tile[num4, num5].wire(wire: true);
						}
						while (num5 != num3)
						{
							if (num5 < num3)
							{
								num5++;
							}
							if (num5 > num3)
							{
								num5--;
							}
							Main.tile[num4, num5].wire(wire: true);
						}
					}
					else if (Main.tile[i, j].type == 105)
					{
						num = 15;
						bool flag3 = false;
						for (int n = 0; n < num * num; n++)
						{
							num2 = i + genRand.Next(-num, num + 1);
							num3 = j + genRand.Next(-num, num + 1);
							PlaceTile(num2, num3, 135, mute: true, forced: true, -1, genRand.Next(2, 4));
							if (Main.tile[num2, num3].type == 135)
							{
								flag3 = true;
								break;
							}
						}
						if (flag3)
						{
							int num6 = i;
							int num7 = j;
							Main.tile[num6, num7].wire(wire: true);
							while (num6 != num2)
							{
								if (num6 < num2)
								{
									num6++;
								}
								if (num6 > num2)
								{
									num6--;
								}
								Main.tile[num6, num7].wire(wire: true);
							}
							while (num7 != num3)
							{
								if (num7 < num3)
								{
									num7++;
								}
								if (num7 > num3)
								{
									num7--;
								}
								Main.tile[num6, num7].wire(wire: true);
							}
						}
					}
				}
				if (Main.tile[i, j].type == 467 && (!tenthAnniversaryWorldGen || remixWorldGen))
				{
					int num8 = 8;
					for (int num9 = 0; num9 < num8 * num8; num9++)
					{
						int num10 = i + genRand.Next(-num8, num8 + 1);
						int num11 = j + genRand.Next(-num8, num8 + 1);
						if (Main.tile[num10, num11].type != 0 && Main.tile[num10, num11].type != 1 && !TileID.Sets.Ore[Main.tile[num10, num11].type] && Main.tile[num10, num11].type != 59 && Main.tile[num10, num11].type != 151)
						{
							continue;
						}
						bool flag4 = true;
						for (int num12 = num10 - 1; num12 <= num10 + 1; num12++)
						{
							for (int num13 = num11 - 1; num13 <= num11 + 1; num13++)
							{
								if (!SolidTile(num12, num13))
								{
									flag4 = false;
								}
							}
						}
						if (!flag4)
						{
							continue;
						}
						Tile tile2 = Main.tile[num10, num11];
						tile2.type = 141;
						tile2.frameX = (tile2.frameY = 0);
						tile2.slope(0);
						tile2.halfBrick(halfBrick: false);
						TileFrame(num10, num11, resetFrame: true);
						if (Main.tile[num10, num11].type != 141)
						{
							continue;
						}
						int num14 = i;
						int num15 = j;
						Main.tile[num14, num15].wire(wire: true);
						while (num14 != num10)
						{
							if (num14 < num10)
							{
								num14++;
							}
							if (num14 > num10)
							{
								num14--;
							}
							Main.tile[num14, num15].wire(wire: true);
						}
						while (num15 != num11)
						{
							if (num15 < num11)
							{
								num15++;
							}
							if (num15 > num11)
							{
								num15--;
							}
							Main.tile[num14, num15].wire(wire: true);
						}
						break;
					}
				}
				else
				{
					j++;
				}
			}
		}
		SetBoulderSolidity(solid: true);
		for (int num16 = 20; num16 < Main.maxTilesX - 20; num16++)
		{
			for (int num17 = 20; num17 < Main.maxTilesY - 20; num17++)
			{
				if (Main.tile[num16, num17].active() && Main.tile[num16, num17].type == 467 && Main.tile[num16, num17].frameX == 144 && Main.tile[num16, num17].frameY == 0 && !Main.tile[num16, num17].wire() && !Main.tile[num16 + 1, num17].wire() && !Main.tile[num16, num17 + 1].wire() && !Main.tile[num16 + 1, num17 + 1].wire())
				{
					Main.tile[num16, num17].type = 21;
					Main.tile[num16, num17].frameX = 36;
					Main.tile[num16 + 1, num17].type = 21;
					Main.tile[num16 + 1, num17].frameX = 54;
					Main.tile[num16, num17 + 1].type = 21;
					Main.tile[num16, num17 + 1].frameX = 36;
					Main.tile[num16 + 1, num17 + 1].type = 21;
					Main.tile[num16 + 1, num17 + 1].frameX = 54;
				}
			}
		}
		for (int num18 = 0; num18 < 8000; num18++)
		{
			Chest chest = Main.chest[num18];
			if (chest == null)
			{
				break;
			}
			if (genRand.Next(15) != 0 || chest.item[1].stack == 0)
			{
				continue;
			}
			for (int num19 = 1; num19 < chest.maxItems; num19++)
			{
				if (chest.item[num19].stack == 0)
				{
					chest.item[num19].SetDefaults(5346);
					break;
				}
			}
		}
	}

	private static void FinishDrunkGen()
	{
		byte color = (byte)genRand.Next(13, 25);
		byte b = 16;
		for (int i = 0; i < Main.maxTilesX; i++)
		{
			bool flag = false;
			for (int j = 0; j < Main.maxTilesY; j++)
			{
				if (!Main.tile[i, j].active() || !Main.tileDungeon[Main.tile[i, j].type])
				{
					continue;
				}
				if (Main.tile[i, j].type == 44)
				{
					color = (byte)genRand.Next(13, 15);
					if (genRand.Next(2) == 0)
					{
						color = (byte)genRand.Next(23, 25);
					}
				}
				if (Main.tile[i, j].type == 43)
				{
					color = (byte)genRand.Next(15, 19);
				}
				if (Main.tile[i, j].type == 41)
				{
					color = (byte)genRand.Next(19, 23);
				}
			}
			if (flag)
			{
				break;
			}
		}
		for (int k = 10; k < Main.maxTilesX - 10; k++)
		{
			for (int l = 10; l < Main.maxTilesY - 10; l++)
			{
				if (Main.tile[k, l].active() && (Main.tileDungeon[Main.tile[k, l].type] || TileID.Sets.CrackedBricks[Main.tile[k, l].type]))
				{
					Main.tile[k, l].color(color);
				}
				if (Main.wallDungeon[Main.tile[k, l].wall])
				{
					Main.tile[k, l].wallColor(25);
				}
				if (Main.tile[k, l].active())
				{
					if (Main.tile[k, l].type == 60)
					{
						int num = 1;
						for (int m = k - num; m <= k + num; m++)
						{
							for (int n = l - num; n <= l + num; n++)
							{
								if (Main.tile[m, n].type == 147 || Main.tile[m, n].type == 161)
								{
									Main.tile[m, n].type = 59;
								}
							}
						}
					}
					bool flag2 = false;
					if (Main.tile[k, l].type == 226)
					{
						flag2 = true;
					}
					if (Main.tile[k, l].type == 60 && Main.tile[k, l + 1].type == 226)
					{
						flag2 = true;
					}
					if (Main.tile[k, l].type == 137)
					{
						int num2 = Main.tile[k, l].frameY / 18;
						if (num2 >= 1 && num2 <= 4)
						{
							flag2 = true;
						}
					}
					if (flag2 && !notTheBees)
					{
						Main.tile[k, l].color(b);
					}
				}
				if (Main.tile[k, l].wall == 87)
				{
					Main.tile[k, l].wallColor(b);
				}
			}
		}
		for (int num3 = 0; num3 < 8000; num3++)
		{
			Chest chest = Main.chest[num3];
			if (chest == null)
			{
				break;
			}
			if (genRand.Next(15) == 0 && chest.item[1].stack != 0)
			{
				for (int num4 = 1; num4 < chest.maxItems; num4++)
				{
					if (chest.item[num4].stack == 0)
					{
						chest.item[num4].SetDefaults(5001);
						break;
					}
				}
			}
			if (genRand.Next(30) != 0 || chest.item[1].stack == 0)
			{
				continue;
			}
			for (int num5 = 1; num5 < chest.maxItems; num5++)
			{
				if (chest.item[num5].stack == 0)
				{
					chest.item[num5].SetDefaults(678);
					break;
				}
			}
		}
	}

	private static void FinishRemixWorld()
	{
		int num = 0;
		for (int i = 25; i < Main.maxTilesX - 25; i++)
		{
			for (int j = 25; j < Main.maxTilesY - 25; j++)
			{
				if (Main.tile[i, j].active() && (TileID.Sets.Clouds[Main.tile[i, j].type] || Main.tile[i, j].type == 202))
				{
					if (j > num)
					{
						num = j;
					}
					if (!tenthAnniversaryWorldGen || getGoodWorldGen)
					{
						if (drunkWorldGen)
						{
							if (GenVars.crimsonLeft)
							{
								if (i < Main.maxTilesX / 2 + genRand.Next(-2, 3))
								{
									Main.tile[i, j].type = 195;
								}
								else
								{
									Main.tile[i, j].type = 474;
								}
							}
							else if (i < Main.maxTilesX / 2 + genRand.Next(-2, 3))
							{
								Main.tile[i, j].type = 474;
							}
							else
							{
								Main.tile[i, j].type = 195;
							}
						}
						else if (crimson)
						{
							Main.tile[i, j].type = 195;
						}
						else
						{
							Main.tile[i, j].type = 474;
						}
					}
				}
				if ((Main.tile[i, j].wall != 73 && Main.tile[i, j].wall != 82) || (tenthAnniversaryWorldGen && !getGoodWorldGen))
				{
					continue;
				}
				if (drunkWorldGen)
				{
					if (GenVars.crimsonLeft)
					{
						if (i < Main.maxTilesX / 2 + genRand.Next(-2, 3))
						{
							Main.tile[i, j].wall = 77;
						}
						else
						{
							Main.tile[i, j].wall = 233;
						}
					}
					else if (i < Main.maxTilesX / 2 + genRand.Next(-2, 3))
					{
						Main.tile[i, j].wall = 233;
					}
					else
					{
						Main.tile[i, j].wall = 77;
					}
				}
				else if (crimson)
				{
					Main.tile[i, j].wall = 77;
				}
				else
				{
					Main.tile[i, j].wall = 233;
				}
			}
		}
		for (int k = 25; k < Main.maxTilesX - 25; k++)
		{
			for (int l = 25; l < Main.maxTilesY - 25; l++)
			{
				int conversionType = 1;
				if (crimson)
				{
					conversionType = 4;
				}
				if ((l > num || SecretSeed.errorWorld.Enabled || SecretSeed.surfaceIsInSpace.Enabled) && (double)l < Main.worldSurface && k > beachDistance && k < Main.maxTilesX - beachDistance)
				{
					if (Main.tile[k, l].wall == 87)
					{
						if (Main.tile[k, l].liquid > 0)
						{
							Main.tile[k, l].liquidType(0);
						}
					}
					else if (getGoodWorldGen)
					{
						if (Main.tile[k, l].liquid > 0)
						{
							if (Main.tileLavaDeath[Main.tile[k, l].type])
							{
								KillTile(k, l);
							}
							Main.tile[k, l].lava(lava: true);
						}
						if (Main.tile[k, l].type == 375 || Main.tile[k, l].type == 373 || Main.tile[k, l].type == 709)
						{
							Main.tile[k, l].type = 374;
						}
						if (Main.tile[k, l].type == 230 || Main.tile[k, l].type == 229 || Main.tile[k, l].type == 659 || Main.tile[k, l].type == 56)
						{
							KillTile(k, l);
						}
						if (Main.tile[k, l].type == 82 || Main.tile[k, l].type == 83 || Main.tile[k, l].type == 84)
						{
							TileFrame(k, l);
						}
					}
					else if (notTheBees)
					{
						if (Main.tile[k, l].liquid > 0)
						{
							Main.tile[k, l].honey(honey: true);
						}
						if (Main.tile[k, l].type == 374 || Main.tile[k, l].type == 373 || Main.tile[k, l].type == 709)
						{
							Main.tile[k, l].type = 375;
						}
						if (Main.tile[k, l].type == 230 || Main.tile[k, l].type == 229 || Main.tile[k, l].type == 659 || Main.tile[k, l].type == 56)
						{
							KillTile(k, l);
						}
						if (Main.tile[k, l].type == 82 || Main.tile[k, l].type == 83 || Main.tile[k, l].type == 84)
						{
							TileFrame(k, l);
						}
					}
					else if (drunkWorldGen && tenthAnniversaryWorldGen)
					{
						if (Main.tile[k, l].liquid > 0)
						{
							if (Main.tileLavaDeath[Main.tile[k, l].type])
							{
								KillTile(k, l);
							}
							Main.tile[k, l].shimmer(shimmer: true);
						}
						if (Main.tile[k, l].type == 374 || Main.tile[k, l].type == 373 || Main.tile[k, l].type == 375)
						{
							Main.tile[k, l].type = 709;
						}
						if (Main.tile[k, l].type == 230 || Main.tile[k, l].type == 229 || Main.tile[k, l].type == 659 || Main.tile[k, l].type == 56)
						{
							KillTile(k, l);
						}
						if (Main.tile[k, l].type == 82 || Main.tile[k, l].type == 83 || Main.tile[k, l].type == 84)
						{
							TileFrame(k, l);
						}
					}
				}
				if ((double)l < Main.worldSurface + (double)genRand.Next(3))
				{
					if (tenthAnniversaryWorldGen && !getGoodWorldGen)
					{
						if (Main.tile[k, l].wall != 3 && Main.tile[k, l].wall != 83)
						{
							Convert(k, l, 2);
							if (Main.tile[k, l].type == 661 || Main.tile[k, l].type == 662)
							{
								Main.tile[k, l].type = 109;
								SquareTileFrame(k, l);
								if (SolidTile(k, l) && !Main.tile[k, l - 1].active())
								{
									PlaceTile(k, l, 110);
								}
								for (int m = k - 3; m <= k + 3; m++)
								{
									for (int n = l - 3; n <= l + 3; n++)
									{
										if (Main.tile[m, n].type == 59)
										{
											Main.tile[m, n].type = 0;
										}
									}
								}
							}
						}
					}
					else if (drunkWorldGen)
					{
						if (GenVars.crimsonLeft)
						{
							if (k < Main.maxTilesX / 2 + genRand.Next(-2, 3))
							{
								Convert(k, l, 4);
							}
							else
							{
								Convert(k, l, 1);
							}
						}
						else if (k < Main.maxTilesX / 2 + genRand.Next(-2, 3))
						{
							Convert(k, l, 1);
						}
						else
						{
							Convert(k, l, 4);
						}
					}
					else
					{
						Convert(k, l, conversionType);
					}
				}
				if ((double)l < Main.worldSurface - (double)genRand.Next(19, 22) && (Main.tile[k, l].wall == 178 || Main.tile[k, l].wall == 180))
				{
					Main.tile[k, l].wall = 0;
				}
				if (Main.tile[k, l].active() && Main.tile[k, l].type == 56)
				{
					KillTile(k, l);
				}
				if ((double)l > Main.rockLayer && l < Main.maxTilesY - 350 && Main.tile[k, l].type == 0 && Main.tile[k, l].active() && (!Main.tile[k - 1, l - 1].active() || !SolidTile(k, l - 1) || !Main.tile[k + 1, l - 1].active() || !Main.tile[k - 1, l].active() || !Main.tile[k + 1, l].active() || !Main.tile[k - 1, l + 1].active() || !Main.tile[k, l + 1].active() || !Main.tile[k + 1, l + 1].active()))
				{
					Main.tile[k, l].type = 2;
				}
			}
		}
		Liquid.QuickWater(-2);
		bool flag = true;
		if (SecretSeed.randomSpawn.Enabled)
		{
			flag = false;
		}
		while (flag)
		{
			int num2 = (int)((double)Main.maxTilesX * 0.38);
			int num3 = (int)((double)Main.maxTilesX * 0.62);
			_ = Main.maxTilesY;
			int num4 = Main.maxTilesY - 135;
			_ = Main.maxTilesY;
			for (int num5 = num2; num5 < num3 + 15; num5++)
			{
				for (int num6 = Main.maxTilesY - 200; num6 < num4 + 10; num6++)
				{
					Main.tile[num5, num6].liquid = 0;
					if (Main.tile[num5, num6].type == 58)
					{
						Main.tile[num5, num6].type = 57;
					}
					if (Main.tile[num5, num6].type == 230)
					{
						Main.tile[num5, num6].active(active: false);
					}
					if (Main.tile[num5, num6].type == 56)
					{
						Main.tile[num5, num6].active(active: false);
					}
					if (Main.tile[num5, num6].type == 659)
					{
						Main.tile[num5, num6].active(active: false);
					}
				}
			}
			Liquid.QuickWater(-2);
			flag = false;
			for (int num7 = -10; num7 < 15; num7++)
			{
				if (Main.tile[Main.spawnTileX, Main.spawnTileY - num7].liquid > 0)
				{
					flag = true;
					break;
				}
			}
		}
		AddTrees(undergroundOnly: true);
		if (!tenthAnniversaryWorldGen || getGoodWorldGen)
		{
			for (int num8 = 10; num8 < Main.maxTilesX - 10; num8++)
			{
				byte color = 22;
				byte color2 = 22;
				if (drunkWorldGen)
				{
					if ((GenVars.crimsonLeft && num8 < Main.maxTilesX / 2) || (!GenVars.crimsonLeft && num8 > Main.maxTilesX / 2))
					{
						color2 = 13;
						color = 13;
					}
				}
				else if (crimson)
				{
					color2 = 13;
					color = 13;
				}
				for (int num9 = 10; num9 < Main.maxTilesY - 10; num9++)
				{
					if (Main.tile[num8, num9].active() && (Main.tileDungeon[Main.tile[num8, num9].type] || TileID.Sets.CrackedBricks[Main.tile[num8, num9].type]))
					{
						Main.tile[num8, num9].color(color);
					}
					if (Main.wallDungeon[Main.tile[num8, num9].wall])
					{
						Main.tile[num8, num9].wallColor(25);
						if (Main.tile[num8, num9].type == 19 && Main.tile[num8, num9].frameY != 180)
						{
							Main.tile[num8, num9].color(color);
						}
					}
					if (Main.tile[num8, num9].active())
					{
						bool flag2 = false;
						if (Main.tenthAnniversaryWorld)
						{
							if (!SecretSeed.noSurface.Enabled && Main.tile[num8, num9].type == 191)
							{
								flag2 = true;
							}
							if (Main.tile[num8, num9].active() && Main.tile[num8, num9].type == 151)
							{
								Main.tile[num8, num9].color(color);
							}
						}
						if (Main.tile[num8, num9].type == 226)
						{
							flag2 = true;
						}
						if (Main.tile[num8, num9].type == 61 && Main.tile[num8, num9 + 1].type == 226)
						{
							flag2 = true;
						}
						if (Main.tile[num8, num9].type == 137)
						{
							int num10 = Main.tile[num8, num9].frameY / 18;
							if (num10 >= 1 && num10 <= 4)
							{
								flag2 = true;
							}
						}
						if (flag2)
						{
							Main.tile[num8, num9].color(color2);
						}
					}
					if (!SecretSeed.noSurface.Enabled && Main.tile[num8, num9].wall == 244)
					{
						Main.tile[num8, num9].wallColor(25);
					}
					if (Main.tile[num8, num9].wall == 34)
					{
						Main.tile[num8, num9].wallColor(25);
					}
					if (Main.tile[num8, num9].wall == 87)
					{
						Main.tile[num8, num9].wallColor(25);
						Main.tile[num8, num9].color(color2);
					}
				}
			}
		}
		double num11 = (double)Main.maxTilesX / 4200.0;
		num11 *= (double)genRand.Next(2, 5);
		for (int num12 = 0; (double)num12 < num11; num12++)
		{
			int num13 = genRand.Next((int)((double)Main.maxTilesX * 0.39), (int)((double)Main.maxTilesX * 0.61));
			int num14 = genRand.Next(10, 31);
			for (int num15 = num13 - num14; num15 <= num13 + num14; num15++)
			{
				for (int num16 = Main.maxTilesY - 250; num16 < Main.maxTilesY - 25; num16++)
				{
					if (Main.tile[num15, num16].type == 637)
					{
						Main.tile[num15, num16].frameX = (short)(18 * Main.rand.Next(6, 11));
					}
				}
			}
		}
		if (notTheBees)
		{
			for (int num17 = 3; num17 < Main.maxTilesX - 3; num17++)
			{
				bool flag3 = true;
				for (int num18 = 0; (double)num18 < Main.worldSurface; num18++)
				{
					if (flag3)
					{
						if (Main.tile[num17, num18].wall == 86)
						{
							Main.tile[num17, num18].wall = 0;
						}
						if (Main.tile[num17, num18].active())
						{
							flag3 = false;
						}
					}
					else if (Main.tile[num17, num18].wall == 0 && Main.tile[num17, num18 + 1].wall == 0 && Main.tile[num17, num18 + 2].wall == 0 && Main.tile[num17, num18 + 3].wall == 0 && Main.tile[num17, num18 + 4].wall == 0 && Main.tile[num17 - 1, num18].wall == 0 && Main.tile[num17 + 1, num18].wall == 0 && Main.tile[num17 - 2, num18].wall == 0 && Main.tile[num17 + 2, num18].wall == 0 && !Main.tile[num17, num18].active() && !Main.tile[num17, num18 + 1].active() && !Main.tile[num17, num18 + 2].active() && !Main.tile[num17, num18 + 3].active())
					{
						flag3 = true;
					}
				}
			}
		}
		Liquid.QuickWater(-2);
		for (int num19 = 0; num19 < Main.maxTilesX; num19++)
		{
			for (int num20 = 0; num20 < Main.maxTilesY; num20++)
			{
				if (Main.tile[num19, num20].type == 518)
				{
					CheckLilyPad(num19, num20);
				}
			}
		}
	}

	public static bool isThisInTheRockLayer(int y)
	{
		if (Main.remixWorld)
		{
			if ((double)y > Main.worldSurface && (double)y <= Main.rockLayer)
			{
				return true;
			}
		}
		else if ((double)y > Main.rockLayer)
		{
			return true;
		}
		return false;
	}

	public static bool IsItATrap(Tile tile)
	{
		if (!tile.active())
		{
			return false;
		}
		if (tile.actuator())
		{
			return true;
		}
		if (TileID.Sets.Wiring.IsAMechanism[tile.type])
		{
			return !TileID.Sets.Wiring.IgnoreWhenValidatingTraps[tile.type];
		}
		return false;
	}

	public static bool IsItATrigger(Tile tile)
	{
		if (tile.active())
		{
			if (TileID.Sets.Wiring.IsATrigger[tile.type])
			{
				return true;
			}
			if (tile.type == 467 && tile.frameX / 36 == 4)
			{
				return true;
			}
			if (tile.type == 314 && Minecart.IsPressurePlate(tile))
			{
				return true;
			}
		}
		return false;
	}

	public static void ClearAllBrokenTraps()
	{
		List<Point> list = new List<Point>();
		for (int i = 50; i < Main.maxTilesX - 50; i++)
		{
			for (int j = 50; j < Main.maxTilesY - 50; j++)
			{
				if (Main.tile[i, j].wire() && !list.Contains(new Point(i, j)))
				{
					ClearBrokenTraps(new Point(i, j), list);
				}
			}
		}
	}

	public static void ClearBrokenTraps(Point startTileCoords, List<Point> pointsWeAlreadyWentOver)
	{
		List<Point> t = new List<Point>();
		List<Point> t2 = new List<Point>();
		List<Point> list = new List<Point>();
		bool flag = false;
		bool flag2 = false;
		t2.Add(startTileCoords);
		int num = 2000;
		while (t2.Count > 0)
		{
			num--;
			if (num <= 0)
			{
				break;
			}
			Utils.Swap(ref t, ref t2);
			int num2 = 2000;
			while (t.Count > 0)
			{
				num2--;
				if (num2 <= 0)
				{
					break;
				}
				Point item = t[0];
				t.RemoveAt(0);
				if (!InWorld(item.X, item.Y, 5))
				{
					continue;
				}
				Tile tile = Main.tile[item.X, item.Y];
				if (tile.wire())
				{
					pointsWeAlreadyWentOver.Add(item);
					list.Add(item);
					if (IsItATrap(tile))
					{
						flag = true;
					}
					if (IsItATrigger(tile))
					{
						flag2 = true;
					}
					if (flag2 && flag)
					{
						break;
					}
					Point item2 = new Point(item.X - 1, item.Y);
					if (!list.Contains(item2))
					{
						t2.Add(item2);
					}
					item2 = new Point(item.X + 1, item.Y);
					if (!list.Contains(item2))
					{
						t2.Add(item2);
					}
					item2 = new Point(item.X, item.Y - 1);
					if (!list.Contains(item2))
					{
						t2.Add(item2);
					}
					item2 = new Point(item.X, item.Y + 1);
					if (!list.Contains(item2))
					{
						t2.Add(item2);
					}
				}
			}
			if (flag2 && flag)
			{
				break;
			}
		}
		if (flag2 && flag)
		{
			return;
		}
		foreach (Point item3 in list)
		{
			Tile tile2 = Main.tile[item3.X, item3.Y];
			tile2.wire(wire: false);
			if (tile2.actuator())
			{
				tile2.actuator(actuator: false);
				Tile tile3 = Main.tile[item3.X, item3.Y - 1];
				if (TileID.Sets.Boulders[tile3.type] && tile3.frameX % 16 == 0)
				{
					for (int i = 0; i < 2; i++)
					{
						for (int j = -2; j < 0; j++)
						{
							Tile tile4 = Main.tile[item3.X + i, item3.Y + j];
							if (tile4.active() && TileID.Sets.Boulders[tile4.type])
							{
								tile4.ResetToType(1);
							}
						}
					}
				}
			}
			if (IsItATrap(tile2) && tile2.type != 105)
			{
				KillTile(item3.X, item3.Y);
			}
			else if (IsItATrigger(tile2))
			{
				if (tile2.type == 314)
				{
					tile2.frameX = 1;
				}
				else
				{
					KillTile(item3.X, item3.Y);
				}
			}
		}
	}

	private static double TuneOceanDepth(int count, double depth, bool floridaStyle = false)
	{
		if (!floridaStyle)
		{
			if (count < 3)
			{
				depth += (double)genRand.Next(10, 20) * 0.2;
			}
			else if (count < 6)
			{
				depth += (double)genRand.Next(10, 20) * 0.15;
			}
			else if (count < 9)
			{
				depth += (double)genRand.Next(10, 20) * 0.1;
			}
			else if (count < 15)
			{
				depth += (double)genRand.Next(10, 20) * 0.07;
			}
			else if (count < 50)
			{
				depth += (double)genRand.Next(10, 20) * 0.05;
			}
			else if (count < 75)
			{
				depth += (double)genRand.Next(10, 20) * 0.04;
			}
			else if (count < 100)
			{
				depth += (double)genRand.Next(10, 20) * 0.03;
			}
			else if (count < 125)
			{
				depth += (double)genRand.Next(10, 20) * 0.02;
			}
			else if (count < 150)
			{
				depth += (double)genRand.Next(10, 20) * 0.01;
			}
			else if (count < 175)
			{
				depth += (double)genRand.Next(10, 20) * 0.005;
			}
			else if (count < 200)
			{
				depth += (double)genRand.Next(10, 20) * 0.001;
			}
			else if (count < 230)
			{
				depth += (double)genRand.Next(10, 20) * 0.01;
			}
			else if (count < 235)
			{
				depth += (double)genRand.Next(10, 20) * 0.05;
			}
			else if (count < 240)
			{
				depth += (double)genRand.Next(10, 20) * 0.1;
			}
			else if (count < 245)
			{
				depth += (double)genRand.Next(10, 20) * 0.05;
			}
			else if (count < 255)
			{
				depth += (double)genRand.Next(10, 20) * 0.01;
			}
		}
		else if (count < 3)
		{
			depth += (double)genRand.Next(10, 20) * 0.001;
		}
		else if (count < 6)
		{
			depth += (double)genRand.Next(10, 20) * 0.002;
		}
		else if (count < 9)
		{
			depth += (double)genRand.Next(10, 20) * 0.004;
		}
		else if (count < 15)
		{
			depth += (double)genRand.Next(10, 20) * 0.007;
		}
		else if (count < 50)
		{
			depth += (double)genRand.Next(10, 20) * 0.01;
		}
		else if (count < 75)
		{
			depth += (double)genRand.Next(10, 20) * 0.014;
		}
		else if (count < 100)
		{
			depth += (double)genRand.Next(10, 20) * 0.019;
		}
		else if (count < 125)
		{
			depth += (double)genRand.Next(10, 20) * 0.027;
		}
		else if (count < 150)
		{
			depth += (double)genRand.Next(10, 20) * 0.038;
		}
		else if (count < 175)
		{
			depth += (double)genRand.Next(10, 20) * 0.052;
		}
		else if (count < 200)
		{
			depth += (double)genRand.Next(10, 20) * 0.08;
		}
		else if (count < 230)
		{
			depth += (double)genRand.Next(10, 20) * 0.12;
		}
		else if (count < 235)
		{
			depth += (double)genRand.Next(10, 20) * 0.16;
		}
		else if (count < 240)
		{
			depth += (double)genRand.Next(10, 20) * 0.27;
		}
		else if (count < 245)
		{
			depth += (double)genRand.Next(10, 20) * 0.43;
		}
		else if (count < 255)
		{
			depth += (double)genRand.Next(10, 20) * 0.6;
		}
		return depth;
	}

	public static Point RandomRectanglePoint(Rectangle rectangle)
	{
		return new Point(genRand.Next(rectangle.X, rectangle.X + rectangle.Width), genRand.Next(rectangle.Y, rectangle.Y + rectangle.Height));
	}

	public static Point RandomRectanglePoint(int x, int y, int width, int height)
	{
		return new Point(genRand.Next(x, x + width), genRand.Next(y, y + height));
	}

	public static Point RandomWorldPoint(int padding)
	{
		return RandomWorldPoint(padding, padding, padding, padding);
	}

	public static Point RandomWorldPoint(int top = 0, int right = 0, int bottom = 0, int left = 0)
	{
		return new Point(genRand.Next(left, Main.maxTilesX - right), genRand.Next(top, Main.maxTilesY - bottom));
	}

	public static bool GrowPalmTree(int i, int y, int treeHeightAddon = 0, bool ignoreWalls = false)
	{
		int num = y;
		if (!InWorld(i, y))
		{
			return false;
		}
		while (Main.tile[i, num].active() && Main.tile[i, num].type == 20)
		{
			num++;
			if (Main.tile[i, num] == null)
			{
				return false;
			}
		}
		Tile tile = Main.tile[i, num];
		Tile tile2 = Main.tile[i, num - 1];
		TileColorCache cache = Main.tile[i, num].BlockColorAndCoating();
		if (Main.tenthAnniversaryWorld && !isGeneratingOrLoadingWorld)
		{
			cache.Color = (byte)genRand.Next(1, 13);
		}
		tile.slope();
		tile.halfBrick();
		if (!tile.active() || tile.halfBrick() || tile.slope() != 0)
		{
			return false;
		}
		bool flag = ignoreWalls || DefaultTreeWallTest(Main.tile[i, num - 1].wall);
		if (!flag || tile2.liquid != 0)
		{
			return false;
		}
		if (tile.type != 53 && tile.type != 234 && tile.type != 116 && tile.type != 112)
		{
			return false;
		}
		int num2 = 20 + treeHeightAddon;
		if (!EmptyTileCheck(i, i, num - 2, num - 1, 20))
		{
			return false;
		}
		if (!EmptyTileCheck(i - 1, i + 1, num - num2, num - 3, 20))
		{
			return false;
		}
		int num3 = genRand.Next(10, 21) + treeHeightAddon;
		int num4 = genRand.Next(-8, 9);
		num4 *= 2;
		short num5 = 0;
		for (int j = 0; j < num3; j++)
		{
			tile = Main.tile[i, num - 1 - j];
			if (j == 0)
			{
				tile.active(active: true);
				tile.type = 323;
				tile.frameX = 66;
				tile.frameY = 0;
				tile.UseBlockColors(cache);
				continue;
			}
			if (j == num3 - 1)
			{
				tile.active(active: true);
				tile.type = 323;
				tile.frameX = (short)(22 * genRand.Next(4, 7));
				tile.frameY = num5;
				tile.UseBlockColors(cache);
				continue;
			}
			if (num5 != num4)
			{
				double num6 = (double)j / (double)num3;
				bool flag2 = false;
				if (!(num6 < 0.25) && ((num6 < 0.5 && genRand.Next(13) == 0) || (num6 < 0.7 && genRand.Next(9) == 0) || !(num6 < 0.95) || genRand.Next(5) != 0 || true))
				{
					short num7 = (short)Math.Sign(num4);
					num5 += (short)(num7 * 2);
				}
			}
			tile.active(active: true);
			tile.type = 323;
			tile.frameX = (short)(22 * genRand.Next(0, 3));
			tile.frameY = num5;
			tile.UseBlockColors(cache);
		}
		RangeFrame(i - 2, num - num3 - 1, i + 2, num + 1);
		NetMessage.SendTileSquare(-1, i, num - num3, 1, num3);
		return true;
	}

	public static bool IsPalmOasisTree(int x)
	{
		if (x >= beachDistance)
		{
			return x <= Main.maxTilesX - beachDistance;
		}
		return false;
	}

	public static bool GrowEpicTree(int i, int y)
	{
		int j;
		for (j = y; Main.tile[i, j].active() && Main.tile[i, j].type == 20; j++)
		{
		}
		if (Main.tile[i, j].active() && !Main.tile[i, j].halfBrick() && Main.tile[i, j].slope() == 0 && Main.tile[i, j].type == 2 && Main.tile[i, j - 1].wall == 0 && Main.tile[i, j - 1].liquid == 0 && ((Main.tile[i - 1, j].active() && (Main.tile[i - 1, j].type == 2 || Main.tile[i - 1, j].type == 23 || Main.tile[i - 1, j].type == 60 || Main.tile[i - 1, j].type == 109)) || (Main.tile[i + 1, j].active() && (Main.tile[i + 1, j].type == 2 || Main.tile[i + 1, j].type == 23 || Main.tile[i + 1, j].type == 60 || Main.tile[i + 1, j].type == 109))))
		{
			int num = 2;
			if (EmptyTileCheck(i - num, i + num, j - 55, j - 1, 20))
			{
				bool flag = false;
				bool flag2 = false;
				int num2 = genRand.Next(20, 30);
				if (drunkWorldGen)
				{
					num2 = genRand.Next(3, 7);
				}
				int num3;
				for (int k = j - num2; k < j; k++)
				{
					Main.tile[i, k].active(active: true);
					Main.tile[i, k].type = 5;
					num3 = genRand.Next(3);
					int num4 = genRand.Next(10);
					if (k == j - 1 || k == j - num2)
					{
						num4 = 0;
					}
					while (((num4 == 5 || num4 == 7) && flag) || ((num4 == 6 || num4 == 7) && flag2))
					{
						num4 = genRand.Next(10);
					}
					flag = false;
					flag2 = false;
					if (num4 == 5 || num4 == 7)
					{
						flag = true;
					}
					if (num4 == 6 || num4 == 7)
					{
						flag2 = true;
					}
					switch (num4)
					{
					case 1:
						if (num3 == 0)
						{
							Main.tile[i, k].frameX = 0;
							Main.tile[i, k].frameY = 66;
						}
						if (num3 == 1)
						{
							Main.tile[i, k].frameX = 0;
							Main.tile[i, k].frameY = 88;
						}
						if (num3 == 2)
						{
							Main.tile[i, k].frameX = 0;
							Main.tile[i, k].frameY = 110;
						}
						break;
					case 2:
						if (num3 == 0)
						{
							Main.tile[i, k].frameX = 22;
							Main.tile[i, k].frameY = 0;
						}
						if (num3 == 1)
						{
							Main.tile[i, k].frameX = 22;
							Main.tile[i, k].frameY = 22;
						}
						if (num3 == 2)
						{
							Main.tile[i, k].frameX = 22;
							Main.tile[i, k].frameY = 44;
						}
						break;
					case 3:
						if (num3 == 0)
						{
							Main.tile[i, k].frameX = 44;
							Main.tile[i, k].frameY = 66;
						}
						if (num3 == 1)
						{
							Main.tile[i, k].frameX = 44;
							Main.tile[i, k].frameY = 88;
						}
						if (num3 == 2)
						{
							Main.tile[i, k].frameX = 44;
							Main.tile[i, k].frameY = 110;
						}
						break;
					case 4:
						if (num3 == 0)
						{
							Main.tile[i, k].frameX = 22;
							Main.tile[i, k].frameY = 66;
						}
						if (num3 == 1)
						{
							Main.tile[i, k].frameX = 22;
							Main.tile[i, k].frameY = 88;
						}
						if (num3 == 2)
						{
							Main.tile[i, k].frameX = 22;
							Main.tile[i, k].frameY = 110;
						}
						break;
					case 5:
						if (num3 == 0)
						{
							Main.tile[i, k].frameX = 88;
							Main.tile[i, k].frameY = 0;
						}
						if (num3 == 1)
						{
							Main.tile[i, k].frameX = 88;
							Main.tile[i, k].frameY = 22;
						}
						if (num3 == 2)
						{
							Main.tile[i, k].frameX = 88;
							Main.tile[i, k].frameY = 44;
						}
						break;
					case 6:
						if (num3 == 0)
						{
							Main.tile[i, k].frameX = 66;
							Main.tile[i, k].frameY = 66;
						}
						if (num3 == 1)
						{
							Main.tile[i, k].frameX = 66;
							Main.tile[i, k].frameY = 88;
						}
						if (num3 == 2)
						{
							Main.tile[i, k].frameX = 66;
							Main.tile[i, k].frameY = 110;
						}
						break;
					case 7:
						if (num3 == 0)
						{
							Main.tile[i, k].frameX = 110;
							Main.tile[i, k].frameY = 66;
						}
						if (num3 == 1)
						{
							Main.tile[i, k].frameX = 110;
							Main.tile[i, k].frameY = 88;
						}
						if (num3 == 2)
						{
							Main.tile[i, k].frameX = 110;
							Main.tile[i, k].frameY = 110;
						}
						break;
					default:
						if (num3 == 0)
						{
							Main.tile[i, k].frameX = 0;
							Main.tile[i, k].frameY = 0;
						}
						if (num3 == 1)
						{
							Main.tile[i, k].frameX = 0;
							Main.tile[i, k].frameY = 22;
						}
						if (num3 == 2)
						{
							Main.tile[i, k].frameX = 0;
							Main.tile[i, k].frameY = 44;
						}
						break;
					}
					if (num4 == 5 || num4 == 7)
					{
						Main.tile[i - 1, k].active(active: true);
						Main.tile[i - 1, k].type = 5;
						num3 = genRand.Next(3);
						if (genRand.Next(3) < 2)
						{
							if (num3 == 0)
							{
								Main.tile[i - 1, k].frameX = 44;
								Main.tile[i - 1, k].frameY = 198;
							}
							if (num3 == 1)
							{
								Main.tile[i - 1, k].frameX = 44;
								Main.tile[i - 1, k].frameY = 220;
							}
							if (num3 == 2)
							{
								Main.tile[i - 1, k].frameX = 44;
								Main.tile[i - 1, k].frameY = 242;
							}
						}
						else
						{
							if (num3 == 0)
							{
								Main.tile[i - 1, k].frameX = 66;
								Main.tile[i - 1, k].frameY = 0;
							}
							if (num3 == 1)
							{
								Main.tile[i - 1, k].frameX = 66;
								Main.tile[i - 1, k].frameY = 22;
							}
							if (num3 == 2)
							{
								Main.tile[i - 1, k].frameX = 66;
								Main.tile[i - 1, k].frameY = 44;
							}
						}
					}
					if (num4 != 6 && num4 != 7)
					{
						continue;
					}
					Main.tile[i + 1, k].active(active: true);
					Main.tile[i + 1, k].type = 5;
					num3 = genRand.Next(3);
					if (genRand.Next(3) < 2)
					{
						if (num3 == 0)
						{
							Main.tile[i + 1, k].frameX = 66;
							Main.tile[i + 1, k].frameY = 198;
						}
						if (num3 == 1)
						{
							Main.tile[i + 1, k].frameX = 66;
							Main.tile[i + 1, k].frameY = 220;
						}
						if (num3 == 2)
						{
							Main.tile[i + 1, k].frameX = 66;
							Main.tile[i + 1, k].frameY = 242;
						}
					}
					else
					{
						if (num3 == 0)
						{
							Main.tile[i + 1, k].frameX = 88;
							Main.tile[i + 1, k].frameY = 66;
						}
						if (num3 == 1)
						{
							Main.tile[i + 1, k].frameX = 88;
							Main.tile[i + 1, k].frameY = 88;
						}
						if (num3 == 2)
						{
							Main.tile[i + 1, k].frameX = 88;
							Main.tile[i + 1, k].frameY = 110;
						}
					}
				}
				int num5 = genRand.Next(3);
				bool flag3 = false;
				bool flag4 = false;
				if (Main.tile[i - 1, j].active() && !Main.tile[i - 1, j].halfBrick() && Main.tile[i - 1, j].slope() == 0 && (Main.tile[i - 1, j].type == 2 || Main.tile[i - 1, j].type == 23 || Main.tile[i - 1, j].type == 60 || Main.tile[i - 1, j].type == 109))
				{
					flag3 = true;
				}
				if (Main.tile[i + 1, j].active() && !Main.tile[i + 1, j].halfBrick() && Main.tile[i + 1, j].slope() == 0 && (Main.tile[i + 1, j].type == 2 || Main.tile[i + 1, j].type == 23 || Main.tile[i + 1, j].type == 60 || Main.tile[i + 1, j].type == 109))
				{
					flag4 = true;
				}
				if (!flag3)
				{
					if (num5 == 0)
					{
						num5 = 2;
					}
					if (num5 == 1)
					{
						num5 = 3;
					}
				}
				if (!flag4)
				{
					if (num5 == 0)
					{
						num5 = 1;
					}
					if (num5 == 2)
					{
						num5 = 3;
					}
				}
				if (flag3 && !flag4)
				{
					num5 = 2;
				}
				if (flag4 && !flag3)
				{
					num5 = 1;
				}
				if (num5 == 0 || num5 == 1)
				{
					Main.tile[i + 1, j - 1].active(active: true);
					Main.tile[i + 1, j - 1].type = 5;
					num3 = genRand.Next(3);
					if (num3 == 0)
					{
						Main.tile[i + 1, j - 1].frameX = 22;
						Main.tile[i + 1, j - 1].frameY = 132;
					}
					if (num3 == 1)
					{
						Main.tile[i + 1, j - 1].frameX = 22;
						Main.tile[i + 1, j - 1].frameY = 154;
					}
					if (num3 == 2)
					{
						Main.tile[i + 1, j - 1].frameX = 22;
						Main.tile[i + 1, j - 1].frameY = 176;
					}
				}
				if (num5 == 0 || num5 == 2)
				{
					Main.tile[i - 1, j - 1].active(active: true);
					Main.tile[i - 1, j - 1].type = 5;
					num3 = genRand.Next(3);
					if (num3 == 0)
					{
						Main.tile[i - 1, j - 1].frameX = 44;
						Main.tile[i - 1, j - 1].frameY = 132;
					}
					if (num3 == 1)
					{
						Main.tile[i - 1, j - 1].frameX = 44;
						Main.tile[i - 1, j - 1].frameY = 154;
					}
					if (num3 == 2)
					{
						Main.tile[i - 1, j - 1].frameX = 44;
						Main.tile[i - 1, j - 1].frameY = 176;
					}
				}
				num3 = genRand.Next(3);
				switch (num5)
				{
				case 0:
					if (num3 == 0)
					{
						Main.tile[i, j - 1].frameX = 88;
						Main.tile[i, j - 1].frameY = 132;
					}
					if (num3 == 1)
					{
						Main.tile[i, j - 1].frameX = 88;
						Main.tile[i, j - 1].frameY = 154;
					}
					if (num3 == 2)
					{
						Main.tile[i, j - 1].frameX = 88;
						Main.tile[i, j - 1].frameY = 176;
					}
					break;
				case 1:
					if (num3 == 0)
					{
						Main.tile[i, j - 1].frameX = 0;
						Main.tile[i, j - 1].frameY = 132;
					}
					if (num3 == 1)
					{
						Main.tile[i, j - 1].frameX = 0;
						Main.tile[i, j - 1].frameY = 154;
					}
					if (num3 == 2)
					{
						Main.tile[i, j - 1].frameX = 0;
						Main.tile[i, j - 1].frameY = 176;
					}
					break;
				case 2:
					if (num3 == 0)
					{
						Main.tile[i, j - 1].frameX = 66;
						Main.tile[i, j - 1].frameY = 132;
					}
					if (num3 == 1)
					{
						Main.tile[i, j - 1].frameX = 66;
						Main.tile[i, j - 1].frameY = 154;
					}
					if (num3 == 2)
					{
						Main.tile[i, j - 1].frameX = 66;
						Main.tile[i, j - 1].frameY = 176;
					}
					break;
				}
				if (genRand.Next(13) != 0)
				{
					num3 = genRand.Next(3);
					if (num3 == 0)
					{
						Main.tile[i, j - num2].frameX = 22;
						Main.tile[i, j - num2].frameY = 198;
					}
					if (num3 == 1)
					{
						Main.tile[i, j - num2].frameX = 22;
						Main.tile[i, j - num2].frameY = 220;
					}
					if (num3 == 2)
					{
						Main.tile[i, j - num2].frameX = 22;
						Main.tile[i, j - num2].frameY = 242;
					}
				}
				else
				{
					num3 = genRand.Next(3);
					if (num3 == 0)
					{
						Main.tile[i, j - num2].frameX = 0;
						Main.tile[i, j - num2].frameY = 198;
					}
					if (num3 == 1)
					{
						Main.tile[i, j - num2].frameX = 0;
						Main.tile[i, j - num2].frameY = 220;
					}
					if (num3 == 2)
					{
						Main.tile[i, j - num2].frameX = 0;
						Main.tile[i, j - num2].frameY = 242;
					}
				}
				RangeFrame(i - 2, j - num2 - 1, i + 2, j + 1);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, (int)((double)j - (double)num2 * 0.5), num2 + 1);
				}
				return true;
			}
		}
		return false;
	}

	public static bool Pyramid(int i, int j, int pyramidMinDepth = 75, int pyramidMaxDepth = 125, bool noTunnel = false)
	{
		ushort num = 151;
		ushort wall = 34;
		if (Main.tile[i, j].active() && (Main.tile[i, j].type == 151 || Main.tile[i, j].wall == 151))
		{
			return false;
		}
		if (SecretSeed.dualDungeons.Enabled && DungeonUtils.InAnyPotentialDungeonBounds(i, j + pyramidMaxDepth, 5))
		{
			return false;
		}
		if (SecretSeed.surfaceIsDesert.Enabled || SecretSeed.errorWorld.Enabled || SecretSeed.dualDungeons.Enabled)
		{
			if (SecretSeed.surfaceIsDesert.Enabled || SecretSeed.errorWorld.Enabled)
			{
				if (IsTileNearby(i, j, 151, 100))
				{
					return false;
				}
				if (IsTileNearby(i, j, 203, 100))
				{
					return false;
				}
				if (IsTileNearby(i, j, 25, 100))
				{
					return false;
				}
			}
			if (IsTileNearby(i, j, 41, 100))
			{
				return false;
			}
			if (IsTileNearby(i, j, 43, 100))
			{
				return false;
			}
			if (IsTileNearby(i, j, 44, 100))
			{
				return false;
			}
		}
		int num2 = j - genRand.Next(0, 7);
		int num3 = genRand.Next(9, 13);
		int num4 = 1;
		int num5 = j + genRand.Next(pyramidMinDepth, pyramidMaxDepth);
		for (int k = num2; k < num5; k++)
		{
			for (int l = i - num4; l < i + num4 - 1; l++)
			{
				Main.tile[l, k].type = num;
				Main.tile[l, k].active(active: true);
				Main.tile[l, k].halfBrick(halfBrick: false);
				Main.tile[l, k].slope(0);
			}
			num4++;
		}
		for (int m = i - num4 - 5; m <= i + num4 + 5; m++)
		{
			for (int n = j - 1; n <= num5 + 1; n++)
			{
				bool flag = true;
				for (int num6 = m - 1; num6 <= m + 1; num6++)
				{
					for (int num7 = n - 1; num7 <= n + 1; num7++)
					{
						if (!Main.tile[num6, num7].active() || Main.tile[num6, num7].type != num)
						{
							flag = false;
						}
					}
				}
				if (flag)
				{
					Main.tile[m, n].wall = 34;
					SquareWallFrame(m, n);
				}
			}
		}
		int num8 = 1;
		if (genRand.Next(2) == 0)
		{
			num8 = -1;
		}
		int num9 = i - num3 * num8;
		int num10 = j + num3;
		int num11 = genRand.Next(5, 8);
		bool flag2 = true;
		int num12 = genRand.Next(20, 30);
		while (flag2)
		{
			flag2 = false;
			bool flag3 = false;
			for (int num13 = num10; num13 <= num10 + num11; num13++)
			{
				int num14 = num9;
				if (Main.tile[num14, num13 - 1].active() && Main.tile[num14, num13 - 1].type == 53)
				{
					flag3 = true;
				}
				if (Main.tile[num14, num13].active() && Main.tile[num14, num13].type == num)
				{
					Main.tile[num14, num13 + 1].wall = wall;
					Main.tile[num14 + num8, num13].wall = wall;
					Main.tile[num14, num13].active(active: false);
					flag2 = true;
				}
				if (flag3)
				{
					Main.tile[num14, num13].type = 53;
					Main.tile[num14, num13].active(active: true);
					Main.tile[num14, num13].halfBrick(halfBrick: false);
					Main.tile[num14, num13].slope(0);
				}
			}
			num9 -= num8;
		}
		num9 = i - num3 * num8;
		bool flag4 = true;
		bool flag5 = false;
		flag2 = true;
		while (flag2)
		{
			for (int num15 = num10; num15 <= num10 + num11; num15++)
			{
				int num16 = num9;
				Main.tile[num16, num15].active(active: false);
			}
			num9 += num8;
			num10++;
			num12--;
			if (num10 >= num5 - num11 * 2)
			{
				num12 = 10;
			}
			if (num12 <= 0)
			{
				bool flag6 = false;
				if (!flag4 && !flag5)
				{
					if (noTunnel)
					{
						flag2 = false;
					}
					flag5 = true;
					flag6 = true;
					int num17 = genRand.Next(7, 13);
					int num18 = genRand.Next(23, 28);
					int num19 = num18;
					int num20 = num9;
					while (num18 > 0)
					{
						for (int num21 = num10 - num17 + num11; num21 <= num10 + num11; num21++)
						{
							if (num18 == num19 || num18 == 1)
							{
								if (num21 >= num10 - num17 + num11 + 2)
								{
									Main.tile[num9, num21].active(active: false);
								}
							}
							else if (num18 == num19 - 1 || num18 == 2 || num18 == num19 - 2 || num18 == 3)
							{
								if (num21 >= num10 - num17 + num11 + 1)
								{
									Main.tile[num9, num21].active(active: false);
								}
							}
							else
							{
								Main.tile[num9, num21].active(active: false);
							}
						}
						num18--;
						num9 += num8;
					}
					int num22 = num9 - num8;
					int num23 = num22;
					int num24 = num20;
					if (num22 > num20)
					{
						num23 = num20;
						num24 = num22;
					}
					int num25 = genRand.Next(3);
					if (num25 == 0)
					{
						num25 = genRand.Next(3);
					}
					if (Main.tenthAnniversaryWorld && num25 == 0)
					{
						num25 = 1;
					}
					switch (num25)
					{
					case 0:
						num25 = 848;
						break;
					case 1:
						num25 = 857;
						break;
					case 2:
						num25 = 934;
						break;
					}
					AddBuriedChest((num23 + num24) / 2, num10, num25, notNearOtherChests: false, 1, trySlope: false, 0);
					int num26 = genRand.Next(1, 10);
					for (int num27 = 0; num27 < num26; num27++)
					{
						int i2 = genRand.Next(num23, num24);
						int j2 = num10 + num11;
						PlaceSmallPile(i2, j2, genRand.Next(16, 19), 1, 185);
					}
					PlaceTile(num23 + 2, num10 - num17 + num11 + 1, 91, mute: true, forced: false, -1, genRand.Next(4, 7));
					PlaceTile(num23 + 3, num10 - num17 + num11, 91, mute: true, forced: false, -1, genRand.Next(4, 7));
					PlaceTile(num24 - 2, num10 - num17 + num11 + 1, 91, mute: true, forced: false, -1, genRand.Next(4, 7));
					PlaceTile(num24 - 3, num10 - num17 + num11, 91, mute: true, forced: false, -1, genRand.Next(4, 7));
					for (int num28 = num23; num28 <= num24; num28++)
					{
						PlacePot(num28, num10 + num11, 28, genRand.Next(25, 28));
					}
				}
				if (flag4)
				{
					flag4 = false;
					num8 *= -1;
					num12 = genRand.Next(15, 20);
				}
				else if (flag6)
				{
					num12 = genRand.Next(10, 15);
				}
				else
				{
					num8 *= -1;
					num12 = genRand.Next(20, 40);
				}
			}
			if (num10 >= num5 - num11)
			{
				flag2 = false;
			}
		}
		if (noTunnel)
		{
			return true;
		}
		int num29 = genRand.Next(100, 200);
		int num30 = genRand.Next(500, 800);
		flag2 = true;
		int num31 = num11;
		num12 = genRand.Next(10, 50);
		if (num8 == 1)
		{
			num9 -= num31;
		}
		int num32 = genRand.Next(5, 10);
		while (flag2)
		{
			num29--;
			num30--;
			num12--;
			for (int num33 = num9 - num32 - genRand.Next(0, 2); num33 <= num9 + num31 + num32 + genRand.Next(0, 2); num33++)
			{
				int num34 = num10;
				if (num33 >= num9 && num33 <= num9 + num31)
				{
					Main.tile[num33, num34].active(active: false);
				}
				else if (!Main.wallDungeon[Main.tile[num33, num34].wall])
				{
					Main.tile[num33, num34].type = num;
					Main.tile[num33, num34].active(active: true);
					Main.tile[num33, num34].halfBrick(halfBrick: false);
					Main.tile[num33, num34].slope(0);
				}
				if (num33 >= num9 - 1 && num33 <= num9 + 1 + num31 && !Main.wallDungeon[Main.tile[num33, num34].wall])
				{
					Main.tile[num33, num34].wall = wall;
				}
			}
			num10++;
			num9 += num8;
			if (num29 <= 0)
			{
				flag2 = false;
				for (int num35 = num9 + 1; num35 <= num9 + num31 - 1; num35++)
				{
					if (Main.tile[num35, num10].active())
					{
						flag2 = true;
					}
				}
			}
			if (num12 < 0)
			{
				num12 = genRand.Next(10, 50);
				num8 *= -1;
			}
			if (num30 <= 0)
			{
				flag2 = false;
			}
		}
		return true;
	}

	public static bool GrowLivingTree(int i, int j, bool patch = false)
	{
		int num = 0;
		int[] array = new int[1000];
		int[] array2 = new int[1000];
		int[] array3 = new int[1000];
		int[] array4 = new int[1000];
		int num2 = 0;
		int[] array5 = new int[2000];
		int[] array6 = new int[2000];
		bool[] array7 = new bool[2000];
		if (skyblockWorldGen)
		{
			while (!Main.tile[i, j].active() && j < Main.maxTilesY - 1)
			{
				j++;
			}
			if (j > Main.maxTilesY - 30)
			{
				return false;
			}
			while (Main.tile[i, j].active() && j > 0)
			{
				j--;
			}
		}
		else
		{
			if (!SolidTile(i, j + 1))
			{
				return false;
			}
			if (Main.tile[i, j].active())
			{
				return false;
			}
		}
		if (!SecretSeed.errorWorld.Enabled && !skyblockWorldGen && Main.tile[i, j + 1].type != 0 && Main.tile[i, j + 1].type != 2 && Main.tile[i, j + 1].type != 1 && Main.tile[i, j + 1].type != 40 && !TileID.Sets.Ore[Main.tile[i, j + 1].type] && (!notTheBees || (Main.tile[i, j + 1].type != 60 && Main.tile[i, j + 1].type != 59)))
		{
			if (!notTheBees || !tenthAnniversaryWorldGen || drunkWorldGen)
			{
				return false;
			}
			if (Main.tile[i, j + 1].type == 191 || Main.tile[i, j + 1].type == 192 || Main.tile[i, j + 1].type == 383 || Main.tile[i, j + 1].type == 384)
			{
				return false;
			}
		}
		if (j < 150 && !skyblockWorldGen)
		{
			return false;
		}
		int num3 = i - genRand.Next(2, 3);
		int num4 = i + genRand.Next(2, 3);
		if (skyblockWorldGen)
		{
			num3--;
			num4++;
		}
		else if (SecretSeed.extraLivingTrees.Enabled)
		{
			num3 -= genRand.Next(0, 3);
			num4 += genRand.Next(0, 3);
		}
		else if (notTheBees && !drunkWorldGen)
		{
			num3 -= genRand.Next(0, 2);
			num4 += genRand.Next(0, 2);
		}
		if (genRand.Next(5) == 0)
		{
			if (genRand.Next(2) == 0)
			{
				num3--;
			}
			else
			{
				num4++;
			}
		}
		int num5 = num4 - num3;
		bool flag = num5 >= 4;
		int num6 = i - 50;
		int num7 = i + 50;
		if (patch)
		{
			num6 = i - 20;
			num7 = i + 20;
			num3 = i - genRand.Next(1, 3);
			num4 = i + genRand.Next(1, 3);
			if (notTheBees && !drunkWorldGen)
			{
				num3 -= genRand.Next(0, 2);
				num4 += genRand.Next(0, 2);
			}
			flag = num5 >= 4;
		}
		if (skyblockWorldGen)
		{
			flag = false;
		}
		if (!skyblockWorldGen)
		{
			int num8 = 5;
			if (SecretSeed.extraLivingTrees.Enabled || SecretSeed.extraFloatingIslands.Enabled)
			{
				num8 = FindLowestCloud() + 1;
			}
			if (!SecretSeed.noSurface.Enabled)
			{
				for (int k = num6; k <= num7; k++)
				{
					for (int l = num8; l < j - 5; l++)
					{
						if (Main.tile[k, l].active())
						{
							if (!patch)
							{
								return false;
							}
							int type = Main.tile[k, l].type;
							if (type != 2 && type != 0 && type != 1 && type != 191 && type != 192 && type != 383 && type != 384)
							{
								return false;
							}
						}
					}
				}
			}
		}
		Main.tileSolid[48] = false;
		int num9 = num3;
		int num10 = num4;
		int minl = num3;
		int minr = num4;
		int num11 = j;
		bool flag2 = true;
		int num12 = genRand.Next(-8, -4);
		int num13 = genRand.Next(2);
		int num14 = genRand.Next(5, 15);
		int maxValue = 2;
		bool flag3 = false;
		if (!skyblockWorldGen && SecretSeed.extraLivingTrees.Enabled && num4 - num3 >= 7)
		{
			flag3 = true;
			maxValue = 7;
		}
		while (flag2 && (skyblockWorldGen || !SecretSeed.extraLivingTrees.Enabled || !((double)num11 < Main.worldSurface) || !AreAnyTilesInSetNearby((num3 + num4) / 2, num11 - 35, TileID.Sets.Clouds, 10)))
		{
			if (flag3)
			{
				if (num11 < 130)
				{
					maxValue = 1;
				}
				else if (num11 < 180)
				{
					maxValue = 2;
				}
			}
			num12++;
			if (num12 > num14)
			{
				num14 = genRand.Next(5, 15);
				num12 = 0;
				array2[num] = num11 + genRand.Next(5);
				if (genRand.Next(5) == 0)
				{
					num13 = ((num13 == 0) ? 1 : 0);
				}
				if (num13 == 0)
				{
					array3[num] = -1;
					array[num] = num3;
					array4[num] = num4 - num3;
					if (genRand.Next(maxValue) == 0)
					{
						num3++;
						if (flag3)
						{
							num9++;
						}
						if (SecretSeed.extraLivingTrees.Enabled && !Main.wallDungeon[Main.tile[num3, num11 + 1].wall])
						{
							Main.tile[num3, num11 + 1].active(active: true);
							Main.tile[num3, num11 + 1].type = 191;
							Main.tile[num3, num11 + 1].wall = 0;
						}
					}
					if (!flag3)
					{
						num9++;
					}
					num13 = 1;
				}
				else
				{
					array3[num] = 1;
					array[num] = num4;
					array4[num] = num4 - num3;
					if (genRand.Next(maxValue) == 0)
					{
						num4--;
						if (flag3)
						{
							num10--;
						}
						if (SecretSeed.extraLivingTrees.Enabled && !Main.wallDungeon[Main.tile[num3, num11 + 1].wall])
						{
							Main.tile[num4, num11 + 1].active(active: true);
							Main.tile[num4, num11 + 1].type = 191;
							Main.tile[num4, num11 + 1].wall = 0;
						}
					}
					if (!flag3)
					{
						num10--;
					}
					num13 = 0;
				}
				if (num9 == num10)
				{
					flag2 = false;
				}
				num++;
			}
			for (int m = num3; m <= num4; m++)
			{
				if (!skyblockWorldGen && SecretSeed.extraLivingTrees.Enabled && num4 - num3 > 2)
				{
					if (m == num3 || m == num4)
					{
						if (!Main.wallDungeon[Main.tile[m, num11].wall])
						{
							Main.tile[m, num11].type = 191;
							Main.tile[m, num11].active(active: true);
							Main.tile[m, num11].halfBrick(halfBrick: false);
						}
					}
					else if (!Main.wallDungeon[Main.tile[m, num11].wall])
					{
						Main.tile[m, num11].wall = 244;
						Main.tile[m, num11].active(active: false);
						int n;
						for (n = 1; !Main.tile[(num3 + num4) / 2, num11 + n].active(); n++)
						{
						}
						if (n >= 6)
						{
							Main.tile[m, num11].active(active: false);
							PlaceTile(m, num11, 19, mute: true, forced: false, -1, 23);
						}
					}
				}
				else if (!Main.wallDungeon[Main.tile[m, num11].wall])
				{
					Main.tile[m, num11].type = 191;
					Main.tile[m, num11].active(active: true);
					Main.tile[m, num11].halfBrick(halfBrick: false);
				}
			}
			num11--;
		}
		for (int num15 = 0; num15 < num - 1; num15++)
		{
			int num16 = array[num15] + array3[num15];
			int num17 = array2[num15];
			int num18 = (int)((double)array4[num15] * (1.0 + (double)genRand.Next(20, 30) * 0.1));
			if (!Main.wallDungeon[Main.tile[num16, num17 + 1].wall])
			{
				Main.tile[num16, num17 + 1].type = 191;
				Main.tile[num16, num17 + 1].active(active: true);
				Main.tile[num16, num17 + 1].halfBrick(halfBrick: false);
			}
			int num19 = genRand.Next(3, 5);
			while (num18 > 0)
			{
				num18--;
				if (!Main.wallDungeon[Main.tile[num16, num17].wall])
				{
					Main.tile[num16, num17].type = 191;
					Main.tile[num16, num17].active(active: true);
					Main.tile[num16, num17].halfBrick(halfBrick: false);
				}
				if (genRand.Next(10) == 0)
				{
					num17 = ((genRand.Next(2) != 0) ? (num17 + 1) : (num17 - 1));
				}
				else
				{
					num16 += array3[num15];
				}
				if (num19 > 0)
				{
					num19--;
				}
				else if (genRand.Next(2) == 0)
				{
					num19 = genRand.Next(2, 5);
					if (!Main.wallDungeon[Main.tile[num16, num17].wall])
					{
						if (genRand.Next(2) == 0)
						{
							Main.tile[num16, num17].type = 191;
							Main.tile[num16, num17].active(active: true);
							Main.tile[num16, num17].halfBrick(halfBrick: false);
							Main.tile[num16, num17 - 1].type = 191;
							Main.tile[num16, num17 - 1].active(active: true);
							Main.tile[num16, num17 - 1].halfBrick(halfBrick: false);
							array5[num2] = num16;
							array6[num2] = num17;
							num2++;
						}
						else
						{
							Main.tile[num16, num17].type = 191;
							Main.tile[num16, num17].active(active: true);
							Main.tile[num16, num17].halfBrick(halfBrick: false);
							Main.tile[num16, num17 + 1].type = 191;
							Main.tile[num16, num17 + 1].active(active: true);
							Main.tile[num16, num17 + 1].halfBrick(halfBrick: false);
							array5[num2] = num16;
							array6[num2] = num17;
							num2++;
						}
					}
				}
				if (num18 == 0)
				{
					array5[num2] = num16;
					array6[num2] = num17;
					num2++;
				}
			}
		}
		int num20 = (num3 + num4) / 2;
		int num21 = num11;
		int num22 = genRand.Next(num5 * 3, num5 * 5);
		int num23 = 0;
		int num24 = 0;
		while (num22 > 0 && num21 >= 30)
		{
			if (!Main.wallDungeon[Main.tile[num20, num21].wall])
			{
				Main.tile[num20, num21].type = 191;
				Main.tile[num20, num21].active(active: true);
				Main.tile[num20, num21].halfBrick(halfBrick: false);
			}
			if (num23 > 0)
			{
				num23--;
			}
			if (num24 > 0)
			{
				num24--;
			}
			for (int num25 = -1; num25 < 2; num25++)
			{
				if (num25 == 0 || ((num25 >= 0 || num23 != 0) && (num25 <= 0 || num24 != 0)) || genRand.Next(2) != 0)
				{
					continue;
				}
				int num26 = num20;
				int num27 = num21;
				int num28 = genRand.Next(num5, num5 * 3);
				if (num25 < 0)
				{
					num23 = genRand.Next(3, 5);
				}
				if (num25 > 0)
				{
					num24 = genRand.Next(3, 5);
				}
				int num29 = 0;
				while (num28 > 0)
				{
					num28--;
					num26 += num25;
					if (!Main.wallDungeon[Main.tile[num26, num27].wall])
					{
						Main.tile[num26, num27].type = 191;
						Main.tile[num26, num27].active(active: true);
						Main.tile[num26, num27].halfBrick(halfBrick: false);
					}
					if (num28 == 0)
					{
						array5[num2] = num26;
						array6[num2] = num27;
						array7[num2] = true;
						num2++;
					}
					if (genRand.Next(5) == 0)
					{
						num27 = ((genRand.Next(2) != 0) ? (num27 + 1) : (num27 - 1));
						if (!Main.wallDungeon[Main.tile[num26, num27].wall])
						{
							Main.tile[num26, num27].type = 191;
							Main.tile[num26, num27].active(active: true);
							Main.tile[num26, num27].halfBrick(halfBrick: false);
						}
					}
					if (num29 > 0)
					{
						num29--;
					}
					else if (genRand.Next(3) == 0)
					{
						num29 = genRand.Next(2, 4);
						int num30 = num26;
						int num31 = num27;
						num31 = ((genRand.Next(2) != 0) ? (num31 + 1) : (num31 - 1));
						if (!Main.wallDungeon[Main.tile[num30, num31].wall])
						{
							Main.tile[num30, num31].type = 191;
							Main.tile[num30, num31].active(active: true);
							Main.tile[num30, num31].halfBrick(halfBrick: false);
						}
						array5[num2] = num30;
						array6[num2] = num31;
						array7[num2] = true;
						num2++;
						array5[num2] = num30 + genRand.Next(-5, 6);
						array6[num2] = num31 + genRand.Next(-5, 6);
						array7[num2] = true;
						num2++;
					}
				}
			}
			array5[num2] = num20;
			array6[num2] = num21;
			num2++;
			if (genRand.Next(4) == 0)
			{
				num20 = ((genRand.Next(2) != 0) ? (num20 + 1) : (num20 - 1));
				if (!Main.wallDungeon[Main.tile[num20, num21].wall])
				{
					Main.tile[num20, num21].type = 191;
					Main.tile[num20, num21].active(active: true);
					Main.tile[num20, num21].halfBrick(halfBrick: false);
				}
			}
			num21--;
			num22--;
		}
		for (int num32 = minl; num32 <= minr; num32++)
		{
			int num33 = genRand.Next(1, 6);
			int num34 = j + 1;
			while (num33 > 0)
			{
				if (SolidTile(num32, num34))
				{
					num33--;
				}
				Main.tile[num32, num34].type = 191;
				Main.tile[num32, num34].active(active: true);
				Main.tile[num32, num34].halfBrick(halfBrick: false);
				num34++;
			}
			int num35 = num34;
			int num36 = genRand.Next(2, num5 + 1);
			for (int num37 = 0; num37 < num36; num37++)
			{
				num34 = num35;
				int num38 = (minl + minr) / 2;
				int num39 = 0;
				int num40 = 1;
				num39 = ((num32 >= num38) ? 1 : (-1));
				if (num32 == num38 || (num5 > 6 && (num32 == num38 - 1 || num32 == num38 + 1)))
				{
					num39 = 0;
				}
				int num41 = num39;
				int num42 = num32;
				num33 = genRand.Next((int)((double)num5 * 3.5), num5 * 6);
				while (num33 > 0)
				{
					num33--;
					num42 += num39;
					if (Main.tile[num42, num34].wall != 244)
					{
						Main.tile[num42, num34].type = 191;
						Main.tile[num42, num34].active(active: true);
						Main.tile[num42, num34].halfBrick(halfBrick: false);
					}
					num34 += num40;
					if (Main.tile[num42, num34].wall != 244)
					{
						Main.tile[num42, num34].type = 191;
						Main.tile[num42, num34].active(active: true);
						Main.tile[num42, num34].halfBrick(halfBrick: false);
					}
					if (!Main.tile[num42, num34 + 1].active())
					{
						num39 = 0;
						num40 = 1;
					}
					if (genRand.Next(3) == 0)
					{
						num39 = ((num41 < 0) ? ((num39 == 0) ? (-1) : 0) : ((num41 <= 0) ? genRand.Next(-1, 2) : ((num39 == 0) ? 1 : 0)));
					}
					if (genRand.Next(3) == 0)
					{
						num40 = ((num40 == 0) ? 1 : 0);
					}
				}
			}
		}
		if (remixWorldGen)
		{
			num2 = 0;
		}
		for (int num43 = 0; num43 < num2; num43++)
		{
			int num44 = genRand.Next(5, 8);
			if (SecretSeed.errorWorld.Enabled)
			{
				num44 = genRand.Next(3, 12);
			}
			num44 = (int)((double)num44 * (1.0 + (double)num5 * 0.05));
			if (array7[num43])
			{
				num44 = genRand.Next(6, 12) + num5;
			}
			int num45 = array5[num43] - num44 * 2;
			int num46 = array5[num43] + num44 * 2;
			int num47 = array6[num43] - num44 * 2;
			int num48 = array6[num43] + num44 * 2;
			double num49 = 2.0 - (double)genRand.Next(5) * 0.1;
			for (int num50 = num45; num50 <= num46; num50++)
			{
				for (int num51 = num47; num51 <= num48; num51++)
				{
					if (!GrowLivingTree_CanPlaceLeaves(num50, num51))
					{
						continue;
					}
					if (array7[num43])
					{
						Vector2D vector2D = new Vector2D(array5[num43], array6[num43]) - new Vector2D(num50, num51);
						if (vector2D.Length() < (double)num44 * 0.9)
						{
							Main.tile[num50, num51].type = 192;
							Main.tile[num50, num51].active(active: true);
							Main.tile[num50, num51].halfBrick(halfBrick: false);
						}
						if (SecretSeed.extraLivingTrees.Enabled && vector2D.Length() < (double)num44 * 0.7)
						{
							Main.tile[num50, num51].wall = 60;
						}
					}
					else if ((double)Math.Abs(array5[num43] - num50) + (double)Math.Abs(array6[num43] - num51) * num49 < (double)num44)
					{
						Main.tile[num50, num51].type = 192;
						Main.tile[num50, num51].active(active: true);
						Main.tile[num50, num51].halfBrick(halfBrick: false);
					}
				}
				if (genRand.Next(30) == 0)
				{
					int num52 = num47;
					if (InWorld(num50, num52, 5) && !Main.tile[num50, num52].active())
					{
						for (; !Main.tile[num50, num52 + 1].active() && num52 < num48; num52++)
						{
						}
						if (Main.tile[num50, num52 + 1].type == 192)
						{
							PlaceTile(num50, num52, 187, mute: true, forced: false, -1, genRand.Next(50, 52));
						}
					}
				}
				if (array7[num43] || genRand.Next(15) != 0)
				{
					continue;
				}
				int num53 = num48;
				int num54 = num53 + 100;
				if (Main.tile[num50, num53].active())
				{
					continue;
				}
				for (; !Main.tile[num50, num53 + 1].active() && num53 < num54; num53++)
				{
				}
				if (Main.tile[num50, num53 + 1].type == 192)
				{
					continue;
				}
				if (genRand.Next(2) == 0)
				{
					PlaceTile(num50, num53, 187, mute: true, forced: false, -1, genRand.Next(47, 50));
					continue;
				}
				int num55 = genRand.Next(2);
				int pileStyle = 72;
				if (num55 == 1)
				{
					pileStyle = genRand.Next(59, 62);
				}
				PlaceSmallPile(num50, num53, pileStyle, num55, 185);
			}
		}
		if (flag)
		{
			bool flag4 = false;
			if (!skyblockWorldGen)
			{
				int num56 = j;
				int num57 = j + 20;
				if (!flag4)
				{
					for (int num58 = num56; num58 < num57 && !((double)num58 >= Main.worldSurface - 2.0); num58++)
					{
						for (int num59 = minl; num59 <= minr; num59++)
						{
							if (Main.tile[num59, num58].wall == 0 && !SolidTile(num59, num58))
							{
								flag4 = true;
								break;
							}
						}
					}
				}
			}
			if (!flag4)
			{
				GrowLivingTree_MakePassage(j, num5, ref minl, ref minr, patch);
			}
		}
		Main.tileSolid[48] = true;
		return true;
	}

	private static bool GrowLivingTree_CanPlaceLeaves(int i, int j)
	{
		if (!InWorld(i, j, 5))
		{
			return false;
		}
		Tile tile = Main.tile[i, j];
		if (tile.wall == 244 || tile.wall == 78 || Main.wallDungeon[tile.wall])
		{
			return false;
		}
		if (!tile.active())
		{
			return true;
		}
		if (tile.type == 191 || TileID.Sets.Clouds[tile.type])
		{
			return false;
		}
		return true;
	}

	private static bool GrowLivingTree_HorizontalTunnel(int i, int j)
	{
		int num = i;
		int num2 = i;
		int num3 = 80;
		if (SecretSeed.extraLivingTrees.Enabled)
		{
			num3 = ((genRand.Next(5) == 0) ? genRand.Next(400, 600) : ((genRand.Next(2) != 0) ? genRand.Next(80, 200) : genRand.Next(200, 400)));
		}
		else if (notTheBees && !drunkWorldGen)
		{
			num3 *= 3;
		}
		bool flag = false;
		int num4 = 1;
		if (genRand.Next(2) == 0)
		{
			num4 *= -1;
		}
		for (int k = 0; k < 2; k++)
		{
			flag = false;
			if (num == i && num4 > 0)
			{
				if (SecretSeed.dualDungeons.Enabled && DungeonUtils.IntersectsAnyPotentialDungeonBounds(out var _, new Rectangle(i + 5, j - 7, i + num3, j + 7)))
				{
					return false;
				}
				for (int l = i + 5; l < i + num3; l++)
				{
					if (!InWorld(l, j, 10))
					{
						return false;
					}
					if ((double)j < Main.worldSurface)
					{
						for (int m = j - 7; m <= j + 7 && Main.tile[l, m].wall != 0; m++)
						{
						}
					}
					if (Main.tile[l, j].type == 48)
					{
						flag = true;
						break;
					}
					if (Main.tile[l, j].type == 191)
					{
						for (int n = j - 2; n <= j; n++)
						{
							if (Main.tile[l + 2, n].wall != 244)
							{
								flag = true;
							}
						}
						if (!flag)
						{
							k = 2;
							num2 = l + 2;
						}
						break;
					}
					if (Main.tile[l, j].active())
					{
						continue;
					}
					bool flag2 = true;
					for (int num5 = j - 2; num5 <= j; num5++)
					{
						if ((double)j < Main.worldSurface + 3.0 && (Main.tile[l + 1, num5].wall == 0 || Main.tile[l + 2, num5].wall == 0 || Main.tile[l + 3, num5].wall == 0))
						{
							return false;
						}
						if (Main.tile[l, num5].active() || Main.tile[l + 1, num5].active() || Main.tile[l + 2, num5].active())
						{
							flag2 = false;
						}
					}
					if (flag2)
					{
						k = 2;
						num2 = l;
						break;
					}
				}
			}
			flag = false;
			if (num2 == i && num4 < 0)
			{
				if (SecretSeed.dualDungeons.Enabled && DungeonUtils.IntersectsAnyPotentialDungeonBounds(out var _, new Rectangle(i - num3, j - 7, i - 5, j + 7)))
				{
					return false;
				}
				for (int num6 = i - 5; num6 > i - num3; num6--)
				{
					if (!InWorld(num6, j, 10))
					{
						return false;
					}
					if ((double)j < Main.worldSurface)
					{
						for (int num7 = j - 7; num7 <= j + 7 && Main.tile[num6, num7].wall != 0; num7++)
						{
						}
					}
					if (Main.tile[num6, j].type == 48)
					{
						flag = true;
						break;
					}
					if (Main.tile[num6, j].type == 191)
					{
						for (int num8 = j - 2; num8 <= j; num8++)
						{
							if (Main.tile[num6 - 3, num8].wall != 244)
							{
								flag = true;
							}
						}
						if (!flag)
						{
							k = 2;
							num = num6 - 2;
						}
						break;
					}
					if (!Main.tile[num6, j].active())
					{
						bool flag3 = true;
						for (int num9 = j - 2; num9 <= j; num9++)
						{
							if ((double)j < Main.worldSurface + 3.0 && (Main.tile[num6 - 1, num9].wall == 0 || Main.tile[num6 - 2, num9].wall == 0 || Main.tile[num6 - 3, num9].wall == 0))
							{
								return false;
							}
							if (Main.tile[num6, num9].active() || Main.tile[num6 - 1, num9].active() || Main.tile[num6 - 2, num9].active())
							{
								flag3 = false;
							}
						}
						if (flag3)
						{
							k = 2;
							num = num6;
							break;
						}
					}
				}
			}
			num4 *= -1;
		}
		if (num == num2)
		{
			return false;
		}
		bool flag4 = false;
		bool flag5 = false;
		for (int num10 = j - 5; num10 <= j + 1; num10++)
		{
			for (int num11 = num; num11 <= num2; num11++)
			{
				int num12 = 2;
				if (Math.Abs(num11 - num2) > 3 && Math.Abs(num11 - num) > 3)
				{
					num12 = 4;
				}
				if (Main.tile[num11, num10].wall != 244 && Main.tile[num11, num10].type != 19 && Main.tile[num11, num10].type != 15 && Main.tile[num11, num10].type != 304 && Main.tile[num11, num10].type != 21 && Main.tile[num11, num10].type != 10)
				{
					if (!Main.wallDungeon[Main.tile[num11, num10].wall] && (!Main.tile[num11, num10].active() || (!Main.wallDungeon[Main.tile[num11, num10 - 1].wall] && !Main.wallDungeon[Main.tile[num11, num10 + 1].wall])) && (Main.tile[num11, num10].active() || Main.tile[num11, num10].wall != 34))
					{
						Main.tile[num11, num10].active(active: true);
						Main.tile[num11, num10].type = 191;
						Main.tile[num11, num10].halfBrick(halfBrick: false);
					}
					if (Main.tile[num11, num10 - 1].type == 40)
					{
						Main.tile[num11, num10 - 1].type = 0;
					}
					if (Main.tile[num11, num10 + 1].type == 40)
					{
						Main.tile[num11, num10 + 1].type = 0;
					}
				}
				if (num10 >= j - num12 && num10 <= j && Main.tile[num11, num10].type != 19 && Main.tile[num11, num10].type != 15 && Main.tile[num11, num10].type != 304 && Main.tile[num11, num10].type != 21 && Main.tile[num11, num10].type != 10 && Main.tile[num11, num10 - 1].type != 15 && Main.tile[num11, num10 - 1].type != 304 && Main.tile[num11, num10 - 1].type != 21 && Main.tile[num11, num10 - 1].type != 10 && Main.tile[num11, num10 + 1].type != 10)
				{
					if (!Main.wallDungeon[Main.tile[num11, num10].wall])
					{
						Main.tile[num11, num10].wall = 244;
					}
					Main.tile[num11, num10].liquid = 0;
					Main.tile[num11, num10].active(active: false);
				}
				if (num10 != j)
				{
					continue;
				}
				int style = 7;
				if (Main.wallDungeon[Main.tile[num11, num10].wall] || Main.wallDungeon[Main.tile[num11, num10 - 1].wall] || Main.wallDungeon[Main.tile[num11, num10 - 2].wall])
				{
					style = 13;
				}
				if (num11 <= num + 4 && !flag4)
				{
					if (Main.tile[num11 - 1, num10].type == 10 || Main.tile[num11 + 1, num10].type == 10)
					{
						flag4 = true;
					}
					else if (genRand.Next(3) == 0)
					{
						PlaceTile(num11, num10, 10, mute: true, forced: false, -1, style);
						if (Main.tile[num11, num10].type == 10)
						{
							flag4 = true;
						}
					}
				}
				if (num11 < num2 - 4 || flag5)
				{
					continue;
				}
				if (Main.tile[num11 - 1, num10].type == 10 || Main.tile[num11 + 1, num10].type == 10)
				{
					flag5 = true;
				}
				else if (genRand.Next(3) == 0)
				{
					PlaceTile(num11, num10, 10, mute: true, forced: false, -1, style);
					if (Main.tile[num11, num10].type == 10)
					{
						flag5 = true;
					}
				}
			}
		}
		return true;
	}

	public static void GrowLivingTree_MakePassage(int j, int W, ref int minl, ref int minr, bool noSecretRoom = false)
	{
		bool flag = noSecretRoom;
		int num = minl;
		int num2 = minr;
		bool flag2 = false;
		_ = (minl + minr) / 2;
		int num3 = 5;
		int num4 = j - 6;
		int num5 = 50;
		int num6 = genRand.Next(400, 700);
		if (SecretSeed.extraLivingTrees.Enabled)
		{
			float num7 = Main.maxTilesY / 1200;
			num6 *= 5;
			if (genRand.Next(3) == 0)
			{
				num5 = (int)((float)genRand.Next(200, 1500) * num7);
			}
			else if (genRand.Next(2) == 0)
			{
				num5 = (int)((float)genRand.Next(50, 400) * num7);
			}
		}
		else if (notTheBees && tenthAnniversaryWorldGen && !drunkWorldGen)
		{
			num6 *= 5;
		}
		int num8 = 0;
		bool flag3 = true;
		int num9 = genRand.Next(5, 16);
		if (SecretSeed.dualDungeons.Enabled && DungeonUtils.IntersectsAnyPotentialDungeonBounds(out var iteration, new Rectangle(minl, num4, Math.Max(1, minr - minl), num6)))
		{
			num6 = GenVars.dungeonGenVars[iteration].outerPotentialDungeonBounds.Top - num4 - 2;
		}
		while (num6 > 0)
		{
			if (skyblockWorldGen)
			{
				if (num4 < Main.maxTilesY - 20)
				{
					num6 = 100;
					num5 = 100;
				}
				else
				{
					num6 = 0;
					num5 = 0;
				}
			}
			else
			{
				if (num4 > Main.UnderworldLayer + genRand.Next(15, 31))
				{
					num6 = 0;
				}
				if (SecretSeed.extraLivingTrees.Enabled && Vector2D.Distance(new Vector2D((minl + minr) / 2, num4), GenVars.shimmerPosition) < 120.0)
				{
					num5 = 0;
					num6 = 0;
				}
			}
			num4++;
			num6--;
			num5--;
			int num10 = (minl + minr) / 2;
			if (!Main.tile[minl, num4].active() && Main.tile[minl, num4].wall == 244 && !Main.tile[minr, num4].active() && Main.tile[minr, num4].wall == 244)
			{
				num6 = 0;
				break;
			}
			int num11 = 1;
			if (num4 > j && W <= 4)
			{
				num11++;
			}
			for (int i = minl - num11; i <= minr + num11; i++)
			{
				if (Main.wallDungeon[Main.tile[i, num4].wall])
				{
					flag = true;
					flag2 = true;
				}
				if (i > num10 - 2 && i <= num10 + 1)
				{
					if (num4 > j - 4)
					{
						bool flag4 = true;
						if (!Main.tile[i, num4 + 1].active() && Main.tile[i, num4 + 1].wall == 34)
						{
							flag4 = false;
						}
						if (Main.tile[i, num4].type != 19 && Main.tile[i, num4].type != 15 && Main.tile[i, num4].type != 304 && Main.tile[i, num4].type != 21 && Main.tile[i, num4].type != 10 && Main.tile[i, num4 - 1].type != 15 && Main.tile[i, num4 - 1].type != 304 && Main.tile[i, num4 - 1].type != 21 && Main.tile[i, num4 - 1].type != 10 && Main.tile[i, num4 + 1].type != 10)
						{
							Main.tile[i, num4].active(active: false);
						}
						if (!Main.wallDungeon[Main.tile[i, num4].wall] && Main.tile[i, num4].wall != 3 && Main.tile[i, num4].wall != 83)
						{
							Main.tile[i, num4].wall = 244;
						}
						if (!Main.wallDungeon[Main.tile[i - 1, num4].wall] && (Main.tile[i - 1, num4].wall > 0 || (double)num4 >= Main.worldSurface))
						{
							Main.tile[i - 1, num4].wall = 244;
						}
						if (!Main.wallDungeon[Main.tile[i + 1, num4].wall] && (Main.tile[i + 1, num4].wall > 0 || (double)num4 >= Main.worldSurface))
						{
							Main.tile[i + 1, num4].wall = 244;
						}
						if (num4 == j && i > num10 - 2 && i <= num10 + 1 && flag4)
						{
							Main.tile[i, num4 + 1].active(active: false);
							PlaceTile(i, num4 + 1, 19, mute: true, forced: false, -1, 23);
						}
					}
				}
				else
				{
					if (Main.tile[i, num4].type != 15 && Main.tile[i, num4].type != 304 && Main.tile[i, num4].type != 21 && Main.tile[i, num4].type != 10 && Main.tile[i - 1, num4].type != 10 && Main.tile[i + 1, num4].type != 10)
					{
						if (!Main.wallDungeon[Main.tile[i, num4].wall] && Main.tile[i, num4].wall != 3 && Main.tile[i, num4].wall != 83 && (Main.tile[i, num4].active() || Main.tile[i, num4].wall != 34))
						{
							Main.tile[i, num4].type = 191;
							Main.tile[i, num4].active(active: true);
							Main.tile[i, num4].halfBrick(halfBrick: false);
						}
						if (Main.tile[i - 1, num4].type == 40)
						{
							Main.tile[i - 1, num4].type = 0;
						}
						if (Main.tile[i + 1, num4].type == 40)
						{
							Main.tile[i + 1, num4].type = 0;
						}
					}
					if (num4 <= j && num4 > j - 4 && i > minl - num11 && i <= minr + num11 - 1)
					{
						Main.tile[i, num4].wall = 244;
					}
				}
				if (!isGeneratingOrLoadingWorld)
				{
					SquareTileFrame(i, num4);
					SquareWallFrame(i, num4);
				}
			}
			num8++;
			if (num8 >= 6)
			{
				num8 = 0;
				int num12 = genRand.Next(3);
				if (num12 == 0)
				{
					num12 = -1;
				}
				if (flag3)
				{
					num12 = 2;
				}
				if (num12 == -1 && Main.tile[minl - num3, num4].wall == 244)
				{
					num12 = 1;
				}
				else if (num12 == 1 && Main.tile[minr + num3, num4].wall == 244)
				{
					num12 = -1;
				}
				if (num12 == 2)
				{
					flag3 = false;
					int style = 23;
					if (Main.wallDungeon[Main.tile[minl, num4 + 1].wall] || Main.wallDungeon[Main.tile[minl + 1, num4 + 1].wall] || Main.wallDungeon[Main.tile[minl + 2, num4 + 1].wall])
					{
						style = 12;
					}
					for (int k = minl; k <= minr; k++)
					{
						if (k > num10 - 2 && k <= num10 + 1)
						{
							Main.tile[k, num4 + 1].active(active: false);
							PlaceTile(k, num4 + 1, 19, mute: true, forced: false, -1, style);
						}
					}
				}
				else
				{
					minl += num12;
					minr += num12;
				}
				if (noSecretRoom)
				{
					num9--;
					if (num9 <= 0)
					{
						num9 = ((!GrowLivingTree_HorizontalTunnel(num10, num4)) ? genRand.Next(2, 11) : genRand.Next(5, 21));
					}
				}
				if (num5 <= 0 && !flag)
				{
					flag = true;
					GrowLivingTreePassageRoom(minl, minr, num4);
				}
			}
			if (flag2)
			{
				bool flag5 = true;
				for (int l = minl; l <= minr; l++)
				{
					for (int m = num4 + 1; m <= num4 + 2; m++)
					{
						if (SolidTile(l, m))
						{
							flag5 = false;
						}
					}
				}
				if (flag5)
				{
					num6 = 0;
				}
			}
			else
			{
				if (num5 > 0)
				{
					continue;
				}
				bool flag6 = true;
				for (int n = minl; n <= minr; n++)
				{
					for (int num13 = num4 + 1; num13 <= num4 + 4; num13++)
					{
						if (SolidTile(n, num13))
						{
							flag6 = false;
						}
					}
				}
				if (flag6)
				{
					num6 = 0;
				}
			}
		}
		minl = num;
		minr = num2;
		_ = (minl + minr) / 2;
		for (int num14 = minl; num14 <= minr; num14++)
		{
			for (int num15 = j - 3; num15 <= j; num15++)
			{
				Main.tile[num14, num15].active(active: false);
				bool flag7 = true;
				for (int num16 = num14 - 1; num16 <= num14 + 1; num16++)
				{
					for (int num17 = num15 - 1; num17 <= num15 + 1; num17++)
					{
						if (!Main.tile[num16, num17].active() && Main.tile[num16, num17].wall == 0)
						{
							flag7 = false;
						}
					}
				}
				if (flag7 && !Main.wallDungeon[Main.tile[num14, num15].wall])
				{
					Main.tile[num14, num15].wall = 244;
				}
			}
		}
	}

	private static void GrowLivingTreePassageRoom(int minl, int minr, int Y)
	{
		int num = genRand.Next(2);
		if (num == 0)
		{
			num = -1;
		}
		int num2 = Y - 2;
		int num3 = (minl + minr) / 2;
		if (num < 0)
		{
			num3--;
		}
		if (num > 0)
		{
			num3++;
		}
		int num4 = genRand.Next(15, 30);
		int num5 = num3 + num4;
		if (num < 0)
		{
			num5 = num3;
			num3 -= num4;
		}
		for (int i = num3; i < num5; i++)
		{
			for (int j = Y - 20; j < Y + 10; j++)
			{
				if (Main.tile[i, j].wall == 0 && !Main.tile[i, j].active() && (double)j < Main.worldSurface)
				{
					return;
				}
			}
		}
		if (SecretSeed.dualDungeons.Enabled && DungeonUtils.IntersectsAnyPotentialDungeonBounds(out var _, new Rectangle(num3, Y - 20, num5, Y + 10)))
		{
			return;
		}
		for (int k = num3; k <= num5; k++)
		{
			for (int l = num2 - 2; l <= Y + 2; l++)
			{
				if (Main.tile[k - 1, l].type == 40)
				{
					Main.tile[k - 1, l].type = 0;
				}
				if (Main.tile[k + 1, l].type == 40)
				{
					Main.tile[k + 1, l].type = 0;
				}
				if (Main.tile[k, l - 1].type == 40)
				{
					Main.tile[k, l - 1].type = 0;
				}
				if (Main.tile[k, l + 1].type == 40)
				{
					Main.tile[k, l + 1].type = 0;
				}
				if (Main.tile[k, l].wall != 244 && Main.tile[k, l].type != 19)
				{
					Main.tile[k, l].active(active: true);
					Main.tile[k, l].type = 191;
					Main.tile[k, l].halfBrick(halfBrick: false);
				}
				if (l >= num2 && l <= Y)
				{
					Main.tile[k, l].liquid = 0;
					Main.tile[k, l].wall = 244;
					Main.tile[k, l].active(active: false);
				}
			}
		}
		int i2 = (minl + minr) / 2 + 3 * num;
		PlaceTile(i2, Y, 10, mute: true, forced: false, -1, 7);
		int num6 = genRand.Next(5, 9);
		int num7 = genRand.Next(4, 6);
		if (num < 0)
		{
			num5 = num3 + num6;
			num3 -= num6;
		}
		else
		{
			num3 = num5 - num6;
			num5 += num6;
		}
		num2 = Y - num7;
		for (int m = num3 - 2; m <= num5 + 2; m++)
		{
			for (int n = num2 - 2; n <= Y + 2; n++)
			{
				if (Main.tile[m - 1, n].type == 40)
				{
					Main.tile[m - 1, n].type = 40;
				}
				if (Main.tile[m + 1, n].type == 40)
				{
					Main.tile[m + 1, n].type = 40;
				}
				if (Main.tile[m, n - 1].type == 40)
				{
					Main.tile[m, n - 1].type = 40;
				}
				if (Main.tile[m, n + 1].type == 40)
				{
					Main.tile[m, n + 1].type = 40;
				}
				if (Main.tile[m, n].wall != 244 && Main.tile[m, n].type != 19)
				{
					Main.tile[m, n].active(active: true);
					Main.tile[m, n].type = 191;
					Main.tile[m, n].halfBrick(halfBrick: false);
				}
				if (n >= num2 && n <= Y && m >= num3 && m <= num5)
				{
					Main.tile[m, n].liquid = 0;
					Main.tile[m, n].wall = 244;
					Main.tile[m, n].active(active: false);
				}
			}
		}
		i2 = num3 - 2;
		if (num < 0)
		{
			i2 = num5 + 2;
		}
		PlaceTile(i2, Y, 10, mute: true, forced: false, -1, 7);
		int num8 = num5;
		if (num < 0)
		{
			num8 = num3;
		}
		int num9 = 2;
		if (genRand.Next(num9) == 0)
		{
			num9 += 2;
			PlaceTile(num8, Y, 15, mute: true, forced: false, -1, 5);
			if (num < 0)
			{
				Main.tile[num8, Y - 1].frameX += 18;
				Main.tile[num8, Y].frameX += 18;
			}
		}
		num8 = num5 - 2;
		if (num < 0)
		{
			num8 = num3 + 2;
		}
		PlaceTile(num8, Y, 304, mute: true);
		num8 = num5 - 4;
		if (num < 0)
		{
			num8 = num3 + 4;
		}
		if (genRand.Next(num9) == 0)
		{
			PlaceTile(num8, Y, 15, mute: true, forced: false, -1, 5);
			if (num > 0)
			{
				Main.tile[num8, Y - 1].frameX += 18;
				Main.tile[num8, Y].frameX += 18;
			}
		}
		num8 = num5 - 7;
		if (num < 0)
		{
			num8 = num3 + 8;
		}
		int mainItemInChest = 832;
		if (genRand.Next(3) == 0)
		{
			mainItemInChest = 4281;
		}
		if (remixWorldGen)
		{
			int num10 = genRand.Next(1, 3);
			for (int num11 = 0; num11 < num10; num11++)
			{
				bool flag = false;
				int num12 = 1000;
				while (!flag)
				{
					num12--;
					if (num12 <= 0)
					{
						break;
					}
					int num13 = genRand.Next(Main.maxTilesX / 8, Main.maxTilesX - Main.maxTilesX / 8);
					int num14 = genRand.Next((int)Main.rockLayer, Main.maxTilesY - 350);
					if (!IsTileNearby(num13, num14, 53, 20) && !IsTileNearby(num13, num14, 147, 20) && !IsTileNearby(num13, num14, 59, 20))
					{
						flag = AddBuriedChest(num13, num14, mainItemInChest, notNearOtherChests: false, 12, trySlope: false, 0);
					}
				}
			}
			if (crimson)
			{
				AddBuriedChest(num8, Y, 0, notNearOtherChests: false, 14, trySlope: false, 0);
			}
			else
			{
				AddBuriedChest(num8, Y, 0, notNearOtherChests: false, 7, trySlope: false, 0);
			}
		}
		else
		{
			AddBuriedChest(num8, Y, mainItemInChest, notNearOtherChests: false, 12, trySlope: false, 0);
		}
	}

	public static void TreeGrowFXCheck(int x, int y)
	{
		int treeHeight = 1;
		int passStyle = -1;
		Tile topTile = null;
		for (int num = -1; num > -100; num--)
		{
			Tile tile = Main.tile[x, y + num];
			if (!tile.active() || !TileID.Sets.GetsCheckedForLeaves[tile.type])
			{
				break;
			}
			topTile = tile;
			treeHeight++;
		}
		for (int i = 1; i < 5; i++)
		{
			Tile tile2 = Main.tile[x, y + i];
			if (tile2.active() && TileID.Sets.GetsCheckedForLeaves[tile2.type])
			{
				treeHeight++;
				continue;
			}
			GetTreeLeaf(x, topTile, tile2, ref treeHeight, out var _, out passStyle);
			break;
		}
		if (treeHeight > 0 && passStyle > 0)
		{
			if (Main.netMode == 2)
			{
				NetMessage.SendData(112, -1, -1, null, 1, x, y, treeHeight, passStyle);
			}
			if (Main.netMode == 0)
			{
				TreeGrowFX(x, y, treeHeight, passStyle);
			}
		}
	}

	public static void GetTreeLeaf(int x, Tile topTile, Tile t, ref int treeHeight, out int treeFrame, out int passStyle)
	{
		treeFrame = 0;
		passStyle = -1;
		if (topTile.frameX == 22 || topTile.frameX == 44 || topTile.frameX == 66)
		{
			if (topTile.frameY == 220)
			{
				treeFrame = 1;
			}
			else if (topTile.frameY == 242)
			{
				treeFrame = 2;
			}
		}
		if (topTile.frameX == 44 || topTile.frameX == 66)
		{
			if (topTile.frameY == 220)
			{
				treeFrame = 1;
			}
			else if (topTile.frameY == 242)
			{
				treeFrame = 2;
			}
		}
		switch (topTile.type)
		{
		case 596:
			passStyle = 1248;
			break;
		case 616:
			passStyle = 1257;
			break;
		case 634:
			passStyle = 1278;
			break;
		case 583:
		case 584:
		case 585:
		case 586:
		case 587:
		case 588:
		case 589:
			passStyle = 1249 + (topTile.type - 583);
			break;
		}
		if (passStyle > -1)
		{
			return;
		}
		switch (t.type)
		{
		case 2:
		case 477:
			passStyle = 910;
			break;
		case 60:
			passStyle = 914;
			break;
		case 70:
			passStyle = 912;
			break;
		case 23:
		case 112:
			passStyle = 915;
			break;
		case 199:
		case 234:
			passStyle = 916;
			break;
		case 53:
			passStyle = 911;
			break;
		case 116:
			passStyle = 919;
			break;
		case 147:
			passStyle = 913;
			break;
		case 633:
			passStyle = 1278;
			break;
		case 109:
		case 492:
		{
			int num = 917;
			int hollowTreeFoliageStyle = GetHollowTreeFoliageStyle();
			if (hollowTreeFoliageStyle != 20)
			{
				if (x % 3 == 1)
				{
					treeFrame += 3;
				}
				if (x % 3 == 2)
				{
					treeFrame += 6;
				}
				switch (treeFrame)
				{
				case 0:
					passStyle = 2;
					break;
				case 1:
					passStyle = 1;
					break;
				case 2:
					passStyle = 7;
					break;
				case 3:
					passStyle = 4;
					break;
				case 4:
					passStyle = 5;
					break;
				case 5:
					passStyle = 6;
					break;
				case 6:
					passStyle = 3;
					break;
				case 7:
					passStyle = 8;
					break;
				case 8:
					passStyle = 0;
					break;
				}
			}
			else
			{
				int num2 = 196;
				if (x % 6 == 1)
				{
					treeFrame += 3;
				}
				else if (x % 6 == 2)
				{
					treeFrame += 6;
				}
				else if (x % 6 == 3)
				{
					treeFrame += 9;
				}
				else if (x % 6 == 4)
				{
					treeFrame += 12;
				}
				else if (x % 6 == 5)
				{
					treeFrame += 15;
				}
				switch (treeFrame)
				{
				case 0:
					passStyle = num2;
					break;
				case 1:
					passStyle = num2;
					break;
				case 2:
					passStyle = num2;
					break;
				case 3:
					passStyle = num2 + 1;
					break;
				case 4:
					passStyle = num2 + 2;
					break;
				case 5:
					passStyle = num2 + 1;
					break;
				case 6:
					passStyle = num2 + 3;
					break;
				case 7:
					passStyle = num2 + 4;
					break;
				case 8:
					passStyle = num2 + 5;
					break;
				case 9:
					passStyle = num2 + 6;
					break;
				case 10:
					passStyle = num2 + 6;
					break;
				case 11:
					passStyle = num2 + 6;
					break;
				case 12:
					passStyle = num2 + 7;
					break;
				case 13:
					passStyle = num2 + 7;
					break;
				case 14:
					passStyle = num2 + 7;
					break;
				case 15:
					passStyle = num2 + 8;
					break;
				case 16:
					passStyle = num2 + 8;
					break;
				case 17:
					passStyle = num2 + 8;
					break;
				}
			}
			passStyle += num;
			treeHeight += 5;
			break;
		}
		}
	}

	public static void TreeGrowFX(int x, int y, int height, int treeGore, bool hitTree = false)
	{
		Vector2 vector = new Vector2(x, y) * 16f + new Vector2(8f, 8f);
		if (treeGore == 1278)
		{
			TreeGrowFX_AshShake(x, y, height, hitTree);
			return;
		}
		byte currentColumn = 0;
		if (InWorld(x, y, 2))
		{
			Tile tile = Main.tile[x, y];
			if (tile != null && tile.active() && (TileID.Sets.IsATreeTrunk[tile.type] || tile.type == 323))
			{
				currentColumn = Main.tile[x, y].color();
			}
		}
		for (int num = 0; num > -height; num--)
		{
			float num2 = 10f;
			Vector2 vector2 = new Vector2(5f, 7f);
			Main.gore[Gore.NewGore(vector + new Vector2(-16f, num * 16) - vector2, Utils.RandomVector2(Main.rand, 0f - num2, num2), treeGore, 0.7f + Main.rand.NextFloat() * 0.6f)].Frame.CurrentColumn = currentColumn;
			Main.gore[Gore.NewGore(vector + new Vector2(0f, num * 16) - vector2, Utils.RandomVector2(Main.rand, 0f - num2, num2), treeGore, 0.7f + Main.rand.NextFloat() * 0.6f)].Frame.CurrentColumn = currentColumn;
			Main.gore[Gore.NewGore(vector + new Vector2(16f, num * 16) - vector2, Utils.RandomVector2(Main.rand, 0f - num2, num2), treeGore, 0.7f + Main.rand.NextFloat() * 0.6f)].Frame.CurrentColumn = currentColumn;
			if (num == -height + 1)
			{
				int num3 = 20;
				if (hitTree)
				{
					num3 = 5;
				}
				for (int i = 0; i < num3; i++)
				{
					Main.gore[Gore.NewGore(vector + new Vector2(0f, num * 16 - 40) + Utils.RandomVector2(Main.rand, -40f, 40f) - vector2, Utils.RandomVector2(Main.rand, -10f, 10f), treeGore, 0.7f + Main.rand.NextFloat() * 0.6f)].Frame.CurrentColumn = currentColumn;
				}
			}
		}
	}

	private static void TreeGrowFX_AshShake(int x, int y, int height, bool hitTree = false)
	{
		Vector2 vector = new Vector2(x, y) * 16f + new Vector2(8f, 8f);
		for (int num = 0; num > -height; num--)
		{
			if (num >= -height / 2 && Main.rand.Next(3) != 0)
			{
				int num2 = (hitTree ? 10 : 5);
				for (int i = 0; i < num2; i++)
				{
					Dust.NewDustDirect(vector + new Vector2(-16f, num * 16) + Utils.RandomVector2(Main.rand, -30f, 30f), 4, 4, 31, 0f, -3f, 100).velocity = Main.rand.NextVector2Circular(2f, 2f) + new Vector2(0f, -0.6f);
				}
			}
			if ((float)num >= (float)(-height) * 0.7f && Main.rand.Next(3) != 0)
			{
				int num3 = (hitTree ? 16 : 10);
				for (int j = 0; j < num3; j++)
				{
					Dust dust = Dust.NewDustDirect(vector + new Vector2(-16f, num * 16) + Utils.RandomVector2(Main.rand, -30f, 30f), 4, 4, 6, 0f, -4f, 0, default(Color), 1f + 0.7f * Main.rand.NextFloat());
					dust.velocity = Main.rand.NextVector2Circular(2f, 2f) + new Vector2(0f, -0.6f);
					if (Main.rand.Next(2) == 0)
					{
						dust.velocity *= 2f;
						dust.noGravity = true;
					}
					dust.velocity += new Vector2(0f, hitTree ? (-1f) : (-2f));
				}
			}
			if (!hitTree)
			{
				Gore.NewGoreDirect(vector + new Vector2(-16f, num * 16 - 40) + Utils.RandomVector2(Main.rand, -40f, 40f) * new Vector2(0.5f, 1f), Vector2.Zero, 61 + Main.rand.Next(3)).velocity *= 0.5f;
			}
		}
	}

	public static bool IsTileALeafyTreeTop(int i, int j)
	{
		return IsTileALeafyTreeTop(Framing.GetTileSafely(i, j));
	}

	public static bool IsTileALeafyTreeTop(Tile t)
	{
		if (t.active() && TileID.Sets.GetsCheckedForLeaves[t.type])
		{
			if (t.type == 323 && t.frameX >= 88)
			{
				return true;
			}
			if (t.frameX == 22 && t.frameY >= 198 && t.frameY <= 242)
			{
				return true;
			}
		}
		return false;
	}

	public static bool IsTileTypeFitForTree(ushort type)
	{
		switch (type)
		{
		case 2:
		case 23:
		case 60:
		case 70:
		case 109:
		case 147:
		case 199:
		case 477:
		case 492:
		case 633:
		case 661:
		case 662:
			return true;
		default:
			return false;
		}
	}

	public static bool IsTileATreeBranch(int x, int y, out int offsetToTrunk)
	{
		offsetToTrunk = 0;
		if (!InWorld(x, y, 2))
		{
			return false;
		}
		Tile tile = Main.tile[x, y];
		if (tile == null || !tile.active() || tile.type == 323 || !TileID.Sets.IsATreeTrunk[tile.type])
		{
			return false;
		}
		if ((tile.frameX == 44 && (tile.frameY == 198 || tile.frameY == 220 || tile.frameY == 242)) || (tile.frameX == 66 && (tile.frameY == 0 || tile.frameY == 22 || tile.frameY == 44)))
		{
			offsetToTrunk = 1;
			return true;
		}
		if ((tile.frameX == 66 && (tile.frameY == 198 || tile.frameY == 220 || tile.frameY == 242)) || (tile.frameX == 88 && (tile.frameY == 66 || tile.frameY == 88 || tile.frameY == 110)))
		{
			offsetToTrunk = -1;
			return true;
		}
		return false;
	}

	public static bool IsTileATreeRoot(int x, int y, out int offsetToTrunk)
	{
		offsetToTrunk = 0;
		if (!InWorld(x, y, 2))
		{
			return false;
		}
		Tile tile = Main.tile[x, y];
		if (tile == null || !tile.active() || tile.type == 323 || !TileID.Sets.IsATreeTrunk[tile.type])
		{
			return false;
		}
		if (tile.frameX == 44 && (tile.frameY == 132 || tile.frameY == 154 || tile.frameY == 176))
		{
			offsetToTrunk = 1;
			return true;
		}
		if (tile.frameX == 22 && (tile.frameY == 132 || tile.frameY == 154 || tile.frameY == 176))
		{
			offsetToTrunk = -1;
			return true;
		}
		return false;
	}

	public static bool GrowTree(int i, int y, int treeHeightAddon = 0, bool ignoreWalls = false)
	{
		int j;
		for (j = y; Main.tile[i, j].active() && Main.tile[i, j].type == 20; j++)
		{
		}
		if ((Main.tile[i - 1, j - 1].liquid != 0 || Main.tile[i, j - 1].liquid != 0 || Main.tile[i + 1, j - 1].liquid != 0) && !notTheBees)
		{
			return false;
		}
		if (Main.tile[i, j].nactive() && !Main.tile[i, j].halfBrick() && Main.tile[i, j].slope() == 0)
		{
			bool flag = ignoreWalls || DefaultTreeWallTest(Main.tile[i, j - 1].wall);
			if (IsTileTypeFitForTree(Main.tile[i, j].type) && ((Main.remixWorld && (double)j > Main.worldSurface) || Main.notTheBeesWorld || Main.tile[i, j - 1].wall == 0 || flag) && ((Main.tile[i - 1, j].active() && IsTileTypeFitForTree(Main.tile[i - 1, j].type)) || (Main.tile[i + 1, j].active() && IsTileTypeFitForTree(Main.tile[i + 1, j].type))))
			{
				_ = Main.tile[i, j].type;
				TileColorCache cache = Main.tile[i, j].BlockColorAndCoating();
				if (Main.tenthAnniversaryWorld && !isGeneratingOrLoadingWorld && ((!Main.notTheBeesWorld && !Main.dontStarveWorld) || Main.remixWorld))
				{
					cache.Color = (byte)genRand.Next(1, 13);
				}
				int num = 2;
				int num2 = genRand.Next(5, 17) + treeHeightAddon;
				if (SecretSeed.errorWorld.Enabled && genRand.Next(SecretSeed.Variations.errorWorldAdjustment(3.0)) == 0)
				{
					num2 = genRand.Next(2, 101);
				}
				else if (SecretSeed.extraLivingTrees.Enabled)
				{
					num2 += genRand.Next(0, 11);
				}
				int num3 = num2 + 4;
				if (Main.tile[i, j].type == 60)
				{
					num3 += 5;
				}
				bool flag2 = false;
				if (Main.tile[i, j].type == 70 && EmptyTileCheck(i - num, i + num, j - num3, j - 3, 20) && EmptyTileCheck(i - 1, i + 1, j - 2, j - 1, 20))
				{
					flag2 = true;
				}
				if (EmptyTileCheck(i - num, i + num, j - num3, j - 1, 20))
				{
					flag2 = true;
				}
				if (flag2)
				{
					bool flag3 = Main.remixWorld && (double)j < Main.worldSurface;
					bool flag4 = false;
					bool flag5 = false;
					int num4;
					for (int k = j - num2; k < j; k++)
					{
						Main.tile[i, k].active(active: true);
						Main.tile[i, k].type = 5;
						Main.tile[i, k].UseBlockColors(cache);
						num4 = genRand.Next(3);
						int num5 = genRand.Next(10);
						if (k == j - 1 || k == j - num2)
						{
							num5 = 0;
						}
						while (((num5 == 5 || num5 == 7) && flag4) || ((num5 == 6 || num5 == 7) && flag5))
						{
							num5 = genRand.Next(10);
						}
						flag4 = false;
						flag5 = false;
						if (num5 == 5 || num5 == 7)
						{
							flag4 = true;
						}
						if (num5 == 6 || num5 == 7)
						{
							flag5 = true;
						}
						switch (num5)
						{
						case 1:
							if (num4 == 0)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 66;
							}
							if (num4 == 1)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 88;
							}
							if (num4 == 2)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 110;
							}
							break;
						case 2:
							if (num4 == 0)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 0;
							}
							if (num4 == 1)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 22;
							}
							if (num4 == 2)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 44;
							}
							break;
						case 3:
							if (num4 == 0)
							{
								Main.tile[i, k].frameX = 44;
								Main.tile[i, k].frameY = 66;
							}
							if (num4 == 1)
							{
								Main.tile[i, k].frameX = 44;
								Main.tile[i, k].frameY = 88;
							}
							if (num4 == 2)
							{
								Main.tile[i, k].frameX = 44;
								Main.tile[i, k].frameY = 110;
							}
							break;
						case 4:
							if (num4 == 0)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 66;
							}
							if (num4 == 1)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 88;
							}
							if (num4 == 2)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 110;
							}
							break;
						case 5:
							if (num4 == 0)
							{
								Main.tile[i, k].frameX = 88;
								Main.tile[i, k].frameY = 0;
							}
							if (num4 == 1)
							{
								Main.tile[i, k].frameX = 88;
								Main.tile[i, k].frameY = 22;
							}
							if (num4 == 2)
							{
								Main.tile[i, k].frameX = 88;
								Main.tile[i, k].frameY = 44;
							}
							break;
						case 6:
							if (num4 == 0)
							{
								Main.tile[i, k].frameX = 66;
								Main.tile[i, k].frameY = 66;
							}
							if (num4 == 1)
							{
								Main.tile[i, k].frameX = 66;
								Main.tile[i, k].frameY = 88;
							}
							if (num4 == 2)
							{
								Main.tile[i, k].frameX = 66;
								Main.tile[i, k].frameY = 110;
							}
							break;
						case 7:
							if (num4 == 0)
							{
								Main.tile[i, k].frameX = 110;
								Main.tile[i, k].frameY = 66;
							}
							if (num4 == 1)
							{
								Main.tile[i, k].frameX = 110;
								Main.tile[i, k].frameY = 88;
							}
							if (num4 == 2)
							{
								Main.tile[i, k].frameX = 110;
								Main.tile[i, k].frameY = 110;
							}
							break;
						default:
							if (num4 == 0)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 0;
							}
							if (num4 == 1)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 22;
							}
							if (num4 == 2)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 44;
							}
							break;
						}
						if (num5 == 5 || num5 == 7)
						{
							Main.tile[i - 1, k].active(active: true);
							Main.tile[i - 1, k].type = 5;
							Main.tile[i - 1, k].UseBlockColors(cache);
							num4 = genRand.Next(3);
							if (genRand.Next(3) < 2 && !flag3)
							{
								if (num4 == 0)
								{
									Main.tile[i - 1, k].frameX = 44;
									Main.tile[i - 1, k].frameY = 198;
								}
								if (num4 == 1)
								{
									Main.tile[i - 1, k].frameX = 44;
									Main.tile[i - 1, k].frameY = 220;
								}
								if (num4 == 2)
								{
									Main.tile[i - 1, k].frameX = 44;
									Main.tile[i - 1, k].frameY = 242;
								}
							}
							else
							{
								if (num4 == 0)
								{
									Main.tile[i - 1, k].frameX = 66;
									Main.tile[i - 1, k].frameY = 0;
								}
								if (num4 == 1)
								{
									Main.tile[i - 1, k].frameX = 66;
									Main.tile[i - 1, k].frameY = 22;
								}
								if (num4 == 2)
								{
									Main.tile[i - 1, k].frameX = 66;
									Main.tile[i - 1, k].frameY = 44;
								}
							}
						}
						if (num5 != 6 && num5 != 7)
						{
							continue;
						}
						Main.tile[i + 1, k].active(active: true);
						Main.tile[i + 1, k].type = 5;
						Main.tile[i + 1, k].UseBlockColors(cache);
						num4 = genRand.Next(3);
						if (genRand.Next(3) < 2 && !flag3)
						{
							if (num4 == 0)
							{
								Main.tile[i + 1, k].frameX = 66;
								Main.tile[i + 1, k].frameY = 198;
							}
							if (num4 == 1)
							{
								Main.tile[i + 1, k].frameX = 66;
								Main.tile[i + 1, k].frameY = 220;
							}
							if (num4 == 2)
							{
								Main.tile[i + 1, k].frameX = 66;
								Main.tile[i + 1, k].frameY = 242;
							}
						}
						else
						{
							if (num4 == 0)
							{
								Main.tile[i + 1, k].frameX = 88;
								Main.tile[i + 1, k].frameY = 66;
							}
							if (num4 == 1)
							{
								Main.tile[i + 1, k].frameX = 88;
								Main.tile[i + 1, k].frameY = 88;
							}
							if (num4 == 2)
							{
								Main.tile[i + 1, k].frameX = 88;
								Main.tile[i + 1, k].frameY = 110;
							}
						}
					}
					int num6 = genRand.Next(3);
					bool flag6 = false;
					bool flag7 = false;
					if (Main.tile[i - 1, j].nactive() && !Main.tile[i - 1, j].halfBrick() && Main.tile[i - 1, j].slope() == 0 && IsTileTypeFitForTree(Main.tile[i - 1, j].type))
					{
						flag6 = true;
					}
					if (Main.tile[i + 1, j].nactive() && !Main.tile[i + 1, j].halfBrick() && Main.tile[i + 1, j].slope() == 0 && IsTileTypeFitForTree(Main.tile[i + 1, j].type))
					{
						flag7 = true;
					}
					if (!flag6)
					{
						if (num6 == 0)
						{
							num6 = 2;
						}
						if (num6 == 1)
						{
							num6 = 3;
						}
					}
					if (!flag7)
					{
						if (num6 == 0)
						{
							num6 = 1;
						}
						if (num6 == 2)
						{
							num6 = 3;
						}
					}
					if (flag6 && !flag7)
					{
						num6 = 2;
					}
					if (flag7 && !flag6)
					{
						num6 = 1;
					}
					if (num6 == 0 || num6 == 1)
					{
						Main.tile[i + 1, j - 1].active(active: true);
						Main.tile[i + 1, j - 1].type = 5;
						Main.tile[i + 1, j - 1].UseBlockColors(cache);
						num4 = genRand.Next(3);
						if (num4 == 0)
						{
							Main.tile[i + 1, j - 1].frameX = 22;
							Main.tile[i + 1, j - 1].frameY = 132;
						}
						if (num4 == 1)
						{
							Main.tile[i + 1, j - 1].frameX = 22;
							Main.tile[i + 1, j - 1].frameY = 154;
						}
						if (num4 == 2)
						{
							Main.tile[i + 1, j - 1].frameX = 22;
							Main.tile[i + 1, j - 1].frameY = 176;
						}
					}
					if (num6 == 0 || num6 == 2)
					{
						Main.tile[i - 1, j - 1].active(active: true);
						Main.tile[i - 1, j - 1].type = 5;
						Main.tile[i - 1, j - 1].UseBlockColors(cache);
						num4 = genRand.Next(3);
						if (num4 == 0)
						{
							Main.tile[i - 1, j - 1].frameX = 44;
							Main.tile[i - 1, j - 1].frameY = 132;
						}
						if (num4 == 1)
						{
							Main.tile[i - 1, j - 1].frameX = 44;
							Main.tile[i - 1, j - 1].frameY = 154;
						}
						if (num4 == 2)
						{
							Main.tile[i - 1, j - 1].frameX = 44;
							Main.tile[i - 1, j - 1].frameY = 176;
						}
					}
					num4 = genRand.Next(3);
					switch (num6)
					{
					case 0:
						if (num4 == 0)
						{
							Main.tile[i, j - 1].frameX = 88;
							Main.tile[i, j - 1].frameY = 132;
						}
						if (num4 == 1)
						{
							Main.tile[i, j - 1].frameX = 88;
							Main.tile[i, j - 1].frameY = 154;
						}
						if (num4 == 2)
						{
							Main.tile[i, j - 1].frameX = 88;
							Main.tile[i, j - 1].frameY = 176;
						}
						break;
					case 1:
						if (num4 == 0)
						{
							Main.tile[i, j - 1].frameX = 0;
							Main.tile[i, j - 1].frameY = 132;
						}
						if (num4 == 1)
						{
							Main.tile[i, j - 1].frameX = 0;
							Main.tile[i, j - 1].frameY = 154;
						}
						if (num4 == 2)
						{
							Main.tile[i, j - 1].frameX = 0;
							Main.tile[i, j - 1].frameY = 176;
						}
						break;
					case 2:
						if (num4 == 0)
						{
							Main.tile[i, j - 1].frameX = 66;
							Main.tile[i, j - 1].frameY = 132;
						}
						if (num4 == 1)
						{
							Main.tile[i, j - 1].frameX = 66;
							Main.tile[i, j - 1].frameY = 154;
						}
						if (num4 == 2)
						{
							Main.tile[i, j - 1].frameX = 66;
							Main.tile[i, j - 1].frameY = 176;
						}
						break;
					}
					if (genRand.Next(13) != 0 && !flag3)
					{
						num4 = genRand.Next(3);
						if (num4 == 0)
						{
							Main.tile[i, j - num2].frameX = 22;
							Main.tile[i, j - num2].frameY = 198;
						}
						if (num4 == 1)
						{
							Main.tile[i, j - num2].frameX = 22;
							Main.tile[i, j - num2].frameY = 220;
						}
						if (num4 == 2)
						{
							Main.tile[i, j - num2].frameX = 22;
							Main.tile[i, j - num2].frameY = 242;
						}
					}
					else
					{
						num4 = genRand.Next(3);
						if (num4 == 0)
						{
							Main.tile[i, j - num2].frameX = 0;
							Main.tile[i, j - num2].frameY = 198;
						}
						if (num4 == 1)
						{
							Main.tile[i, j - num2].frameX = 0;
							Main.tile[i, j - num2].frameY = 220;
						}
						if (num4 == 2)
						{
							Main.tile[i, j - num2].frameX = 0;
							Main.tile[i, j - num2].frameY = 242;
						}
					}
					RangeFrame(i - 2, j - num2 - 1, i + 2, j + 1);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i - 1, j - num2, 3, num2);
					}
					return true;
				}
			}
		}
		return false;
	}

	public static bool DefaultTreeWallTest(int wallType)
	{
		if (wallType >= 0 && wallType < WallID.Count && WallID.Sets.AllowsPlantsToGrow[wallType])
		{
			return true;
		}
		return false;
	}

	public static bool GemTreeWallTest(int wallType)
	{
		if (DefaultTreeWallTest(wallType))
		{
			return true;
		}
		switch (wallType)
		{
		case 2:
		case 54:
		case 55:
		case 56:
		case 57:
		case 58:
		case 59:
		case 61:
		case 185:
		case 196:
		case 197:
		case 198:
		case 199:
		case 208:
		case 209:
		case 210:
		case 211:
		case 212:
		case 213:
		case 214:
		case 215:
			return true;
		default:
			return false;
		}
	}

	public static bool GemTreeGroundTest(int tileType)
	{
		if (tileType < 0)
		{
			return false;
		}
		if (TileID.Sets.Conversion.Stone[tileType] || TileID.Sets.Conversion.Moss[tileType])
		{
			return true;
		}
		return false;
	}

	public static bool VanityTreeGroundTest(int tileType)
	{
		if (tileType < 0)
		{
			return false;
		}
		if (TileID.Sets.Conversion.Grass[tileType] && tileType != 23 && tileType != 199)
		{
			return true;
		}
		return false;
	}

	public static bool AshTreeGroundTest(int tileType)
	{
		if (tileType < 0)
		{
			return false;
		}
		if (tileType == 633)
		{
			return true;
		}
		return false;
	}

	public static bool TryGrowingTreeByType(int treeTileType, int checkedX, int checkedY, int treeHeightAddon = 0, bool ignoreWalls = false)
	{
		bool result = false;
		switch (treeTileType)
		{
		case 5:
			result = GrowTree(checkedX, checkedY, treeHeightAddon, ignoreWalls);
			break;
		case 323:
			result = GrowPalmTree(checkedX, checkedY, treeHeightAddon, ignoreWalls);
			break;
		case 587:
			result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Ruby, treeHeightAddon, ignoreWalls);
			break;
		case 588:
			result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Diamond, treeHeightAddon, ignoreWalls);
			break;
		case 583:
			result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Topaz, treeHeightAddon, ignoreWalls);
			break;
		case 584:
			result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Amethyst, treeHeightAddon, ignoreWalls);
			break;
		case 589:
			result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Amber, treeHeightAddon, ignoreWalls);
			break;
		case 586:
			result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Emerald, treeHeightAddon, ignoreWalls);
			break;
		case 585:
			result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Sapphire, treeHeightAddon, ignoreWalls);
			break;
		case 596:
			result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.VanityTree_Sakura, treeHeightAddon, ignoreWalls);
			break;
		case 616:
			result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.VanityTree_Willow, treeHeightAddon, ignoreWalls);
			break;
		case 634:
			result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.Tree_Ash, treeHeightAddon, ignoreWalls);
			break;
		}
		return result;
	}

	public static bool GrowTreeWithSettings(int checkedX, int checkedY, GrowTreeSettings settings, int treeHeightAddon = 0, bool ignoreWalls = false)
	{
		int num = checkedY;
		while (Main.tile[checkedX, checkedY].active() && Main.tile[checkedX, num].type == settings.SaplingTileType)
		{
			num++;
		}
		if (Main.tile[checkedX - 1, num - 1].liquid != 0 || Main.tile[checkedX, num - 1].liquid != 0 || Main.tile[checkedX + 1, num - 1].liquid != 0)
		{
			return false;
		}
		Tile tile = Main.tile[checkedX, num];
		if (!tile.nactive() || tile.halfBrick() || tile.slope() != 0)
		{
			return false;
		}
		bool flag = ignoreWalls || settings.WallTest(Main.tile[checkedX, num - 1].wall);
		if (!settings.GroundTest(tile.type) || !flag)
		{
			return false;
		}
		if ((!Main.tile[checkedX - 1, num].active() || !settings.GroundTest(Main.tile[checkedX - 1, num].type)) && (!Main.tile[checkedX + 1, num].active() || !settings.GroundTest(Main.tile[checkedX + 1, num].type)))
		{
			return false;
		}
		TileColorCache cache = Main.tile[checkedX, num].BlockColorAndCoating();
		if (Main.tenthAnniversaryWorld && !isGeneratingOrLoadingWorld && ((!Main.notTheBeesWorld && !Main.dontStarveWorld) || Main.remixWorld) && (settings.TreeTileType == 596 || settings.TreeTileType == 616))
		{
			cache.Color = (byte)genRand.Next(1, 13);
		}
		int num2 = 2;
		int num3 = genRand.Next(settings.TreeHeightMin, settings.TreeHeightMax + 1) + treeHeightAddon;
		if (SecretSeed.errorWorld.Enabled && genRand.Next(SecretSeed.Variations.errorWorldAdjustment(2.0)) == 0)
		{
			num3 = ((!((double)checkedY < Main.worldSurface)) ? genRand.Next(3, 15) : genRand.Next(3, 50));
		}
		int num4 = num3 + settings.TreeTopPaddingNeeded;
		if (!EmptyTileCheck(checkedX - num2, checkedX + num2, num - num4, num - 1, 20))
		{
			return false;
		}
		bool flag2 = false;
		bool flag3 = false;
		int num5;
		for (int i = num - num3; i < num; i++)
		{
			Tile tile2 = Main.tile[checkedX, i];
			tile2.active(active: true);
			tile2.type = settings.TreeTileType;
			tile2.UseBlockColors(cache);
			num5 = genRand.Next(3);
			int num6 = genRand.Next(10);
			if (i == num - 1 || i == num - num3)
			{
				num6 = 0;
			}
			while (((num6 == 5 || num6 == 7) && flag2) || ((num6 == 6 || num6 == 7) && flag3))
			{
				num6 = genRand.Next(10);
			}
			flag2 = false;
			flag3 = false;
			if (num6 == 5 || num6 == 7)
			{
				flag2 = true;
			}
			if (num6 == 6 || num6 == 7)
			{
				flag3 = true;
			}
			switch (num6)
			{
			case 1:
				if (num5 == 0)
				{
					tile2.frameX = 0;
					tile2.frameY = 66;
				}
				if (num5 == 1)
				{
					tile2.frameX = 0;
					tile2.frameY = 88;
				}
				if (num5 == 2)
				{
					tile2.frameX = 0;
					tile2.frameY = 110;
				}
				break;
			case 2:
				if (num5 == 0)
				{
					tile2.frameX = 22;
					tile2.frameY = 0;
				}
				if (num5 == 1)
				{
					tile2.frameX = 22;
					tile2.frameY = 22;
				}
				if (num5 == 2)
				{
					tile2.frameX = 22;
					tile2.frameY = 44;
				}
				break;
			case 3:
				if (num5 == 0)
				{
					tile2.frameX = 44;
					tile2.frameY = 66;
				}
				if (num5 == 1)
				{
					tile2.frameX = 44;
					tile2.frameY = 88;
				}
				if (num5 == 2)
				{
					tile2.frameX = 44;
					tile2.frameY = 110;
				}
				break;
			case 4:
				if (num5 == 0)
				{
					tile2.frameX = 22;
					tile2.frameY = 66;
				}
				if (num5 == 1)
				{
					tile2.frameX = 22;
					tile2.frameY = 88;
				}
				if (num5 == 2)
				{
					tile2.frameX = 22;
					tile2.frameY = 110;
				}
				break;
			case 5:
				if (num5 == 0)
				{
					tile2.frameX = 88;
					tile2.frameY = 0;
				}
				if (num5 == 1)
				{
					tile2.frameX = 88;
					tile2.frameY = 22;
				}
				if (num5 == 2)
				{
					tile2.frameX = 88;
					tile2.frameY = 44;
				}
				break;
			case 6:
				if (num5 == 0)
				{
					tile2.frameX = 66;
					tile2.frameY = 66;
				}
				if (num5 == 1)
				{
					tile2.frameX = 66;
					tile2.frameY = 88;
				}
				if (num5 == 2)
				{
					tile2.frameX = 66;
					tile2.frameY = 110;
				}
				break;
			case 7:
				if (num5 == 0)
				{
					tile2.frameX = 110;
					tile2.frameY = 66;
				}
				if (num5 == 1)
				{
					tile2.frameX = 110;
					tile2.frameY = 88;
				}
				if (num5 == 2)
				{
					tile2.frameX = 110;
					tile2.frameY = 110;
				}
				break;
			default:
				if (num5 == 0)
				{
					tile2.frameX = 0;
					tile2.frameY = 0;
				}
				if (num5 == 1)
				{
					tile2.frameX = 0;
					tile2.frameY = 22;
				}
				if (num5 == 2)
				{
					tile2.frameX = 0;
					tile2.frameY = 44;
				}
				break;
			}
			if (num6 == 5 || num6 == 7)
			{
				Tile tile3 = Main.tile[checkedX - 1, i];
				tile3.active(active: true);
				tile3.type = settings.TreeTileType;
				tile3.UseBlockColors(cache);
				num5 = genRand.Next(3);
				if (genRand.Next(3) < 2)
				{
					if (num5 == 0)
					{
						tile3.frameX = 44;
						tile3.frameY = 198;
					}
					if (num5 == 1)
					{
						tile3.frameX = 44;
						tile3.frameY = 220;
					}
					if (num5 == 2)
					{
						tile3.frameX = 44;
						tile3.frameY = 242;
					}
				}
				else
				{
					if (num5 == 0)
					{
						tile3.frameX = 66;
						tile3.frameY = 0;
					}
					if (num5 == 1)
					{
						tile3.frameX = 66;
						tile3.frameY = 22;
					}
					if (num5 == 2)
					{
						tile3.frameX = 66;
						tile3.frameY = 44;
					}
				}
			}
			if (num6 != 6 && num6 != 7)
			{
				continue;
			}
			Tile tile4 = Main.tile[checkedX + 1, i];
			tile4.active(active: true);
			tile4.type = settings.TreeTileType;
			tile4.UseBlockColors(cache);
			num5 = genRand.Next(3);
			if (genRand.Next(3) < 2)
			{
				if (num5 == 0)
				{
					tile4.frameX = 66;
					tile4.frameY = 198;
				}
				if (num5 == 1)
				{
					tile4.frameX = 66;
					tile4.frameY = 220;
				}
				if (num5 == 2)
				{
					tile4.frameX = 66;
					tile4.frameY = 242;
				}
			}
			else
			{
				if (num5 == 0)
				{
					tile4.frameX = 88;
					tile4.frameY = 66;
				}
				if (num5 == 1)
				{
					tile4.frameX = 88;
					tile4.frameY = 88;
				}
				if (num5 == 2)
				{
					tile4.frameX = 88;
					tile4.frameY = 110;
				}
			}
		}
		bool flag4 = false;
		bool flag5 = false;
		if (Main.tile[checkedX - 1, num].nactive() && !Main.tile[checkedX - 1, num].halfBrick() && Main.tile[checkedX - 1, num].slope() == 0 && IsTileTypeFitForTree(Main.tile[checkedX - 1, num].type))
		{
			flag4 = true;
		}
		if (Main.tile[checkedX + 1, num].nactive() && !Main.tile[checkedX + 1, num].halfBrick() && Main.tile[checkedX + 1, num].slope() == 0 && IsTileTypeFitForTree(Main.tile[checkedX + 1, num].type))
		{
			flag5 = true;
		}
		if (genRand.Next(3) == 0)
		{
			flag4 = false;
		}
		if (genRand.Next(3) == 0)
		{
			flag5 = false;
		}
		if (flag5)
		{
			Main.tile[checkedX + 1, num - 1].active(active: true);
			Main.tile[checkedX + 1, num - 1].type = settings.TreeTileType;
			Main.tile[checkedX + 1, num - 1].UseBlockColors(cache);
			num5 = genRand.Next(3);
			if (num5 == 0)
			{
				Main.tile[checkedX + 1, num - 1].frameX = 22;
				Main.tile[checkedX + 1, num - 1].frameY = 132;
			}
			if (num5 == 1)
			{
				Main.tile[checkedX + 1, num - 1].frameX = 22;
				Main.tile[checkedX + 1, num - 1].frameY = 154;
			}
			if (num5 == 2)
			{
				Main.tile[checkedX + 1, num - 1].frameX = 22;
				Main.tile[checkedX + 1, num - 1].frameY = 176;
			}
		}
		if (flag4)
		{
			Main.tile[checkedX - 1, num - 1].active(active: true);
			Main.tile[checkedX - 1, num - 1].type = settings.TreeTileType;
			Main.tile[checkedX - 1, num - 1].UseBlockColors(cache);
			num5 = genRand.Next(3);
			if (num5 == 0)
			{
				Main.tile[checkedX - 1, num - 1].frameX = 44;
				Main.tile[checkedX - 1, num - 1].frameY = 132;
			}
			if (num5 == 1)
			{
				Main.tile[checkedX - 1, num - 1].frameX = 44;
				Main.tile[checkedX - 1, num - 1].frameY = 154;
			}
			if (num5 == 2)
			{
				Main.tile[checkedX - 1, num - 1].frameX = 44;
				Main.tile[checkedX - 1, num - 1].frameY = 176;
			}
		}
		num5 = genRand.Next(3);
		if (flag4 && flag5)
		{
			if (num5 == 0)
			{
				Main.tile[checkedX, num - 1].frameX = 88;
				Main.tile[checkedX, num - 1].frameY = 132;
			}
			if (num5 == 1)
			{
				Main.tile[checkedX, num - 1].frameX = 88;
				Main.tile[checkedX, num - 1].frameY = 154;
			}
			if (num5 == 2)
			{
				Main.tile[checkedX, num - 1].frameX = 88;
				Main.tile[checkedX, num - 1].frameY = 176;
			}
		}
		else if (flag4)
		{
			if (num5 == 0)
			{
				Main.tile[checkedX, num - 1].frameX = 0;
				Main.tile[checkedX, num - 1].frameY = 132;
			}
			if (num5 == 1)
			{
				Main.tile[checkedX, num - 1].frameX = 0;
				Main.tile[checkedX, num - 1].frameY = 154;
			}
			if (num5 == 2)
			{
				Main.tile[checkedX, num - 1].frameX = 0;
				Main.tile[checkedX, num - 1].frameY = 176;
			}
		}
		else if (flag5)
		{
			if (num5 == 0)
			{
				Main.tile[checkedX, num - 1].frameX = 66;
				Main.tile[checkedX, num - 1].frameY = 132;
			}
			if (num5 == 1)
			{
				Main.tile[checkedX, num - 1].frameX = 66;
				Main.tile[checkedX, num - 1].frameY = 154;
			}
			if (num5 == 2)
			{
				Main.tile[checkedX, num - 1].frameX = 66;
				Main.tile[checkedX, num - 1].frameY = 176;
			}
		}
		if (genRand.Next(13) != 0)
		{
			num5 = genRand.Next(3);
			if (num5 == 0)
			{
				Main.tile[checkedX, num - num3].frameX = 22;
				Main.tile[checkedX, num - num3].frameY = 198;
			}
			if (num5 == 1)
			{
				Main.tile[checkedX, num - num3].frameX = 22;
				Main.tile[checkedX, num - num3].frameY = 220;
			}
			if (num5 == 2)
			{
				Main.tile[checkedX, num - num3].frameX = 22;
				Main.tile[checkedX, num - num3].frameY = 242;
			}
		}
		else
		{
			num5 = genRand.Next(3);
			if (num5 == 0)
			{
				Main.tile[checkedX, num - num3].frameX = 0;
				Main.tile[checkedX, num - num3].frameY = 198;
			}
			if (num5 == 1)
			{
				Main.tile[checkedX, num - num3].frameX = 0;
				Main.tile[checkedX, num - num3].frameY = 220;
			}
			if (num5 == 2)
			{
				Main.tile[checkedX, num - num3].frameX = 0;
				Main.tile[checkedX, num - num3].frameY = 242;
			}
		}
		RangeFrame(checkedX - 2, num - num3 - 1, checkedX + 2, num + 1);
		if (Main.netMode == 2)
		{
			NetMessage.SendTileSquare(-1, checkedX - 1, num - num3, 3, num3);
		}
		return true;
	}

	public static void GrowUndergroundTree(int i, int y, int treeHeightAddon = 0)
	{
		if (Main.tile[i, y].type != 60 || !Main.tile[i, y].nactive() || Main.tile[i, y].halfBrick() || Main.tile[i, y].slope() != 0 || Main.tile[i, y].type != 60 || ((!Main.tile[i - 1, y].active() || Main.tile[i - 1, y].type != 60) && (!Main.tile[i + 1, y].active() || Main.tile[i + 1, y].type != 60)))
		{
			return;
		}
		int num = 1;
		int num2 = genRand.Next(5, 15) + treeHeightAddon;
		int num3 = num2 + 2;
		if (Main.tile[i, y].type == 60)
		{
			num3 += 5;
		}
		if (!EmptyTileCheck(i - num, i + num, y - num3, y - 1, 20))
		{
			return;
		}
		bool flag = false;
		bool flag2 = false;
		int num4;
		for (int j = y - num2; j < y; j++)
		{
			Main.tile[i, j].active(active: true);
			Main.tile[i, j].type = 5;
			num4 = genRand.Next(3);
			int num5 = genRand.Next(10);
			if (j == y - 1 || j == y - num2)
			{
				num5 = 0;
			}
			while (((num5 == 5 || num5 == 7) && flag) || ((num5 == 6 || num5 == 7) && flag2))
			{
				num5 = genRand.Next(10);
			}
			flag = false;
			flag2 = false;
			if (num5 == 5 || num5 == 7)
			{
				flag = true;
			}
			if (num5 == 6 || num5 == 7)
			{
				flag2 = true;
			}
			switch (num5)
			{
			case 1:
				if (num4 == 0)
				{
					Main.tile[i, j].frameX = 0;
					Main.tile[i, j].frameY = 66;
				}
				if (num4 == 1)
				{
					Main.tile[i, j].frameX = 0;
					Main.tile[i, j].frameY = 88;
				}
				if (num4 == 2)
				{
					Main.tile[i, j].frameX = 0;
					Main.tile[i, j].frameY = 110;
				}
				break;
			case 2:
				if (num4 == 0)
				{
					Main.tile[i, j].frameX = 22;
					Main.tile[i, j].frameY = 0;
				}
				if (num4 == 1)
				{
					Main.tile[i, j].frameX = 22;
					Main.tile[i, j].frameY = 22;
				}
				if (num4 == 2)
				{
					Main.tile[i, j].frameX = 22;
					Main.tile[i, j].frameY = 44;
				}
				break;
			case 3:
				if (num4 == 0)
				{
					Main.tile[i, j].frameX = 44;
					Main.tile[i, j].frameY = 66;
				}
				if (num4 == 1)
				{
					Main.tile[i, j].frameX = 44;
					Main.tile[i, j].frameY = 88;
				}
				if (num4 == 2)
				{
					Main.tile[i, j].frameX = 44;
					Main.tile[i, j].frameY = 110;
				}
				break;
			case 4:
				if (num4 == 0)
				{
					Main.tile[i, j].frameX = 22;
					Main.tile[i, j].frameY = 66;
				}
				if (num4 == 1)
				{
					Main.tile[i, j].frameX = 22;
					Main.tile[i, j].frameY = 88;
				}
				if (num4 == 2)
				{
					Main.tile[i, j].frameX = 22;
					Main.tile[i, j].frameY = 110;
				}
				break;
			case 5:
				if (num4 == 0)
				{
					Main.tile[i, j].frameX = 88;
					Main.tile[i, j].frameY = 0;
				}
				if (num4 == 1)
				{
					Main.tile[i, j].frameX = 88;
					Main.tile[i, j].frameY = 22;
				}
				if (num4 == 2)
				{
					Main.tile[i, j].frameX = 88;
					Main.tile[i, j].frameY = 44;
				}
				break;
			case 6:
				if (num4 == 0)
				{
					Main.tile[i, j].frameX = 66;
					Main.tile[i, j].frameY = 66;
				}
				if (num4 == 1)
				{
					Main.tile[i, j].frameX = 66;
					Main.tile[i, j].frameY = 88;
				}
				if (num4 == 2)
				{
					Main.tile[i, j].frameX = 66;
					Main.tile[i, j].frameY = 110;
				}
				break;
			case 7:
				if (num4 == 0)
				{
					Main.tile[i, j].frameX = 110;
					Main.tile[i, j].frameY = 66;
				}
				if (num4 == 1)
				{
					Main.tile[i, j].frameX = 110;
					Main.tile[i, j].frameY = 88;
				}
				if (num4 == 2)
				{
					Main.tile[i, j].frameX = 110;
					Main.tile[i, j].frameY = 110;
				}
				break;
			default:
				if (num4 == 0)
				{
					Main.tile[i, j].frameX = 0;
					Main.tile[i, j].frameY = 0;
				}
				if (num4 == 1)
				{
					Main.tile[i, j].frameX = 0;
					Main.tile[i, j].frameY = 22;
				}
				if (num4 == 2)
				{
					Main.tile[i, j].frameX = 0;
					Main.tile[i, j].frameY = 44;
				}
				break;
			}
			if (num5 == 5 || num5 == 7)
			{
				Main.tile[i - 1, j].active(active: true);
				Main.tile[i - 1, j].type = 5;
				num4 = genRand.Next(3);
				if (genRand.Next(3) < 2)
				{
					if (num4 == 0)
					{
						Main.tile[i - 1, j].frameX = 44;
						Main.tile[i - 1, j].frameY = 198;
					}
					if (num4 == 1)
					{
						Main.tile[i - 1, j].frameX = 44;
						Main.tile[i - 1, j].frameY = 220;
					}
					if (num4 == 2)
					{
						Main.tile[i - 1, j].frameX = 44;
						Main.tile[i - 1, j].frameY = 242;
					}
				}
				else
				{
					if (num4 == 0)
					{
						Main.tile[i - 1, j].frameX = 66;
						Main.tile[i - 1, j].frameY = 0;
					}
					if (num4 == 1)
					{
						Main.tile[i - 1, j].frameX = 66;
						Main.tile[i - 1, j].frameY = 22;
					}
					if (num4 == 2)
					{
						Main.tile[i - 1, j].frameX = 66;
						Main.tile[i - 1, j].frameY = 44;
					}
				}
			}
			if (num5 != 6 && num5 != 7)
			{
				continue;
			}
			Main.tile[i + 1, j].active(active: true);
			Main.tile[i + 1, j].type = 5;
			num4 = genRand.Next(3);
			if (genRand.Next(3) < 2)
			{
				if (num4 == 0)
				{
					Main.tile[i + 1, j].frameX = 66;
					Main.tile[i + 1, j].frameY = 198;
				}
				if (num4 == 1)
				{
					Main.tile[i + 1, j].frameX = 66;
					Main.tile[i + 1, j].frameY = 220;
				}
				if (num4 == 2)
				{
					Main.tile[i + 1, j].frameX = 66;
					Main.tile[i + 1, j].frameY = 242;
				}
			}
			else
			{
				if (num4 == 0)
				{
					Main.tile[i + 1, j].frameX = 88;
					Main.tile[i + 1, j].frameY = 66;
				}
				if (num4 == 1)
				{
					Main.tile[i + 1, j].frameX = 88;
					Main.tile[i + 1, j].frameY = 88;
				}
				if (num4 == 2)
				{
					Main.tile[i + 1, j].frameX = 88;
					Main.tile[i + 1, j].frameY = 110;
				}
			}
		}
		int num6 = genRand.Next(3);
		bool flag3 = false;
		bool flag4 = false;
		if (Main.tile[i - 1, y].nactive() && !Main.tile[i - 1, y].halfBrick() && Main.tile[i - 1, y].slope() == 0 && (Main.tile[i - 1, y].type == 2 || Main.tile[i - 1, y].type == 23 || Main.tile[i - 1, y].type == 60 || Main.tile[i - 1, y].type == 109 || Main.tile[i - 1, y].type == 147))
		{
			flag3 = true;
		}
		if (Main.tile[i + 1, y].nactive() && !Main.tile[i + 1, y].halfBrick() && Main.tile[i + 1, y].slope() == 0 && (Main.tile[i + 1, y].type == 2 || Main.tile[i + 1, y].type == 23 || Main.tile[i + 1, y].type == 60 || Main.tile[i + 1, y].type == 109 || Main.tile[i + 1, y].type == 147))
		{
			flag4 = true;
		}
		if (!flag3)
		{
			if (num6 == 0)
			{
				num6 = 2;
			}
			if (num6 == 1)
			{
				num6 = 3;
			}
		}
		if (!flag4)
		{
			if (num6 == 0)
			{
				num6 = 1;
			}
			if (num6 == 2)
			{
				num6 = 3;
			}
		}
		if (flag3 && !flag4)
		{
			num6 = 2;
		}
		if (flag4 && !flag3)
		{
			num6 = 1;
		}
		if (num6 == 0 || num6 == 1)
		{
			Main.tile[i + 1, y - 1].active(active: true);
			Main.tile[i + 1, y - 1].type = 5;
			num4 = genRand.Next(3);
			if (num4 == 0)
			{
				Main.tile[i + 1, y - 1].frameX = 22;
				Main.tile[i + 1, y - 1].frameY = 132;
			}
			if (num4 == 1)
			{
				Main.tile[i + 1, y - 1].frameX = 22;
				Main.tile[i + 1, y - 1].frameY = 154;
			}
			if (num4 == 2)
			{
				Main.tile[i + 1, y - 1].frameX = 22;
				Main.tile[i + 1, y - 1].frameY = 176;
			}
		}
		if (num6 == 0 || num6 == 2)
		{
			Main.tile[i - 1, y - 1].active(active: true);
			Main.tile[i - 1, y - 1].type = 5;
			num4 = genRand.Next(3);
			if (num4 == 0)
			{
				Main.tile[i - 1, y - 1].frameX = 44;
				Main.tile[i - 1, y - 1].frameY = 132;
			}
			if (num4 == 1)
			{
				Main.tile[i - 1, y - 1].frameX = 44;
				Main.tile[i - 1, y - 1].frameY = 154;
			}
			if (num4 == 2)
			{
				Main.tile[i - 1, y - 1].frameX = 44;
				Main.tile[i - 1, y - 1].frameY = 176;
			}
		}
		num4 = genRand.Next(3);
		switch (num6)
		{
		case 0:
			if (num4 == 0)
			{
				Main.tile[i, y - 1].frameX = 88;
				Main.tile[i, y - 1].frameY = 132;
			}
			if (num4 == 1)
			{
				Main.tile[i, y - 1].frameX = 88;
				Main.tile[i, y - 1].frameY = 154;
			}
			if (num4 == 2)
			{
				Main.tile[i, y - 1].frameX = 88;
				Main.tile[i, y - 1].frameY = 176;
			}
			break;
		case 1:
			if (num4 == 0)
			{
				Main.tile[i, y - 1].frameX = 0;
				Main.tile[i, y - 1].frameY = 132;
			}
			if (num4 == 1)
			{
				Main.tile[i, y - 1].frameX = 0;
				Main.tile[i, y - 1].frameY = 154;
			}
			if (num4 == 2)
			{
				Main.tile[i, y - 1].frameX = 0;
				Main.tile[i, y - 1].frameY = 176;
			}
			break;
		case 2:
			if (num4 == 0)
			{
				Main.tile[i, y - 1].frameX = 66;
				Main.tile[i, y - 1].frameY = 132;
			}
			if (num4 == 1)
			{
				Main.tile[i, y - 1].frameX = 66;
				Main.tile[i, y - 1].frameY = 154;
			}
			if (num4 == 2)
			{
				Main.tile[i, y - 1].frameX = 66;
				Main.tile[i, y - 1].frameY = 176;
			}
			break;
		}
		if (genRand.Next(8) != 0)
		{
			num4 = genRand.Next(3);
			if (num4 == 0)
			{
				Main.tile[i, y - num2].frameX = 22;
				Main.tile[i, y - num2].frameY = 198;
			}
			if (num4 == 1)
			{
				Main.tile[i, y - num2].frameX = 22;
				Main.tile[i, y - num2].frameY = 220;
			}
			if (num4 == 2)
			{
				Main.tile[i, y - num2].frameX = 22;
				Main.tile[i, y - num2].frameY = 242;
			}
		}
		else
		{
			num4 = genRand.Next(3);
			if (num4 == 0)
			{
				Main.tile[i, y - num2].frameX = 0;
				Main.tile[i, y - num2].frameY = 198;
			}
			if (num4 == 1)
			{
				Main.tile[i, y - num2].frameX = 0;
				Main.tile[i, y - num2].frameY = 220;
			}
			if (num4 == 2)
			{
				Main.tile[i, y - num2].frameX = 0;
				Main.tile[i, y - num2].frameY = 242;
			}
		}
		RangeFrame(i - 2, y - num2 - 1, i + 2, y + 1);
		if (Main.netMode == 2 && !isGeneratingOrLoadingWorld)
		{
			NetMessage.SendTileSquare(-1, i - 1, y - num2, 3, num2);
		}
	}

	public static bool GrowShroom(int i, int y)
	{
		if (Main.tile[i - 1, y - 1].anyLava() || Main.tile[i - 1, y - 1].anyLava() || Main.tile[i + 1, y - 1].anyLava())
		{
			return false;
		}
		if (Main.tile[i, y].nactive() && Main.tile[i, y].type == 70 && Main.tile[i, y - 1].wall == 0 && Main.tile[i - 1, y].active() && Main.tile[i - 1, y].type == 70 && Main.tile[i + 1, y].active() && Main.tile[i + 1, y].type == 70 && EmptyTileCheck(i - 2, i + 2, y - 13, y - 3, 71) && EmptyTileCheck(i - 1, i + 1, y - 3, y - 1, 71))
		{
			if (isGeneratingOrLoadingWorld && genRand.Next(3) != 0)
			{
				Main.tile[i, y].halfBrick(halfBrick: false);
				Main.tile[i, y].slope(0);
			}
			if (!Main.tile[i, y].halfBrick() && Main.tile[i, y].slope() == 0)
			{
				int num = genRand.Next(4, 11);
				for (int j = y - num; j < y; j++)
				{
					Main.tile[i, j].active(active: true);
					Main.tile[i, j].type = 72;
					int num2 = genRand.Next(3);
					if (num2 == 0)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 0;
					}
					if (num2 == 1)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 18;
					}
					if (num2 == 2)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 36;
					}
				}
				int num3 = genRand.Next(3);
				if (num3 == 0)
				{
					Main.tile[i, y - num].frameX = 36;
					Main.tile[i, y - num].frameY = 0;
				}
				if (num3 == 1)
				{
					Main.tile[i, y - num].frameX = 36;
					Main.tile[i, y - num].frameY = 18;
				}
				if (num3 == 2)
				{
					Main.tile[i, y - num].frameX = 36;
					Main.tile[i, y - num].frameY = 36;
				}
				RangeFrame(i - 2, y - num - 1, i + 2, y + 1);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i - 1, y - num, 3, num);
				}
				return true;
			}
		}
		return false;
	}

	public static void AddTrees(bool undergroundOnly = false)
	{
		double num = 0.1 + genRand.NextDouble() * 0.35;
		double num2 = 0.1 + genRand.NextDouble() * 0.35;
		int num3 = 20;
		int num4 = (int)Main.worldSurface;
		if (!undergroundOnly)
		{
			for (int i = 1; i < Main.maxTilesX - 1; i++)
			{
				for (int j = num3; j < num4; j++)
				{
					if (i < 380)
					{
						if (genRand.NextDouble() < num && Main.tile[i, j].liquid == 0)
						{
							TryGrowingTreeByType(323, i, j);
						}
					}
					else if (i > Main.maxTilesX - 380 && genRand.NextDouble() < num2 && Main.tile[i, j].liquid == 0)
					{
						TryGrowingTreeByType(323, i, j);
					}
					int num5 = 20;
					if (drunkWorldGen)
					{
						num5 /= 3;
					}
					if (remixWorldGen)
					{
						num5 /= 2;
					}
					if (Main.tile[i, j].active() && Main.tile[i, j].type == 2 && (Main.tenthAnniversaryWorld || genRand.Next(num5) == 0))
					{
						if (genRand.Next(2) == 0)
						{
							TryGrowingTreeByType(616, i, j);
						}
						else
						{
							TryGrowingTreeByType(596, i, j);
						}
					}
					else
					{
						TryGrowingTreeByType(5, i, j);
					}
				}
				if (genRand.Next(3) == 0)
				{
					i++;
				}
				if (genRand.Next(4) == 0)
				{
					i++;
				}
			}
		}
		if (!remixWorldGen)
		{
			return;
		}
		num3 = (int)Main.worldSurface;
		num4 = Main.maxTilesY - 300;
		for (int k = 1; k < Main.maxTilesX - 1; k++)
		{
			for (int l = num3; l < num4; l++)
			{
				int maxValue = 7;
				if (Main.tile[k, l].active() && Main.tile[k, l].type == 2 && (Main.tenthAnniversaryWorld || genRand.Next(maxValue) == 0))
				{
					if (genRand.Next(2) == 0)
					{
						TryGrowingTreeByType(616, k, l);
					}
					else
					{
						TryGrowingTreeByType(596, k, l);
					}
				}
				else
				{
					TryGrowingTreeByType(5, k, l);
				}
			}
		}
	}

	public static bool EmptyTileCheck(int startX, int endX, int startY, int endY, int ignoreID = -1)
	{
		if (startX < 0)
		{
			return false;
		}
		if (endX >= Main.maxTilesX)
		{
			return false;
		}
		if (startY < 0)
		{
			return false;
		}
		if (endY >= Main.maxTilesY)
		{
			return false;
		}
		bool flag = false;
		if (ignoreID != -1 && TileID.Sets.CommonSapling[ignoreID])
		{
			flag = true;
		}
		for (int i = startX; i < endX + 1; i++)
		{
			for (int j = startY; j < endY + 1; j++)
			{
				if (!Main.tile[i, j].active())
				{
					continue;
				}
				switch (ignoreID)
				{
				case -1:
					return false;
				case 11:
				{
					ushort type = Main.tile[i, j].type;
					if (type != 11)
					{
						return false;
					}
					continue;
				}
				case 71:
				{
					ushort type = Main.tile[i, j].type;
					if (type != 71)
					{
						return false;
					}
					continue;
				}
				}
				if (flag && !TileID.Sets.CommonSapling[Main.tile[i, j].type])
				{
					switch (Main.tile[i, j].type)
					{
					case 3:
					case 24:
					case 32:
					case 61:
					case 62:
					case 69:
					case 71:
					case 73:
					case 74:
					case 82:
					case 83:
					case 84:
					case 110:
					case 113:
					case 184:
					case 201:
					case 233:
					case 352:
					case 485:
					case 529:
					case 530:
					case 637:
					case 655:
						continue;
					}
					return false;
				}
			}
		}
		return true;
	}

	public static void TryProtectingSpawnedItems()
	{
		for (int i = 0; i < 400; i++)
		{
			WorldItem worldItem = Main.item[i];
			if (EligibleForSpawnProtection(worldItem))
			{
				worldItem.timeSinceItemSpawned -= 18000;
			}
		}
	}

	private static bool EligibleForSpawnProtection(WorldItem item)
	{
		if (item.active)
		{
			return ItemID.Sets.OverflowProtectionTimeOffset[item.type] == 0;
		}
		return false;
	}

	public static void UndoSpawnedItemProtection()
	{
		for (int i = 0; i < 400; i++)
		{
			WorldItem worldItem = Main.item[i];
			if (EligibleForSpawnProtection(worldItem) && worldItem.timeSinceItemSpawned < 0)
			{
				worldItem.timeSinceItemSpawned += 18000;
			}
		}
	}

	private static void initializeHardMode()
	{
		if (Main.rand == null)
		{
			Main.rand = new UnifiedRandom((int)DateTime.Now.Ticks);
		}
		bool flag = true;
		if (Main.dualDungeonsSeed)
		{
			flag = false;
		}
		double num = (double)genRand.Next(300, 400) * 0.001;
		double num2 = (double)genRand.Next(200, 300) * 0.001;
		int num3 = (int)((double)Main.maxTilesX * num);
		int num4 = (int)((double)Main.maxTilesX * (1.0 - num));
		int num5 = 1;
		if (genRand.Next(2) == 0)
		{
			num4 = (int)((double)Main.maxTilesX * num);
			num3 = (int)((double)Main.maxTilesX * (1.0 - num));
			num5 = -1;
		}
		int num6 = 1;
		if (Main.dungeonX < Main.maxTilesX / 2)
		{
			num6 = -1;
		}
		if (num6 < 0)
		{
			if (num4 < num3)
			{
				num4 = (int)((double)Main.maxTilesX * num2);
			}
			else
			{
				num3 = (int)((double)Main.maxTilesX * num2);
			}
		}
		else if (num4 > num3)
		{
			num4 = (int)((double)Main.maxTilesX * (1.0 - num2));
		}
		else
		{
			num3 = (int)((double)Main.maxTilesX * (1.0 - num2));
		}
		if (flag)
		{
			if (Main.remixWorld)
			{
				int num7 = Main.maxTilesX / 7;
				int num8 = Main.maxTilesX / 14;
				if (Main.dungeonX < Main.maxTilesX / 2)
				{
					for (int i = Main.maxTilesX - num7 - num8; i < Main.maxTilesX; i++)
					{
						for (int j = (int)Main.worldSurface + genRand.Next(-1, 2); j < Main.maxTilesY - 10; j++)
						{
							if (i > Main.maxTilesX - num7)
							{
								Convert(i, j, 2);
							}
							else if (TileID.Sets.Crimson[Main.tile[i, j].type] || TileID.Sets.Corrupt[Main.tile[i, j].type])
							{
								Convert(i, j, 2);
							}
						}
					}
				}
				else
				{
					for (int k = 0; k < num7 + num8; k++)
					{
						for (int l = (int)Main.worldSurface + genRand.Next(-1, 2); l < Main.maxTilesY - 10; l++)
						{
							if (k < num7)
							{
								Convert(k, l, 2);
							}
							else if (TileID.Sets.Crimson[Main.tile[k, l].type] || TileID.Sets.Corrupt[Main.tile[k, l].type])
							{
								Convert(k, l, 2);
							}
						}
					}
				}
			}
			else
			{
				GERunner(num3, 0, 3 * num5, 5.0);
				GERunner(num4, 0, 3 * -num5, 5.0, good: false);
			}
		}
		double num9 = (double)Main.maxTilesX / 4200.0;
		int num10 = (int)(25.0 * num9);
		ShapeData shapeData = new ShapeData();
		int num11 = 0;
		while (num10 > 0)
		{
			if (++num11 % 15000 == 0)
			{
				num10--;
			}
			Point point = ((!(Main.worldSurface > 100.0)) ? RandomWorldPoint(20, 1, 190, 1) : RandomWorldPoint((int)Main.worldSurface - 100, 1, 190, 1));
			Tile tile = Main.tile[point.X, point.Y];
			Tile tile2 = Main.tile[point.X, point.Y - 1];
			ushort num12 = 0;
			if (TileID.Sets.Crimson[tile.type])
			{
				num12 = (ushort)(192 + genRand.Next(4));
			}
			else if (TileID.Sets.Corrupt[tile.type])
			{
				num12 = (ushort)(188 + genRand.Next(4));
			}
			else if (TileID.Sets.Hallow[tile.type])
			{
				num12 = (ushort)(200 + genRand.Next(4));
			}
			if (tile.active() && num12 != 0 && !tile2.active())
			{
				bool flag2 = WorldUtils.Gen(new Point(point.X, point.Y - 1), new ShapeFloodFill(1000), Actions.Chain(new Modifiers.IsNotSolid(), new Modifiers.OnlyWalls(0, 54, 55, 56, 57, 58, 59, 61, 185, 212, 213, 214, 215, 2, 196, 197, 198, 199, 15, 40, 71, 64, 204, 205, 206, 207, 208, 209, 210, 211, 71), new Actions.Blank().Output(shapeData)));
				if (shapeData.Count > 50 && flag2)
				{
					WorldUtils.Gen(new Point(point.X, point.Y), new ModShapes.OuterOutline(shapeData, useDiagonals: true, useInterior: true), new Actions.PlaceWall(num12));
					num10--;
				}
				shapeData.Clear();
			}
		}
	}

	public static void StartHardmode(bool force = false)
	{
		if (Main.netMode == 1 || (Main.hardMode && !force))
		{
			return;
		}
		Main.hardMode = true;
		TryProtectingSpawnedItems();
		TransformWorldOnBackgroundThread(initializeHardMode, delegate
		{
			if (Main.netMode == 0)
			{
				Main.NewText(Lang.misc[15].Value, 50, byte.MaxValue, 130);
			}
			else if (Main.netMode == 2)
			{
				ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[15].Key), new Color(50, 255, 130));
			}
			AchievementsHelper.NotifyProgressionEvent(9);
			if (Main.netMode == 2)
			{
				Netplay.ResetSections();
			}
			UndoSpawnedItemProtection();
		});
	}

	public static void TransformWorldOnBackgroundThread(Action transform, Action mainThreadFollowup)
	{
		Interlocked.Increment(ref _transformingWorld);
		Task.Factory.StartNew(delegate
		{
			try
			{
				lock (WorldFile.IOLock)
				{
					transform();
				}
			}
			finally
			{
				Interlocked.Decrement(ref _transformingWorld);
				if (mainThreadFollowup != null)
				{
					Main.QueueMainThreadAction(mainThreadFollowup);
				}
			}
		});
	}

	public static void ClearUnbreakableWallsWithPaintUpTo(int tierColor)
	{
		if (Main.netMode == 1)
		{
			return;
		}
		TransformWorldOnBackgroundThread(delegate
		{
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				for (int j = 0; j < Main.maxTilesY; j++)
				{
					Tile tile = Main.tile[i, j];
					if (tile.wall == 350 && (tile.wallColor() & 0xF) <= tierColor)
					{
						tile.wall = TileID.Sets.MatchingUnsafeWall[tile.type];
						tile.wallColor(0);
					}
				}
			}
		}, delegate
		{
			if (Main.netMode == 2)
			{
				Netplay.ResetSections();
			}
		});
	}

	public static bool PlaceDoor(int i, int j, int type, int style = 0)
	{
		int num = style / 36;
		int num2 = style % 36;
		int num3 = 54 * num;
		int num4 = 54 * num2;
		try
		{
			if (Main.tile[i, j - 2].nactive() && Main.tileSolid[Main.tile[i, j - 2].type] && SolidTile(i, j + 2))
			{
				Main.tile[i, j - 1].active(active: true);
				Main.tile[i, j - 1].type = 10;
				Main.tile[i, j - 1].frameY = (short)num4;
				Main.tile[i, j - 1].frameX = (short)(num3 + genRand.Next(3) * 18);
				Main.tile[i, j].active(active: true);
				Main.tile[i, j].type = 10;
				Main.tile[i, j].frameY = (short)(num4 + 18);
				Main.tile[i, j].frameX = (short)(num3 + genRand.Next(3) * 18);
				Main.tile[i, j + 1].active(active: true);
				Main.tile[i, j + 1].type = 10;
				Main.tile[i, j + 1].frameY = (short)(num4 + 36);
				Main.tile[i, j + 1].frameX = (short)(num3 + genRand.Next(3) * 18);
				return true;
			}
			return false;
		}
		catch
		{
			return false;
		}
	}

	public static bool CloseDoor(int i, int j, bool forced = false)
	{
		int num = 0;
		int num2 = i;
		int num3 = j;
		if (Main.tile[i, j] == null)
		{
			Main.tile[i, j] = new Tile();
		}
		int frameX = Main.tile[i, j].frameX;
		Tile tile = Main.tile[i, j];
		if (tile.type != 11)
		{
			return false;
		}
		int num4 = tile.frameY;
		int num5 = 0;
		int num6 = 0;
		while (num4 >= 54)
		{
			num4 -= 54;
			num5++;
		}
		if (frameX >= 72)
		{
			num5 += 36 * (frameX / 72);
			num6 += 54 * (frameX / 72);
		}
		num3 = j - num4 / 18;
		switch (frameX % 72)
		{
		case 0:
			num2 = i;
			num = 1;
			break;
		case 18:
			num2 = i - 1;
			num = 1;
			break;
		case 36:
			num2 = i + 1;
			num = -1;
			break;
		case 54:
			num2 = i;
			num = -1;
			break;
		}
		int num7 = num2;
		if (num == -1)
		{
			num7 = num2 - 1;
		}
		if (!forced)
		{
			for (int k = num3; k < num3 + 3; k++)
			{
				if (!Collision.EmptyTile(num2, k, ignoreTiles: true))
				{
					return false;
				}
			}
		}
		if (!ValidateTileSquareIsActiveAndOfType(num7, num3, 2, 3, 11))
		{
			return false;
		}
		for (int l = num7; l < num7 + 2; l++)
		{
			for (int m = num3; m < num3 + 3; m++)
			{
				if (Main.tile[l, m] == null)
				{
					Main.tile[l, m] = new Tile();
				}
				Tile tile2 = Main.tile[l, m];
				if (tile2.active() && tile2.type == 11)
				{
					if (l == num2)
					{
						tile2.type = 10;
						tile2.frameX = (short)(genRand.Next(3) * 18 + num6);
					}
					else
					{
						tile2.active(active: false);
					}
				}
			}
		}
		if (Main.netMode != 1 && Wiring.running)
		{
			Wiring.SkipWire(num2, num3);
			Wiring.SkipWire(num2, num3 + 1);
			Wiring.SkipWire(num2, num3 + 2);
		}
		for (int n = num2 - 1; n <= num2 + 1; n++)
		{
			for (int num8 = num3 - 1; num8 <= num3 + 2; num8++)
			{
				TileFrame(n, num8);
			}
		}
		SoundEngine.PlaySound(9, i * 16, j * 16);
		return true;
	}

	public static bool AddLifeCrystal(int i, int j)
	{
		for (int k = j; k < Main.maxTilesY; k++)
		{
			if (Main.tile[i, k].active() && Main.tileSolid[Main.tile[i, k].type])
			{
				int num = k - 1;
				if (Main.tile[i, num - 1].anyLava() || Main.tile[i - 1, num - 1].anyLava())
				{
					return false;
				}
				if (Main.tile[i, num - 1].anyShimmer())
				{
					return false;
				}
				if (!EmptyTileCheck(i - 1, i, num - 1, num))
				{
					return false;
				}
				if (Main.wallDungeon[Main.tile[i, num].wall])
				{
					return false;
				}
				if (skyblockWorldGen && IsTileNearby(i, num, 12, 50))
				{
					return false;
				}
				Tile tile = Main.tile[i - 1, num + 1];
				Tile tile2 = Main.tile[i, num + 1];
				if (!tile.nactive() || !Main.tileSolid[tile.type])
				{
					return false;
				}
				if (!tile2.nactive() || !Main.tileSolid[tile2.type])
				{
					return false;
				}
				if (tile.blockType() != 0)
				{
					tile.slope(0);
					tile.halfBrick(halfBrick: false);
				}
				if (tile2.blockType() != 0)
				{
					tile2.slope(0);
					tile2.halfBrick(halfBrick: false);
				}
				Main.tile[i - 1, num - 1].active(active: true);
				Main.tile[i - 1, num - 1].type = 12;
				Main.tile[i - 1, num - 1].frameX = 0;
				Main.tile[i - 1, num - 1].frameY = 0;
				Main.tile[i, num - 1].active(active: true);
				Main.tile[i, num - 1].type = 12;
				Main.tile[i, num - 1].frameX = 18;
				Main.tile[i, num - 1].frameY = 0;
				Main.tile[i - 1, num].active(active: true);
				Main.tile[i - 1, num].type = 12;
				Main.tile[i - 1, num].frameX = 0;
				Main.tile[i - 1, num].frameY = 18;
				Main.tile[i, num].active(active: true);
				Main.tile[i, num].type = 12;
				Main.tile[i, num].frameX = 18;
				Main.tile[i, num].frameY = 18;
				return true;
			}
		}
		return false;
	}

	public static bool AddManaCrystal(int i, int j)
	{
		for (int k = j; k < Main.maxTilesY; k++)
		{
			if (Main.tile[i, k].active() && Main.tileSolid[Main.tile[i, k].type])
			{
				int num = k - 1;
				if (Main.tile[i, num - 1].anyLava() || Main.tile[i - 1, num - 1].anyLava())
				{
					return false;
				}
				if (Main.tile[i, num - 1].anyShimmer())
				{
					return false;
				}
				if (!EmptyTileCheck(i - 1, i, num - 1, num))
				{
					return false;
				}
				if (Main.wallDungeon[Main.tile[i, num].wall])
				{
					return false;
				}
				if (skyblockWorldGen && IsTileNearby(i, num, 639, 50))
				{
					return false;
				}
				Tile tile = Main.tile[i - 1, num + 1];
				Tile tile2 = Main.tile[i, num + 1];
				if (!tile.nactive() || !Main.tileSolid[tile.type])
				{
					return false;
				}
				if (!tile2.nactive() || !Main.tileSolid[tile2.type])
				{
					return false;
				}
				if (tile.blockType() != 0)
				{
					tile.slope(0);
					tile.halfBrick(halfBrick: false);
				}
				if (tile2.blockType() != 0)
				{
					tile2.slope(0);
					tile2.halfBrick(halfBrick: false);
				}
				Main.tile[i - 1, num - 1].active(active: true);
				Main.tile[i - 1, num - 1].type = 639;
				Main.tile[i - 1, num - 1].frameX = 0;
				Main.tile[i - 1, num - 1].frameY = 0;
				Main.tile[i, num - 1].active(active: true);
				Main.tile[i, num - 1].type = 639;
				Main.tile[i, num - 1].frameX = 18;
				Main.tile[i, num - 1].frameY = 0;
				Main.tile[i - 1, num].active(active: true);
				Main.tile[i - 1, num].type = 639;
				Main.tile[i - 1, num].frameX = 0;
				Main.tile[i - 1, num].frameY = 18;
				Main.tile[i, num].active(active: true);
				Main.tile[i, num].type = 639;
				Main.tile[i, num].frameX = 18;
				Main.tile[i, num].frameY = 18;
				return true;
			}
		}
		return false;
	}

	public static void AddBeeLarva(int x, int y)
	{
		for (int i = x - 1; i <= x + 1; i++)
		{
			for (int j = y - 2; j <= y + 1; j++)
			{
				if (j != y + 1)
				{
					Main.tile[i, j].ClearTile();
					continue;
				}
				ushort wall = Main.tile[i, j].wall;
				Main.tile[i, j].ClearEverything();
				Main.tile[i, j].active(active: true);
				Main.tile[i, j].type = 225;
				Main.tile[i, j].wall = wall;
			}
		}
		PlaceTile(x, y, 231, mute: true);
	}

	public static void AddLihzahrdAltar(int x, int y)
	{
		for (int i = 0; i < 3; i++)
		{
			for (int j = 0; j < 2; j++)
			{
				int num = x + i;
				int num2 = y + j;
				ushort wall = Main.tile[num, num2].wall;
				Main.tile[num, num2].ClearEverything();
				Main.tile[num, num2].active(active: true);
				Main.tile[num, num2].type = 237;
				Main.tile[num, num2].frameX = (short)(i * 18);
				Main.tile[num, num2].frameY = (short)(j * 18);
				Main.tile[num, num2].wall = wall;
			}
			Main.tile[x + i, y + 2].ClearEverything();
			Main.tile[x + i, y + 2].active(active: true);
			Main.tile[x + i, y + 2].slope(0);
			Main.tile[x + i, y + 2].halfBrick(halfBrick: false);
			Main.tile[x + i, y + 2].type = 226;
		}
	}

	public static void AddShadowOrb(int x, int y, bool crimsonHeart)
	{
		if (x < 10 || x > Main.maxTilesX - 10 || y < 10 || y > Main.maxTilesY - 10)
		{
			return;
		}
		for (int i = x - 1; i < x + 1; i++)
		{
			for (int j = y - 1; j < y + 1; j++)
			{
				if (Main.tile[i, j].active() && Main.tile[i, j].type == 31)
				{
					return;
				}
			}
		}
		short num = 0;
		if (crimsonHeart)
		{
			num += 36;
		}
		Main.tile[x - 1, y - 1].active(active: true);
		Main.tile[x - 1, y - 1].type = 31;
		Main.tile[x - 1, y - 1].frameX = num;
		Main.tile[x - 1, y - 1].frameY = 0;
		Main.tile[x, y - 1].active(active: true);
		Main.tile[x, y - 1].type = 31;
		Main.tile[x, y - 1].frameX = (short)(18 + num);
		Main.tile[x, y - 1].frameY = 0;
		Main.tile[x - 1, y].active(active: true);
		Main.tile[x - 1, y].type = 31;
		Main.tile[x - 1, y].frameX = num;
		Main.tile[x - 1, y].frameY = 18;
		Main.tile[x, y].active(active: true);
		Main.tile[x, y].type = 31;
		Main.tile[x, y].frameX = (short)(18 + num);
		Main.tile[x, y].frameY = 18;
	}

	public static void AddHellHouses()
	{
		int num = (int)((double)Main.maxTilesX * 0.25);
		for (int i = 100; i < Main.maxTilesX - 100; i++)
		{
			if (((drunkWorldGen || remixWorldGen) && i > num && i < Main.maxTilesX - num) || (!drunkWorldGen && !remixWorldGen && (i < num || i > Main.maxTilesX - num)))
			{
				continue;
			}
			int num2 = Main.maxTilesY - 40;
			while (Main.tile[i, num2].active() || Main.tile[i, num2].liquid > 0)
			{
				num2--;
			}
			if (Main.tile[i, num2 + 1].active())
			{
				ushort num3 = (ushort)genRand.Next(75, 77);
				byte wallType = 13;
				if (genRand.Next(5) > 0)
				{
					num3 = 75;
				}
				if (num3 == 75)
				{
					wallType = 14;
				}
				if (getGoodWorldGen)
				{
					num3 = 76;
				}
				HellFort(i, num2, num3, wallType);
				i += genRand.Next(30, 130);
				if (genRand.Next(10) == 0)
				{
					i += genRand.Next(0, 200);
				}
			}
		}
		float num4 = Main.maxTilesX / 4200;
		for (int j = 0; (float)j < 200f * num4; j++)
		{
			int num5 = 0;
			bool flag = false;
			while (!flag)
			{
				num5++;
				int num6 = genRand.Next((int)((double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.8));
				int num7 = genRand.Next(Main.maxTilesY - 300, Main.maxTilesY - 20);
				if (Main.tile[num6, num7].active() && (Main.tile[num6, num7].type == 75 || Main.tile[num6, num7].type == 76))
				{
					int num8 = 0;
					if (Main.tile[num6 - 1, num7].wall > 0)
					{
						num8 = -1;
					}
					else if (Main.tile[num6 + 1, num7].wall > 0)
					{
						num8 = 1;
					}
					if (!Main.tile[num6 + num8, num7].active() && !Main.tile[num6 + num8, num7 + 1].active())
					{
						bool flag2 = false;
						for (int k = num6 - 8; k < num6 + 8; k++)
						{
							for (int l = num7 - 8; l < num7 + 8; l++)
							{
								if (Main.tile[k, l].active() && Main.tile[k, l].type == 4)
								{
									flag2 = true;
									break;
								}
							}
						}
						if (!flag2)
						{
							PlaceTile(num6 + num8, num7, 4, mute: true, forced: true, -1, 7);
							flag = true;
						}
					}
				}
				if (num5 > 1000)
				{
					flag = true;
				}
			}
		}
		double num9 = 4200000.0 / (double)Main.maxTilesX;
		for (int m = 0; (double)m < num9; m++)
		{
			int num10 = 0;
			int num11 = genRand.Next(num, Main.maxTilesX - num);
			int n = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
			while ((Main.tile[num11, n].wall != 13 && Main.tile[num11, n].wall != 14) || Main.tile[num11, n].active())
			{
				num11 = genRand.Next(num, Main.maxTilesX - num);
				n = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
				if (drunkWorldGen || remixWorldGen)
				{
					num11 = ((genRand.Next(2) != 0) ? genRand.Next(Main.maxTilesX - num, Main.maxTilesX - 50) : genRand.Next(50, num));
				}
				num10++;
				if (num10 > 100000)
				{
					break;
				}
			}
			if (num10 > 100000 || (Main.tile[num11, n].wall != 13 && Main.tile[num11, n].wall != 14) || Main.tile[num11, n].active())
			{
				continue;
			}
			for (; !SolidTile(num11, n) && n < Main.maxTilesY - 20; n++)
			{
			}
			n--;
			int num12 = num11;
			int num13 = num11;
			while (!Main.tile[num12, n].active() && SolidTile(num12, n + 1))
			{
				num12--;
			}
			num12++;
			for (; !Main.tile[num13, n].active() && SolidTile(num13, n + 1); num13++)
			{
			}
			num13--;
			int num14 = num13 - num12;
			int num15 = (num13 + num12) / 2;
			if (Main.tile[num15, n].active() || (Main.tile[num15, n].wall != 13 && Main.tile[num15, n].wall != 14) || !SolidTile(num15, n + 1))
			{
				continue;
			}
			int style = 16;
			int style2 = 13;
			int style3 = 14;
			int style4 = 49;
			int style5 = 4;
			int style6 = 8;
			int style7 = 15;
			int style8 = 9;
			int style9 = 10;
			int style10 = 17;
			int style11 = 25;
			int style12 = 25;
			int style13 = 23;
			int style14 = 25;
			int num16 = genRand.Next(13);
			int num17 = 0;
			int num18 = 0;
			if (num16 == 0)
			{
				num17 = 5;
				num18 = 4;
			}
			if (num16 == 1)
			{
				num17 = 4;
				num18 = 3;
			}
			if (num16 == 2)
			{
				num17 = 3;
				num18 = 5;
			}
			if (num16 == 3)
			{
				num17 = 4;
				num18 = 6;
			}
			if (num16 == 4)
			{
				num17 = 3;
				num18 = 3;
			}
			if (num16 == 5)
			{
				num17 = 5;
				num18 = 3;
			}
			if (num16 == 6)
			{
				num17 = 5;
				num18 = 4;
			}
			if (num16 == 7)
			{
				num17 = 5;
				num18 = 4;
			}
			if (num16 == 8)
			{
				num17 = 5;
				num18 = 4;
			}
			if (num16 == 9)
			{
				num17 = 3;
				num18 = 5;
			}
			if (num16 == 10)
			{
				num17 = 5;
				num18 = 3;
			}
			if (num16 == 11)
			{
				num17 = 2;
				num18 = 4;
			}
			if (num16 == 12)
			{
				num17 = 3;
				num18 = 3;
			}
			for (int num19 = num15 - num17; num19 <= num15 + num17; num19++)
			{
				for (int num20 = n - num18; num20 <= n; num20++)
				{
					if (Main.tile[num19, num20].active())
					{
						num16 = -1;
						break;
					}
				}
			}
			if ((double)num14 < (double)num17 * 1.75)
			{
				num16 = -1;
			}
			switch (num16)
			{
			case 0:
			{
				PlaceTile(num15, n, 14, mute: true, forced: false, -1, style2);
				int num22 = genRand.Next(6);
				if (num22 < 3)
				{
					PlaceTile(num15 + num22, n - 2, 33, mute: true, forced: false, -1, style12);
				}
				if (!Main.tile[num15, n].active())
				{
					break;
				}
				if (!Main.tile[num15 - 2, n].active())
				{
					PlaceTile(num15 - 2, n, 15, mute: true, forced: false, -1, style);
					if (Main.tile[num15 - 2, n].active())
					{
						Main.tile[num15 - 2, n].frameX += 18;
						Main.tile[num15 - 2, n - 1].frameX += 18;
					}
				}
				if (!Main.tile[num15 + 2, n].active())
				{
					PlaceTile(num15 + 2, n, 15, mute: true, forced: false, -1, style);
				}
				break;
			}
			case 1:
			{
				PlaceTile(num15, n, 18, mute: true, forced: false, -1, style3);
				int num21 = genRand.Next(4);
				if (num21 < 2)
				{
					PlaceTile(num15 + num21, n - 1, 33, mute: true, forced: false, -1, style12);
				}
				if (!Main.tile[num15, n].active())
				{
					break;
				}
				if (genRand.Next(2) == 0)
				{
					if (!Main.tile[num15 - 1, n].active())
					{
						PlaceTile(num15 - 1, n, 15, mute: true, forced: false, -1, style);
						if (Main.tile[num15 - 1, n].active())
						{
							Main.tile[num15 - 1, n].frameX += 18;
							Main.tile[num15 - 1, n - 1].frameX += 18;
						}
					}
				}
				else if (!Main.tile[num15 + 2, n].active())
				{
					PlaceTile(num15 + 2, n, 15, mute: true, forced: false, -1, style);
				}
				break;
			}
			case 2:
				PlaceTile(num15, n, 105, mute: true, forced: false, -1, style4);
				break;
			case 3:
				PlaceTile(num15, n, 101, mute: true, forced: false, -1, style5);
				break;
			case 4:
				if (genRand.Next(2) == 0)
				{
					PlaceTile(num15, n, 15, mute: true, forced: false, -1, style);
					Main.tile[num15, n].frameX += 18;
					Main.tile[num15, n - 1].frameX += 18;
				}
				else
				{
					PlaceTile(num15, n, 15, mute: true, forced: false, -1, style);
				}
				break;
			case 5:
				if (genRand.Next(2) == 0)
				{
					Place4x2(num15, n, 79, 1, style6);
				}
				else
				{
					Place4x2(num15, n, 79, -1, style6);
				}
				break;
			case 6:
				PlaceTile(num15, n, 87, mute: true, forced: false, -1, style7);
				break;
			case 7:
				PlaceTile(num15, n, 88, mute: true, forced: false, -1, style8);
				break;
			case 8:
				PlaceTile(num15, n, 89, mute: true, forced: false, -1, style9);
				break;
			case 9:
				PlaceTile(num15, n, 104, mute: true, forced: false, -1, style10);
				break;
			case 10:
				if (genRand.Next(2) == 0)
				{
					Place4x2(num15, n, 90, 1, style14);
				}
				else
				{
					Place4x2(num15, n, 90, -1, style14);
				}
				break;
			case 11:
				PlaceTile(num15, n, 93, mute: true, forced: false, -1, style13);
				break;
			case 12:
				PlaceTile(num15, n, 100, mute: true, forced: false, -1, style11);
				break;
			}
		}
		num9 = 420000.0 / (double)Main.maxTilesX;
		for (int num23 = 0; (double)num23 < num9; num23++)
		{
			int num24 = 0;
			int num25 = genRand.Next(num, Main.maxTilesX - num);
			int num26 = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
			while ((Main.tile[num25, num26].wall != 13 && Main.tile[num25, num26].wall != 14) || Main.tile[num25, num26].active())
			{
				num25 = genRand.Next(num, Main.maxTilesX - num);
				num26 = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
				if (drunkWorldGen || remixWorldGen)
				{
					num25 = ((genRand.Next(2) != 0) ? genRand.Next(Main.maxTilesX - num, Main.maxTilesX - 50) : genRand.Next(50, num));
				}
				num24++;
				if (num24 > 100000)
				{
					break;
				}
			}
			if (num24 > 100000)
			{
				continue;
			}
			int num27 = num25;
			int num28 = num25;
			int num29 = num26;
			int num30 = num26;
			int num31 = 0;
			for (int num32 = 0; num32 < 2; num32++)
			{
				num27 = num25;
				num28 = num25;
				while (!Main.tile[num27, num26].active() && (Main.tile[num27, num26].wall == 13 || Main.tile[num27, num26].wall == 14) && num27 > 10)
				{
					num27--;
				}
				num27++;
				for (; !Main.tile[num28, num26].active() && (Main.tile[num28, num26].wall == 13 || Main.tile[num28, num26].wall == 14) && num28 < Main.maxTilesX - 10; num28++)
				{
				}
				num28--;
				num25 = (num27 + num28) / 2;
				num29 = num26;
				num30 = num26;
				while (!Main.tile[num25, num29].active() && (Main.tile[num25, num29].wall == 13 || Main.tile[num25, num29].wall == 14))
				{
					num29--;
				}
				num29++;
				for (; !Main.tile[num25, num30].active() && (Main.tile[num25, num30].wall == 13 || Main.tile[num25, num30].wall == 14); num30++)
				{
				}
				num30--;
				num26 = (num29 + num30) / 2;
			}
			num27 = num25;
			num28 = num25;
			while (!Main.tile[num27, num26].active() && !Main.tile[num27, num26 - 1].active() && !Main.tile[num27, num26 + 1].active() && num27 > 10)
			{
				num27--;
			}
			num27++;
			for (; !Main.tile[num28, num26].active() && !Main.tile[num28, num26 - 1].active() && !Main.tile[num28, num26 + 1].active() && num28 < Main.maxTilesX - 10; num28++)
			{
			}
			num28--;
			num29 = num26;
			num30 = num26;
			while (!Main.tile[num25, num29].active() && !Main.tile[num25 - 1, num29].active() && !Main.tile[num25 + 1, num29].active())
			{
				num29--;
			}
			num29++;
			for (; !Main.tile[num25, num30].active() && !Main.tile[num25 - 1, num30].active() && !Main.tile[num25 + 1, num30].active(); num30++)
			{
			}
			num30--;
			num25 = (num27 + num28) / 2;
			num26 = (num29 + num30) / 2;
			int num33 = num28 - num27;
			num31 = num30 - num29;
			if (num33 <= 7 || num31 <= 5)
			{
				continue;
			}
			int num34 = 0;
			if (nearPicture2(num25, num26))
			{
				num34 = -1;
			}
			if (num34 == 0)
			{
				PaintingEntry paintingEntry = RandHellPicture();
				if (!nearPicture(num25, num26))
				{
					PlaceTile(num25, num26, paintingEntry.tileType, mute: true, forced: false, -1, paintingEntry.style);
				}
			}
		}
		int[] array = new int[3]
		{
			genRand.Next(16, 22),
			genRand.Next(16, 22),
			genRand.Next(16, 22)
		};
		while (array[1] == array[0])
		{
			array[1] = genRand.Next(16, 22);
		}
		while (array[2] == array[0] || array[2] == array[1])
		{
			array[2] = genRand.Next(16, 22);
		}
		num9 = 420000.0 / (double)Main.maxTilesX;
		for (int num35 = 0; (double)num35 < num9; num35++)
		{
			int num36 = 0;
			int num37;
			int num38;
			do
			{
				num37 = genRand.Next(num, Main.maxTilesX - num);
				num38 = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
				if (drunkWorldGen || remixWorldGen)
				{
					num37 = ((genRand.Next(2) != 0) ? genRand.Next(Main.maxTilesX - num, Main.maxTilesX - 50) : genRand.Next(50, num));
				}
				num36++;
			}
			while (num36 <= 100000 && ((Main.tile[num37, num38].wall != 13 && Main.tile[num37, num38].wall != 14) || Main.tile[num37, num38].active()));
			if (num36 > 100000)
			{
				continue;
			}
			while (!SolidTile(num37, num38) && num38 > 10)
			{
				num38--;
			}
			num38++;
			if (Main.tile[num37, num38].wall != 13 && Main.tile[num37, num38].wall != 14)
			{
				continue;
			}
			int num39 = genRand.Next(3);
			int style15 = 32;
			int style16 = 32;
			int num40;
			int num41;
			switch (num39)
			{
			default:
				num40 = 1;
				num41 = 3;
				break;
			case 1:
				num40 = 3;
				num41 = 3;
				break;
			case 2:
				num40 = 1;
				num41 = 2;
				break;
			}
			for (int num42 = num37 - 1; num42 <= num37 + num40; num42++)
			{
				for (int num43 = num38; num43 <= num38 + num41; num43++)
				{
					Tile tile = Main.tile[num37, num38];
					if (num42 < num37 || num42 == num37 + num40)
					{
						if (tile.active())
						{
							switch (tile.type)
							{
							case 10:
							case 11:
							case 34:
							case 42:
							case 91:
								num39 = -1;
								break;
							}
						}
					}
					else if (tile.active())
					{
						num39 = -1;
					}
				}
			}
			switch (num39)
			{
			case 0:
				PlaceTile(num37, num38, 91, mute: true, forced: false, -1, array[genRand.Next(3)]);
				break;
			case 1:
				PlaceTile(num37, num38, 34, mute: true, forced: false, -1, style15);
				break;
			case 2:
				PlaceTile(num37, num38, 42, mute: true, forced: false, -1, style16);
				break;
			}
		}
	}

	public static void HellFort(int i, int j, ushort tileType = 75, byte wallType = 14)
	{
		int[] array = new int[5];
		int[] array2 = new int[5];
		int[] array3 = new int[10];
		int[] array4 = new int[10];
		int num = 8;
		int num2 = 20;
		if (drunkWorldGen)
		{
			num /= 2;
			num2 *= 2;
		}
		if (SecretSeed.errorWorld.Enabled)
		{
			if (genRand.Next(15) == 0)
			{
				num2 *= 3;
			}
			if (genRand.Next(15) == 0)
			{
				j -= genRand.Next(400);
			}
		}
		array[2] = i - genRand.Next(num / 2, num2 / 2);
		array2[2] = i + genRand.Next(num / 2, num2 / 2);
		array[3] = array2[2];
		array2[3] = array[3] + genRand.Next(num, num2);
		array[4] = array2[3];
		array2[4] = array[4] + genRand.Next(num, num2);
		array2[1] = array[2];
		array[1] = array2[1] - genRand.Next(num, num2);
		array2[0] = array[1];
		array[0] = array2[0] - genRand.Next(num, num2);
		num = 6;
		num2 = 12;
		array3[3] = j - genRand.Next(num, num2);
		array4[3] = j;
		for (int k = 4; k < 10; k++)
		{
			array3[k] = array4[k - 1];
			array4[k] = array3[k] + genRand.Next(num, num2);
		}
		for (int num3 = 2; num3 >= 0; num3--)
		{
			array4[num3] = array3[num3 + 1];
			array3[num3] = array4[num3] - genRand.Next(num, num2);
		}
		bool flag = false;
		bool flag2 = false;
		bool[,] array5 = new bool[5, 10];
		int num4 = 3;
		int num5 = 3;
		for (int l = 0; l < 2; l++)
		{
			if (genRand.Next(3) == 0 || drunkWorldGen)
			{
				flag = true;
				int num6 = genRand.Next(10);
				if (num6 < num4)
				{
					num4 = num6;
				}
				if (num6 > num5)
				{
					num5 = num6;
				}
				int num7 = 1;
				if (genRand.Next(2) == 0 || drunkWorldGen)
				{
					array5[0, num6] = true;
					array5[1, num6] = true;
					num7 = 0;
				}
				else
				{
					array5[1, num6] = true;
				}
				int num8 = genRand.Next(2);
				if (num8 == 0)
				{
					num8 = -1;
				}
				int num9 = genRand.Next(10);
				while (num9 > 0 && num6 >= 0 && num6 < 10)
				{
					array5[num7, num6] = true;
					num6 += num8;
				}
			}
			if (genRand.Next(3) == 0 || drunkWorldGen)
			{
				flag2 = true;
				int num10 = genRand.Next(10);
				if (num10 < num4)
				{
					num4 = num10;
				}
				if (num10 > num5)
				{
					num5 = num10;
				}
				int num11 = 3;
				if (genRand.Next(2) == 0 || drunkWorldGen)
				{
					array5[3, num10] = true;
					array5[4, num10] = true;
					num11 = 4;
				}
				else
				{
					array5[3, num10] = true;
				}
				int num12 = genRand.Next(2);
				if (num12 == 0)
				{
					num12 = -1;
				}
				int num13 = genRand.Next(10);
				while (num13 > 0 && num10 >= 0 && num10 < 10)
				{
					array5[num11, num10] = true;
					num10 += num12;
				}
			}
		}
		for (int m = 0; m < 5; m++)
		{
			int num14 = array[m];
			bool flag3 = false;
			if (num14 < 10 || num14 > Main.maxTilesX - 10)
			{
				flag3 = true;
			}
			else
			{
				for (int n = Main.UnderworldLayer; n < Main.maxTilesY; n++)
				{
					if (Main.tile[num14, n].wall > 0)
					{
						flag3 = true;
					}
				}
			}
			if (flag3)
			{
				for (int num15 = 0; num15 < 10; num15++)
				{
					array5[m, num15] = false;
				}
			}
		}
		int num16 = genRand.Next(10);
		if (num16 < num4)
		{
			num4 = num16;
		}
		num16 = genRand.Next(10);
		if (num16 > num5)
		{
			num5 = num16;
		}
		if (!flag && !flag2)
		{
			while (num5 - num4 < 5)
			{
				num16 = genRand.Next(10);
				if (num16 < num4)
				{
					num4 = num16;
				}
				num16 = genRand.Next(10);
				if (num16 > num5)
				{
					num5 = num16;
				}
			}
		}
		for (int num17 = num4; num17 <= num5; num17++)
		{
			array5[2, num17] = true;
		}
		for (int num18 = 0; num18 < 5; num18++)
		{
			for (int num19 = 0; num19 < 10; num19++)
			{
				if (array5[num18, num19])
				{
					if (array3[num19] < Main.UnderworldLayer && !SecretSeed.errorWorld.Enabled)
					{
						array5[num18, num19] = false;
					}
					if (array4[num19] > Main.maxTilesY - 20)
					{
						array5[num18, num19] = false;
					}
				}
			}
		}
		for (int num20 = 0; num20 < 5; num20++)
		{
			for (int num21 = 0; num21 < 10; num21++)
			{
				if (!array5[num20, num21])
				{
					continue;
				}
				for (int num22 = array[num20]; num22 <= array2[num20]; num22++)
				{
					for (int num23 = array3[num21]; num23 <= array4[num21] && InWorld(num22, num23, 10); num23++)
					{
						Main.tile[num22, num23].liquid = 0;
						if (num22 == array[num20] || num22 == array2[num20] || num23 == array3[num21] || num23 == array4[num21])
						{
							Main.tile[num22, num23].active(active: true);
							Main.tile[num22, num23].type = tileType;
							Main.tile[num22, num23].halfBrick(halfBrick: false);
							Main.tile[num22, num23].slope(0);
						}
						else
						{
							Main.tile[num22, num23].wall = wallType;
							Main.tile[num22, num23].active(active: false);
						}
					}
				}
			}
		}
		int style = 19;
		int style2 = 13;
		for (int num24 = 0; num24 < 4; num24++)
		{
			bool[] array6 = new bool[10];
			bool flag4 = false;
			for (int num25 = 0; num25 < 10; num25++)
			{
				if (array5[num24, num25] && array5[num24 + 1, num25])
				{
					array6[num25] = true;
					flag4 = true;
				}
			}
			while (flag4)
			{
				int num26 = genRand.Next(10);
				if (array6[num26])
				{
					flag4 = false;
					if (InWorld(array2[num24], array4[num26], 10))
					{
						Main.tile[array2[num24], array4[num26] - 1].active(active: false);
						Main.tile[array2[num24], array4[num26] - 2].active(active: false);
						Main.tile[array2[num24], array4[num26] - 3].active(active: false);
						Main.tile[array2[num24], array4[num26] - 1].wall = wallType;
						Main.tile[array2[num24], array4[num26] - 2].wall = wallType;
						Main.tile[array2[num24], array4[num26] - 3].wall = wallType;
						PlaceTile(array2[num24], array4[num26] - 1, 10, mute: true, forced: false, -1, style);
					}
				}
			}
		}
		for (int num27 = 0; num27 < 5; num27++)
		{
			for (int num28 = 0; num28 < 10; num28++)
			{
				if (!array5[num27, num28] || !InWorld(array2[num27], array4[num28], 10))
				{
					continue;
				}
				if (num28 > 0 && array5[num27, num28 - 1])
				{
					int num29 = genRand.Next(array[num27] + 2, array2[num27] - 1);
					int num30 = genRand.Next(array[num27] + 2, array2[num27] - 1);
					int num31 = 0;
					while (num30 - num29 < 2 || num30 - num29 > 5)
					{
						num29 = genRand.Next(array[num27] + 2, array2[num27] - 1);
						num30 = genRand.Next(array[num27] + 2, array2[num27] - 1);
						num31++;
						if (num31 > 10000)
						{
							break;
						}
					}
					if (num31 > 10000)
					{
						break;
					}
					for (int num32 = num29; num32 <= num30 && num32 >= 20 && num32 <= Main.maxTilesX - 20 && InWorld(num32, array3[num28], 5); num32++)
					{
						Main.tile[num32, array3[num28]].active(active: false);
						PlaceTile(num32, array3[num28], 19, mute: true, forced: true, -1, style2);
						Main.tile[num32, array3[num28]].wall = wallType;
					}
				}
				if (num27 < 4 && array5[num27 + 1, num28] && genRand.Next(3) == 0)
				{
					Main.tile[array2[num27], array4[num28] - 1].active(active: false);
					Main.tile[array2[num27], array4[num28] - 2].active(active: false);
					Main.tile[array2[num27], array4[num28] - 3].active(active: false);
					Main.tile[array2[num27], array4[num28] - 1].wall = wallType;
					Main.tile[array2[num27], array4[num28] - 2].wall = wallType;
					Main.tile[array2[num27], array4[num28] - 3].wall = wallType;
					PlaceTile(array2[num27], array4[num28] - 1, 10, mute: true, forced: false, -1, style);
				}
			}
		}
		bool flag5 = false;
		for (int num33 = 0; num33 < 5; num33++)
		{
			bool[] array7 = new bool[10];
			for (int num34 = 0; num34 < 10; num34++)
			{
				if (array5[num33, num34])
				{
					flag5 = true;
					array7[num34] = true;
				}
			}
			if (!flag5)
			{
				continue;
			}
			bool flag6 = false;
			for (int num35 = 0; num35 < 10; num35++)
			{
				if (array7[num35])
				{
					if (!Main.tile[array[num33] - 1, array4[num35] - 1].active() && !Main.tile[array[num33] - 1, array4[num35] - 2].active() && !Main.tile[array[num33] - 1, array4[num35] - 3].active() && Main.tile[array[num33] - 1, array4[num35] - 1].liquid == 0 && Main.tile[array[num33] - 1, array4[num35] - 2].liquid == 0 && Main.tile[array[num33] - 1, array4[num35] - 3].liquid == 0)
					{
						flag6 = true;
					}
					else
					{
						array7[num35] = false;
					}
				}
			}
			while (flag6)
			{
				int num36 = genRand.Next(10);
				if (array7[num36])
				{
					flag6 = false;
					Main.tile[array[num33], array4[num36] - 1].active(active: false);
					Main.tile[array[num33], array4[num36] - 2].active(active: false);
					Main.tile[array[num33], array4[num36] - 3].active(active: false);
					PlaceTile(array[num33], array4[num36] - 1, 10, mute: true, forced: false, -1, style);
				}
			}
			break;
		}
		bool flag7 = false;
		for (int num37 = 4; num37 >= 0; num37--)
		{
			bool[] array8 = new bool[10];
			for (int num38 = 0; num38 < 10; num38++)
			{
				if (array5[num37, num38])
				{
					flag7 = true;
					array8[num38] = true;
				}
			}
			if (flag7)
			{
				bool flag8 = false;
				for (int num39 = 0; num39 < 10; num39++)
				{
					if (array8[num39])
					{
						if (num37 < 20 || num37 > Main.maxTilesX - 20)
						{
							break;
						}
						if (!Main.tile[array2[num37] + 1, array4[num39] - 1].active() && !Main.tile[array2[num37] + 1, array4[num39] - 2].active() && !Main.tile[array2[num37] + 1, array4[num39] - 3].active() && Main.tile[array2[num37] + 1, array4[num39] - 1].liquid == 0 && Main.tile[array2[num37] + 1, array4[num39] - 2].liquid == 0 && Main.tile[array2[num37] + 1, array4[num39] - 3].liquid == 0)
						{
							flag8 = true;
						}
						else
						{
							array8[num39] = false;
						}
					}
				}
				while (flag8)
				{
					int num40 = genRand.Next(10);
					if (array8[num40])
					{
						flag8 = false;
						Main.tile[array2[num37], array4[num40] - 1].active(active: false);
						Main.tile[array2[num37], array4[num40] - 2].active(active: false);
						Main.tile[array2[num37], array4[num40] - 3].active(active: false);
						PlaceTile(array2[num37], array4[num40] - 1, 10, mute: true, forced: false, -1, style);
					}
				}
				break;
			}
		}
		bool flag9 = false;
		for (int num41 = 0; num41 < 10; num41++)
		{
			bool[] array9 = new bool[10];
			for (int num42 = 0; num42 < 5; num42++)
			{
				if (array5[num42, num41])
				{
					flag9 = true;
					array9[num42] = true;
				}
			}
			if (!flag9)
			{
				continue;
			}
			bool flag10 = true;
			while (flag10)
			{
				int num43 = genRand.Next(5);
				if (!array9[num43])
				{
					continue;
				}
				int num44 = genRand.Next(array[num43] + 2, array2[num43] - 1);
				int num45 = genRand.Next(array[num43] + 2, array2[num43] - 1);
				int num46 = 0;
				while (num45 - num44 < 2 || num45 - num44 > 5)
				{
					num44 = genRand.Next(array[num43] + 2, array2[num43] - 1);
					num45 = genRand.Next(array[num43] + 2, array2[num43] - 1);
					num46++;
					if (num46 > 10000)
					{
						break;
					}
				}
				if (num46 > 10000)
				{
					break;
				}
				for (int num47 = num44; num47 <= num45 && num47 >= 10 && num47 <= Main.maxTilesX - 10; num47++)
				{
					if (Main.tile[num47, array3[num41] - 1].active() || Main.tile[num47, array3[num41] - 1].liquid > 0)
					{
						flag10 = false;
					}
				}
				if (flag10)
				{
					for (int num48 = num44; num48 <= num45 && num48 >= 10 && num48 <= Main.maxTilesX - 10; num48++)
					{
						Main.tile[num48, array3[num41]].active(active: false);
						PlaceTile(num48, array3[num41], 19, mute: true, forced: true, -1, style2);
					}
				}
				flag10 = false;
			}
			break;
		}
	}

	public static void HellHouse(int i, int j, byte type = 76, byte wall = 13)
	{
		int num = genRand.Next(8, 20);
		int num2 = genRand.Next(1, 3);
		int num3 = genRand.Next(4, 13);
		int num4 = j;
		for (int k = 0; k < num2; k++)
		{
			int num5 = genRand.Next(5, 9);
			HellRoom(i, num4, num, num5, type, wall);
			num4 -= num5;
		}
		num4 = j;
		for (int l = 0; l < num3; l++)
		{
			int num6 = genRand.Next(5, 9);
			num4 += num6;
			HellRoom(i, num4, num, num6, type, wall);
		}
		for (int m = i - num / 2; m <= i + num / 2; m++)
		{
			for (num4 = j; num4 < Main.maxTilesY && ((Main.tile[m, num4].active() && (Main.tile[m, num4].type == 76 || Main.tile[m, num4].type == 75)) || Main.tile[i, num4].wall == 13 || Main.tile[i, num4].wall == 14); num4++)
			{
			}
			int num7 = 6 + genRand.Next(3);
			while (num4 < Main.maxTilesY && !Main.tile[m, num4].active())
			{
				num7--;
				Main.tile[m, num4].active(active: true);
				Main.tile[m, num4].type = 57;
				num4++;
				if (num7 <= 0)
				{
					break;
				}
			}
		}
		int num8 = 0;
		int num9 = 0;
		for (num4 = j; num4 < Main.maxTilesY && ((Main.tile[i, num4].active() && (Main.tile[i, num4].type == 76 || Main.tile[i, num4].type == 75)) || Main.tile[i, num4].wall == 13 || Main.tile[i, num4].wall == 14); num4++)
		{
		}
		num4--;
		num9 = num4;
		while ((Main.tile[i, num4].active() && (Main.tile[i, num4].type == 76 || Main.tile[i, num4].type == 75)) || Main.tile[i, num4].wall == 13 || Main.tile[i, num4].wall == 14)
		{
			num4--;
			if (!Main.tile[i, num4].active() || (Main.tile[i, num4].type != 76 && Main.tile[i, num4].type != 75))
			{
				continue;
			}
			int num10 = genRand.Next(i - num / 2 + 1, i + num / 2 - 1);
			int num11 = genRand.Next(i - num / 2 + 1, i + num / 2 - 1);
			if (num10 > num11)
			{
				int num12 = num10;
				num10 = num11;
				num11 = num12;
			}
			if (num10 == num11)
			{
				if (num10 < i)
				{
					num11++;
				}
				else
				{
					num10--;
				}
			}
			for (int n = num10; n <= num11; n++)
			{
				if (Main.tile[n, num4 - 1].wall == 13)
				{
					Main.tile[n, num4].wall = 13;
				}
				if (Main.tile[n, num4 - 1].wall == 14)
				{
					Main.tile[n, num4].wall = 14;
				}
				Main.tile[n, num4].type = 19;
				Main.tile[n, num4].active(active: true);
			}
			num4--;
		}
		num8 = num4;
		double num13 = (double)((num9 - num8) * num) * 0.02;
		for (int num14 = 0; (double)num14 < num13; num14++)
		{
			int num15 = genRand.Next(i - num / 2, i + num / 2 + 1);
			int num16 = genRand.Next(num8, num9);
			int num17 = genRand.Next(3, 8);
			for (int num18 = num15 - num17; num18 <= num15 + num17; num18++)
			{
				for (int num19 = num16 - num17; num19 <= num16 + num17; num19++)
				{
					double num20 = Math.Abs(num18 - num15);
					double num21 = Math.Abs(num19 - num16);
					if (!(Math.Sqrt(num20 * num20 + num21 * num21) < (double)num17 * 0.4))
					{
						continue;
					}
					try
					{
						if (Main.tile[num18, num19].type == 76 || Main.tile[num18, num19].type == 19)
						{
							Main.tile[num18, num19].active(active: false);
						}
						Main.tile[num18, num19].wall = 0;
					}
					catch
					{
					}
				}
			}
		}
	}

	public static void HellRoom(int i, int j, int width, int height, byte type = 76, byte wall = 13)
	{
		if (j > Main.maxTilesY - 40)
		{
			return;
		}
		for (int k = i - width / 2; k <= i + width / 2; k++)
		{
			for (int l = j - height; l <= j; l++)
			{
				try
				{
					Main.tile[k, l].active(active: true);
					Main.tile[k, l].type = type;
					Main.tile[k, l].liquid = 0;
					Main.tile[k, l].lava(lava: false);
				}
				catch
				{
				}
			}
		}
		for (int m = i - width / 2 + 1; m <= i + width / 2 - 1; m++)
		{
			for (int n = j - height + 1; n <= j - 1; n++)
			{
				try
				{
					Main.tile[m, n].active(active: false);
					Main.tile[m, n].wall = wall;
					Main.tile[m, n].liquid = 0;
					Main.tile[m, n].lava(lava: false);
				}
				catch
				{
				}
			}
		}
	}

	public static void templeCleaner(int x, int y)
	{
		int num = 0;
		if (Main.tile[x + 1, y].active() && Main.tile[x + 1, y].type == 226)
		{
			num++;
		}
		if (Main.tile[x - 1, y].active() && Main.tile[x - 1, y].type == 226)
		{
			num++;
		}
		if (Main.tile[x, y + 1].active() && Main.tile[x, y + 1].type == 226)
		{
			num++;
		}
		if (Main.tile[x, y - 1].active() && Main.tile[x, y - 1].type == 226)
		{
			num++;
		}
		if (Main.tile[x, y].active() && Main.tile[x, y].type == 226)
		{
			if (num <= 1)
			{
				Main.tile[x, y].active(active: false);
				Main.tile[x, y].wall = 87;
			}
		}
		else if (!Main.tile[x, y].active() && num == 3)
		{
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].type = 226;
			Main.tile[x, y].liquid = 0;
			Main.tile[x, y].slope(0);
			Main.tile[x, y].halfBrick(halfBrick: false);
		}
	}

	public static Vector2D templePather(Vector2D templePath, int destX, int destY)
	{
		int num = (int)templePath.X;
		int num2 = (int)templePath.Y;
		int num3 = genRand.Next(5, 20);
		int num4 = genRand.Next(2, 5);
		while (num3 > 0 && (num != destX || num2 != destY))
		{
			num3--;
			if (num > destX)
			{
				num--;
			}
			if (num < destX)
			{
				num++;
			}
			if (num2 > destY)
			{
				num2--;
			}
			if (num2 < destY)
			{
				num2++;
			}
			for (int i = num - num4; i < num + num4; i++)
			{
				for (int j = num2 - num4; j < num2 + num4; j++)
				{
					Main.tile[i, j].active(active: false);
					Main.tile[i, j].wall = 87;
				}
			}
		}
		return new Vector2D(num, num2);
	}

	public static void outerTempled(int x, int y)
	{
		if ((Main.tile[x, y].active() & (Main.tile[x, y].type == 226)) || Main.tile[x, y].wall == 87)
		{
			return;
		}
		int num = 6;
		for (int i = x - num; i <= x + num; i++)
		{
			for (int j = y - num; j <= y + num; j++)
			{
				if (!Main.tile[i, j].active() && Main.tile[i, j].wall == 87)
				{
					i = x;
					j = y;
					Main.tile[i, j].active(active: true);
					Main.tile[i, j].type = 226;
					Main.tile[i, j].liquid = 0;
					Main.tile[i, j].slope(0);
					Main.tile[i, j].halfBrick(halfBrick: false);
					return;
				}
			}
		}
	}

	public static void makeTemple(int x, int y, GenerationProgress progress = null)
	{
		double num = (double)Main.maxTilesX / 4200.0;
		int num2 = genRand.Next((int)(num * 10.0), (int)(num * 16.0));
		if (drunkWorldGen)
		{
			num2 *= 3;
		}
		else if (getGoodWorldGen)
		{
			num2 *= 3;
		}
		else if (remixWorldGen)
		{
			num2 *= 2;
		}
		Rectangle[] array = new Rectangle[num2 + 10];
		int num3 = 1;
		if (genRand.Next(2) == 0)
		{
			num3 = -1;
		}
		int num4 = num3;
		int num5 = x;
		int num6 = y;
		int num7 = x;
		int num8 = y;
		int num9 = genRand.Next(1, 3);
		int num10 = 0;
		float num11 = 11f;
		float num12 = 1f / num11;
		for (int i = 0; i < num2; i++)
		{
			if (progress != null)
			{
				float num13 = (float)i / (float)num2;
				progress.Set(num13 * num12);
			}
			num10++;
			int num14 = num3;
			int num15 = num7;
			int num16 = num8;
			bool flag = true;
			int num17 = 0;
			int num18 = 0;
			int num19 = -10;
			Rectangle rectangle = new Rectangle(num15 - num17 / 2, num16 - num18 / 2, num17, num18);
			while (flag)
			{
				num15 = num7;
				num16 = num8;
				num17 = genRand.Next(25, 50);
				num18 = genRand.Next(20, 35);
				if (num18 > num17)
				{
					num18 = num17;
				}
				bool flag2 = num16 + 70 >= Main.UnderworldLayer - 10;
				if (i == num2 - 1 || flag2)
				{
					num2 = i + 1;
					num17 = genRand.Next(55, 65);
					num18 = genRand.Next(45, 50);
					if (num18 > num17)
					{
						num18 = num17;
					}
					num17 = (int)((double)num17 * 1.6);
					num18 = (int)((double)num18 * 1.35);
					num16 += genRand.Next(5, 10);
				}
				if (num10 > num9)
				{
					num16 += genRand.Next(num18 + 1, num18 + 3) + num19;
					num15 += genRand.Next(-5, 6);
					num14 = num3 * -1;
				}
				else
				{
					num15 += (genRand.Next(num17 + 1, num17 + 3) + num19) * num14;
					num16 += genRand.Next(-5, 6);
				}
				flag = false;
				int x2 = num15 - num17 / 2;
				int y2 = num16 - num18 / 2;
				rectangle = new Rectangle(x2, y2, num17, num18);
				if (flag2)
				{
					break;
				}
				for (int j = 0; j < i; j++)
				{
					if (rectangle.Intersects(array[j]))
					{
						flag = true;
					}
					if (genRand.Next(100) == 0)
					{
						num19++;
					}
				}
			}
			if (num10 > num9)
			{
				num9++;
				num10 = 1;
			}
			array[i] = rectangle;
			num3 = num14;
			num7 = num15;
			num8 = num16;
		}
		for (int k = 0; k < num2; k++)
		{
			if (progress != null)
			{
				float num20 = (float)k / (float)num2;
				progress.Set(num12 + num20 * num12 * 5f);
			}
			for (int l = 0; l < 2; l++)
			{
				for (int m = 0; m < num2; m++)
				{
					for (int n = 0; n < 2; n++)
					{
						int num21 = array[k].X;
						if (l == 1)
						{
							num21 += array[k].Width - 1;
						}
						int num22 = array[k].Y;
						int num23 = num22 + array[k].Height;
						int num24 = array[m].X;
						if (n == 1)
						{
							num24 += array[m].Width - 1;
						}
						int y3 = array[m].Y;
						int num25 = y3 + array[m].Height;
						while (num21 != num24 || num22 != y3 || num23 != num25)
						{
							if (num21 < num24)
							{
								num21++;
							}
							if (num21 > num24)
							{
								num21--;
							}
							if (num22 < y3)
							{
								num22++;
							}
							if (num22 > y3)
							{
								num22--;
							}
							if (num23 < num25)
							{
								num23++;
							}
							if (num23 > num25)
							{
								num23--;
							}
							int num26 = num21;
							for (int num27 = num22; num27 < num23; num27++)
							{
								Main.tile[num26, num27].active(active: true);
								Main.tile[num26, num27].type = 226;
								Main.tile[num26, num27].liquid = 0;
								Main.tile[num26, num27].slope(0);
								Main.tile[num26, num27].halfBrick(halfBrick: false);
							}
						}
					}
				}
			}
		}
		for (int num28 = 0; num28 < num2; num28++)
		{
			if (progress != null)
			{
				float num29 = (float)num28 / (float)num2;
				progress.Set(num12 * 6f + num29 * num12);
			}
			if (false)
			{
				continue;
			}
			for (int num30 = array[num28].X; num30 < array[num28].X + array[num28].Width; num30++)
			{
				for (int num31 = array[num28].Y; num31 < array[num28].Y + array[num28].Height; num31++)
				{
					Main.tile[num30, num31].active(active: true);
					Main.tile[num30, num31].type = 226;
					Main.tile[num30, num31].liquid = 0;
					Main.tile[num30, num31].slope(0);
					Main.tile[num30, num31].halfBrick(halfBrick: false);
				}
			}
			int x3 = array[num28].X;
			int num32 = x3 + array[num28].Width;
			int y4 = array[num28].Y;
			int num33 = y4 + array[num28].Height;
			x3 += genRand.Next(3, 8);
			num32 -= genRand.Next(3, 8);
			y4 += genRand.Next(3, 8);
			num33 -= genRand.Next(3, 8);
			int num34 = x3;
			int num35 = num32;
			int num36 = y4;
			int num37 = num33;
			int num38 = (x3 + num32) / 2;
			int num39 = (y4 + num33) / 2;
			for (int num40 = x3; num40 < num32; num40++)
			{
				for (int num41 = y4; num41 < num33; num41++)
				{
					if (genRand.Next(20) == 0)
					{
						num36 += genRand.Next(-1, 2);
					}
					if (genRand.Next(20) == 0)
					{
						num37 += genRand.Next(-1, 2);
					}
					if (genRand.Next(20) == 0)
					{
						num34 += genRand.Next(-1, 2);
					}
					if (genRand.Next(20) == 0)
					{
						num35 += genRand.Next(-1, 2);
					}
					if (num34 < x3)
					{
						num34 = x3;
					}
					if (num35 > num32)
					{
						num35 = num32;
					}
					if (num36 < y4)
					{
						num36 = y4;
					}
					if (num37 > num33)
					{
						num37 = num33;
					}
					if (num34 > num38)
					{
						num34 = num38;
					}
					if (num35 < num38)
					{
						num35 = num38;
					}
					if (num36 > num39)
					{
						num36 = num39;
					}
					if (num37 < num39)
					{
						num37 = num39;
					}
					if (num40 >= num34 && num40 < num35 && num41 >= num36 && num41 <= num37)
					{
						Main.tile[num40, num41].active(active: false);
						Main.tile[num40, num41].wall = 87;
					}
				}
			}
			for (int num42 = num33; num42 > y4; num42--)
			{
				for (int num43 = num32; num43 > x3; num43--)
				{
					if (genRand.Next(20) == 0)
					{
						num36 += genRand.Next(-1, 2);
					}
					if (genRand.Next(20) == 0)
					{
						num37 += genRand.Next(-1, 2);
					}
					if (genRand.Next(20) == 0)
					{
						num34 += genRand.Next(-1, 2);
					}
					if (genRand.Next(20) == 0)
					{
						num35 += genRand.Next(-1, 2);
					}
					if (num34 < x3)
					{
						num34 = x3;
					}
					if (num35 > num32)
					{
						num35 = num32;
					}
					if (num36 < y4)
					{
						num36 = y4;
					}
					if (num37 > num33)
					{
						num37 = num33;
					}
					if (num34 > num38)
					{
						num34 = num38;
					}
					if (num35 < num38)
					{
						num35 = num38;
					}
					if (num36 > num39)
					{
						num36 = num39;
					}
					if (num37 < num39)
					{
						num37 = num39;
					}
					if (num43 >= num34 && num43 < num35 && num42 >= num36 && num42 <= num37)
					{
						Main.tile[num43, num42].active(active: false);
						Main.tile[num43, num42].wall = 87;
					}
				}
			}
		}
		Vector2D templePath = new Vector2D(num5, num6);
		for (int num44 = 0; num44 < num2; num44++)
		{
			if (progress != null)
			{
				float num45 = (float)num44 / (float)num2;
				progress.Set(num12 * 7f + num45 * num12);
			}
			Rectangle rectangle2 = array[num44];
			rectangle2.X += 8;
			rectangle2.Y += 8;
			rectangle2.Width -= 16;
			rectangle2.Height -= 16;
			bool flag3 = true;
			while (flag3)
			{
				int num46 = genRand.Next(rectangle2.X, rectangle2.X + rectangle2.Width);
				int num47 = genRand.Next(rectangle2.Y, rectangle2.Y + rectangle2.Height);
				if (num44 == num2 - 1)
				{
					num46 = rectangle2.X + rectangle2.Width / 2 + genRand.Next(-10, 10);
					num47 = rectangle2.Y + rectangle2.Height / 2 + genRand.Next(-10, 10);
				}
				templePath = templePather(templePath, num46, num47);
				if (templePath.X == (double)num46 && templePath.Y == (double)num47)
				{
					flag3 = false;
				}
			}
			if (num44 >= num2 - 1)
			{
				continue;
			}
			if (genRand.Next(3) != 0)
			{
				int num48 = num44 + 1;
				if (array[num48].Y >= array[num44].Y + array[num44].Height)
				{
					rectangle2.X = array[num48].X;
					if (num44 == 0)
					{
						if (num3 > 0)
						{
							rectangle2.X += (int)((double)array[num48].Width * 0.8);
						}
						else
						{
							rectangle2.X += (int)((double)array[num48].Width * 0.2);
						}
					}
					else if (array[num48].X < array[num44].X)
					{
						rectangle2.X += (int)((double)array[num48].Width * 0.2);
					}
					else
					{
						rectangle2.X += (int)((double)array[num48].Width * 0.8);
					}
					rectangle2.Y = array[num48].Y;
				}
				else
				{
					rectangle2.X = (array[num44].X + array[num44].Width / 2 + array[num48].X + array[num48].Width / 2) / 2;
					rectangle2.Y = (int)((double)array[num48].Y + (double)array[num48].Height * 0.8);
				}
				int x4 = rectangle2.X;
				int y5 = rectangle2.Y;
				flag3 = true;
				while (flag3)
				{
					int num49 = genRand.Next(x4 - 6, x4 + 7);
					int num50 = genRand.Next(y5 - 6, y5 + 7);
					templePath = templePather(templePath, num49, num50);
					if (templePath.X == (double)num49 && templePath.Y == (double)num50)
					{
						flag3 = false;
					}
				}
				continue;
			}
			int num51 = num44 + 1;
			int num52 = (array[num44].X + array[num44].Width / 2 + array[num51].X + array[num51].Width / 2) / 2;
			int num53 = (array[num44].Y + array[num44].Height / 2 + array[num51].Y + array[num51].Height / 2) / 2;
			flag3 = true;
			while (flag3)
			{
				int num54 = genRand.Next(num52 - 6, num52 + 7);
				int num55 = genRand.Next(num53 - 6, num53 + 7);
				templePath = templePather(templePath, num54, num55);
				if (templePath.X == (double)num54 && templePath.Y == (double)num55)
				{
					flag3 = false;
				}
			}
		}
		int num56 = Main.maxTilesX - 20;
		int num57 = 20;
		int num58 = Main.maxTilesY - 20;
		int num59 = 20;
		for (int num60 = 0; num60 < num2; num60++)
		{
			if (array[num60].X != 0 && array[num60].Y != 0 && array[num60].Width != 0 && array[num60].Height != 0)
			{
				if (array[num60].X < num56)
				{
					num56 = array[num60].X;
				}
				if (array[num60].X + array[num60].Width > num57)
				{
					num57 = array[num60].X + array[num60].Width;
				}
				if (array[num60].Y < num58)
				{
					num58 = array[num60].Y;
				}
				if (array[num60].Y + array[num60].Height > num59)
				{
					num59 = array[num60].Y + array[num60].Height;
				}
			}
		}
		num56 -= 10;
		num57 += 10;
		num58 -= 10;
		num59 += 10;
		float num61 = num12 / 4f;
		for (int num62 = num56; num62 < num57; num62++)
		{
			if (progress != null)
			{
				float num63 = (float)num62 / (float)num57;
				progress.Set(num12 * 8f + num63 * num61);
			}
			for (int num64 = num58; num64 < num59; num64++)
			{
				outerTempled(num62, num64);
			}
		}
		for (int num65 = num57; num65 >= num56; num65--)
		{
			if (progress != null)
			{
				float num66 = 1f - (float)num65 / (float)num57;
				progress.Set(num12 * 8f + num61 + num66 * num61);
			}
			for (int num67 = num58; num67 < num59; num67++)
			{
				outerTempled(num65, num67);
			}
		}
		for (int num68 = num58; num68 < num59; num68++)
		{
			if (progress != null)
			{
				float num69 = (float)num68 / (float)num59;
				progress.Set(num12 * 8f + num61 * 2f + num69 * num61);
			}
			for (int num70 = num56; num70 < num57; num70++)
			{
				outerTempled(num70, num68);
			}
		}
		for (int num71 = num59; num71 >= num58; num71--)
		{
			if (progress != null)
			{
				float num72 = 1f - (float)num71 / (float)num59;
				progress.Set(num12 * 8f + num61 * 3f + num72 * num61);
			}
			for (int num73 = num56; num73 < num57; num73++)
			{
				outerTempled(num73, num71);
			}
		}
		int num74 = num6;
		num3 = -num4;
		Vector2D vector2D = new Vector2D(num5, num6);
		int num75 = genRand.Next(2, 5);
		bool flag4 = true;
		int num76 = 0;
		int num77 = genRand.Next(9, 14);
		while (flag4)
		{
			num76++;
			if (num76 >= num77)
			{
				num76 = 0;
				vector2D.Y -= 1.0;
			}
			vector2D.X += num3;
			int num78 = (int)vector2D.X;
			flag4 = false;
			for (int num79 = (int)vector2D.Y - num75; (double)num79 < vector2D.Y + (double)num75; num79++)
			{
				if (Main.tile[num78, num79].wall == 87 || (Main.tile[num78, num79].active() && Main.tile[num78, num79].type == 226))
				{
					flag4 = true;
				}
				if (Main.tile[num78, num79].active() && Main.tile[num78, num79].type == 226)
				{
					if (num79 > num74)
					{
						num74 = num79;
					}
					Main.tile[num78, num79].active(active: false);
					Main.tile[num78, num79].wall = 87;
				}
			}
		}
		num74 += 2;
		int num80 = num5;
		int num81 = num6;
		while (!Main.tile[num80, num81].active())
		{
			num81++;
			if (num81 >= num74)
			{
				num81 = num74;
				Main.tile[num80, num81].ClearEverything();
				Main.tile[num80, num81].active(active: true);
				Main.tile[num80, num81].type = 226;
				break;
			}
		}
		num81 -= 4;
		int num82 = num81;
		while ((Main.tile[num80, num82].active() && Main.tile[num80, num82].type == 226) || Main.tile[num80, num82].wall == 87)
		{
			num82--;
		}
		num82 += 2;
		for (int num83 = num80 - 1; num83 <= num80 + 1; num83++)
		{
			for (int num84 = num82; num84 <= num81; num84++)
			{
				Main.tile[num83, num84].active(active: true);
				Main.tile[num83, num84].type = 226;
				Main.tile[num83, num84].liquid = 0;
				Main.tile[num83, num84].slope(0);
				Main.tile[num83, num84].halfBrick(halfBrick: false);
			}
		}
		for (int num85 = num80 - 4; num85 <= num80 + 4; num85++)
		{
			for (int num86 = num81 - 1; num86 < num81 + 3; num86++)
			{
				Main.tile[num85, num86].active(active: false);
				Main.tile[num85, num86].wall = 87;
			}
		}
		for (int num87 = num80 - 1; num87 <= num80 + 1; num87++)
		{
			for (int num88 = num81 - 5; num88 <= num81 + 8; num88++)
			{
				Main.tile[num87, num88].active(active: true);
				Main.tile[num87, num88].type = 226;
				Main.tile[num87, num88].liquid = 0;
				Main.tile[num87, num88].slope(0);
				Main.tile[num87, num88].halfBrick(halfBrick: false);
			}
		}
		for (int num89 = num80 - 3; num89 <= num80 + 3; num89++)
		{
			for (int num90 = num81 - 2; num90 < num81 + 3; num90++)
			{
				if (num90 >= num81 || num89 < num5 - 1 || num89 > num5 + 1)
				{
					Main.tile[num89, num90].active(active: false);
					Main.tile[num89, num90].wall = 87;
				}
			}
		}
		PlaceTile(num80, num81, 10, mute: true, forced: false, -1, 11);
		for (int num91 = num56; num91 < num57; num91++)
		{
			for (int num92 = num58; num92 < num59; num92++)
			{
				templeCleaner(num91, num92);
			}
		}
		for (int num93 = num59; num93 >= num58; num93--)
		{
			for (int num94 = num57; num94 >= num56; num94--)
			{
				templeCleaner(num94, num93);
			}
		}
		for (int num95 = num56; num95 < num57; num95++)
		{
			if (progress != null)
			{
				float num96 = (float)num95 / (float)num57;
				progress.Set(num12 * 9f + num96 * num12);
			}
			for (int num97 = num58; num97 < num59; num97++)
			{
				bool flag5 = true;
				for (int num98 = num95 - 1; num98 <= num95 + 1; num98++)
				{
					for (int num99 = num97 - 1; num99 <= num97 + 1; num99++)
					{
						if ((!Main.tile[num98, num99].active() || Main.tile[num98, num99].type != 226) && Main.tile[num98, num99].wall != 87)
						{
							flag5 = false;
							break;
						}
					}
				}
				if (flag5)
				{
					Main.tile[num95, num97].wall = 87;
				}
			}
		}
		int num100 = 0;
		Rectangle rectangle3 = array[num2 - 1];
		int num101 = rectangle3.Width / 2;
		int num102 = rectangle3.Height / 2;
		while (true)
		{
			num100++;
			int num103 = rectangle3.X + num101 + 15 - genRand.Next(30);
			int num104 = rectangle3.Y + num102 + 15 - genRand.Next(30);
			PlaceTile(num103, num104, 237);
			if (Main.tile[num103, num104].type == 237)
			{
				GenVars.lAltarX = num103 - Main.tile[num103, num104].frameX / 18;
				GenVars.lAltarY = num104 - Main.tile[num103, num104].frameY / 18;
				break;
			}
			if (num100 < 1000)
			{
				continue;
			}
			num103 = rectangle3.X + num101;
			num104 = rectangle3.Y + num102;
			num103 += genRand.Next(-10, 11);
			for (num104 += genRand.Next(-10, 11); !Main.tile[num103, num104].active(); num104++)
			{
			}
			Main.tile[num103 - 1, num104].active(active: true);
			Main.tile[num103 - 1, num104].slope(0);
			Main.tile[num103 - 1, num104].halfBrick(halfBrick: false);
			Main.tile[num103 - 1, num104].type = 226;
			Main.tile[num103, num104].active(active: true);
			Main.tile[num103, num104].slope(0);
			Main.tile[num103, num104].halfBrick(halfBrick: false);
			Main.tile[num103, num104].type = 226;
			Main.tile[num103 + 1, num104].active(active: true);
			Main.tile[num103 + 1, num104].slope(0);
			Main.tile[num103 + 1, num104].halfBrick(halfBrick: false);
			Main.tile[num103 + 1, num104].type = 226;
			num104 -= 2;
			num103--;
			for (int num105 = -1; num105 <= 3; num105++)
			{
				for (int num106 = -1; num106 <= 1; num106++)
				{
					x = num103 + num105;
					y = num104 + num106;
					Main.tile[x, y].active(active: false);
				}
			}
			GenVars.lAltarX = num103;
			GenVars.lAltarY = num104;
			for (int num107 = 0; num107 <= 2; num107++)
			{
				for (int num108 = 0; num108 <= 1; num108++)
				{
					x = num103 + num107;
					y = num104 + num108;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].type = 237;
					Main.tile[x, y].frameX = (short)(num107 * 18);
					Main.tile[x, y].frameY = (short)(num108 * 18);
				}
			}
			for (int num109 = 0; num109 <= 2; num109++)
			{
				for (int num110 = 0; num110 <= 1; num110++)
				{
					x = num103 + num109;
					y = num104 + num110;
					SquareTileFrame(x, y);
				}
			}
			break;
		}
		double num111 = (double)num2 * 1.1;
		num111 *= 1.0 + (double)genRand.Next(-25, 26) * 0.01;
		if (drunkWorldGen)
		{
			num111 *= 1.5;
		}
		double num112 = num111;
		int num113 = 0;
		while (num111 > 0.0)
		{
			num113++;
			if (progress != null)
			{
				double num114 = 1.0 - num111 / num112;
				progress.Set((double)(num12 * 10f) + num114 * (double)num12);
			}
			int num115 = genRand.Next(num2);
			int num116 = genRand.Next(array[num115].X, array[num115].X + array[num115].Width);
			int num117 = genRand.Next(array[num115].Y, array[num115].Y + array[num115].Height);
			if (Main.tile[num116, num117].wall == 87 && !Main.tile[num116, num117].active())
			{
				bool flag6 = false;
				if (genRand.Next(2) == 0)
				{
					int num118 = 1;
					if (genRand.Next(2) == 0)
					{
						num118 = -1;
					}
					for (; !Main.tile[num116, num117].active(); num117 += num118)
					{
					}
					num117 -= num118;
					int num119 = genRand.Next(2);
					int num120 = genRand.Next(3, 10);
					bool flag7 = true;
					for (int num121 = num116 - num120; num121 < num116 + num120; num121++)
					{
						for (int num122 = num117 - num120; num122 < num117 + num120; num122++)
						{
							if (Main.tile[num121, num122].active() && (Main.tile[num121, num122].type == 10 || Main.tile[num121, num122].type == 237))
							{
								flag7 = false;
								break;
							}
						}
					}
					if (flag7)
					{
						for (int num123 = num116 - num120; num123 < num116 + num120; num123++)
						{
							for (int num124 = num117 - num120; num124 < num117 + num120; num124++)
							{
								if (!SolidTile(num123, num124) || Main.tile[num123, num124].type == 232 || SolidTile(num123, num124 - num118))
								{
									continue;
								}
								Main.tile[num123, num124].type = 232;
								flag6 = true;
								if (num119 == 0)
								{
									Main.tile[num123, num124 - 1].type = 232;
									Main.tile[num123, num124 - 1].active(active: true);
									if (drunkWorldGen)
									{
										Main.tile[num123, num124 - 2].type = 232;
										Main.tile[num123, num124 - 2].active(active: true);
									}
								}
								else
								{
									Main.tile[num123, num124 + 1].type = 232;
									Main.tile[num123, num124 + 1].active(active: true);
									if (drunkWorldGen)
									{
										Main.tile[num123, num124 + 2].type = 232;
										Main.tile[num123, num124 + 2].active(active: true);
									}
								}
								num119++;
								if (num119 > 1)
								{
									num119 = 0;
								}
							}
						}
					}
					if (flag6)
					{
						num113 = 0;
						num111 -= 1.0;
					}
				}
				else
				{
					int num125 = 1;
					if (genRand.Next(2) == 0)
					{
						num125 = -1;
					}
					for (; !Main.tile[num116, num117].active(); num116 += num125)
					{
					}
					num116 -= num125;
					int num126 = genRand.Next(2);
					int num127 = genRand.Next(3, 10);
					bool flag8 = true;
					for (int num128 = num116 - num127; num128 < num116 + num127; num128++)
					{
						for (int num129 = num117 - num127; num129 < num117 + num127; num129++)
						{
							if (Main.tile[num128, num129].active() && Main.tile[num128, num129].type == 10)
							{
								flag8 = false;
								break;
							}
						}
					}
					if (flag8)
					{
						for (int num130 = num116 - num127; num130 < num116 + num127; num130++)
						{
							for (int num131 = num117 - num127; num131 < num117 + num127; num131++)
							{
								if (!SolidTile(num130, num131) || Main.tile[num130, num131].type == 232 || SolidTile(num130 - num125, num131))
								{
									continue;
								}
								Main.tile[num130, num131].type = 232;
								flag6 = true;
								if (num126 == 0)
								{
									Main.tile[num130 - 1, num131].type = 232;
									Main.tile[num130 - 1, num131].active(active: true);
									if (drunkWorldGen)
									{
										Main.tile[num130 - 2, num131].type = 232;
										Main.tile[num130 - 2, num131].active(active: true);
									}
								}
								else
								{
									Main.tile[num130 + 1, num131].type = 232;
									Main.tile[num130 + 1, num131].active(active: true);
									if (drunkWorldGen)
									{
										Main.tile[num130 - 2, num131].type = 232;
										Main.tile[num130 - 2, num131].active(active: true);
									}
								}
								num126++;
								if (num126 > 1)
								{
									num126 = 0;
								}
							}
						}
					}
					if (flag6)
					{
						num113 = 0;
						num111 -= 1.0;
					}
				}
			}
			if (num113 > 1000)
			{
				num113 = 0;
				num111 -= 1.0;
			}
		}
		progress?.Set(1.0);
		GenVars.tLeft = num56;
		GenVars.tRight = num57;
		GenVars.tTop = num58;
		GenVars.tBottom = num59;
		GenVars.tRooms = num2;
	}

	public static void templePart2()
	{
		int tLeft = GenVars.tLeft;
		int tRight = GenVars.tRight;
		int tTop = GenVars.tTop;
		int tBottom = GenVars.tBottom;
		int tRooms = GenVars.tRooms;
		double num = (double)tRooms * 1.9;
		num *= 1.0 + (double)genRand.Next(-15, 16) * 0.01;
		int num2 = 0;
		while (num > 0.0)
		{
			int num3 = genRand.Next(tLeft, tRight);
			int num4 = genRand.Next(tTop, tBottom);
			if (Main.tile[num3, num4].wall == 87 && !Main.tile[num3, num4].active())
			{
				if (mayanTrap(num3, num4))
				{
					num -= 1.0;
					num2 = 0;
				}
				else
				{
					num2++;
				}
			}
			else
			{
				num2++;
			}
			if (num2 > 100)
			{
				num2 = 0;
				num -= 1.0;
			}
		}
		Main.tileSolid[232] = false;
		double num5 = (double)tRooms * 0.35;
		num5 *= 1.0 + (double)genRand.Next(-15, 16) * 0.01;
		short mainItemInChest = 1293;
		num2 = 0;
		while (num5 > 0.0)
		{
			int num6 = genRand.Next(tLeft, tRight);
			int num7 = genRand.Next(tTop, tBottom);
			if (Main.tile[num6, num7].wall == 87 && !Main.tile[num6, num7].active() && AddBuriedChest(num6, num7, mainItemInChest, notNearOtherChests: true, 16, trySlope: false, 0))
			{
				num5 -= 1.0;
				num2 = 0;
			}
			num2++;
			if (num2 > 10000)
			{
				break;
			}
		}
		double num8 = (double)tRooms * 1.25;
		num8 *= 1.0 + (double)genRand.Next(-25, 36) * 0.01;
		num2 = 0;
		while (num8 > 0.0)
		{
			num2++;
			int num9 = genRand.Next(tLeft, tRight);
			int num10 = genRand.Next(tTop, tBottom);
			if (Main.tile[num9, num10].wall == 87 && !Main.tile[num9, num10].active())
			{
				int num11 = num9;
				int num12 = num10;
				while (!Main.tile[num11, num12].active())
				{
					num12++;
					if (num12 > tBottom)
					{
						break;
					}
				}
				num12--;
				if (num12 <= tBottom)
				{
					PlaceTile(num11, num12, 105, mute: true, forced: false, -1, genRand.Next(43, 46));
					if (Main.tile[num11, num12].type == 105)
					{
						num8 -= 1.0;
					}
				}
			}
			if (num2 > 10000)
			{
				break;
			}
		}
		double num13 = (double)tRooms * 1.35;
		num13 *= 1.0 + (double)genRand.Next(-15, 26) * 0.01;
		num2 = 0;
		while (num13 > 0.0)
		{
			num2++;
			int num14 = genRand.Next(tLeft, tRight);
			int num15 = genRand.Next(tTop, tBottom);
			if (Main.tile[num14, num15].wall == 87 && !Main.tile[num14, num15].active())
			{
				int num16 = num14;
				int num17 = num15;
				while (!Main.tile[num16, num17].active())
				{
					num17++;
					if (num17 > tBottom)
					{
						break;
					}
				}
				num17--;
				if (num17 <= tBottom)
				{
					switch (genRand.Next(3))
					{
					case 0:
						PlaceTile(num16, num17, 18, mute: true, forced: false, -1, 10);
						if (Main.tile[num16, num17].type == 18)
						{
							num13 -= 1.0;
						}
						break;
					case 1:
						PlaceTile(num16, num17, 14, mute: true, forced: false, -1, 9);
						if (Main.tile[num16, num17].type == 14)
						{
							num13 -= 1.0;
						}
						break;
					case 2:
						PlaceTile(num16, num17, 15, mute: true, forced: false, -1, 12);
						if (Main.tile[num16, num17].type == 15)
						{
							num13 -= 1.0;
						}
						break;
					}
				}
			}
			if (num2 > 10000)
			{
				break;
			}
		}
		int num18 = 1;
		if (Main.maxTilesX > 4200)
		{
			num18++;
		}
		if (Main.maxTilesX > 6400)
		{
			num18 += genRand.Next(2);
		}
		num2 = 0;
		while (num18 > 0)
		{
			num2++;
			int num19 = genRand.Next(tLeft, tRight);
			int num20 = genRand.Next(tTop, tBottom);
			if (Main.tile[num19, num20].wall == 87 && !Main.tile[num19, num20].active())
			{
				bool flag = false;
				for (int i = -70; i <= 70; i++)
				{
					for (int j = -70; j <= 70; j++)
					{
						int num21 = i + num19;
						int num22 = j + num20;
						if (!InWorld(num21, num22, 5))
						{
							continue;
						}
						Tile tile = Main.tile[num21, num22];
						if (tile.active())
						{
							if (tile.type == 240)
							{
								flag = true;
								break;
							}
							if (i >= -4 && i <= 4 && j >= -4 && j <= 4 && tile.type == 226)
							{
								flag = true;
								break;
							}
						}
					}
					if (flag)
					{
						break;
					}
				}
				if (flag)
				{
					continue;
				}
				if (PlaceTile(num19, num20, 240, mute: true, forced: false, -1, 88))
				{
					num18--;
				}
			}
			if (num2 > 10000)
			{
				break;
			}
		}
		Main.tileSolid[232] = true;
	}

	public static bool nearPicture(int x, int y)
	{
		for (int i = x - 4; i <= x + 3; i++)
		{
			for (int j = y - 3; j <= y + 2; j++)
			{
				if (Main.tile[i, j].active())
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool nearPicture2(int x, int y)
	{
		if (Main.tile[x, y].wall != 7 && Main.tile[x, y].wall != 8 && Main.tile[x, y].wall != 9)
		{
			for (int i = x - 8; i <= x + 8; i++)
			{
				for (int j = y - 5; j <= y + 5; j++)
				{
					if (Main.tile[i, j].active() && (Main.tile[i, j].type == 240 || Main.tile[i, j].type == 241 || Main.tile[i, j].type == 242))
					{
						return true;
					}
				}
			}
		}
		else
		{
			for (int k = x - 15; k <= x + 15; k++)
			{
				for (int l = y - 10; l <= y + 10; l++)
				{
					if (Main.tile[k, l].active() && (Main.tile[k, l].type == 240 || Main.tile[k, l].type == 241 || Main.tile[k, l].type == 242))
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	private static void ShimmerCleanUp()
	{
		if (GenVars.shimmerPosition.X == 0.0 && GenVars.shimmerPosition.Y == 0.0)
		{
			return;
		}
		ShimmerRemoveWater();
		int num = 120;
		int num2 = 90;
		int num3 = (int)GenVars.shimmerPosition.X - num;
		int num4 = (int)GenVars.shimmerPosition.X + num;
		int num5 = (int)GenVars.shimmerPosition.Y - num;
		int num6 = (int)GenVars.shimmerPosition.Y + num;
		_ = num / 4;
		for (int i = num5; i <= num6; i++)
		{
			for (int j = num3; j <= num4; j++)
			{
				int num7 = (int)Math.Sqrt(Math.Pow(Math.Abs((double)j - GenVars.shimmerPosition.X), 2.0) + Math.Pow(Math.Abs((double)i - GenVars.shimmerPosition.Y), 2.0));
				if (num7 < num)
				{
					if (Main.tile[j, i].type == 22 || Main.tile[j, i].type == 204)
					{
						Main.tile[j, i].type = 1;
					}
					if (Main.tile[j, i].type == 51 || Main.tile[j, i].type == 56 || Main.tile[j, i].type == 229 || Main.tile[j, i].type == 230 || Main.tile[j, i].type == 659)
					{
						Main.tile[j, i].active(active: false);
					}
					if (TileID.Sets.Conversion.Moss[Main.tile[j, i].type])
					{
						Main.tile[j, i].type = 1;
					}
					if (Main.tile[j, i].type == 184)
					{
						Main.tile[j, i].active(active: false);
					}
				}
				num7 = ((!((double)i > GenVars.shimmerPosition.Y)) ? ((int)Math.Sqrt(Math.Pow(Math.Abs((double)j - GenVars.shimmerPosition.X) * (1.0 + genRand.NextDouble() * 0.02), 2.0) + Math.Pow(Math.Abs((double)i - GenVars.shimmerPosition.Y) * 1.4 * (1.0 + genRand.NextDouble() * 0.02), 2.0))) : ((int)Math.Sqrt(Math.Pow(Math.Abs((double)j - GenVars.shimmerPosition.X) * (1.0 + genRand.NextDouble() * 0.02), 2.0) + Math.Pow(Math.Abs((double)i - GenVars.shimmerPosition.Y) * 1.2 * (1.0 + genRand.NextDouble() * 0.02), 2.0))));
				if (num7 < num2)
				{
					if (Main.tile[j, i].type == 162)
					{
						Main.tile[j, i].active(active: false);
					}
					Main.tile[j, i].wall = 0;
					Convert(j, i, 0, 3);
				}
			}
		}
		int num8 = (int)GenVars.shimmerPosition.X;
		int num9 = (int)GenVars.shimmerPosition.Y;
		byte b = 127;
		Liquid.tilesIgnoreWater(ignoreSolids: true);
		while (Main.tile[num8, num9].liquid <= b || !Main.tile[num8, num9].shimmer())
		{
			while (!Main.tile[num8, num9].active())
			{
				Main.tile[num8, num9].liquid = b;
				Main.tile[num8, num9].shimmer(shimmer: true);
				num8--;
			}
			for (num8 = (int)GenVars.shimmerPosition.X; !Main.tile[num8, num9].active(); num8++)
			{
				Main.tile[num8, num9].liquid = b;
				Main.tile[num8, num9].shimmer(shimmer: true);
			}
			num8 = (int)GenVars.shimmerPosition.X;
			num9++;
			b = byte.MaxValue;
			if (Main.tile[num8, num9].active())
			{
				break;
			}
		}
		if (tenthAnniversaryWorldGen)
		{
			int num10 = 170;
			for (int k = (int)GenVars.shimmerPosition.X - num10; (double)k <= GenVars.shimmerPosition.X + (double)num10; k++)
			{
				for (int l = (int)GenVars.shimmerPosition.Y + 40; l < Main.maxTilesY - 330 - 100; l++)
				{
					if (InWorld(k, l) && Main.tile[k, l].wall != 86)
					{
						if (Main.tile[k, l].type == 375 || Main.tile[k, l].type == 374 || Main.tile[k, l].type == 373)
						{
							Main.tile[k, l].type = 709;
						}
						if (Main.tile[k, l].liquid > 0 && !Main.tile[k, l].shimmer() && !Main.tile[k, l].honey())
						{
							Shimmerator(k, l);
						}
					}
				}
			}
		}
		Liquid.tilesIgnoreWater(ignoreSolids: false);
		for (int m = 10; m < Main.maxTilesX - 10; m++)
		{
			for (int n = 10; n < Main.maxTilesY - 10; n++)
			{
				if (Main.tile[m, n].liquid > 0 && Main.tile[m, n].shimmer() && Main.tile[m, n].type == 5)
				{
					KillTile(m, n);
				}
			}
		}
	}

	public static void ShimmerRemoveWater()
	{
		if (!generatingWorld)
		{
			return;
		}
		int num = 150;
		int num2 = (int)GenVars.shimmerPosition.X - num;
		int num3 = (int)GenVars.shimmerPosition.X + num;
		int num4 = (int)GenVars.shimmerPosition.Y - num;
		int num5 = (int)GenVars.shimmerPosition.Y + num / 2;
		for (int i = num4; i <= num5; i++)
		{
			for (int j = num2; j <= num3; j++)
			{
				if (InWorld(j, i) && (int)Math.Sqrt(Math.Pow(Math.Abs(j - (int)GenVars.shimmerPosition.X), 2.0) + Math.Pow(Math.Abs(i - (int)GenVars.shimmerPosition.Y), 2.0)) < num)
				{
					if (!Main.tile[j, i].shimmer())
					{
						Main.tile[j, i].liquid = 0;
					}
					if (Main.tile[j, i].type == 162)
					{
						Main.tile[j, i].active(active: false);
					}
				}
			}
		}
	}

	public static bool ShimmerMakeBiome(int X, int Y)
	{
		int num = genRand.Next(2);
		double num2 = 0.6;
		double num3 = 1.3;
		double num4 = 0.3;
		if (num == 0)
		{
			num2 = 0.55;
			num3 = 2.0;
		}
		num2 *= 1.05 - genRand.NextDouble() * 0.1;
		num3 *= 1.05 - genRand.NextDouble() * 0.1;
		num4 *= 1.0 - genRand.NextDouble() * 0.1;
		int num5 = genRand.Next(105, 125);
		int num6 = (int)((double)num5 * num4);
		int num7 = (int)((double)num5 * num2);
		int num8 = genRand.Next(9, 13);
		int num9 = X - num5;
		int num10 = X + num5;
		int num11 = Y - num5;
		int num12 = Y + num5;
		for (int i = num11; i <= num12; i++)
		{
			for (int j = num9; j <= num10; j++)
			{
				if (!InWorld(j, i, 50))
				{
					return false;
				}
				if (Main.tile[j, i].type == 203 || Main.tile[j, i].type == 25)
				{
					return false;
				}
			}
		}
		int num13 = Y;
		if (genRand.Next(4) == 0)
		{
			num13 = Y - genRand.Next(2);
		}
		int num14 = Y - num8;
		if (genRand.Next(4) == 0)
		{
			num14 = Y - num8 - genRand.Next(2);
		}
		for (int k = num11; k <= num12; k++)
		{
			for (int l = num9; l <= num10; l++)
			{
				Main.tile[l, k].liquid = 0;
				if (genRand.Next(4) == 0)
				{
					num13 = Y - genRand.Next(2);
				}
				if (genRand.Next(4) == 0)
				{
					num14 = Y - num8 + genRand.Next(2);
				}
				int num15 = ((k <= Y) ? ((int)Math.Sqrt(Math.Pow((double)Math.Abs(l - X) * (1.0 + genRand.NextDouble() * 0.02), 2.0) + Math.Pow((double)Math.Abs(k - Y) * 1.4 * (1.0 + genRand.NextDouble() * 0.02), 2.0))) : ((int)Math.Sqrt(Math.Pow((double)Math.Abs(l - X) * (1.0 + genRand.NextDouble() * 0.02), 2.0) + Math.Pow((double)Math.Abs(k - Y) * 1.2 * (1.0 + genRand.NextDouble() * 0.02), 2.0))));
				if (num15 < num5)
				{
					Main.tile[l, k].color(0);
					Main.tile[l, k].wallColor(0);
					Main.tile[l, k].slope(0);
					Main.tile[l, k].halfBrick(halfBrick: false);
					Main.tile[l, k].type = 1;
					if (l > num9 + 5 + genRand.Next(2) && l < num10 - 5 - genRand.Next(2))
					{
						Main.tile[l, k].active(active: true);
					}
					if ((double)num15 < (double)num5 * 0.9)
					{
						Main.tile[l, k].wall = 0;
					}
				}
				num15 = (int)Math.Sqrt(Math.Pow((double)Math.Abs(l - X) * (1.0 + genRand.NextDouble() * 0.02), 2.0) + Math.Pow((double)Math.Abs(k - Y) * num3 * (1.0 + genRand.NextDouble() * 0.02), 2.0));
				if (k > num14 && k < num13)
				{
					Main.tile[l, k].active(active: false);
				}
				if (k < num13 && num15 < (int)((double)num7 * (1.0 + genRand.NextDouble() * 0.02)))
				{
					Main.tile[l, k].active(active: false);
				}
				num15 = (int)Math.Sqrt(Math.Pow((double)Math.Abs(l - X) * (1.0 + genRand.NextDouble() * 0.02), 2.0) + Math.Pow((double)(Math.Abs(k - Y) * 2) * (1.0 + genRand.NextDouble() * 0.02), 2.0));
				if (k < Y - 1 || num15 >= (int)((double)num6 * (1.0 + genRand.NextDouble() * 0.025)))
				{
					continue;
				}
				if (k <= Y + 2 || num15 != num6 - 1 || genRand.Next(2) != 0)
				{
					Main.tile[l, k].active(active: false);
				}
				if (k >= Y)
				{
					if (k == Y)
					{
						Main.tile[l, k].liquid = 127;
					}
					else
					{
						Main.tile[l, k].liquid = byte.MaxValue;
					}
					Main.tile[l, k].shimmer(shimmer: true);
				}
			}
		}
		if (num == 0)
		{
			num9 = (int)((double)X - (double)num5 * num4) - genRand.Next(-15, 1) - 5;
			num10 = (int)((double)X + (double)num5 * num4) + genRand.Next(0, 16);
			int m = num9;
			int num16 = 0;
			for (; m < num10; m += genRand.Next(9, 14))
			{
				int num17 = Y - 3;
				while (!Main.tile[m, num17].active())
				{
					num17--;
				}
				num17 -= 4;
				int num18 = genRand.Next(5, 10);
				int num19 = genRand.Next(15, 21);
				int n = m - num18;
				while (num18 > 0)
				{
					for (n = m - num18; n < m + num18; n++)
					{
						Main.tile[n, num17].active(active: true);
						Main.tile[n, num17].type = 1;
					}
					num16++;
					if (genRand.Next(3) < num16)
					{
						num16 = 0;
						num18--;
						m += genRand.Next(-1, 2);
					}
					if (num19 <= 0)
					{
						num18--;
					}
					num19--;
					num17++;
				}
				n -= genRand.Next(1, 3);
				Main.tile[n, num17 - 2].active(active: true);
				Main.tile[n, num17 - 2].type = 1;
				Main.tile[n, num17 - 1].active(active: true);
				Main.tile[n, num17 - 1].type = 1;
				Main.tile[n, num17].active(active: true);
				Main.tile[n, num17].type = 1;
				if (genRand.Next(2) == 0)
				{
					Main.tile[n, num17 + 1].active(active: true);
					Main.tile[n, num17 + 1].type = 1;
					PlaceTight(n, num17 + 2);
				}
				else
				{
					PlaceTight(n, num17 + 1);
				}
			}
		}
		ShimmerMakeBiomeOpening(-1, X - num5, Y, num8);
		ShimmerMakeBiomeOpening(1, X + num5, Y, num8);
		int num20 = 70;
		for (int num21 = 0; num21 < 500; num21++)
		{
			int num22 = genRand.Next(X - num20, X + num20);
			int num23 = genRand.Next(Y - 2, Y + 3);
			int num24 = genRand.Next(7);
			int treeTileType = 0;
			switch (num24)
			{
			case 0:
				treeTileType = 583;
				break;
			case 1:
				treeTileType = 584;
				break;
			case 2:
				treeTileType = 585;
				break;
			case 3:
				treeTileType = 586;
				break;
			case 4:
				treeTileType = 587;
				break;
			case 5:
				treeTileType = 588;
				break;
			case 6:
				treeTileType = 589;
				break;
			}
			if (SolidTile(num22 - 1, num23) && SolidTile(num22 + 1, num23))
			{
				TryGrowingTreeByType(treeTileType, num22, num23);
			}
		}
		return true;
	}

	private static void ShimmerMakeBiomeOpening(int direction, int X, int Y, int caveOpenningSize)
	{
		int num = X;
		caveOpenningSize--;
		bool flag;
		do
		{
			num += direction;
			flag = true;
			for (int i = Y - caveOpenningSize + 1; i < Y - 1; i++)
			{
				if (SolidTile(num, i))
				{
					flag = false;
				}
				if (SolidTile(num + direction, i))
				{
					flag = false;
				}
				if (SolidTile(num + direction * 2, i))
				{
					flag = false;
				}
				Main.tile[num, i].active(active: false);
			}
			for (int j = Y - caveOpenningSize; j < Y; j++)
			{
				Main.tile[num - direction, j].active(active: false);
			}
			if (SolidTile(num - direction, Y - caveOpenningSize - 1))
			{
				Main.tile[num - direction, Y - caveOpenningSize - 1].wall = 0;
			}
			if (SolidTile(num - direction, Y))
			{
				Main.tile[num - direction, Y].wall = 0;
			}
			if (genRand.Next(2) == 0)
			{
				Y += genRand.Next(-1, 2);
			}
		}
		while (!flag && num >= 50 && num <= Main.maxTilesX - 50 && Math.Abs(num - X) <= 100);
	}

	private static void Shimminate()
	{
		foreach (KeyValuePair<Point, bool> countedTile in CountedTiles)
		{
			Point key = countedTile.Key;
			Main.tile[key.X, key.Y].shimmer(shimmer: true);
			Main.tile[key.X, key.Y].liquid = byte.MaxValue;
			if (Main.tile[key.X, key.Y].type == 5 || Main.tile[key.X, key.Y].type == 56 || (Main.tileCut[Main.tile[key.X, key.Y].type] && Main.tile[key.X, key.Y].type != 28))
			{
				KillTile(key.X, key.Y);
			}
		}
	}

	public static void Shimmerator(int x, int y, bool jungle = false, bool lavaOk = false)
	{
		numTileCount = 0;
		CountedTiles.Clear();
		ShimmeratorNext(x, y);
		if (numTileCount > 0 && numTileCount < maxTileCount)
		{
			Shimminate();
		}
	}

	private static void ShimmeratorNext(int x, int y)
	{
		if (numTileCount < maxTileCount)
		{
			if (x <= 1 || x >= Main.maxTilesX - 1 || y <= 1 || y >= Main.maxTilesY - 1)
			{
				numTileCount = maxTileCount;
			}
			else if (!CountedTiles.ContainsKey(new Point(x, y)) && ((!SolidTile(x, y) && !Main.tile[x, y].shimmer() && Main.tile[x, y].liquid > 0) || (Main.tile[x, y].active() && Main.tile[x, y].type == 56)))
			{
				CountedTiles.Add(new Point(x, y), value: true);
				numTileCount++;
				ShimmeratorNext(x - 1, y);
				ShimmeratorNext(x + 1, y);
				ShimmeratorNext(x, y - 1);
				ShimmeratorNext(x, y + 1);
			}
		}
	}

	private static void DungeonDesertCleanup(int x)
	{
		int num = (int)Main.worldSurface - 10 + GenVars.CurrentDungeonGenVars.preGenDungeonEntranceSettings.BuriedEntranceSandDugoutYOffset;
		num -= genRand.Next(25, 46);
		int num2 = 1;
		int num3 = 1;
		while (num > FindLowestCloud())
		{
			for (int i = x - num2; i <= x + num3; i++)
			{
				if (InWorld(i, num, 5))
				{
					Tile tile = Main.tile[i, num];
					Tile tile2 = Main.tile[i, num + 1];
					tile.active(active: false);
					tile.wall = 0;
					tile2.wall = 0;
				}
			}
			num--;
			num2 = ((num2 >= 20) ? ((num2 >= 40) ? (num2 + genRand.Next(1, 3)) : (num2 + genRand.Next(2, 4))) : (num2 + genRand.Next(4, 5)));
			num3 = ((num3 >= 20) ? ((num3 >= 40) ? (num3 + genRand.Next(1, 3)) : (num3 + genRand.Next(2, 4))) : (num3 + genRand.Next(4, 5)));
		}
	}

	public static PaintingEntry RandHellPicture()
	{
		int num = genRand.Next(4);
		int num2 = 0;
		if (num == 1)
		{
			num = genRand.Next(4);
		}
		switch (num)
		{
		case 0:
			num = 240;
			num2 = genRand.Next(5);
			switch (num2)
			{
			case 0:
				num2 = 27;
				break;
			case 1:
				num2 = 29;
				break;
			case 2:
				num2 = 30;
				break;
			case 3:
				num2 = 31;
				break;
			case 4:
				num2 = 32;
				break;
			}
			break;
		case 1:
			num = 242;
			num2 = 14;
			break;
		case 2:
			num = 245;
			num2 = genRand.Next(3);
			switch (num2)
			{
			case 0:
				num2 = 1;
				break;
			case 1:
				num2 = 2;
				break;
			case 2:
				num2 = 4;
				break;
			}
			break;
		default:
			num = 246;
			num2 = genRand.Next(3);
			switch (num2)
			{
			case 0:
				num2 = 0;
				break;
			case 1:
				num2 = 16;
				break;
			case 2:
				num2 = 17;
				break;
			}
			break;
		}
		return new PaintingEntry
		{
			tileType = num,
			style = num2
		};
	}

	public static PaintingEntry RandHousePictureDesert()
	{
		int num = genRand.Next(4);
		int num2 = 0;
		if (num <= 1)
		{
			num = 240;
			int maxValue = 6;
			num2 = genRand.Next(maxValue);
			switch (num2)
			{
			case 0:
				num2 = 63;
				break;
			case 1:
				num2 = 64;
				break;
			case 2:
				num2 = 65;
				break;
			case 3:
				num2 = 66;
				break;
			case 4:
				num2 = 67;
				break;
			case 5:
				num2 = 68;
				break;
			}
		}
		else if (num == 2)
		{
			num = 245;
			int maxValue2 = 2;
			num2 = 7 + genRand.Next(maxValue2);
		}
		else
		{
			num = 242;
			int maxValue3 = 6;
			num2 = 37 + genRand.Next(maxValue3);
		}
		return new PaintingEntry
		{
			tileType = num,
			style = num2
		};
	}

	public static PaintingEntry RandHousePicture()
	{
		int num = genRand.Next(4);
		int num2 = 0;
		if (num >= 3 && genRand.Next(2) != 0)
		{
			num = genRand.Next(3);
		}
		if (num <= 1)
		{
			num = 240;
			int maxValue = 18;
			num2 = genRand.Next(maxValue);
			switch (num2)
			{
			case 0:
				num2 = 26;
				break;
			case 1:
				num2 = 28;
				break;
			case 2:
				num2 = 20;
				break;
			case 3:
				num2 = 21;
				break;
			case 4:
				num2 = 22;
				break;
			case 5:
				num2 = 24;
				break;
			case 6:
				num2 = 25;
				break;
			case 7:
				num2 = 33;
				break;
			case 8:
				num2 = 34;
				break;
			case 9:
				num2 = 35;
				break;
			case 10:
				num2 = 76;
				break;
			case 11:
				num2 = 77;
				break;
			case 12:
				num2 = 78;
				break;
			case 13:
				num2 = 79;
				break;
			case 14:
				num2 = 82;
				break;
			case 15:
				num2 = 96;
				break;
			case 16:
				num2 = 98;
				break;
			case 17:
				num2 = 100;
				break;
			}
		}
		else if (num == 2)
		{
			int maxValue2 = 9;
			num = 245;
			num2 = genRand.Next(maxValue2);
			if (num2 == 0 && genRand.Next(3) != 0)
			{
				num2 = genRand.Next(maxValue2);
			}
			switch (num2)
			{
			case 0:
				num2 = 0;
				break;
			case 1:
				num2 = 3;
				break;
			case 2:
				num2 = 5;
				break;
			case 3:
				num2 = 6;
				break;
			case 4:
				num2 = 14;
				break;
			case 5:
			{
				int num3 = genRand.Next(4);
				if (num3 == 0)
				{
					num2 = 15;
				}
				if (num3 == 1)
				{
					num2 = 16;
				}
				if (num3 == 2)
				{
					num2 = 17;
				}
				if (num3 == 3)
				{
					num2 = 18;
				}
				break;
			}
			case 6:
				num2 = 19;
				break;
			case 7:
				num2 = 20;
				break;
			case 8:
				num2 = 21;
				break;
			}
		}
		else
		{
			num = 246;
			int maxValue3 = 8;
			num2 = genRand.Next(maxValue3);
			switch (num2)
			{
			case 0:
				num2 = 1;
				break;
			case 1:
				num2 = 30;
				break;
			case 2:
				num2 = 31;
				break;
			case 3:
				num2 = 32;
				break;
			case 4:
				num2 = 33;
				break;
			case 5:
				num2 = 34;
				break;
			case 6:
				num2 = 35;
				break;
			case 7:
				num2 = 36;
				break;
			}
		}
		return new PaintingEntry
		{
			tileType = num,
			style = num2
		};
	}

	public static bool PlaceSandTrap(int i, int j)
	{
		if (SecretSeed.Variations.actuallyNoTrapsForRealIMeanIt)
		{
			return true;
		}
		int num = 6;
		int num2 = 4;
		int num3 = 25;
		int k;
		for (k = j; !Main.tile[i, k].active() && k < Main.UnderworldLayer; k++)
		{
		}
		if (k >= Main.UnderworldLayer)
		{
			return false;
		}
		if (!Main.tileSolid[Main.tile[i, k].type] || Main.tile[i, k].halfBrick() || Main.tile[i, k].topSlope())
		{
			return false;
		}
		if ((Main.tile[i, k].type != 53 && Main.tile[i, k].type != 397 && Main.tile[i, k].type != 396) || (Main.tile[i, k].wall != 216 && Main.tile[i, k].wall != 187))
		{
			return false;
		}
		k--;
		int num4 = -1;
		int num5 = genRand.Next(6, 12);
		int num6 = genRand.Next(6, 14);
		for (int l = i - num3; l <= i + num3; l++)
		{
			for (int m = k - num3; m < k + num3; m++)
			{
				if (Main.tile[l, m].wire())
				{
					return false;
				}
				if (TileID.Sets.BasicChest[Main.tile[l, m].type])
				{
					return false;
				}
				if (TileID.Sets.Paintings[Main.tile[l, m].type])
				{
					return false;
				}
				if (Main.tile[l, m].type == 10)
				{
					return false;
				}
				if (Main.tile[l, m].type == 19)
				{
					return false;
				}
				if (Main.tile[l, m].type == 15)
				{
					return false;
				}
				if (Main.tile[l, m].type == 219)
				{
					return false;
				}
				if (Main.tile[l, m].type == 314)
				{
					return false;
				}
			}
		}
		for (int n = i - 2; n <= i + 2; n++)
		{
			for (int num7 = k + 1; num7 <= k + 3; num7++)
			{
				if (!Main.tile[n, num7].active() || !Main.tileSolid[Main.tile[n, num7].type])
				{
					return false;
				}
			}
		}
		if (Main.tile[i, k + 1].type == 162)
		{
			return false;
		}
		for (int num8 = k; num8 > k - 30; num8--)
		{
			if (Main.tile[i, num8].active())
			{
				if (Main.tile[i, num8].type == 396)
				{
					num4 = num8;
					break;
				}
				return false;
			}
		}
		if (num4 <= -1)
		{
			return false;
		}
		if (k - num4 < num6 + num2)
		{
			return false;
		}
		int num9 = 0;
		int num10 = (k + num4) / 2;
		for (int num11 = i - num5; num11 <= i + num5; num11++)
		{
			if (Main.tile[num11, num10].active() && Main.tileSolid[Main.tile[num11, num10].type])
			{
				return false;
			}
			for (int num12 = num4 - num6; num12 <= num4; num12++)
			{
				if (Main.tile[num11, num12].active())
				{
					if (TileID.Sets.Ore[Main.tile[num11, num12].type] || Main.tile[num11, num12].type == 404)
					{
						return false;
					}
					if (Main.tileSolid[Main.tile[num11, num12].type])
					{
						num9++;
					}
				}
			}
		}
		double num13 = (double)((num5 * 2 + 1) * (num6 + 1)) * 0.75;
		if ((double)num9 < num13)
		{
			return false;
		}
		for (int num14 = i - num5 - 1; num14 <= i + num5 + 1; num14++)
		{
			for (int num15 = num4 - num6; num15 <= num4; num15++)
			{
				bool flag = false;
				if (Main.tile[num14, num15].active() && Main.tileSolid[Main.tile[num14, num15].type])
				{
					flag = true;
				}
				if (num15 == num4)
				{
					Main.tile[num14, num15].slope(0);
					Main.tile[num14, num15].halfBrick(halfBrick: false);
					if (!flag)
					{
						Main.tile[num14, num15].active(active: true);
						Main.tile[num14, num15].type = 396;
					}
				}
				else if (num15 == num4 - num6)
				{
					Main.tile[num14, num15].ClearTile();
					Main.tile[num14, num15].active(active: true);
					if (flag && Main.tile[num14, num15 - 1].active() && Main.tileSolid[Main.tile[num14, num15 - 1].type])
					{
						Main.tile[num14, num15].type = 397;
					}
					else
					{
						Main.tile[num14, num15].type = 396;
					}
				}
				else if (num14 == i - num5 - 1 || num14 == i + num5 + 1)
				{
					if (!flag)
					{
						Main.tile[num14, num15].ClearTile();
						Main.tile[num14, num15].active(active: true);
						Main.tile[num14, num15].type = 396;
					}
					else
					{
						Main.tile[num14, num15].slope(0);
						Main.tile[num14, num15].halfBrick(halfBrick: false);
					}
				}
				else
				{
					Main.tile[num14, num15].ClearTile();
					Main.tile[num14, num15].active(active: true);
					Main.tile[num14, num15].type = 53;
				}
			}
		}
		for (int num16 = (int)((double)num4 - (double)num6 * 0.666); (double)num16 <= (double)num4 - (double)num6 * 0.333; num16++)
		{
			if ((double)num16 < (double)num4 - (double)num6 * 0.4)
			{
				if (Main.tile[i - num5 - 2, num16].bottomSlope())
				{
					Main.tile[i - num5 - 2, num16].slope(0);
				}
			}
			else if ((double)num16 > (double)num4 - (double)num6 * 0.6)
			{
				if (Main.tile[i - num5 - 2, num16].topSlope())
				{
					Main.tile[i - num5 - 2, num16].slope(0);
				}
				Main.tile[i - num5 - 2, num16].halfBrick(halfBrick: false);
			}
			else
			{
				Main.tile[i - num5 - 2, num16].halfBrick(halfBrick: false);
				Main.tile[i - num5 - 2, num16].slope(0);
			}
			if (!Main.tile[i - num5 - 2, num16].active() || !Main.tileSolid[Main.tile[i - num5 - 2, num16].type])
			{
				Main.tile[i - num5 - 2, num16].active(active: true);
				Main.tile[i - num5 - 2, num16].type = 396;
			}
			if (!Main.tile[i + num5 + 2, num16].active() || !Main.tileSolid[Main.tile[i + num5 + 2, num16].type])
			{
				Main.tile[i + num5 + 2, num16].active(active: true);
				Main.tile[i + num5 + 2, num16].type = 396;
			}
		}
		for (int num17 = num4 - num6; num17 <= num4; num17++)
		{
			Main.tile[i - num5 - 2, num17].slope(0);
			Main.tile[i - num5 - 2, num17].halfBrick(halfBrick: false);
			Main.tile[i - num5 - 1, num17].slope(0);
			Main.tile[i - num5 - 1, num17].halfBrick(halfBrick: false);
			Main.tile[i - num5 + 1, num17].slope(0);
			Main.tile[i - num5 + 1, num17].halfBrick(halfBrick: false);
			Main.tile[i - num5 + 2, num17].slope(0);
			Main.tile[i - num5 + 2, num17].halfBrick(halfBrick: false);
		}
		for (int num18 = i - num5 - 1; num18 < i + num5 + 1; num18++)
		{
			int num19 = k - num6 - 1;
			if (Main.tile[num18, num19].bottomSlope())
			{
				Main.tile[num18, num19].slope(0);
			}
			Main.tile[num18, num19].halfBrick(halfBrick: false);
		}
		KillTile(i - 2, k);
		KillTile(i - 1, k);
		KillTile(i + 1, k);
		KillTile(i + 2, k);
		PlaceTile(i, k, 135, mute: true, forced: false, -1, 7);
		for (int num20 = i - num5; num20 <= i + num5; num20++)
		{
			int num21 = k;
			if ((double)num20 < (double)i - (double)num5 * 0.8 || (double)num20 > (double)i + (double)num5 * 0.8)
			{
				num21 = k - 3;
			}
			else if ((double)num20 < (double)i - (double)num5 * 0.6 || (double)num20 > (double)i + (double)num5 * 0.6)
			{
				num21 = k - 2;
			}
			else if ((double)num20 < (double)i - (double)num5 * 0.4 || (double)num20 > (double)i + (double)num5 * 0.4)
			{
				num21 = k - 1;
			}
			for (int num22 = num4; num22 <= k; num22++)
			{
				if (num20 == i && num22 <= k)
				{
					Main.tile[i, num22].wire(wire: true);
				}
				if (Main.tile[num20, num22].active() && Main.tileSolid[Main.tile[num20, num22].type])
				{
					if (num22 < num4 + num - 4)
					{
						Main.tile[num20, num22].actuator(actuator: true);
						Main.tile[num20, num22].wire(wire: true);
					}
					else if (num22 < num21)
					{
						KillTile(num20, num22);
					}
				}
			}
		}
		return true;
	}

	public static bool AddBuriedChest(Point point, int contain = 0, bool notNearOtherChests = false, int Style = -1)
	{
		return AddBuriedChest(point.X, point.Y, contain, notNearOtherChests, Style, trySlope: false, 0);
	}

	public static bool IsChestRigged(int x, int y)
	{
		if (Main.tile[x, y].type == 467)
		{
			return Main.tile[x, y].frameX / 36 == 4;
		}
		return false;
	}

	private static bool IsUndergroundDesert(int x, int y)
	{
		if ((double)y < Main.worldSurface)
		{
			return false;
		}
		if ((double)x < (double)Main.maxTilesX * 0.15 || (double)x > (double)Main.maxTilesX * 0.85)
		{
			return false;
		}
		if (remixWorldGen && (double)y > Main.rockLayer)
		{
			return false;
		}
		int num = 15;
		for (int i = x - num; i <= x + num; i++)
		{
			for (int j = y - num; j <= y + num; j++)
			{
				if (Main.tile[i, j].wall == 187 || Main.tile[i, j].wall == 216)
				{
					return true;
				}
			}
		}
		return false;
	}

	private static bool IsDungeon(int x, int y)
	{
		if ((double)y < Main.worldSurface || y >= Main.maxTilesY)
		{
			return false;
		}
		if (x < 0 || x >= Main.maxTilesX)
		{
			return false;
		}
		if (Main.wallDungeon[Main.tile[x, y].wall])
		{
			return true;
		}
		return false;
	}

	public static void GetDungeonLootAndChestStyle(int x, int y, ref int itemType, ref int chestStyle)
	{
		itemType = 0;
		chestStyle = 2;
		if (GenVars.CurrentDungeonGenVars.dungeonLootStyle >= 8)
		{
			GenVars.CurrentDungeonGenVars.dungeonLootStyle = 0;
		}
		switch (GenVars.CurrentDungeonGenVars.dungeonLootStyle)
		{
		default:
			itemType = 155;
			break;
		case 1:
			itemType = 156;
			break;
		case 2:
			if (remixWorldGen)
			{
				itemType = 2623;
			}
			else
			{
				itemType = 157;
			}
			break;
		case 3:
			itemType = 163;
			break;
		case 4:
			itemType = 113;
			break;
		case 5:
			itemType = 3317;
			break;
		case 6:
			itemType = 327;
			chestStyle = 0;
			break;
		case 7:
			itemType = 164;
			break;
		}
		if ((double)y < Main.worldSurface + 50.0)
		{
			itemType = 327;
			chestStyle = 0;
		}
	}

	public static bool IsLockedDungeonBiomeChest(ushort chestType, int chestStyle)
	{
		switch (chestType)
		{
		case 21:
			if ((uint)(chestStyle - 23) > 4u)
			{
				return false;
			}
			return true;
		case 467:
			if (chestStyle != 13)
			{
				return false;
			}
			return true;
		default:
			return false;
		}
	}

	public static bool AddBuriedChest(int i, int j, int mainItemInChest = 0, bool notNearOtherChests = false, int chestStyle = -1, bool trySlope = false, ushort chestTileType = 0)
	{
		Point chestLocation = Point.Zero;
		return AddBuriedChest(i, j, out chestLocation, mainItemInChest, notNearOtherChests, chestStyle, trySlope, chestTileType);
	}

	public static bool AddBuriedChest(int i, int j, out Point chestLocation, int mainItemInChest = 0, bool notNearOtherChests = false, int chestStyle = -1, bool trySlope = false, ushort chestTileType = 0)
	{
		chestLocation = Point.Zero;
		if (chestTileType == 0)
		{
			chestTileType = 21;
		}
		int num = 15;
		if (tenthAnniversaryWorldGen)
		{
			num *= 3;
		}
		for (int k = j; k < Main.maxTilesY - 10; k++)
		{
			bool flag = false;
			bool flag2 = false;
			bool flag3 = false;
			bool flag4 = false;
			bool flag5 = false;
			bool flag6 = false;
			bool flag7 = false;
			bool flag8 = false;
			bool flag9 = false;
			bool flag10 = false;
			bool flag11 = false;
			bool flag12 = false;
			bool flag13 = false;
			int num2 = -1;
			int num3 = -1;
			if (Main.tile[i, k].anyShimmer())
			{
				return false;
			}
			if (Main.tile[i, k].active() && Main.tile[i, k].type == 231)
			{
				return false;
			}
			if (trySlope && Main.tile[i, k].active() && Main.tileSolid[Main.tile[i, k].type] && !Main.tileSolidTop[Main.tile[i, k].type])
			{
				if (chestStyle == 17)
				{
					int num4 = 30;
					for (int l = i - num4; l <= i + num4; l++)
					{
						for (int m = k - num4; m <= k + num4; m++)
						{
							if (!InWorld(l, m, 5))
							{
								return false;
							}
							if (Main.tile[l, m].active() && (Main.tile[l, m].type == 21 || Main.tile[l, m].type == 467))
							{
								return false;
							}
						}
					}
				}
				if (Main.tile[i - 1, k].topSlope())
				{
					num2 = Main.tile[i - 1, k].slope();
					Main.tile[i - 1, k].slope(0);
				}
				if (Main.tile[i, k].topSlope())
				{
					num3 = Main.tile[i, k].slope();
					Main.tile[i, k].slope(0);
				}
			}
			if (remixWorldGen && (double)i > (double)Main.maxTilesX * 0.37 && (double)i < (double)Main.maxTilesX * 0.63 && k > Main.maxTilesY - 250)
			{
				return false;
			}
			int num5 = 2;
			for (int n = i - num5; n <= i + num5; n++)
			{
				for (int num6 = k - num5; num6 <= k + num5; num6++)
				{
					if (InWorld(n, num6, 100) && Main.tile[n, num6].active() && (TileID.Sets.Boulders[Main.tile[n, num6].type] || Main.tile[n, num6].type == 26 || Main.tile[n, num6].type == 237))
					{
						return false;
					}
				}
			}
			if (!SolidTile(i, k))
			{
				continue;
			}
			bool flag14 = false;
			int num7 = k;
			int num8 = -1;
			int num9 = 0;
			int num10 = 0;
			bool flag15 = (double)num7 >= Main.worldSurface + 25.0;
			if (remixWorldGen)
			{
				flag15 = num7 < Main.maxTilesY - 400;
			}
			if (flag15 || num10 > 0)
			{
				num9 = 1;
			}
			if (chestStyle >= 0)
			{
				num9 = chestStyle;
			}
			if (mainItemInChest >= 0)
			{
				num10 = mainItemInChest;
			}
			if (SecretSeed.errorWorld.Enabled && chestTileType == 21 && genRand.Next(2) == 0)
			{
				int num11 = -1;
				switch (num9)
				{
				case 1:
				case 11:
				case 12:
				case 13:
				case 15:
					num11 = 6;
					break;
				case 0:
					num11 = 5;
					break;
				}
				if (num11 > -1)
				{
					if (genRand.Next(3) == 0)
					{
						num11 = genRand.Next(52);
						while (num11 >= 18 && num11 <= 27)
						{
							num11 = genRand.Next(53);
						}
					}
					num9 = num11;
				}
			}
			bool flag16 = Main.remixWorld && Main.getGoodWorld;
			bool flag17 = Main.drunkWorld && Main.tenthAnniversaryWorld;
			bool flag18 = Main.notTheBeesWorld && Main.tenthAnniversaryWorld;
			bool flag19 = chestTileType == 21;
			if (chestTileType == 21 && (chestStyle == 0 || (chestStyle == -1 && num9 == 0)))
			{
				flag = true;
			}
			if ((chestTileType == 467 && chestStyle == 10) || (chestTileType == 21 && chestStyle == 42 && flag16) || (num10 == 0 && num7 <= Main.maxTilesY - 205 && IsUndergroundDesert(i, k)))
			{
				flag3 = true;
				num9 = 10;
				chestTileType = 467;
				if (flag16 && chestStyle == 42 && flag19)
				{
					num9 = 42;
					chestTileType = 21;
				}
				bool flag20 = false;
				if (SecretSeed.dualDungeons.Enabled)
				{
					flag20 = GenVars.CurrentDungeonGenVars.desertChestLootState;
					GenVars.CurrentDungeonGenVars.desertChestLootState = !GenVars.CurrentDungeonGenVars.desertChestLootState;
				}
				else
				{
					flag20 = num7 > (GenVars.desertHiveHigh * 3 + GenVars.desertHiveLow * 4) / 7;
				}
				num10 = ((!flag20) ? Utils.SelectRandom(genRand, new short[4] { 4056, 4055, 4262, 4263 }) : Utils.SelectRandom(genRand, new short[3] { 4061, 4062, 4276 }));
				if (getGoodWorldGen && genRand.Next(num) == 0)
				{
					num10 = 52;
				}
			}
			bool flag21 = false;
			if (notTheBees && !remixWorldGen && !dontStarveWorldGen)
			{
				int num12 = GenVars.lavaLine + genRand.Next(5);
				int num13 = (int)Main.worldSurface + genRand.Next(-2, 3) + 35;
				_ = (num12 + num13) / 2;
				if (num7 > num13 && num7 <= num12 && (i < beachDistance + 200 - 20 - genRand.Next(-2, 3) || i > Main.maxTilesX - beachDistance - 200 + 20 + genRand.Next(-2, 3)))
				{
					flag21 = true;
				}
			}
			if ((chestTileType == 21 && chestStyle == 11) || (chestTileType == 467 && chestStyle == 24) || (num10 == 0 && (double)num7 >= Main.worldSurface + 25.0 && num7 <= Main.maxTilesY - 205 && (Main.tile[i, k].type == 147 || Main.tile[i, k].type == 161 || Main.tile[i, k].type == 162 || Main.tile[i, k].type == 197 || flag21)))
			{
				flag2 = true;
				if (chestTileType == 21)
				{
					num9 = 11;
				}
				if (flag17 && chestTileType == 21 && chestStyle == 34)
				{
					num9 = 34;
				}
				num10 = genRand.Next(6) switch
				{
					0 => 670, 
					1 => 724, 
					2 => 950, 
					3 => (!remixWorldGen) ? 1319 : 725, 
					4 => 987, 
					_ => 1579, 
				};
				if (genRand.Next(20) == 0)
				{
					num10 = 997;
				}
				if (genRand.Next(50) == 0)
				{
					num10 = 669;
				}
				if (getGoodWorldGen && genRand.Next(num) == 0)
				{
					num10 = 52;
				}
			}
			if ((chestTileType == 21 && (chestStyle == 10 || ((chestStyle == 8 || chestStyle == 29) && SecretSeed.dualDungeons.Enabled) || (chestStyle == 29 && flag18))) || (chestTileType == 467 && chestStyle == 11 && flag18) || num10 == 211 || num10 == 212 || num10 == 213 || num10 == 753)
			{
				flag4 = true;
				if (!GenVars.CurrentDungeonGenVars.GeneratingDungeon)
				{
					num9 = 10;
					chestTileType = 21;
				}
				if (flag18)
				{
					if (chestStyle == 29 && flag19)
					{
						num9 = 29;
						chestTileType = 21;
					}
					else if (chestStyle == 11 && !flag19)
					{
						num9 = 11;
						chestTileType = 467;
					}
				}
				if (getGoodWorldGen && genRand.Next(num) == 0)
				{
					num10 = 52;
				}
			}
			if (chestTileType == 21 && (chestStyle == 4 || (num7 > Main.maxTilesY - 205 && num10 == 0)))
			{
				flag8 = true;
				num10 = GenVars.hellChestItem[GenVars.hellChest];
				num9 = 4;
				flag14 = true;
				if (getGoodWorldGen && genRand.Next(num) == 0)
				{
					num10 = 52;
				}
			}
			if (chestTileType == 21 && num9 == 17)
			{
				flag5 = true;
				if (getGoodWorldGen && genRand.Next(num) == 0)
				{
					num10 = 52;
				}
			}
			if (chestTileType == 21 && num9 == 12)
			{
				if (Main.tile[i - 1, num7 - 1].wall != 244)
				{
					num9 = 0;
					num10 = 0;
					flag = true;
				}
				else
				{
					flag6 = true;
					if (getGoodWorldGen && genRand.Next(num) == 0)
					{
						num10 = 52;
					}
				}
			}
			if (chestTileType == 21 && num9 == 32)
			{
				flag7 = true;
				if (getGoodWorldGen && genRand.Next(num) == 0)
				{
					num10 = 52;
				}
			}
			if (chestTileType == 21 && num9 == 16)
			{
				flag13 = true;
			}
			if (chestTileType == 21 && num9 != 0 && IsDungeon(i, k))
			{
				flag9 = true;
			}
			if (IsLockedDungeonBiomeChest(chestTileType, num9))
			{
				flag9 = true;
				flag10 = true;
			}
			if (chestTileType == 21 && num9 != 0 && (num10 == 848 || num10 == 857 || num10 == 934))
			{
				flag11 = true;
			}
			if (chestTileType == 21 && (num9 == 13 || num10 == 159 || num10 == 65 || num10 == 158 || num10 == 2219))
			{
				flag12 = true;
				if (remixWorldGen && !getGoodWorldGen && !tenthAnniversaryWorldGen)
				{
					bool flag22 = crimson;
					if (drunkWorldGen)
					{
						flag22 = (GenVars.crimsonLeft && i < Main.maxTilesX / 2) || ((!GenVars.crimsonLeft && i > Main.maxTilesX / 2) ? true : false);
					}
					if (flag22)
					{
						num9 = 43;
					}
					else
					{
						chestTileType = 467;
						num9 = 3;
					}
				}
			}
			if ((num10 == 939 || (chestTileType == 21 && num9 == 15) || (chestTileType == 467 && num9 == 2)) && num10 == 0)
			{
				num10 = 939;
			}
			if (noTrapsWorldGen && num9 == 1 && chestTileType == 21 && (!remixWorldGen || genRand.Next(3) == 0))
			{
				num9 = 4;
				chestTileType = 467;
			}
			num8 = ((chestTileType != 467) ? PlaceChest(i - 1, num7 - 1, chestTileType, notNearOtherChests, num9) : PlaceChest(i - 1, num7 - 1, chestTileType, notNearOtherChests, num9));
			if (num8 >= 0)
			{
				chestLocation = new Point(i - 1, num7 - 1);
				if (flag14)
				{
					GenVars.hellChest++;
					if (GenVars.hellChest >= GenVars.hellChestItem.Length)
					{
						GenVars.hellChest = 0;
					}
				}
				Chest chest = Main.chest[num8];
				int itemIndex = 0;
				while (itemIndex == 0)
				{
					bool flag23 = (double)num7 < Main.worldSurface + 25.0;
					if (remixWorldGen)
					{
						flag23 = (double)num7 >= (Main.rockLayer + (double)((Main.maxTilesY - 350) * 2)) / 3.0;
					}
					if ((flag23 && (flag || flag6)) || flag11)
					{
						if (num10 > 0)
						{
							chest.item[itemIndex].SetDefaults(num10);
							chest.item[itemIndex].Prefix(-1);
							itemIndex++;
							switch (num10)
							{
							case 848:
								chest.item[itemIndex].SetDefaults(866);
								itemIndex++;
								break;
							case 832:
								chest.item[itemIndex].SetDefaults(933);
								itemIndex++;
								break;
							}
							if (flag6 && genRand.Next(3) == 0)
							{
								chest.item[itemIndex++].SetDefaults(5629);
							}
							if (flag6 && genRand.Next(6) == 0)
							{
								int num14 = genRand.Next(2);
								switch (num14)
								{
								case 0:
									num14 = 4429;
									break;
								case 1:
									num14 = 4427;
									break;
								}
								chest.item[itemIndex++].SetDefaults(num14);
							}
							if (flag6 && genRand.Next(3) != 0)
							{
								chest.item[itemIndex++].SetDefaults(5528);
							}
							if (Main.tenthAnniversaryWorld && flag11)
							{
								chest.item[itemIndex++].SetDefaults(848);
								chest.item[itemIndex++].SetDefaults(866);
							}
						}
						else
						{
							int num15 = genRand.Next(10);
							if (num15 == 0)
							{
								chest.item[itemIndex].SetDefaults(280);
								chest.item[itemIndex].Prefix(-1);
							}
							if (num15 == 1)
							{
								chest.item[itemIndex].SetDefaults(281);
								chest.item[itemIndex].Prefix(-1);
							}
							if (num15 == 2)
							{
								chest.item[itemIndex].SetDefaults(284);
								chest.item[itemIndex].Prefix(-1);
							}
							if (num15 == 3)
							{
								chest.item[itemIndex].SetDefaults(285);
								chest.item[itemIndex].Prefix(-1);
							}
							if (num15 == 4)
							{
								chest.item[itemIndex].SetDefaults(953);
								chest.item[itemIndex].Prefix(-1);
							}
							if (num15 == 5)
							{
								chest.item[itemIndex].SetDefaults(946);
								chest.item[itemIndex].Prefix(-1);
							}
							if (num15 == 6)
							{
								chest.item[itemIndex].SetDefaults(3068);
								chest.item[itemIndex].Prefix(-1);
							}
							if (num15 == 7)
							{
								if (remixWorldGen)
								{
									chest.item[itemIndex].SetDefaults(517);
									chest.item[itemIndex].Prefix(-1);
								}
								else
								{
									chest.item[itemIndex].SetDefaults(3069);
									chest.item[itemIndex].Prefix(-1);
								}
							}
							if (num15 == 8)
							{
								chest.item[itemIndex].SetDefaults(3084);
								chest.item[itemIndex].Prefix(-1);
							}
							if (num15 == 9)
							{
								chest.item[itemIndex].SetDefaults(4341);
								chest.item[itemIndex].Prefix(-1);
							}
							itemIndex++;
						}
						if (genRand.Next(6) == 0)
						{
							int stack = genRand.Next(40, 76);
							short type = 282;
							if (SecretSeed.GenerateRainbowGlowsticks)
							{
								type = 5643;
							}
							chest.item[itemIndex].SetDefaults(type);
							chest.item[itemIndex].stack = stack;
							itemIndex++;
						}
						if (genRand.Next(6) == 0)
						{
							int stack2 = genRand.Next(150, 301);
							chest.item[itemIndex].SetDefaults(279);
							chest.item[itemIndex].stack = stack2;
							itemIndex++;
						}
						if (genRand.Next(6) == 0)
						{
							chest.item[itemIndex].SetDefaults(3093);
							chest.item[itemIndex].stack = 1;
							if (genRand.Next(5) == 0)
							{
								chest.item[itemIndex].stack += genRand.Next(2);
							}
							if (genRand.Next(10) == 0)
							{
								chest.item[itemIndex].stack += genRand.Next(3);
							}
							itemIndex++;
						}
						if (genRand.Next(6) == 0)
						{
							chest.item[itemIndex].SetDefaults(4345);
							chest.item[itemIndex].stack = 1;
							if (genRand.Next(5) == 0)
							{
								chest.item[itemIndex].stack += genRand.Next(2);
							}
							if (genRand.Next(10) == 0)
							{
								chest.item[itemIndex].stack += genRand.Next(3);
							}
							itemIndex++;
						}
						if (genRand.Next(3) == 0)
						{
							chest.item[itemIndex].SetDefaults(168);
							chest.item[itemIndex].stack = genRand.Next(3, 6);
							itemIndex++;
						}
						if (genRand.Next(2) == 0)
						{
							int num16 = genRand.Next(2);
							int stack3 = genRand.Next(8) + 3;
							if (num16 == 0)
							{
								chest.item[itemIndex].SetDefaults(GenVars.copperBar);
							}
							if (num16 == 1)
							{
								chest.item[itemIndex].SetDefaults(GenVars.ironBar);
							}
							chest.item[itemIndex].stack = stack3;
							itemIndex++;
						}
						if (genRand.Next(2) == 0)
						{
							int stack4 = genRand.Next(50, 101);
							chest.item[itemIndex].SetDefaults(965);
							chest.item[itemIndex].stack = stack4;
							itemIndex++;
						}
						if (genRand.Next(3) != 0)
						{
							int num17 = genRand.Next(2);
							int stack5 = genRand.Next(26) + 25;
							if (num17 == 0)
							{
								chest.item[itemIndex].SetDefaults(40);
							}
							if (num17 == 1)
							{
								chest.item[itemIndex].SetDefaults(42);
							}
							chest.item[itemIndex].stack = stack5;
							itemIndex++;
						}
						if (genRand.Next(2) == 0)
						{
							int stack6 = genRand.Next(3) + 3;
							chest.item[itemIndex].SetDefaults(28);
							chest.item[itemIndex].stack = stack6;
							itemIndex++;
						}
						if (genRand.Next(3) != 0)
						{
							chest.item[itemIndex].SetDefaults(2350);
							chest.item[itemIndex].stack = genRand.Next(3, 6);
							itemIndex++;
						}
						if (genRand.Next(3) > 0)
						{
							int num18 = genRand.Next(6);
							int stack7 = genRand.Next(1, 3);
							if (num18 == 0)
							{
								chest.item[itemIndex].SetDefaults(292);
							}
							if (num18 == 1)
							{
								chest.item[itemIndex].SetDefaults(298);
							}
							if (num18 == 2)
							{
								chest.item[itemIndex].SetDefaults(299);
							}
							if (num18 == 3)
							{
								chest.item[itemIndex].SetDefaults(290);
							}
							if (num18 == 4)
							{
								chest.item[itemIndex].SetDefaults(2322);
							}
							if (num18 == 5)
							{
								chest.item[itemIndex].SetDefaults(2325);
							}
							chest.item[itemIndex].stack = stack7;
							itemIndex++;
						}
						if (genRand.Next(2) == 0)
						{
							int num19 = genRand.Next(2);
							int stack8 = genRand.Next(11) + 10;
							if (num19 == 0)
							{
								chest.item[itemIndex].SetDefaults(8);
							}
							else
							{
								chest.item[itemIndex].SetDefaults(31);
							}
							chest.item[itemIndex].stack = stack8;
							itemIndex++;
						}
						if (genRand.Next(2) == 0)
						{
							chest.item[itemIndex].SetDefaults(72);
							chest.item[itemIndex].stack = genRand.Next(10, 30);
							itemIndex++;
						}
						if (genRand.Next(2) == 0)
						{
							chest.item[itemIndex].SetDefaults(9);
							chest.item[itemIndex].stack = genRand.Next(50, 100);
							itemIndex++;
						}
					}
					else if ((!remixWorldGen && (double)num7 < Main.rockLayer) || (remixWorldGen && (double)num7 > Main.rockLayer && num7 < Main.maxTilesY - 250))
					{
						if (num10 > 0)
						{
							if (num10 == 832)
							{
								chest.item[itemIndex].SetDefaults(933);
								itemIndex++;
							}
							chest.item[itemIndex].SetDefaults(num10);
							chest.item[itemIndex].Prefix(-1);
							itemIndex++;
							if (flag5)
							{
								if (genRand.Next(2) == 0)
								{
									chest.item[itemIndex++].SetDefaults(4425);
								}
								if (genRand.Next(2) == 0)
								{
									chest.item[itemIndex++].SetDefaults(4460);
								}
							}
							if (flag12 && genRand.Next(40) == 0)
							{
								chest.item[itemIndex].SetDefaults(4978);
								chest.item[itemIndex].Prefix(-1);
								itemIndex++;
							}
							if (flag6 && genRand.Next(3) == 0)
							{
								chest.item[itemIndex++].SetDefaults(5629);
							}
							if (flag6 && genRand.Next(6) == 0)
							{
								int num20 = genRand.Next(2);
								switch (num20)
								{
								case 0:
									num20 = 4429;
									break;
								case 1:
									num20 = 4427;
									break;
								}
								chest.item[itemIndex].SetDefaults(num20);
								itemIndex++;
							}
							if (flag6 && genRand.Next(3) != 0)
							{
								chest.item[itemIndex++].SetDefaults(5528);
							}
							if (flag9 && !flag10)
							{
								if (!GenVars.generatedShadowKey || genRand.Next(3) == 0)
								{
									GenVars.generatedShadowKey = true;
									chest.item[itemIndex].SetDefaults(329);
									itemIndex++;
								}
								if (!GenVars.generatedRamRune || genRand.Next(8) == 0)
								{
									GenVars.generatedRamRune = true;
									chest.item[itemIndex].SetDefaults(5465);
									chest.item[itemIndex].Prefix(-1);
									itemIndex++;
								}
							}
						}
						else
						{
							switch (genRand.Next(6))
							{
							case 0:
								chest.item[itemIndex].SetDefaults(49);
								chest.item[itemIndex].Prefix(-1);
								break;
							case 1:
								chest.item[itemIndex].SetDefaults(50);
								chest.item[itemIndex].Prefix(-1);
								break;
							case 2:
								chest.item[itemIndex].SetDefaults(53);
								chest.item[itemIndex].Prefix(-1);
								break;
							case 3:
								chest.item[itemIndex].SetDefaults(54);
								chest.item[itemIndex].Prefix(-1);
								break;
							case 4:
								chest.item[itemIndex].SetDefaults(5011);
								chest.item[itemIndex].Prefix(-1);
								break;
							default:
								chest.item[itemIndex].SetDefaults(975);
								chest.item[itemIndex].Prefix(-1);
								break;
							}
							if (Main.vampireSeed && genRand.Next(10) == 1)
							{
								if (genRand.Next(2) == 0)
								{
									chest.item[itemIndex].SetDefaults(1800);
									chest.item[itemIndex].Prefix(-1);
								}
								else
								{
									chest.item[itemIndex].SetDefaults(900);
									chest.item[itemIndex].Prefix(-1);
								}
							}
							if (SecretSeed.errorWorld.Enabled && genRand.Next(SecretSeed.Variations.errorWorldAdjustment(3.0)) == 0)
							{
								int num21 = SecretSeed.DoErrorWorldFindChestItem();
								if (num21 > 0)
								{
									chest.item[itemIndex].SetDefaults(num21);
								}
								chest.item[itemIndex].Prefix(-1);
							}
							itemIndex++;
							if (genRand.Next(20) == 0)
							{
								chest.item[itemIndex].SetDefaults(997);
								chest.item[itemIndex].Prefix(-1);
								itemIndex++;
							}
							else if (genRand.Next(20) == 0)
							{
								chest.item[itemIndex].SetDefaults(930);
								chest.item[itemIndex].Prefix(-1);
								itemIndex++;
								if (SecretSeed.rainbowStuff.Enabled)
								{
									chest.item[itemIndex].SetDefaults(5379);
									chest.item[itemIndex].stack = genRand.Next(50) + 50;
								}
								else
								{
									chest.item[itemIndex].SetDefaults(931);
									chest.item[itemIndex].stack = genRand.Next(26) + 25;
								}
								itemIndex++;
							}
							if (flag7 && genRand.Next(2) == 0)
							{
								chest.item[itemIndex].SetDefaults(4450);
								itemIndex++;
							}
							if (flag7 && genRand.Next(3) == 0)
							{
								chest.item[itemIndex].SetDefaults(4779);
								itemIndex++;
								chest.item[itemIndex].SetDefaults(4780);
								itemIndex++;
								chest.item[itemIndex].SetDefaults(4781);
								itemIndex++;
							}
						}
						if (flag3)
						{
							if (genRand.Next(3) == 0)
							{
								chest.item[itemIndex].SetDefaults(4423);
								chest.item[itemIndex].stack = genRand.Next(10, 20);
								itemIndex++;
							}
						}
						else if (genRand.Next(3) == 0)
						{
							chest.item[itemIndex].SetDefaults(166);
							chest.item[itemIndex].stack = genRand.Next(10, 20);
							itemIndex++;
						}
						if (genRand.Next(5) == 0)
						{
							chest.item[itemIndex].SetDefaults(52);
							itemIndex++;
						}
						if (genRand.Next(3) == 0)
						{
							int stack9 = genRand.Next(50, 101);
							chest.item[itemIndex].SetDefaults(965);
							chest.item[itemIndex].stack = stack9;
							itemIndex++;
						}
						if (genRand.Next(2) == 0)
						{
							int num22 = genRand.Next(2);
							int stack10 = genRand.Next(10) + 5;
							if (num22 == 0)
							{
								chest.item[itemIndex].SetDefaults(GenVars.ironBar);
							}
							if (num22 == 1)
							{
								chest.item[itemIndex].SetDefaults(GenVars.silverBar);
							}
							chest.item[itemIndex].stack = stack10;
							itemIndex++;
						}
						if (genRand.Next(2) == 0)
						{
							int num23 = genRand.Next(2);
							int stack11 = genRand.Next(25) + 25;
							if (num23 == 0)
							{
								chest.item[itemIndex].SetDefaults(40);
							}
							if (num23 == 1)
							{
								chest.item[itemIndex].SetDefaults(42);
							}
							chest.item[itemIndex].stack = stack11;
							itemIndex++;
						}
						if (genRand.Next(2) == 0)
						{
							int stack12 = genRand.Next(3) + 3;
							chest.item[itemIndex].SetDefaults(28);
							chest.item[itemIndex].stack = stack12;
							itemIndex++;
						}
						if (genRand.Next(3) > 0)
						{
							int num24 = genRand.Next(9);
							int stack13 = genRand.Next(1, 3);
							if (num24 == 0)
							{
								chest.item[itemIndex].SetDefaults(289);
							}
							if (num24 == 1)
							{
								chest.item[itemIndex].SetDefaults(298);
							}
							if (num24 == 2)
							{
								chest.item[itemIndex].SetDefaults(299);
							}
							if (num24 == 3)
							{
								chest.item[itemIndex].SetDefaults(290);
							}
							if (num24 == 4)
							{
								chest.item[itemIndex].SetDefaults(303);
							}
							if (num24 == 5)
							{
								chest.item[itemIndex].SetDefaults(291);
							}
							if (num24 == 6)
							{
								chest.item[itemIndex].SetDefaults(304);
							}
							if (num24 == 7)
							{
								chest.item[itemIndex].SetDefaults(2322);
							}
							if (num24 == 8)
							{
								chest.item[itemIndex].SetDefaults(2329);
							}
							chest.item[itemIndex].stack = stack13;
							itemIndex++;
						}
						if (genRand.Next(3) != 0)
						{
							int stack14 = genRand.Next(2, 5);
							chest.item[itemIndex].SetDefaults(2350);
							chest.item[itemIndex].stack = stack14;
							itemIndex++;
						}
						if (genRand.Next(2) == 0)
						{
							int stack15 = genRand.Next(11) + 10;
							if (flag2)
							{
								chest.item[itemIndex].SetDefaults(974);
							}
							else
							{
								chest.item[itemIndex].SetDefaults(8);
							}
							chest.item[itemIndex].stack = stack15;
							itemIndex++;
						}
						if (genRand.Next(2) == 0)
						{
							chest.item[itemIndex].SetDefaults(72);
							chest.item[itemIndex].stack = genRand.Next(50, 90);
							itemIndex++;
						}
					}
					else if (num7 < Main.maxTilesY - 250 || (remixWorldGen && (chestStyle == 7 || chestStyle == 14)))
					{
						if (num10 > 0)
						{
							chest.item[itemIndex].SetDefaults(num10);
							chest.item[itemIndex].Prefix(-1);
							itemIndex++;
							if (flag2 && genRand.Next(5) == 0)
							{
								chest.item[itemIndex].SetDefaults(3199);
								itemIndex++;
							}
							if (flag3)
							{
								if (genRand.Next(7) == 0)
								{
									chest.item[itemIndex].SetDefaults(4346);
									itemIndex++;
								}
								if (genRand.Next(15) == 0)
								{
									chest.item[itemIndex].SetDefaults(4066);
									itemIndex++;
								}
							}
							if (flag4)
							{
								if (!GenVars.gennedLivingMahoganyWands || genRand.Next(5) == 0)
								{
									GenVars.gennedLivingMahoganyWands = true;
									chest.item[itemIndex++].SetDefaults(3360);
									chest.item[itemIndex++].SetDefaults(3361);
								}
								if (genRand.Next(10) == 0)
								{
									chest.item[itemIndex++].SetDefaults(4426);
								}
								if (genRand.Next(10) == 0)
								{
									chest.item[itemIndex++].SetDefaults(5525);
								}
							}
							if (flag5)
							{
								if (genRand.Next(2) == 0)
								{
									chest.item[itemIndex++].SetDefaults(4425);
								}
								if (genRand.Next(2) == 0)
								{
									chest.item[itemIndex++].SetDefaults(4460);
								}
							}
							if (flag9 && !flag10)
							{
								if (!GenVars.generatedShadowKey || genRand.Next(3) == 0)
								{
									GenVars.generatedShadowKey = true;
									chest.item[itemIndex].SetDefaults(329);
									itemIndex++;
								}
								if (!GenVars.generatedRamRune || genRand.Next(8) == 0)
								{
									GenVars.generatedRamRune = true;
									chest.item[itemIndex].SetDefaults(5465);
									chest.item[itemIndex].Prefix(-1);
									itemIndex++;
								}
							}
						}
						else
						{
							int num25 = genRand.Next(7);
							bool flag24 = num7 > GenVars.lavaLine;
							if (remixWorldGen)
							{
								flag24 = (double)num7 > Main.worldSurface && (double)num7 < Main.rockLayer;
							}
							int maxValue = 20;
							if (tenthAnniversaryWorldGen)
							{
								maxValue = 15;
							}
							if (genRand.Next(maxValue) == 0 && flag24)
							{
								chest.item[itemIndex].SetDefaults(906);
								chest.item[itemIndex].Prefix(-1);
							}
							else if (genRand.Next(15) == 0)
							{
								chest.item[itemIndex].SetDefaults(997);
								chest.item[itemIndex].Prefix(-1);
							}
							else
							{
								if (num25 == 0)
								{
									chest.item[itemIndex].SetDefaults(49);
									chest.item[itemIndex].Prefix(-1);
								}
								if (num25 == 1)
								{
									chest.item[itemIndex].SetDefaults(50);
									chest.item[itemIndex].Prefix(-1);
								}
								if (num25 == 2)
								{
									chest.item[itemIndex].SetDefaults(53);
									chest.item[itemIndex].Prefix(-1);
								}
								if (num25 == 3)
								{
									chest.item[itemIndex].SetDefaults(54);
									chest.item[itemIndex].Prefix(-1);
								}
								if (num25 == 4)
								{
									chest.item[itemIndex].SetDefaults(5011);
									chest.item[itemIndex].Prefix(-1);
								}
								if (num25 == 5)
								{
									chest.item[itemIndex].SetDefaults(975);
									chest.item[itemIndex].Prefix(-1);
								}
								if (num25 == 6)
								{
									chest.item[itemIndex].SetDefaults(930);
									chest.item[itemIndex].Prefix(-1);
									itemIndex++;
									if (SecretSeed.rainbowStuff.Enabled)
									{
										chest.item[itemIndex].SetDefaults(5379);
										chest.item[itemIndex].stack = genRand.Next(50) + 50;
									}
									else
									{
										chest.item[itemIndex].SetDefaults(931);
										chest.item[itemIndex].stack = genRand.Next(26) + 25;
									}
								}
								else
								{
									if (Main.vampireSeed && genRand.Next(10) == 0)
									{
										if (genRand.Next(2) == 0)
										{
											chest.item[itemIndex].SetDefaults(1800);
											chest.item[itemIndex].Prefix(-1);
										}
										else
										{
											chest.item[itemIndex].SetDefaults(900);
											chest.item[itemIndex].Prefix(-1);
										}
									}
									if (SecretSeed.errorWorld.Enabled && genRand.Next(SecretSeed.Variations.errorWorldAdjustment(3.0)) == 0)
									{
										num25 = SecretSeed.DoErrorWorldFindChestItem();
										if (num25 > 0)
										{
											chest.item[itemIndex].SetDefaults(num25);
										}
										chest.item[itemIndex].Prefix(-1);
									}
								}
							}
							itemIndex++;
							if (flag7)
							{
								if (genRand.Next(2) == 0)
								{
									chest.item[itemIndex].SetDefaults(4450);
									itemIndex++;
								}
								else
								{
									chest.item[itemIndex].SetDefaults(4779);
									itemIndex++;
									chest.item[itemIndex].SetDefaults(4780);
									itemIndex++;
									chest.item[itemIndex].SetDefaults(4781);
									itemIndex++;
								}
							}
						}
						if (genRand.Next(5) == 0)
						{
							if (flag2)
							{
								chest.item[itemIndex].SetDefaults(5120);
							}
							else
							{
								chest.item[itemIndex].SetDefaults(43);
							}
							itemIndex++;
						}
						if (genRand.Next(3) == 0)
						{
							chest.item[itemIndex].SetDefaults(167);
							itemIndex++;
						}
						if (genRand.Next(4) == 0)
						{
							chest.item[itemIndex].SetDefaults(51);
							chest.item[itemIndex].stack = genRand.Next(26) + 25;
							itemIndex++;
						}
						if (genRand.Next(2) == 0)
						{
							int num26 = genRand.Next(2);
							int stack16 = genRand.Next(8) + 3;
							if (num26 == 0)
							{
								chest.item[itemIndex].SetDefaults(GenVars.goldBar);
							}
							if (num26 == 1)
							{
								chest.item[itemIndex].SetDefaults(GenVars.silverBar);
							}
							chest.item[itemIndex].stack = stack16;
							itemIndex++;
						}
						if (genRand.Next(2) == 0)
						{
							int num27 = genRand.Next(2);
							int stack17 = genRand.Next(26) + 25;
							if (num27 == 0)
							{
								chest.item[itemIndex].SetDefaults(41);
							}
							if (num27 == 1)
							{
								chest.item[itemIndex].SetDefaults(279);
							}
							chest.item[itemIndex].stack = stack17;
							itemIndex++;
						}
						if (genRand.Next(2) == 0)
						{
							int stack18 = genRand.Next(3) + 3;
							chest.item[itemIndex].SetDefaults(188);
							chest.item[itemIndex].stack = stack18;
							itemIndex++;
						}
						if (genRand.Next(3) > 0)
						{
							int num28 = genRand.Next(6);
							int stack19 = genRand.Next(1, 3);
							if (num28 == 0)
							{
								chest.item[itemIndex].SetDefaults(296);
							}
							if (num28 == 1)
							{
								chest.item[itemIndex].SetDefaults(295);
							}
							if (num28 == 2)
							{
								chest.item[itemIndex].SetDefaults(299);
							}
							if (num28 == 3)
							{
								chest.item[itemIndex].SetDefaults(302);
							}
							if (num28 == 4)
							{
								chest.item[itemIndex].SetDefaults(303);
							}
							if (num28 == 5)
							{
								chest.item[itemIndex].SetDefaults(305);
							}
							chest.item[itemIndex].stack = stack19;
							itemIndex++;
						}
						if (genRand.Next(3) > 1)
						{
							int num29 = genRand.Next(6);
							int stack20 = genRand.Next(1, 3);
							if (num29 == 0)
							{
								chest.item[itemIndex].SetDefaults(301);
							}
							if (num29 == 1)
							{
								chest.item[itemIndex].SetDefaults(297);
							}
							if (num29 == 2)
							{
								chest.item[itemIndex].SetDefaults(304);
							}
							if (num29 == 3)
							{
								chest.item[itemIndex].SetDefaults(2329);
							}
							if (num29 == 4)
							{
								chest.item[itemIndex].SetDefaults(2351);
							}
							if (num29 == 5)
							{
								chest.item[itemIndex].SetDefaults(2326);
							}
							chest.item[itemIndex].stack = stack20;
							itemIndex++;
						}
						if (genRand.Next(2) == 0)
						{
							int stack21 = genRand.Next(2, 5);
							chest.item[itemIndex].SetDefaults(2350);
							chest.item[itemIndex].stack = stack21;
							itemIndex++;
						}
						if (genRand.Next(2) == 0 || (Main.vampireSeed && genRand.Next(2) == 0))
						{
							int num30 = genRand.Next(2);
							int num31 = genRand.Next(15, 31);
							if (Main.vampireSeed)
							{
								num31 *= 2;
							}
							if (num30 == 0)
							{
								if (flag2)
								{
									chest.item[itemIndex].SetDefaults(974);
								}
								else
								{
									chest.item[itemIndex].SetDefaults(8);
								}
							}
							else
							{
								short type2 = 282;
								if (SecretSeed.GenerateRainbowGlowsticks)
								{
									type2 = 5643;
								}
								chest.item[itemIndex].SetDefaults(type2);
							}
							chest.item[itemIndex].stack = num31;
							itemIndex++;
						}
						if (genRand.Next(2) == 0)
						{
							chest.item[itemIndex].SetDefaults(73);
							chest.item[itemIndex].stack = genRand.Next(1, 3);
							itemIndex++;
						}
					}
					else
					{
						if (num10 > 0)
						{
							chest.item[itemIndex].SetDefaults(num10);
							chest.item[itemIndex].Prefix(-1);
							itemIndex++;
							if (flag8 && genRand.Next(5) == 0)
							{
								chest.item[itemIndex].SetDefaults(5010);
								chest.item[itemIndex].Prefix(-1);
								itemIndex++;
							}
							if (flag8 && genRand.Next(10) == 0)
							{
								chest.item[itemIndex].SetDefaults(4443);
								itemIndex++;
							}
							if (flag8 && genRand.Next(10) == 0)
							{
								chest.item[itemIndex].SetDefaults(4737);
								itemIndex++;
							}
							if (flag8 && genRand.Next(10) == 0)
							{
								chest.item[itemIndex].SetDefaults(4551);
								itemIndex++;
							}
						}
						else
						{
							int num32 = genRand.Next(4);
							if (num32 == 0)
							{
								chest.item[itemIndex].SetDefaults(49);
								chest.item[itemIndex].Prefix(-1);
							}
							if (num32 == 1)
							{
								chest.item[itemIndex].SetDefaults(50);
								chest.item[itemIndex].Prefix(-1);
							}
							if (num32 == 2)
							{
								chest.item[itemIndex].SetDefaults(53);
								chest.item[itemIndex].Prefix(-1);
							}
							if (num32 == 3)
							{
								chest.item[itemIndex].SetDefaults(54);
								chest.item[itemIndex].Prefix(-1);
							}
							itemIndex++;
						}
						if (genRand.Next(3) == 0)
						{
							chest.item[itemIndex].SetDefaults(167);
							itemIndex++;
						}
						if (genRand.Next(2) == 0)
						{
							int num33 = genRand.Next(2);
							int stack22 = genRand.Next(15) + 15;
							if (num33 == 0)
							{
								chest.item[itemIndex].SetDefaults(117);
							}
							if (num33 == 1)
							{
								chest.item[itemIndex].SetDefaults(GenVars.goldBar);
							}
							chest.item[itemIndex].stack = stack22;
							itemIndex++;
						}
						if (genRand.Next(2) == 0)
						{
							int num34 = genRand.Next(2);
							int stack23 = genRand.Next(25) + 50;
							if (num34 == 0)
							{
								chest.item[itemIndex].SetDefaults(265);
							}
							if (num34 == 1)
							{
								if (SavedOreTiers.Silver == 168)
								{
									chest.item[itemIndex].SetDefaults(4915);
								}
								else
								{
									chest.item[itemIndex].SetDefaults(278);
								}
							}
							chest.item[itemIndex].stack = stack23;
							itemIndex++;
						}
						if (genRand.Next(2) == 0)
						{
							int stack24 = genRand.Next(6) + 15;
							chest.item[itemIndex].SetDefaults(227);
							chest.item[itemIndex].stack = stack24;
							itemIndex++;
						}
						if (genRand.Next(4) > 0)
						{
							int num35 = genRand.Next(8);
							int stack25 = genRand.Next(1, 3);
							if (num35 == 0)
							{
								chest.item[itemIndex].SetDefaults(296);
							}
							if (num35 == 1)
							{
								chest.item[itemIndex].SetDefaults(295);
							}
							if (num35 == 2)
							{
								chest.item[itemIndex].SetDefaults(293);
							}
							if (num35 == 3)
							{
								chest.item[itemIndex].SetDefaults(288);
							}
							if (num35 == 4)
							{
								chest.item[itemIndex].SetDefaults(294);
							}
							if (num35 == 5)
							{
								chest.item[itemIndex].SetDefaults(297);
							}
							if (num35 == 6)
							{
								chest.item[itemIndex].SetDefaults(304);
							}
							if (num35 == 7)
							{
								chest.item[itemIndex].SetDefaults(2323);
							}
							chest.item[itemIndex].stack = stack25;
							itemIndex++;
						}
						if (genRand.Next(3) > 0)
						{
							int num36 = genRand.Next(8);
							int stack26 = genRand.Next(1, 3);
							if (num36 == 0)
							{
								chest.item[itemIndex].SetDefaults(305);
							}
							if (num36 == 1)
							{
								chest.item[itemIndex].SetDefaults(301);
							}
							if (num36 == 2)
							{
								chest.item[itemIndex].SetDefaults(302);
							}
							if (num36 == 3)
							{
								chest.item[itemIndex].SetDefaults(288);
							}
							if (num36 == 4)
							{
								chest.item[itemIndex].SetDefaults(300);
							}
							if (num36 == 5)
							{
								chest.item[itemIndex].SetDefaults(2351);
							}
							if (num36 == 6)
							{
								chest.item[itemIndex].SetDefaults(2348);
							}
							if (num36 == 7)
							{
								chest.item[itemIndex].SetDefaults(2345);
							}
							chest.item[itemIndex].stack = stack26;
							itemIndex++;
						}
						if (genRand.Next(3) == 0)
						{
							int stack27 = genRand.Next(1, 3);
							if (genRand.Next(2) == 0)
							{
								chest.item[itemIndex].SetDefaults(2350);
							}
							else
							{
								chest.item[itemIndex].SetDefaults(4870);
							}
							chest.item[itemIndex].stack = stack27;
							itemIndex++;
						}
						if (genRand.Next(2) == 0)
						{
							int num37 = genRand.Next(2);
							int stack28 = genRand.Next(15) + 15;
							if (num37 == 0)
							{
								chest.item[itemIndex].SetDefaults(8);
							}
							else
							{
								short type3 = 282;
								if (SecretSeed.GenerateRainbowGlowsticks)
								{
									type3 = 5643;
								}
								chest.item[itemIndex].SetDefaults(type3);
							}
							chest.item[itemIndex].stack = stack28;
							itemIndex++;
						}
						if (genRand.Next(2) == 0)
						{
							chest.item[itemIndex].SetDefaults(73);
							chest.item[itemIndex].stack = genRand.Next(2, 5);
							itemIndex++;
						}
					}
					if (itemIndex > 0 && chestTileType == 21)
					{
						if (flag4 && genRand.Next(4) == 0)
						{
							chest.item[itemIndex++].SetDefaults(2204);
						}
						if (flag2 && genRand.Next(7) == 0)
						{
							chest.item[itemIndex++].SetDefaults(2198);
						}
						if (flag12 && genRand.Next(3) == 0)
						{
							chest.item[itemIndex++].SetDefaults(2197);
						}
						if (flag13)
						{
							chest.item[itemIndex++].SetDefaults(2195);
						}
						if (flag9 && genRand.Next(8) == 0)
						{
							chest.item[itemIndex++].SetDefaults(2192);
						}
						if (flag9 && Main.getGoodWorld && genRand.Next(5) == 0)
						{
							chest.item[itemIndex++].SetDefaults(5515);
						}
						if (flag12)
						{
							int num38 = genRand.Next(6);
							if (num38 == 0)
							{
								chest.item[itemIndex].SetDefaults(5258);
							}
							if (num38 == 1)
							{
								chest.item[itemIndex].SetDefaults(5226);
							}
							if (num38 == 2)
							{
								chest.item[itemIndex].SetDefaults(5254);
							}
							if (num38 == 3)
							{
								chest.item[itemIndex].SetDefaults(5238);
							}
							if (num38 == 4)
							{
								chest.item[itemIndex].SetDefaults(5255);
							}
							if (num38 == 5)
							{
								chest.item[itemIndex].SetDefaults(5388);
							}
							itemIndex++;
						}
						if (flag12)
						{
							chest.item[itemIndex].SetDefaults(751);
							chest.item[itemIndex].stack = genRand.Next(50, 101);
							itemIndex++;
						}
						if ((num9 == 23 || num9 == 24 || num9 == 25 || num9 == 26 || num9 == 27) && genRand.Next(2) == 0)
						{
							chest.item[itemIndex++].SetDefaults(5234);
						}
						if (flag13)
						{
							if (genRand.Next(5) == 0)
							{
								chest.item[itemIndex++].SetDefaults(2767);
							}
							else
							{
								chest.item[itemIndex].SetDefaults(2766);
								chest.item[itemIndex].stack = genRand.Next(3, 8);
								itemIndex++;
							}
						}
					}
					if (itemIndex > 0 && chestTileType == 467)
					{
						if (flag4 && genRand.Next(4) == 0)
						{
							chest.item[itemIndex++].SetDefaults(2204);
						}
						if (flag2 && genRand.Next(7) == 0)
						{
							chest.item[itemIndex++].SetDefaults(2198);
						}
						if (flag12 && genRand.Next(3) == 0)
						{
							chest.item[itemIndex++].SetDefaults(2197);
						}
						if (flag12)
						{
							int num39 = genRand.Next(6);
							if (num39 == 0)
							{
								chest.item[itemIndex].SetDefaults(5258);
							}
							if (num39 == 1)
							{
								chest.item[itemIndex].SetDefaults(5226);
							}
							if (num39 == 2)
							{
								chest.item[itemIndex].SetDefaults(5254);
							}
							if (num39 == 3)
							{
								chest.item[itemIndex].SetDefaults(5238);
							}
							if (num39 == 4)
							{
								chest.item[itemIndex].SetDefaults(5255);
							}
							if (num39 == 5)
							{
								chest.item[itemIndex].SetDefaults(5388);
							}
							itemIndex++;
						}
						if (flag12)
						{
							chest.item[itemIndex].SetDefaults(751);
							chest.item[itemIndex].stack = genRand.Next(50, 101);
							itemIndex++;
						}
						if (num9 == 13 && genRand.Next(2) == 0)
						{
							chest.item[itemIndex++].SetDefaults(5234);
						}
					}
					if (SecretSeed.rainbowStuff.Enabled && (num10 == 1156 || num10 == 1571 || num10 == 1569 || num10 == 1572 || num10 == 4607))
					{
						chest.item[itemIndex].SetDefaults(1260);
						chest.item[itemIndex].Prefix(-1);
						itemIndex++;
					}
					if (Main.vampireSeed && !flag9 && !flag13 && !flag12 && !flag8 && genRand.Next(4) == 0)
					{
						chest.item[itemIndex++].SetDefaults(5597);
					}
					if (genRand.Next(12) == 0)
					{
						AddVoiceChangeItemToChest(chest, ref itemIndex);
					}
					else if (Main.vampireSeed && genRand.Next(12) == 0)
					{
						AddMonsterVoiceChangeItemToChest(chest, ref itemIndex);
					}
				}
				return true;
			}
			if (trySlope)
			{
				if (num2 > -1)
				{
					Main.tile[i - 1, k].slope((byte)num2);
				}
				if (num3 > -1)
				{
					Main.tile[i, k].slope((byte)num3);
				}
			}
			return false;
		}
		return false;
	}

	public static void AddVoiceChangeItemToChest(Chest chest, ref int itemIndex)
	{
		int randomVoiceItem = Item.GetRandomVoiceItem();
		chest.item[itemIndex].SetDefaults(randomVoiceItem);
		chest.item[itemIndex].Prefix(-1);
		itemIndex++;
	}

	public static void AddMonsterVoiceChangeItemToChest(Chest chest, ref int itemIndex)
	{
		int num = genRand.Next(4);
		short type = 5509;
		switch (num)
		{
		case 1:
			type = 5505;
			break;
		case 2:
			type = 5506;
			break;
		case 3:
			type = 5508;
			break;
		}
		chest.item[itemIndex].SetDefaults(type);
		chest.item[itemIndex].Prefix(-1);
		itemIndex++;
	}

	public static void UnlockDoor(int i, int j)
	{
		int num = j;
		if (Main.tile[i, num] == null)
		{
			return;
		}
		while (Main.tile[i, num].frameY != 594)
		{
			num--;
			if (Main.tile[i, num].frameY < 594 || num <= 0)
			{
				return;
			}
		}
		SoundEngine.PlaySound(22, i * 16, num * 16 + 16);
		for (int k = num; k <= num + 2; k++)
		{
			if (Main.tile[i, k] == null)
			{
				Main.tile[i, k] = new Tile();
			}
			Main.tile[i, k].frameY += 54;
			for (int l = 0; l < 4; l++)
			{
				Dust.NewDust(new Vector2(i * 16, k * 16), 16, 16, 11);
			}
		}
		AchievementsHelper.NotifyProgressionEvent(22);
	}

	public static bool OpenDoor(int i, int j, int direction)
	{
		int num = 0;
		if (Main.tile[i, j - 1] == null)
		{
			Main.tile[i, j - 1] = new Tile();
		}
		if (Main.tile[i, j - 2] == null)
		{
			Main.tile[i, j - 2] = new Tile();
		}
		if (Main.tile[i, j + 1] == null)
		{
			Main.tile[i, j + 1] = new Tile();
		}
		if (Main.tile[i, j] == null)
		{
			Main.tile[i, j] = new Tile();
		}
		Tile tile = Main.tile[i, j];
		if (tile.type != 10)
		{
			return false;
		}
		if (IsLockedDoor(tile))
		{
			return false;
		}
		short num2 = 0;
		int num3 = tile.frameY;
		int num4 = 0;
		while (num3 >= 54)
		{
			num3 -= 54;
			num4++;
		}
		if (tile.frameX >= 54)
		{
			int num5 = tile.frameX / 54;
			num4 += 36 * num5;
			num2 += (short)(72 * num5);
		}
		num = j - num3 / 18;
		int num6 = i;
		if (!ValidateTileSquareIsActiveAndOfType(num6, num, 1, 3, 10))
		{
			return false;
		}
		TileColorCache cache = Main.tile[num6, num].BlockColorAndCoating();
		if (Main.tile[num6, num + 1] == null)
		{
			Main.tile[num6, num + 1] = new Tile();
		}
		TileColorCache cache2 = Main.tile[num6, num + 1].BlockColorAndCoating();
		if (Main.tile[num6, num + 2] == null)
		{
			Main.tile[num6, num + 2] = new Tile();
		}
		TileColorCache cache3 = Main.tile[num6, num + 2].BlockColorAndCoating();
		int num7;
		if (direction == -1)
		{
			num6 = i - 1;
			num2 += 36;
			num7 = i - 1;
		}
		else
		{
			num6 = i;
			num7 = i + 1;
		}
		for (int k = num; k < num + 3; k++)
		{
			tile = Framing.GetTileSafely(num7, k);
			if (tile.active() && !Main.tileCut[tile.type] && tile.type != 165 && !TileID.Sets.IsADripTile[tile.type])
			{
				return false;
			}
		}
		for (int l = num; l < num + 3; l++)
		{
			tile = Main.tile[num7, l];
			if (tile != null && tile.active() && (Main.tileCut[tile.type] || tile.type == 165 || TileID.Sets.IsADripTile[tile.type]))
			{
				KillTile(num7, l);
			}
		}
		if (Main.netMode != 1 && Wiring.running)
		{
			Wiring.SkipWire(num6, num);
			Wiring.SkipWire(num6, num + 1);
			Wiring.SkipWire(num6, num + 2);
			Wiring.SkipWire(num6 + 1, num);
			Wiring.SkipWire(num6 + 1, num + 1);
			Wiring.SkipWire(num6 + 1, num + 2);
		}
		int num8 = num4 % 36 * 54;
		SoundEngine.PlaySound(8, i * 16, j * 16);
		Main.tile[num6, num].active(active: true);
		Main.tile[num6, num].type = 11;
		Main.tile[num6, num].frameY = (short)num8;
		Main.tile[num6, num].frameX = num2;
		Main.tile[num6, num].UseBlockColors(cache);
		if (Main.tile[num6 + 1, num] == null)
		{
			Main.tile[num6 + 1, num] = new Tile();
		}
		Main.tile[num6 + 1, num].active(active: true);
		Main.tile[num6 + 1, num].type = 11;
		Main.tile[num6 + 1, num].frameY = (short)num8;
		Main.tile[num6 + 1, num].frameX = (short)(num2 + 18);
		Main.tile[num6 + 1, num].UseBlockColors(cache);
		if (Main.tile[num6, num + 1] == null)
		{
			Main.tile[num6, num + 1] = new Tile();
		}
		Main.tile[num6, num + 1].active(active: true);
		Main.tile[num6, num + 1].type = 11;
		Main.tile[num6, num + 1].frameY = (short)(num8 + 18);
		Main.tile[num6, num + 1].frameX = num2;
		Main.tile[num6, num + 1].UseBlockColors(cache2);
		if (Main.tile[num6 + 1, num + 1] == null)
		{
			Main.tile[num6 + 1, num + 1] = new Tile();
		}
		Main.tile[num6 + 1, num + 1].active(active: true);
		Main.tile[num6 + 1, num + 1].type = 11;
		Main.tile[num6 + 1, num + 1].frameY = (short)(num8 + 18);
		Main.tile[num6 + 1, num + 1].frameX = (short)(num2 + 18);
		Main.tile[num6 + 1, num + 1].UseBlockColors(cache2);
		if (Main.tile[num6, num + 2] == null)
		{
			Main.tile[num6, num + 2] = new Tile();
		}
		Main.tile[num6, num + 2].active(active: true);
		Main.tile[num6, num + 2].type = 11;
		Main.tile[num6, num + 2].frameY = (short)(num8 + 36);
		Main.tile[num6, num + 2].frameX = num2;
		Main.tile[num6, num + 2].UseBlockColors(cache3);
		if (Main.tile[num6 + 1, num + 2] == null)
		{
			Main.tile[num6 + 1, num + 2] = new Tile();
		}
		Main.tile[num6 + 1, num + 2].active(active: true);
		Main.tile[num6 + 1, num + 2].type = 11;
		Main.tile[num6 + 1, num + 2].frameY = (short)(num8 + 36);
		Main.tile[num6 + 1, num + 2].frameX = (short)(num2 + 18);
		Main.tile[num6 + 1, num + 2].UseBlockColors(cache3);
		for (int m = num6 - 1; m <= num6 + 2; m++)
		{
			for (int n = num - 1; n <= num + 2; n++)
			{
				TileFrame(m, n);
			}
		}
		return true;
	}

	public static void Check1xX(int x, int j, short type)
	{
		if (destroyObject)
		{
			return;
		}
		int frameX = Main.tile[x, j].frameX;
		int num = 3;
		if (type == 92)
		{
			num = 6;
		}
		int num2 = Main.tile[x, j].frameY;
		int num3 = 0;
		while (num2 >= 18 * num)
		{
			num2 -= 18 * num;
			num3++;
		}
		int num4 = Main.tile[x, j].frameX / 18;
		int num5 = j - num2 / 18;
		bool flag = false;
		for (int i = 0; i < num; i++)
		{
			if (Main.tile[x, num5 + i] == null)
			{
				Main.tile[x, num5 + i] = new Tile();
			}
			if (!Main.tile[x, num5 + i].active())
			{
				flag = true;
			}
			else if (Main.tile[x, num5 + i].type != type)
			{
				flag = true;
			}
			else if (Main.tile[x, num5 + i].frameY != i * 18 + num3 * num * 18)
			{
				flag = true;
			}
			else if (Main.tile[x, num5 + i].frameX != frameX)
			{
				flag = true;
			}
		}
		if (Main.tile[x, num5 + num] == null)
		{
			Main.tile[x, num5 + num] = new Tile();
		}
		if (!SolidTileAllowBottomSlope(x, num5 + num))
		{
			flag = true;
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		for (int k = 0; k < num; k++)
		{
			if (Main.tile[x, num5 + k].type == type)
			{
				KillTile(x, num5 + k);
			}
		}
		if (type == 92)
		{
			Item.NewItem(GetItemSource_FromTileBreak(x, j), x * 16, j * 16, 32, 32, 341);
		}
		if (type == 453)
		{
			int num6 = 0;
			num6 = ((num4 < 2) ? 3744 : ((num4 >= 4) ? 3743 : 3745));
			Item.NewItem(GetItemSource_FromTileBreak(x, j), x * 16, j * 16, 16, 32, num6);
		}
		if (type == 93)
		{
			int itemDrop_Lamps = GetItemDrop_Lamps(num3);
			Item.NewItem(GetItemSource_FromTileBreak(x, j), x * 16, j * 16, 32, 32, itemDrop_Lamps);
		}
		destroyObject = false;
	}

	public static bool ValidateTileSquareIsActiveAndOfType(int topLeftX, int topLeftY, int width, int height, int type)
	{
		bool flag = false;
		for (int i = 0; i < width; i++)
		{
			for (int j = 0; j < height; j++)
			{
				int num = topLeftX + i;
				int num2 = topLeftY + j;
				if (!InWorld(num, num2))
				{
					return false;
				}
				Tile tile = Main.tile[num, num2];
				if (tile != null && (!tile.active() || tile.type != type))
				{
					flag = true;
					break;
				}
			}
			if (flag)
			{
				break;
			}
		}
		if (flag)
		{
			for (int k = 0; k < width; k++)
			{
				for (int l = 0; l < height; l++)
				{
					int num3 = topLeftX + k;
					int num4 = topLeftY + l;
					Tile tile2 = Main.tile[num3, num4];
					if (tile2 != null && tile2.active() && tile2.type == type)
					{
						KillTile(num3, num4);
						if (Main.netMode != 0)
						{
							NetMessage.SendData(17, -1, -1, null, 0, num3, num4);
						}
					}
				}
			}
			return false;
		}
		return true;
	}

	public static int GetRandomStatueStyleForStatueMimics()
	{
		int num = genRand.Next(83);
		while (num >= 43 && num <= 49)
		{
			num = genRand.Next(83);
		}
		return num;
	}

	public static int StatueStyleToItem(int style)
	{
		switch (style)
		{
		case 0:
			style = 360;
			break;
		case 1:
			style = 52;
			break;
		case 43:
			style = 1152;
			break;
		case 44:
			style = 1153;
			break;
		case 45:
			style = 1154;
			break;
		case 46:
			style = 1408;
			break;
		case 47:
			style = 1409;
			break;
		case 48:
			style = 1410;
			break;
		case 49:
			style = 1462;
			break;
		case 50:
			style = 2672;
			break;
		case 51:
		case 52:
		case 53:
		case 54:
		case 55:
		case 56:
		case 57:
		case 58:
		case 59:
		case 60:
		case 61:
		case 62:
			style = 3651 + style - 51;
			break;
		default:
			style = ((style >= 63 && style <= 75) ? (3708 + style - 63) : (style switch
			{
				76 => 4397, 
				77 => 4360, 
				78 => 4342, 
				79 => 4466, 
				80 => 5317, 
				81 => 5318, 
				82 => 5319, 
				_ => 438 + style - 2, 
			}));
			break;
		}
		return style;
	}

	public static void Check2xX(int i, int j, ushort type)
	{
		if (destroyObject)
		{
			return;
		}
		int num = i;
		int num2;
		for (num2 = Main.tile[i, j].frameX; num2 >= 36; num2 -= 36)
		{
		}
		if (num2 == 18)
		{
			num--;
		}
		if (Main.tile[num, j] == null)
		{
			Main.tile[num, j] = new Tile();
		}
		int num3 = Main.tile[num, j].frameY / 18;
		int num4 = 3;
		if (type == 104)
		{
			num4 = 5;
		}
		if (type == 207)
		{
			num4 = 4;
		}
		int num5 = 0;
		while (num3 >= num4)
		{
			num3 -= num4;
			num5 += num4 * 18;
		}
		int num6 = j - num3;
		if (type == 410 && num5 != 0)
		{
			num5 += 2;
		}
		if (Main.tile[num, num6] == null)
		{
			Main.tile[num, num6] = new Tile();
		}
		int frameX = Main.tile[num, j].frameX;
		int frameY = Main.tile[num, j].frameY;
		bool flag = false;
		for (int k = 0; k < num4; k++)
		{
			if (Main.tile[num, num6 + k] == null)
			{
				Main.tile[num, num6 + k] = new Tile();
			}
			if (!Main.tile[num, num6 + k].active())
			{
				flag = true;
			}
			else if (Main.tile[num, num6 + k].type != type)
			{
				flag = true;
			}
			else if (Main.tile[num, num6 + k].frameY != k * 18 + num5)
			{
				flag = true;
			}
			else if (Main.tile[num, num6 + k].frameX != frameX)
			{
				flag = true;
			}
			if (Main.tile[num + 1, num6 + k] == null)
			{
				Main.tile[num + 1, num6 + k] = new Tile();
			}
			if (!Main.tile[num + 1, num6 + k].active())
			{
				flag = true;
			}
			else if (Main.tile[num + 1, num6 + k].type != type)
			{
				flag = true;
			}
			else if (Main.tile[num + 1, num6 + k].frameY != k * 18 + num5)
			{
				flag = true;
			}
			else if (Main.tile[num + 1, num6 + k].frameX != frameX + 18)
			{
				flag = true;
			}
		}
		if (type == 465 || type == 531 || type == 591 || type == 592)
		{
			int num7 = -1;
			for (int l = 0; l < 2; l++)
			{
				int num8 = 0;
				bool flag2 = false;
				Tile tileSafely = Framing.GetTileSafely(num + l, num6 - 1);
				if (type != 531 && tileSafely.type == 380)
				{
					flag2 = true;
				}
				else if (type != 531 && TileID.Sets.Platforms[tileSafely.type])
				{
					if (IsBelowANonHammeredPlatform(num + l, num6))
					{
						num8 = 8;
					}
					flag2 = true;
				}
				else
				{
					flag2 = SolidTileAllowTopSlope(num + l, num6 - 1);
				}
				if (flag2)
				{
					if (num7 == -1)
					{
						num7 = num8;
					}
					if (num7 != num8)
					{
						flag2 = false;
					}
				}
				if (!flag2)
				{
					flag = true;
					break;
				}
			}
		}
		else
		{
			if (!SolidTileAllowBottomSlope(num, num6 + num4))
			{
				flag = true;
			}
			if (!SolidTileAllowBottomSlope(num + 1, num6 + num4))
			{
				flag = true;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		for (int m = 0; m < num4; m++)
		{
			if (Main.tile[num, num6 + m].type == type)
			{
				KillTile(num, num6 + m);
			}
			if (Main.tile[num + 1, num6 + m].type == type)
			{
				KillTile(num + 1, num6 + m);
			}
		}
		if (type == 104)
		{
			int itemDrop_Clocks = GetItemDrop_Clocks(frameX / 36);
			Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, itemDrop_Clocks);
		}
		if (type == 105)
		{
			int num9 = frameX / 36;
			int num10 = frameY / 54;
			num10 %= 3;
			num9 += num10 * 55;
			num9 = StatueStyleToItem(num9);
			Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, num9);
		}
		if (type == 356)
		{
			Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 3064);
		}
		if (type == 663)
		{
			Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 5381);
		}
		if (type == 456)
		{
			Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 3748);
		}
		if (type == 337)
		{
			int num11 = frameX / 36;
			Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 2702 + num11);
		}
		if (type == 207)
		{
			int num12 = frameX / 36;
			switch (num12)
			{
			case 0:
				num12 = 909;
				break;
			case 1:
				num12 = 910;
				break;
			case 2:
			case 3:
			case 4:
			case 5:
			case 6:
			case 7:
				num12 = 938 + num12;
				break;
			default:
				switch (num12)
				{
				case 8:
					num12 = 4922;
					break;
				case 9:
					num12 = 4417;
					break;
				}
				break;
			}
			Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, num12);
		}
		if (type == 410)
		{
			int num13 = frameX / 36;
			Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, num13 + 3536);
		}
		if (type == 480)
		{
			Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 4054);
		}
		if (type == 509)
		{
			Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 4318);
		}
		if (type == 657)
		{
			Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 5345);
		}
		if (type == 658)
		{
			Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 5347);
		}
		if (type == 720)
		{
			Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 5598);
		}
		if (type == 721)
		{
			Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 5599);
		}
		if (type == 725)
		{
			Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 5655);
		}
		if (type == 489)
		{
			Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 4074);
		}
		if (type == 320)
		{
			Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 2496);
		}
		if (type == 349)
		{
			Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 470);
		}
		if (type == 506)
		{
			Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 4276);
		}
		if (type == 545)
		{
			Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 4420);
		}
		if (type == 465)
		{
			Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 3815);
		}
		if (type == 531)
		{
			Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 4355);
		}
		if (type == 378)
		{
			Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 48, 3202);
			TileEntityType<TETrainingDummy>.Kill(num, num6);
		}
		if (type == 560)
		{
			int num14 = frameX / 36;
			Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, num14 + 4599);
		}
		if (type == 591)
		{
			int num15 = frameX / 36;
			Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, num15 + 4858);
		}
		if (type == 592)
		{
			Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 4867);
		}
		destroyObject = false;
	}

	public static bool IsBelowANonHammeredPlatform(int x, int y)
	{
		if (y < 1)
		{
			return false;
		}
		Tile tile = Main.tile[x, y - 1];
		if (tile == null || !tile.active() || !TileID.Sets.Platforms[tile.type] || tile.halfBrick() || tile.slope() != 0)
		{
			return false;
		}
		return true;
	}

	public static void PlaceTight(int x, int y, bool spiders = false)
	{
		if (Main.tile[x, y - 1] == null)
		{
			Main.tile[x, y - 1] = new Tile();
		}
		if (Main.tile[x, y] == null)
		{
			Main.tile[x, y] = new Tile();
		}
		if (Main.tile[x, y + 1] == null)
		{
			Main.tile[x, y + 1] = new Tile();
		}
		if (!Main.tile[x, y].anyShimmer() && (!Main.tile[x, y].active() || Main.tile[x, y].type != 231))
		{
			PlaceUncheckedStalactite(x, y, genRand.Next(2) == 0, genRand.Next(3), spiders);
			if (Main.tile[x, y].active() && Main.tile[x, y].type == 165)
			{
				CheckStalactite(x, y);
			}
		}
	}

	public static void PlaceUncheckedStalactite(int x, int y, bool preferSmall, int variation, bool spiders)
	{
		ushort type = 165;
		variation = Utils.Clamp(variation, 0, 2);
		if (SolidTile(x, y - 1) && !Main.tile[x, y].active() && !Main.tile[x, y + 1].active())
		{
			Tile other = Main.tile[x, y - 1];
			if (spiders)
			{
				int num = 108 + variation * 18;
				Main.tile[x, y].type = type;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].ClearSlope();
				Main.tile[x, y].frameX = (short)num;
				Main.tile[x, y].frameY = 0;
				Main.tile[x, y].CopyPaintAndCoating(other);
				Main.tile[x, y + 1].type = type;
				Main.tile[x, y + 1].active(active: true);
				Main.tile[x, y + 1].ClearSlope();
				Main.tile[x, y + 1].frameX = (short)num;
				Main.tile[x, y + 1].frameY = 18;
				Main.tile[x, y + 1].CopyPaintAndCoating(other);
				return;
			}
			if (Main.tile[x, y - 1].type == 147 || Main.tile[x, y - 1].type == 161 || Main.tile[x, y - 1].type == 163 || Main.tile[x, y - 1].type == 164 || Main.tile[x, y - 1].type == 200)
			{
				if (preferSmall)
				{
					int num2 = variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].ClearSlope();
					Main.tile[x, y].frameX = (short)num2;
					Main.tile[x, y].frameY = 72;
					Main.tile[x, y].CopyPaintAndCoating(other);
				}
				else
				{
					int num3 = variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].ClearSlope();
					Main.tile[x, y].frameX = (short)num3;
					Main.tile[x, y].frameY = 0;
					Main.tile[x, y].CopyPaintAndCoating(other);
					Main.tile[x, y + 1].type = type;
					Main.tile[x, y + 1].active(active: true);
					Main.tile[x, y + 1].ClearSlope();
					Main.tile[x, y + 1].frameX = (short)num3;
					Main.tile[x, y + 1].frameY = 18;
					Main.tile[x, y + 1].CopyPaintAndCoating(other);
				}
			}
			if (Main.tile[x, y - 1].type == 1 || Main.tileMoss[Main.tile[x, y - 1].type] || Main.tile[x, y - 1].type == 117 || Main.tile[x, y - 1].type == 25 || Main.tile[x, y - 1].type == 203)
			{
				if (preferSmall)
				{
					int num4 = 54 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].ClearSlope();
					Main.tile[x, y].frameX = (short)num4;
					Main.tile[x, y].frameY = 72;
					Main.tile[x, y].CopyPaintAndCoating(other);
				}
				else
				{
					int num5 = 54 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].ClearSlope();
					Main.tile[x, y].frameX = (short)num5;
					Main.tile[x, y].frameY = 0;
					Main.tile[x, y].CopyPaintAndCoating(other);
					Main.tile[x, y + 1].type = type;
					Main.tile[x, y + 1].active(active: true);
					Main.tile[x, y + 1].ClearSlope();
					Main.tile[x, y + 1].frameX = (short)num5;
					Main.tile[x, y + 1].frameY = 18;
					Main.tile[x, y + 1].CopyPaintAndCoating(other);
				}
			}
			if (Main.tile[x, y - 1].type == 225)
			{
				int num6 = 162 + variation * 18;
				Main.tile[x, y].type = type;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].ClearSlope();
				Main.tile[x, y].frameX = (short)num6;
				Main.tile[x, y].frameY = 72;
				Main.tile[x, y].CopyPaintAndCoating(other);
			}
			if (Main.tile[x, y - 1].type == 396 || Main.tile[x, y - 1].type == 397)
			{
				if (preferSmall)
				{
					int num7 = 378 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].ClearSlope();
					Main.tile[x, y].frameX = (short)num7;
					Main.tile[x, y].frameY = 72;
					Main.tile[x, y].CopyPaintAndCoating(other);
				}
				else
				{
					int num8 = 378 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].ClearSlope();
					Main.tile[x, y].frameX = (short)num8;
					Main.tile[x, y].frameY = 0;
					Main.tile[x, y].CopyPaintAndCoating(other);
					Main.tile[x, y + 1].type = type;
					Main.tile[x, y + 1].active(active: true);
					Main.tile[x, y + 1].ClearSlope();
					Main.tile[x, y + 1].frameX = (short)num8;
					Main.tile[x, y + 1].frameY = 18;
					Main.tile[x, y + 1].CopyPaintAndCoating(other);
				}
			}
			if (Main.tile[x, y - 1].type == 368)
			{
				if (preferSmall)
				{
					int num9 = 432 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].ClearSlope();
					Main.tile[x, y].frameX = (short)num9;
					Main.tile[x, y].frameY = 72;
					Main.tile[x, y].CopyPaintAndCoating(other);
				}
				else
				{
					int num10 = 432 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].ClearSlope();
					Main.tile[x, y].frameX = (short)num10;
					Main.tile[x, y].frameY = 0;
					Main.tile[x, y].CopyPaintAndCoating(other);
					Main.tile[x, y + 1].type = type;
					Main.tile[x, y + 1].active(active: true);
					Main.tile[x, y + 1].ClearSlope();
					Main.tile[x, y + 1].frameX = (short)num10;
					Main.tile[x, y + 1].frameY = 18;
					Main.tile[x, y + 1].CopyPaintAndCoating(other);
				}
			}
			if (Main.tile[x, y - 1].type == 367)
			{
				if (preferSmall)
				{
					int num11 = 486 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].ClearSlope();
					Main.tile[x, y].frameX = (short)num11;
					Main.tile[x, y].frameY = 72;
					Main.tile[x, y].CopyPaintAndCoating(other);
				}
				else
				{
					int num12 = 486 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].ClearSlope();
					Main.tile[x, y].frameX = (short)num12;
					Main.tile[x, y].frameY = 0;
					Main.tile[x, y].CopyPaintAndCoating(other);
					Main.tile[x, y + 1].type = type;
					Main.tile[x, y + 1].active(active: true);
					Main.tile[x, y + 1].ClearSlope();
					Main.tile[x, y + 1].frameX = (short)num12;
					Main.tile[x, y + 1].frameY = 18;
					Main.tile[x, y + 1].CopyPaintAndCoating(other);
				}
			}
		}
		else
		{
			if (spiders || !SolidTile(x, y + 1) || Main.tile[x, y].active() || Main.tile[x, y - 1].active())
			{
				return;
			}
			Tile other2 = Main.tile[x, y + 1];
			if (Main.tile[x, y + 1].type == 1 || Main.tileMoss[Main.tile[x, y + 1].type] || Main.tile[x, y + 1].type == 117 || Main.tile[x, y + 1].type == 25 || Main.tile[x, y + 1].type == 203)
			{
				if (preferSmall)
				{
					int num13 = 54 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].ClearSlope();
					Main.tile[x, y].frameX = (short)num13;
					Main.tile[x, y].frameY = 90;
					Main.tile[x, y].CopyPaintAndCoating(other2);
				}
				else
				{
					int num14 = 54 + variation * 18;
					Main.tile[x, y - 1].type = type;
					Main.tile[x, y - 1].active(active: true);
					Main.tile[x, y - 1].ClearSlope();
					Main.tile[x, y - 1].frameX = (short)num14;
					Main.tile[x, y - 1].frameY = 36;
					Main.tile[x, y - 1].CopyPaintAndCoating(other2);
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].ClearSlope();
					Main.tile[x, y].frameX = (short)num14;
					Main.tile[x, y].frameY = 54;
					Main.tile[x, y].CopyPaintAndCoating(other2);
				}
			}
			if (Main.tile[x, y + 1].type == 225)
			{
				int num15 = 162 + variation * 18;
				Main.tile[x, y].type = type;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].ClearSlope();
				Main.tile[x, y].frameX = (short)num15;
				Main.tile[x, y].frameY = 90;
				Main.tile[x, y].CopyPaintAndCoating(other2);
			}
			if (Main.tile[x, y + 1].type == 396 || Main.tile[x, y + 1].type == 397)
			{
				if (preferSmall)
				{
					int num16 = 378 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].ClearSlope();
					Main.tile[x, y].frameX = (short)num16;
					Main.tile[x, y].frameY = 90;
					Main.tile[x, y].CopyPaintAndCoating(other2);
				}
				else
				{
					int num17 = 378 + variation * 18;
					Main.tile[x, y - 1].type = type;
					Main.tile[x, y - 1].active(active: true);
					Main.tile[x, y - 1].ClearSlope();
					Main.tile[x, y - 1].frameX = (short)num17;
					Main.tile[x, y - 1].frameY = 36;
					Main.tile[x, y - 1].CopyPaintAndCoating(other2);
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].ClearSlope();
					Main.tile[x, y].frameX = (short)num17;
					Main.tile[x, y].frameY = 54;
					Main.tile[x, y].CopyPaintAndCoating(other2);
				}
			}
			if (Main.tile[x, y + 1].type == 368)
			{
				if (preferSmall)
				{
					int num18 = 432 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].ClearSlope();
					Main.tile[x, y].frameX = (short)num18;
					Main.tile[x, y].frameY = 90;
					Main.tile[x, y].CopyPaintAndCoating(other2);
				}
				else
				{
					int num19 = 432 + variation * 18;
					Main.tile[x, y - 1].type = type;
					Main.tile[x, y - 1].active(active: true);
					Main.tile[x, y - 1].ClearSlope();
					Main.tile[x, y - 1].frameX = (short)num19;
					Main.tile[x, y - 1].frameY = 36;
					Main.tile[x, y - 1].CopyPaintAndCoating(other2);
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].ClearSlope();
					Main.tile[x, y].frameX = (short)num19;
					Main.tile[x, y].frameY = 54;
					Main.tile[x, y].CopyPaintAndCoating(other2);
				}
			}
			if (Main.tile[x, y + 1].type == 367)
			{
				if (preferSmall)
				{
					int num20 = 486 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].ClearSlope();
					Main.tile[x, y].frameX = (short)num20;
					Main.tile[x, y].frameY = 90;
					Main.tile[x, y].CopyPaintAndCoating(other2);
				}
				else
				{
					int num21 = 486 + variation * 18;
					Main.tile[x, y - 1].type = type;
					Main.tile[x, y - 1].active(active: true);
					Main.tile[x, y - 1].ClearSlope();
					Main.tile[x, y - 1].frameX = (short)num21;
					Main.tile[x, y - 1].frameY = 36;
					Main.tile[x, y - 1].CopyPaintAndCoating(other2);
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].ClearSlope();
					Main.tile[x, y].frameX = (short)num21;
					Main.tile[x, y].frameY = 54;
					Main.tile[x, y].CopyPaintAndCoating(other2);
				}
			}
		}
	}

	public static bool UpdateStalagtiteStyle(int x, int j)
	{
		if (Main.netMode == 1)
		{
			return true;
		}
		if (Main.tile[x, j] == null)
		{
			return true;
		}
		GetStalagtiteStyle(x, j, out var style, out var fail);
		if (fail)
		{
			return false;
		}
		GetDesiredStalagtiteStyle(x, j, out var fail2, out var desiredStyle, out var height, out var y);
		if (fail2)
		{
			return false;
		}
		if (style != desiredStyle)
		{
			int num = genRand.Next(3) * 18;
			switch (desiredStyle)
			{
			case 0:
				num += 54;
				break;
			case 1:
				num += 216;
				break;
			case 2:
				num += 270;
				break;
			case 3:
				num += 324;
				break;
			case 4:
				num += 378;
				break;
			case 5:
				num += 432;
				break;
			case 6:
				num += 486;
				break;
			case 7:
				num = num;
				break;
			case 8:
				num += 540;
				break;
			case 9:
				num += 594;
				break;
			case 10:
				num += 648;
				break;
			case 11:
				num += 108;
				break;
			case 12:
				num += 162;
				break;
			}
			for (int i = y; i < y + height; i++)
			{
				Main.tile[x, i].frameX = (short)num;
			}
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, x, y, 1, 2);
			}
		}
		return true;
	}

	private static void GetDesiredStalagtiteStyle(int x, int j, out bool fail, out int desiredStyle, out int height, out int y)
	{
		fail = false;
		desiredStyle = 0;
		height = 1;
		y = j;
		Tile tile = Main.tile[x, y];
		int num = 0;
		int num2 = 0;
		if (tile.frameY == 72)
		{
			Tile tile2 = Main.tile[x, y - 1];
			num = 0;
			num2 = tile2.type;
		}
		else if (tile.frameY == 90)
		{
			Tile tile3 = Main.tile[x, y + 1];
			num = 1;
			num2 = tile3.type;
		}
		else if (tile.frameY >= 36)
		{
			if (tile.frameY == 54)
			{
				y--;
			}
			height = 2;
			Tile tile4 = Main.tile[x, y + 2];
			num = 4;
			num2 = tile4.type;
		}
		else
		{
			if (tile.frameY == 18)
			{
				y--;
			}
			height = 2;
			Tile tile5 = Main.tile[x, y - 1];
			num = 3;
			num2 = tile5.type;
		}
		if (num2 == 1 || Main.tileMoss[num2])
		{
			desiredStyle = 0;
			if (num == 3 && tile.wall == 62)
			{
				desiredStyle = 11;
			}
			return;
		}
		switch (num2)
		{
		case 200:
			desiredStyle = 10;
			return;
		case 164:
			desiredStyle = 8;
			return;
		case 163:
			desiredStyle = 9;
			return;
		case 117:
		case 402:
		case 403:
			desiredStyle = 1;
			return;
		case 25:
		case 398:
		case 400:
			desiredStyle = 2;
			return;
		case 203:
		case 399:
		case 401:
			desiredStyle = 3;
			return;
		case 396:
		case 397:
			desiredStyle = 4;
			return;
		case 367:
			desiredStyle = 6;
			return;
		case 368:
			desiredStyle = 5;
			return;
		case 147:
		case 161:
			desiredStyle = 7;
			return;
		}
		if ((num == 0 || num == 1) && num2 == 225)
		{
			desiredStyle = 12;
		}
		else
		{
			fail = true;
		}
	}

	private static void GetStalagtiteStyle(int x, int y, out int style, out bool fail)
	{
		style = 0;
		fail = false;
		switch (Main.tile[x, y].frameX / 54)
		{
		default:
			fail = true;
			break;
		case 0:
			style = 7;
			break;
		case 1:
			style = 0;
			break;
		case 2:
			style = 11;
			break;
		case 3:
			style = 12;
			break;
		case 4:
			style = 1;
			break;
		case 5:
			style = 2;
			break;
		case 6:
			style = 3;
			break;
		case 7:
			style = 4;
			break;
		case 8:
			style = 5;
			break;
		case 9:
			style = 6;
			break;
		case 10:
			style = 8;
			break;
		case 11:
			style = 9;
			break;
		case 12:
			style = 10;
			break;
		}
	}

	public static void CheckStalactiteEcho(int x, int j)
	{
		Tile tile = Main.tile[x, j];
		ushort type = tile.type;
		int num = ((type != 694) ? 1 : 2);
		bool num2 = tile.frameY < num * 18;
		int style = tile.frameX / 18;
		int num3 = j - tile.frameY % (num * 18) / 18;
		int num4 = ((!num2) ? (18 * num) : 0);
		int j2 = (num2 ? (num3 - 1) : (num3 + num));
		bool flag = (num2 ? (!SolidTileAllowTopSlope(x, j2)) : (!SolidTileAllowBottomSlope(x, j2)));
		if (!flag)
		{
			int num5 = num3;
			int num6 = 0;
			while (num5 < num3 + num)
			{
				Tile tile2 = Main.tile[x, num5];
				if (tile2.type != type || tile2.frameX != tile.frameX || tile2.frameY != num4 + num6)
				{
					flag = true;
					break;
				}
				num5++;
				num6 += 18;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		for (int i = num3; i < num3 + num; i++)
		{
			if (Main.tile[x, i].type == type)
			{
				KillTile(x, i);
			}
		}
		destroyObject = false;
		int stalactiteEchoDrop = GetStalactiteEchoDrop(x, j, style);
		if (stalactiteEchoDrop != 0)
		{
			Item.NewItem(GetItemSource_FromTileBreak(x, j), x * 16, j * 16, 16, 32, stalactiteEchoDrop);
		}
	}

	private static int GetStalactiteEchoDrop(int x, int j, int style)
	{
		int result = 0;
		if (style < 3)
		{
			result = 664;
		}
		else if (style < 6)
		{
			result = 3;
		}
		else if (style < 9)
		{
			result = 150;
		}
		else if (style < 12)
		{
			result = 1124;
		}
		else if (style < 15)
		{
			result = 409;
		}
		else if (style < 18)
		{
			result = 61;
		}
		else if (style < 21)
		{
			result = 836;
		}
		else if (style < 24)
		{
			result = 3271;
		}
		else if (style < 27)
		{
			result = 3086;
		}
		else if (style < 30)
		{
			result = 3081;
		}
		else if (style < 33)
		{
			result = 834;
		}
		else if (style < 36)
		{
			result = 833;
		}
		else if (style < 39)
		{
			result = 835;
		}
		return result;
	}

	public static bool InvalidTileForPilesOrSpeleothems(int x, int y)
	{
		if (!InWorld(x, y, 2))
		{
			return false;
		}
		if (Main.tile[x, y] == null)
		{
			return false;
		}
		if (Main.tile[x, y].active())
		{
			return TileID.Sets.Boulders[Main.tile[x, y].type];
		}
		return false;
	}

	public static void CheckStalactite(int x, int j)
	{
		if (Main.tile[x, j] == null)
		{
			return;
		}
		int num = j;
		if (Main.tile[x, num].frameY == 72)
		{
			if (Main.tile[x, num - 1] == null)
			{
				Main.tile[x, num - 1] = new Tile();
			}
			if (Main.tile[x, num] == null)
			{
				Main.tile[x, num] = new Tile();
			}
			if (Main.tile[x, num + 1] == null)
			{
				Main.tile[x, num + 1] = new Tile();
			}
			bool flag = false;
			if (!SolidTile(x, num - 1))
			{
				flag = true;
			}
			if (!flag && !UpdateStalagtiteStyle(x, num))
			{
				flag = true;
			}
			if (flag)
			{
				destroyObject = true;
				if (Main.tile[x, num].type == Main.tile[x, j].type)
				{
					KillTile(x, num);
				}
				destroyObject = false;
			}
			return;
		}
		if (Main.tile[x, num].frameY == 90)
		{
			if (Main.tile[x, num - 1] == null)
			{
				Main.tile[x, num - 1] = new Tile();
			}
			if (Main.tile[x, num] == null)
			{
				Main.tile[x, num] = new Tile();
			}
			if (Main.tile[x, num + 1] == null)
			{
				Main.tile[x, num + 1] = new Tile();
			}
			bool flag2 = false;
			if (!SolidTile(x, num + 1))
			{
				flag2 = true;
			}
			if (!flag2 && InvalidTileForPilesOrSpeleothems(x, num + 1))
			{
				flag2 = true;
			}
			if (!flag2 && !UpdateStalagtiteStyle(x, num))
			{
				flag2 = true;
			}
			if (flag2)
			{
				destroyObject = true;
				if (Main.tile[x, num].type == Main.tile[x, j].type)
				{
					KillTile(x, num);
				}
				destroyObject = false;
			}
			return;
		}
		if (Main.tile[x, num].frameY >= 36)
		{
			if (Main.tile[x, num].frameY == 54)
			{
				num--;
			}
			if (Main.tile[x, num] == null)
			{
				Main.tile[x, num] = new Tile();
			}
			if (Main.tile[x, num + 1] == null)
			{
				Main.tile[x, num + 1] = new Tile();
			}
			if (Main.tile[x, num + 2] == null)
			{
				Main.tile[x, num + 2] = new Tile();
			}
			bool flag3 = false;
			if (!SolidTile(x, num + 2))
			{
				flag3 = true;
			}
			if (!Main.tile[x, num].active() || !Main.tile[x, num + 1].active() || Main.tile[x, num + 1].type != Main.tile[x, num].type)
			{
				flag3 = true;
			}
			if (Main.tile[x, num + 1].frameX != Main.tile[x, num].frameX)
			{
				flag3 = true;
			}
			if (!flag3 && InvalidTileForPilesOrSpeleothems(x, num + 2))
			{
				flag3 = true;
			}
			if (!flag3 && !UpdateStalagtiteStyle(x, num))
			{
				flag3 = true;
			}
			if (flag3)
			{
				destroyObject = true;
				if (Main.tile[x, num].type == Main.tile[x, j].type)
				{
					KillTile(x, num);
				}
				if (Main.tile[x, num + 1].type == Main.tile[x, j].type)
				{
					KillTile(x, num + 1);
				}
				destroyObject = false;
			}
			return;
		}
		if (Main.tile[x, num].frameY == 18)
		{
			num--;
		}
		if (Main.tile[x, num - 1] == null)
		{
			Main.tile[x, num - 1] = new Tile();
		}
		if (Main.tile[x, num] == null)
		{
			Main.tile[x, num] = new Tile();
		}
		if (Main.tile[x, num + 1] == null)
		{
			Main.tile[x, num + 1] = new Tile();
		}
		bool flag4 = false;
		if (!SolidTile(x, num - 1))
		{
			flag4 = true;
		}
		if (!Main.tile[x, num].active() || !Main.tile[x, num + 1].active() || Main.tile[x, num + 1].type != Main.tile[x, num].type)
		{
			flag4 = true;
		}
		if (Main.tile[x, num + 1].frameX != Main.tile[x, num].frameX)
		{
			flag4 = true;
		}
		if (!flag4 && !UpdateStalagtiteStyle(x, num))
		{
			flag4 = true;
		}
		if (flag4)
		{
			destroyObject = true;
			if (Main.tile[x, num].type == Main.tile[x, j].type)
			{
				KillTile(x, num);
			}
			if (Main.tile[x, num + 1].type == Main.tile[x, j].type)
			{
				KillTile(x, num + 1);
			}
			destroyObject = false;
		}
	}

	public static void Place1xX(int x, int y, ushort type, int style = 0)
	{
		int num = style * 18;
		int num2 = 3;
		if (type == 92)
		{
			num2 = 6;
		}
		bool flag = true;
		for (int i = y - num2 + 1; i < y + 1; i++)
		{
			if (Main.tile[x, i] == null)
			{
				Main.tile[x, i] = new Tile();
			}
			if (Main.tile[x, i].active())
			{
				flag = false;
			}
			if (type == 93 && Main.tile[x, i].liquid > 0)
			{
				flag = false;
			}
		}
		if (flag && SolidTile2(x, y + 1))
		{
			for (int j = 0; j < num2; j++)
			{
				Main.tile[x, y - num2 + 1 + j].active(active: true);
				Main.tile[x, y - num2 + 1 + j].frameY = (short)(j * 18 + num2 * num);
				Main.tile[x, y - num2 + 1 + j].frameX = 0;
				Main.tile[x, y - num2 + 1 + j].type = type;
			}
		}
	}

	public static int checkXmasTreeDrop(int x, int y, int obj)
	{
		int num = x;
		int num2 = y;
		if (Main.tile[x, y].frameX < 10)
		{
			num -= Main.tile[x, y].frameX;
			num2 -= Main.tile[x, y].frameY;
		}
		int num3 = 0;
		if ((Main.tile[num, num2].frameY & 1) == 1)
		{
			num3++;
		}
		if ((Main.tile[num, num2].frameY & 2) == 2)
		{
			num3 += 2;
		}
		if ((Main.tile[num, num2].frameY & 4) == 4)
		{
			num3 += 4;
		}
		int num4 = 0;
		if ((Main.tile[num, num2].frameY & 8) == 8)
		{
			num4++;
		}
		if ((Main.tile[num, num2].frameY & 0x10) == 16)
		{
			num4 += 2;
		}
		if ((Main.tile[num, num2].frameY & 0x20) == 32)
		{
			num4 += 4;
		}
		int num5 = 0;
		if ((Main.tile[num, num2].frameY & 0x40) == 64)
		{
			num5++;
		}
		if ((Main.tile[num, num2].frameY & 0x80) == 128)
		{
			num5 += 2;
		}
		if ((Main.tile[num, num2].frameY & 0x100) == 256)
		{
			num5 += 4;
		}
		if ((Main.tile[num, num2].frameY & 0x200) == 512)
		{
			num5 += 8;
		}
		int num6 = 0;
		if ((Main.tile[num, num2].frameY & 0x400) == 1024)
		{
			num6++;
		}
		if ((Main.tile[num, num2].frameY & 0x800) == 2048)
		{
			num6 += 2;
		}
		if ((Main.tile[num, num2].frameY & 0x1000) == 4096)
		{
			num6 += 4;
		}
		if ((Main.tile[num, num2].frameY & 0x2000) == 8192)
		{
			num6 += 8;
		}
		if (obj == 0 && num3 > 0)
		{
			return num3;
		}
		if (obj == 1 && num4 > 0)
		{
			return num4;
		}
		if (obj == 2 && num5 > 0)
		{
			return num5;
		}
		if (obj == 3 && num6 > 0)
		{
			return num6;
		}
		return -1;
	}

	public static void dropXmasTree(int x, int y, int obj)
	{
		int num = x;
		int num2 = y;
		if (Main.tile[x, y].frameX < 10)
		{
			num -= Main.tile[x, y].frameX;
			num2 -= Main.tile[x, y].frameY;
		}
		int num3 = 0;
		if ((Main.tile[num, num2].frameY & 1) == 1)
		{
			num3++;
		}
		if ((Main.tile[num, num2].frameY & 2) == 2)
		{
			num3 += 2;
		}
		if ((Main.tile[num, num2].frameY & 4) == 4)
		{
			num3 += 4;
		}
		int num4 = 0;
		if ((Main.tile[num, num2].frameY & 8) == 8)
		{
			num4++;
		}
		if ((Main.tile[num, num2].frameY & 0x10) == 16)
		{
			num4 += 2;
		}
		if ((Main.tile[num, num2].frameY & 0x20) == 32)
		{
			num4 += 4;
		}
		int num5 = 0;
		if ((Main.tile[num, num2].frameY & 0x40) == 64)
		{
			num5++;
		}
		if ((Main.tile[num, num2].frameY & 0x80) == 128)
		{
			num5 += 2;
		}
		if ((Main.tile[num, num2].frameY & 0x100) == 256)
		{
			num5 += 4;
		}
		if ((Main.tile[num, num2].frameY & 0x200) == 512)
		{
			num5 += 8;
		}
		int num6 = 0;
		if ((Main.tile[num, num2].frameY & 0x400) == 1024)
		{
			num6++;
		}
		if ((Main.tile[num, num2].frameY & 0x800) == 2048)
		{
			num6 += 2;
		}
		if ((Main.tile[num, num2].frameY & 0x1000) == 4096)
		{
			num6 += 4;
		}
		if ((Main.tile[num, num2].frameY & 0x2000) == 8192)
		{
			num6 += 8;
		}
		if (obj == 0 && num3 > 0)
		{
			int number = Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, 1874 + num3 - 1);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(21, -1, -1, null, number, 1f);
			}
		}
		else if (obj == 1 && num4 > 0)
		{
			int number2 = Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, 1878 + num4 - 1);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(21, -1, -1, null, number2, 1f);
			}
		}
		else if (obj == 2 && num5 > 0)
		{
			int number3 = Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, 1884 + num5 - 1);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(21, -1, -1, null, number3, 1f);
			}
		}
		else if (obj == 3 && num6 > 0)
		{
			int number4 = Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, 1895 + num6 - 1);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(21, -1, -1, null, number4, 1f);
			}
		}
	}

	public static void setXmasTree(int x, int y, int obj, int style)
	{
		int num = x;
		int num2 = y;
		if (Main.tile[x, y].frameX < 10)
		{
			num -= Main.tile[x, y].frameX;
			num2 -= Main.tile[x, y].frameY;
		}
		if (obj == 0)
		{
			if ((style & 1) == 1)
			{
				Main.tile[num, num2].frameY |= 1;
			}
			else
			{
				Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -2);
			}
			if ((style & 2) == 2)
			{
				Main.tile[num, num2].frameY |= 2;
			}
			else
			{
				Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -3);
			}
			if ((style & 4) == 4)
			{
				Main.tile[num, num2].frameY |= 4;
			}
			else
			{
				Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -5);
			}
		}
		if (obj == 1)
		{
			if ((style & 1) == 1)
			{
				Main.tile[num, num2].frameY |= 8;
			}
			else
			{
				Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -9);
			}
			if ((style & 2) == 2)
			{
				Main.tile[num, num2].frameY |= 16;
			}
			else
			{
				Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -17);
			}
			if ((style & 4) == 4)
			{
				Main.tile[num, num2].frameY |= 32;
			}
			else
			{
				Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -33);
			}
		}
		if (obj == 2)
		{
			if ((style & 1) == 1)
			{
				Main.tile[num, num2].frameY |= 64;
			}
			else
			{
				Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -65);
			}
			if ((style & 2) == 2)
			{
				Main.tile[num, num2].frameY |= 128;
			}
			else
			{
				Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -129);
			}
			if ((style & 4) == 4)
			{
				Main.tile[num, num2].frameY |= 256;
			}
			else
			{
				Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -257);
			}
			if ((style & 8) == 8)
			{
				Main.tile[num, num2].frameY |= 512;
			}
			else
			{
				Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -513);
			}
		}
		if (obj == 3)
		{
			if ((style & 1) == 1)
			{
				Main.tile[num, num2].frameY |= 1024;
			}
			else
			{
				Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -1025);
			}
			if ((style & 2) == 2)
			{
				Main.tile[num, num2].frameY |= 2048;
			}
			else
			{
				Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -2049);
			}
			if ((style & 4) == 4)
			{
				Main.tile[num, num2].frameY |= 4096;
			}
			else
			{
				Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -4097);
			}
			if ((style & 8) == 8)
			{
				Main.tile[num, num2].frameY |= 8192;
			}
			else
			{
				Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -8193);
			}
		}
	}

	public static int PlaceXmasTree_Direct(int x, int y, int type, int style, int dir, int alternate)
	{
		for (short num = 0; num < 4; num++)
		{
			for (short num2 = 0; num2 < 8; num2++)
			{
				if (Main.tile[x + num, y + num2] != null && Main.tile[x + num, y + num2].active())
				{
					KillTile(x + num, y + num2);
				}
			}
		}
		for (short num3 = 0; num3 < 4; num3++)
		{
			for (short num4 = 0; num4 < 8; num4++)
			{
				Tile tile = Main.tile[x + num3, y + num4];
				tile.active(active: true);
				tile.type = (ushort)type;
				if (num3 == 0 && num4 == 0)
				{
					tile.frameX = 10;
					tile.frameY = 0;
				}
				else
				{
					tile.frameX = num3;
					tile.frameY = num4;
				}
			}
		}
		return 0;
	}

	public static void PlaceXmasTree(int x, int y, ushort type = 171)
	{
		bool flag = true;
		int num = x - 1;
		int num2 = y - 7;
		for (int i = num; i < num + 4; i++)
		{
			for (int j = num2; j < num2 + 8; j++)
			{
				if (Main.tile[i, j].active())
				{
					flag = false;
				}
			}
			if (i > num && i < num + 3 && !SolidTile(i, num2 + 8))
			{
				flag = false;
			}
		}
		if (!flag)
		{
			return;
		}
		int num3 = 0;
		for (int k = num; k < num + 4; k++)
		{
			int num4 = 0;
			for (int l = num2; l < num2 + 8; l++)
			{
				Main.tile[k, l].active(active: true);
				if (num3 == 0 && num4 == 0)
				{
					Main.tile[k, l].frameX = 10;
					Main.tile[k, l].frameY = 0;
				}
				else
				{
					Main.tile[k, l].frameX = (short)num3;
					Main.tile[k, l].frameY = (short)num4;
				}
				Main.tile[k, l].type = type;
				Main.tile[k, l].active(active: true);
				num4++;
			}
			num3++;
		}
	}

	public static void CheckXmasTree(int x, int y)
	{
		if (destroyObject)
		{
			return;
		}
		int num = x;
		int num2 = y;
		if (Main.tile[x, y].frameX < 10)
		{
			num -= Main.tile[x, y].frameX;
			num2 -= Main.tile[x, y].frameY;
		}
		bool flag = false;
		int num3 = 0;
		for (int i = num; i < num + 4; i++)
		{
			int num4 = 0;
			for (int j = num2; j < num2 + 8; j++)
			{
				if (Main.tile[i, j].active() && Main.tile[i, j].type == 171)
				{
					if (num3 != 0 && num4 != 0 && Main.tile[i, j].frameX != num3 && Main.tile[i, j].frameY != num4)
					{
						flag = true;
					}
				}
				else
				{
					flag = true;
				}
				num4++;
			}
			num3++;
			if (i > num && i < num + 3 && !SolidTile2(i, num2 + 8))
			{
				flag = true;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		for (int k = num; k < num + 4; k++)
		{
			for (int l = num2; l < num2 + 8; l++)
			{
				if (Main.tile[k, l].type == 171)
				{
					KillTile(k, l);
				}
			}
		}
		Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1873);
		destroyObject = false;
	}

	public static void Place2xX(int x, int y, ushort type, int style = 0)
	{
		int num = style * 36;
		int num2 = 0;
		int num3 = 3;
		if (type == 105 && style == 34)
		{
			type = 349;
			style = 0;
			num = 0;
		}
		if (type == 105)
		{
			int num4 = style / 55;
			num -= 1980 * num4;
			num2 += 54 * num4;
		}
		if (type == 104)
		{
			num3 = 5;
		}
		if (type == 207)
		{
			num3 = 4;
		}
		bool flag = true;
		for (int i = y - num3 + 1; i < y + 1; i++)
		{
			if (Main.tile[x, i] == null)
			{
				Main.tile[x, i] = new Tile();
			}
			if (Main.tile[x, i].active())
			{
				flag = false;
			}
			if (Main.tile[x + 1, i] == null)
			{
				Main.tile[x + 1, i] = new Tile();
			}
			if (Main.tile[x + 1, i].active())
			{
				flag = false;
			}
		}
		if (flag && SolidTile2(x, y + 1) && SolidTile2(x + 1, y + 1))
		{
			for (int j = 0; j < num3; j++)
			{
				Main.tile[x, y - num3 + 1 + j].active(active: true);
				Main.tile[x, y - num3 + 1 + j].frameY = (short)(num2 + j * 18);
				Main.tile[x, y - num3 + 1 + j].frameX = (short)num;
				Main.tile[x, y - num3 + 1 + j].type = type;
				Main.tile[x + 1, y - num3 + 1 + j].active(active: true);
				Main.tile[x + 1, y - num3 + 1 + j].frameY = (short)(num2 + j * 18);
				Main.tile[x + 1, y - num3 + 1 + j].frameX = (short)(num + 18);
				Main.tile[x + 1, y - num3 + 1 + j].type = type;
			}
		}
	}

	public static int GetItemDrop_Candles(int style)
	{
		int result = 105;
		switch (style)
		{
		case 1:
			result = 1405;
			break;
		case 2:
			result = 1406;
			break;
		case 3:
			result = 1407;
			break;
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
		case 12:
		case 13:
			result = 2045 + style - 4;
			break;
		default:
			if (style >= 14 && style <= 16)
			{
				result = 2153 + style - 14;
				break;
			}
			switch (style)
			{
			case 17:
				result = 2236;
				break;
			case 18:
				result = 2523;
				break;
			case 19:
				result = 2542;
				break;
			case 20:
				result = 2556;
				break;
			case 21:
				result = 2571;
				break;
			case 22:
				result = 2648;
				break;
			case 23:
				result = 2649;
				break;
			case 24:
				result = 2650;
				break;
			case 25:
				result = 2651;
				break;
			case 26:
				result = 2818;
				break;
			case 27:
				result = 3171;
				break;
			case 28:
				result = 3173;
				break;
			case 29:
				result = 3172;
				break;
			case 30:
				result = 3890;
				break;
			case 31:
				result = 3936;
				break;
			case 32:
				result = 3962;
				break;
			case 33:
				result = 4150;
				break;
			case 34:
				result = 4171;
				break;
			case 35:
				result = 4192;
				break;
			case 36:
				result = 4213;
				break;
			case 37:
				result = 4303;
				break;
			case 38:
				result = 4571;
				break;
			case 39:
				result = 5153;
				break;
			case 40:
				result = 5174;
				break;
			case 41:
				result = 5195;
				break;
			case 42:
				result = 5553;
				break;
			case 43:
				result = 5606;
				break;
			case 44:
				result = 5694;
				break;
			case 45:
				result = 5717;
				break;
			case 46:
				result = 5743;
				break;
			case 47:
				result = 5760;
				break;
			case 48:
				result = 5781;
				break;
			case 49:
				result = 5802;
				break;
			case 50:
				result = 5823;
				break;
			case 51:
				result = 5844;
				break;
			case 52:
				result = 5862;
				break;
			case 53:
				result = 5883;
				break;
			case 54:
				result = 5902;
				break;
			case 55:
				result = 5936;
				break;
			case 56:
				result = 5959;
				break;
			case 57:
				result = 5979;
				break;
			case 58:
				result = 6002;
				break;
			case 59:
				result = 6025;
				break;
			case 60:
				result = 6048;
				break;
			case 61:
				result = 6071;
				break;
			case 62:
				result = 6094;
				break;
			case 63:
				result = 6115;
				break;
			}
			break;
		}
		return result;
	}

	public static int GetItemDrop_Beds(int style)
	{
		int result = 224;
		switch (style)
		{
		case 0:
			result = 224;
			break;
		case 1:
		case 2:
		case 3:
			result = style + 643;
			break;
		default:
			switch (style)
			{
			case 4:
				result = 920;
				break;
			case 5:
			case 6:
			case 7:
			case 8:
				result = 1465 + style;
				break;
			default:
				if (style >= 9 && style <= 12)
				{
					result = 1710 + style;
					break;
				}
				if (style >= 13 && style <= 18)
				{
					result = 2066 + style - 13;
					break;
				}
				switch (style)
				{
				case 19:
					result = 2139;
					break;
				case 20:
					result = 2140;
					break;
				case 21:
					result = 2231;
					break;
				case 22:
					result = 2520;
					break;
				case 23:
					result = 2538;
					break;
				case 24:
					result = 2553;
					break;
				case 25:
					result = 2568;
					break;
				case 26:
					result = 2669;
					break;
				case 27:
					result = 2811;
					break;
				case 28:
					result = 3162;
					break;
				case 29:
					result = 3164;
					break;
				case 30:
					result = 3163;
					break;
				case 31:
					result = 3897;
					break;
				case 32:
					result = 3932;
					break;
				case 33:
					result = 3959;
					break;
				case 34:
					result = 4146;
					break;
				case 35:
					result = 4167;
					break;
				case 36:
					result = 4188;
					break;
				case 37:
					result = 4209;
					break;
				case 38:
					result = 4299;
					break;
				case 39:
					result = 4567;
					break;
				case 40:
					result = 5149;
					break;
				case 41:
					result = 5170;
					break;
				case 42:
					result = 5191;
					break;
				case 43:
					result = 5549;
					break;
				case 44:
					result = 5602;
					break;
				case 45:
					result = 5690;
					break;
				case 46:
					result = 5713;
					break;
				case 47:
					result = 5740;
					break;
				case 48:
					result = 5757;
					break;
				case 49:
					result = 5778;
					break;
				case 50:
					result = 5799;
					break;
				case 51:
					result = 5820;
					break;
				case 52:
					result = 5841;
					break;
				case 53:
					result = 5859;
					break;
				case 54:
					result = 5880;
					break;
				case 55:
					result = 5899;
					break;
				case 56:
					result = 5933;
					break;
				case 57:
					result = 5956;
					break;
				case 58:
					result = 5976;
					break;
				case 59:
					result = 5999;
					break;
				case 60:
					result = 6022;
					break;
				case 61:
					result = 6045;
					break;
				case 62:
					result = 6068;
					break;
				case 63:
					result = 6091;
					break;
				case 64:
					result = 6112;
					break;
				}
				break;
			}
			break;
		}
		return result;
	}

	public static int GetItemDrop_Clocks(int style)
	{
		int num = 359;
		if (style >= 1 && style <= 5)
		{
			return 2237 + style - 1;
		}
		switch (style)
		{
		case 6:
			return 2560;
		case 7:
			return 2575;
		case 8:
		case 9:
		case 10:
		case 11:
		case 12:
		case 13:
		case 14:
		case 15:
		case 16:
		case 17:
		case 18:
		case 19:
		case 20:
		case 21:
		case 22:
		case 23:
			return 2591 + style - 8;
		default:
			return style switch
			{
				24 => 2809, 
				25 => 3126, 
				26 => 3128, 
				27 => 3127, 
				28 => 3898, 
				29 => 3899, 
				30 => 3900, 
				31 => 3901, 
				32 => 3902, 
				33 => 3940, 
				34 => 3966, 
				35 => 4154, 
				36 => 4175, 
				37 => 4196, 
				38 => 4217, 
				39 => 4306, 
				40 => 4575, 
				41 => 5157, 
				42 => 5178, 
				43 => 5199, 
				44 => 5557, 
				45 => 5610, 
				46 => 5698, 
				47 => 5721, 
				48 => 5746, 
				49 => 5764, 
				50 => 5785, 
				51 => 5806, 
				52 => 5827, 
				53 => 5847, 
				54 => 5866, 
				55 => 5887, 
				56 => 5906, 
				57 => 5940, 
				58 => 5963, 
				59 => 5983, 
				60 => 6006, 
				61 => 6029, 
				62 => 6052, 
				63 => 6075, 
				64 => 6097, 
				65 => 6119, 
				_ => 359, 
			};
		}
	}

	public static int GetItemDrop_Benches(int style)
	{
		return style switch
		{
			1 => 2397, 
			2 => 2398, 
			3 => 2399, 
			4 => 2400, 
			5 => 2401, 
			6 => 2402, 
			7 => 2403, 
			8 => 2404, 
			9 => 2405, 
			10 => 2406, 
			11 => 2407, 
			12 => 2408, 
			13 => 2409, 
			14 => 2410, 
			15 => 2411, 
			16 => 2412, 
			17 => 2413, 
			18 => 2414, 
			19 => 2415, 
			20 => 2416, 
			21 => 2521, 
			22 => 2527, 
			23 => 2539, 
			24 => 858, 
			25 => 2582, 
			26 => 2634, 
			27 => 2635, 
			28 => 2636, 
			29 => 2823, 
			30 => 3150, 
			31 => 3152, 
			32 => 3151, 
			33 => 3918, 
			34 => 3919, 
			35 => 3947, 
			36 => 3973, 
			37 => 4161, 
			38 => 4182, 
			39 => 4203, 
			40 => 4224, 
			41 => 4313, 
			42 => 4582, 
			43 => 4993, 
			44 => 5164, 
			45 => 5185, 
			46 => 5206, 
			47 => 5564, 
			48 => 5617, 
			49 => 5705, 
			50 => 5728, 
			51 => 5753, 
			52 => 5772, 
			53 => 5793, 
			54 => 5814, 
			55 => 5835, 
			56 => 5854, 
			57 => 5874, 
			58 => 5893, 
			59 => 5914, 
			60 => 5948, 
			61 => 5970, 
			62 => 5991, 
			63 => 6014, 
			64 => 6037, 
			65 => 6060, 
			66 => 6083, 
			67 => 6105, 
			68 => 6127, 
			_ => 335, 
		};
	}

	public static int GetItemDrop_PicnicTables(int style)
	{
		if (style == 0 || style != 1)
		{
			return 4064;
		}
		return 4065;
	}

	public static int GetItemDrop_Candelabras(int style)
	{
		int result = 349;
		switch (style)
		{
		case 0:
			result = 349;
			break;
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
		case 12:
			result = 2092 + style - 1;
			break;
		default:
			if (style >= 13 && style <= 16)
			{
				result = 2149 + style - 13;
				break;
			}
			switch (style)
			{
			case 17:
				result = 2227;
				break;
			case 18:
				result = 2522;
				break;
			case 19:
				result = 2541;
				break;
			case 20:
				result = 2555;
				break;
			case 21:
				result = 2570;
				break;
			case 22:
				result = 2664;
				break;
			case 23:
				result = 2665;
				break;
			case 24:
				result = 2666;
				break;
			case 25:
				result = 2667;
				break;
			case 26:
				result = 2668;
				break;
			case 27:
				result = 2825;
				break;
			case 28:
				result = 3168;
				break;
			case 29:
				result = 3170;
				break;
			case 30:
				result = 3169;
				break;
			case 31:
				result = 3893;
				break;
			case 32:
				result = 3935;
				break;
			case 33:
				result = 3961;
				break;
			case 34:
				result = 4149;
				break;
			case 35:
				result = 4170;
				break;
			case 36:
				result = 4191;
				break;
			case 37:
				result = 4212;
				break;
			case 38:
				result = 4302;
				break;
			case 39:
				result = 4570;
				break;
			case 40:
				result = 5152;
				break;
			case 41:
				result = 5173;
				break;
			case 42:
				result = 5194;
				break;
			case 43:
				result = 5552;
				break;
			case 44:
				result = 5605;
				break;
			case 45:
				result = 5693;
				break;
			case 46:
				result = 5716;
				break;
			case 47:
				result = 5742;
				break;
			case 48:
				result = 5759;
				break;
			case 49:
				result = 5780;
				break;
			case 50:
				result = 5801;
				break;
			case 51:
				result = 5822;
				break;
			case 52:
				result = 5843;
				break;
			case 53:
				result = 5861;
				break;
			case 54:
				result = 5882;
				break;
			case 55:
				result = 5901;
				break;
			case 56:
				result = 5935;
				break;
			case 57:
				result = 5958;
				break;
			case 58:
				result = 5978;
				break;
			case 59:
				result = 6001;
				break;
			case 60:
				result = 6024;
				break;
			case 61:
				result = 6047;
				break;
			case 62:
				result = 6070;
				break;
			case 63:
				result = 6093;
				break;
			case 64:
				result = 6114;
				break;
			}
			break;
		}
		return result;
	}

	public static int GetItemDrop_Bookcases(int style)
	{
		int result = 354;
		switch (style)
		{
		case 1:
			result = 1414;
			break;
		case 2:
			result = 1415;
			break;
		case 3:
			result = 1416;
			break;
		case 4:
			result = 1463;
			break;
		case 5:
			result = 1512;
			break;
		case 6:
			result = 2020;
			break;
		case 7:
			result = 2021;
			break;
		case 8:
			result = 2022;
			break;
		case 9:
			result = 2023;
			break;
		case 10:
			result = 2024;
			break;
		case 11:
			result = 2025;
			break;
		case 12:
			result = 2026;
			break;
		case 13:
			result = 2027;
			break;
		case 14:
			result = 2028;
			break;
		case 15:
			result = 2029;
			break;
		case 16:
			result = 2030;
			break;
		case 17:
			result = 2031;
			break;
		case 18:
		case 19:
		case 20:
		case 21:
			result = 2135 + style - 18;
			break;
		default:
			switch (style)
			{
			case 22:
				result = 2233;
				break;
			case 23:
				result = 2536;
				break;
			case 24:
				result = 2540;
				break;
			case 25:
				result = 2554;
				break;
			case 26:
				result = 2569;
				break;
			case 27:
				result = 2670;
				break;
			case 28:
				result = 2817;
				break;
			case 29:
				result = 3165;
				break;
			case 30:
				result = 3167;
				break;
			case 31:
				result = 3166;
				break;
			case 32:
				result = 3917;
				break;
			case 33:
				result = 3933;
				break;
			case 34:
				result = 3960;
				break;
			case 35:
				result = 4147;
				break;
			case 36:
				result = 4168;
				break;
			case 37:
				result = 4189;
				break;
			case 38:
				result = 4210;
				break;
			case 39:
				result = 4300;
				break;
			case 40:
				result = 4568;
				break;
			case 41:
				result = 5150;
				break;
			case 42:
				result = 5171;
				break;
			case 43:
				result = 5192;
				break;
			case 44:
				result = 5550;
				break;
			case 45:
				result = 5603;
				break;
			case 46:
				result = 5691;
				break;
			case 47:
				result = 5714;
				break;
			case 48:
				result = 5758;
				break;
			case 49:
				result = 5779;
				break;
			case 50:
				result = 5800;
				break;
			case 51:
				result = 5821;
				break;
			case 52:
				result = 5842;
				break;
			case 53:
				result = 5860;
				break;
			case 54:
				result = 5881;
				break;
			case 55:
				result = 5900;
				break;
			case 56:
				result = 5934;
				break;
			case 57:
				result = 5957;
				break;
			case 58:
				result = 5977;
				break;
			case 59:
				result = 6000;
				break;
			case 60:
				result = 6023;
				break;
			case 61:
				result = 6046;
				break;
			case 62:
				result = 6069;
				break;
			case 63:
				result = 6092;
				break;
			case 64:
				result = 6113;
				break;
			}
			break;
		}
		return result;
	}

	public static int GetItemDrop_Chandeliers(int style)
	{
		int result = 106;
		switch (style)
		{
		case 1:
			result = 107;
			break;
		case 2:
			result = 108;
			break;
		case 3:
			result = 710;
			break;
		case 4:
			result = 711;
			break;
		case 5:
			result = 712;
			break;
		case 6:
			result = 1812;
			break;
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
		case 12:
		case 13:
		case 14:
		case 15:
		case 16:
		case 17:
			result = 2055 + style - 7;
			break;
		default:
			if (style >= 18 && style <= 21)
			{
				result = 2141 + style - 18;
				break;
			}
			switch (style)
			{
			case 22:
				result = 2224;
				break;
			case 23:
				result = 2525;
				break;
			case 24:
				result = 2543;
				break;
			case 25:
				result = 2558;
				break;
			case 26:
				result = 2573;
				break;
			case 27:
				result = 2652;
				break;
			case 28:
				result = 2653;
				break;
			case 29:
				result = 2654;
				break;
			case 30:
				result = 2655;
				break;
			case 31:
				result = 2656;
				break;
			case 32:
				result = 2657;
				break;
			case 33:
				result = 2813;
				break;
			case 34:
				result = 3177;
				break;
			case 35:
				result = 3179;
				break;
			case 36:
				result = 3178;
				break;
			case 37:
				result = 3894;
				break;
			case 38:
				result = 3938;
				break;
			case 39:
				result = 3964;
				break;
			case 40:
				result = 4152;
				break;
			case 41:
				result = 4173;
				break;
			case 42:
				result = 4194;
				break;
			case 43:
				result = 4215;
				break;
			case 44:
				result = 4305;
				break;
			case 45:
				result = 4573;
				break;
			case 46:
				result = 5155;
				break;
			case 47:
				result = 5176;
				break;
			case 48:
				result = 5197;
				break;
			case 49:
				result = 5555;
				break;
			case 50:
				result = 5608;
				break;
			case 51:
				result = 5696;
				break;
			case 52:
				result = 5719;
				break;
			case 53:
				result = 5744;
				break;
			case 54:
				result = 5762;
				break;
			case 55:
				result = 5783;
				break;
			case 56:
				result = 5804;
				break;
			case 57:
				result = 5825;
				break;
			case 58:
				result = 5845;
				break;
			case 59:
				result = 5864;
				break;
			case 60:
				result = 5885;
				break;
			case 61:
				result = 5904;
				break;
			case 62:
				result = 5938;
				break;
			case 63:
				result = 5961;
				break;
			case 64:
				result = 5981;
				break;
			case 65:
				result = 6004;
				break;
			case 66:
				result = 6027;
				break;
			case 67:
				result = 6050;
				break;
			case 68:
				result = 6073;
				break;
			case 69:
				result = 6096;
				break;
			case 70:
				result = 6117;
				break;
			}
			break;
		}
		return result;
	}

	public static int GetItemDrop_Lanterns(int style)
	{
		int result = 136;
		if (style == 0)
		{
			result = 136;
		}
		else if (style == 7)
		{
			result = 1431;
		}
		else if (style == 8)
		{
			result = 1808;
		}
		else if (style == 9)
		{
			result = 1859;
		}
		else if (style < 10)
		{
			result = 1389 + style;
		}
		else
		{
			switch (style)
			{
			case 10:
				result = 2032;
				break;
			case 11:
				result = 2033;
				break;
			case 12:
				result = 2034;
				break;
			case 13:
				result = 2035;
				break;
			case 14:
				result = 2036;
				break;
			case 15:
				result = 2037;
				break;
			case 16:
				result = 2038;
				break;
			case 17:
				result = 2039;
				break;
			case 18:
				result = 2040;
				break;
			case 19:
				result = 2041;
				break;
			case 20:
				result = 2042;
				break;
			case 21:
				result = 2043;
				break;
			case 22:
			case 23:
			case 24:
			case 25:
				result = 2145 + style - 22;
				break;
			default:
				switch (style)
				{
				case 26:
					result = 2226;
					break;
				case 27:
					result = 2530;
					break;
				case 28:
					result = 2546;
					break;
				case 29:
					result = 2564;
					break;
				case 30:
					result = 2579;
					break;
				case 31:
					result = 2641;
					break;
				case 32:
					result = 2642;
					break;
				case 33:
					result = 2820;
					break;
				case 34:
					result = 3138;
					break;
				case 35:
					result = 3140;
					break;
				case 36:
					result = 3139;
					break;
				case 37:
					result = 3891;
					break;
				case 38:
					result = 3943;
					break;
				case 39:
					result = 3970;
					break;
				case 40:
					result = 4157;
					break;
				case 41:
					result = 4178;
					break;
				case 42:
					result = 4199;
					break;
				case 43:
					result = 4220;
					break;
				case 44:
					result = 4309;
					break;
				case 45:
					result = 4578;
					break;
				case 46:
					result = 5160;
					break;
				case 47:
					result = 5181;
					break;
				case 48:
					result = 5202;
					break;
				case 49:
					result = 5560;
					break;
				case 50:
					result = 5613;
					break;
				case 51:
					result = 5701;
					break;
				case 52:
					result = 5724;
					break;
				case 53:
					result = 5749;
					break;
				case 54:
					result = 5768;
					break;
				case 55:
					result = 5789;
					break;
				case 56:
					result = 5810;
					break;
				case 57:
					result = 5831;
					break;
				case 58:
					result = 5850;
					break;
				case 59:
					result = 5870;
					break;
				case 60:
					result = 5890;
					break;
				case 61:
					result = 5910;
					break;
				case 62:
					result = 5944;
					break;
				case 63:
					result = 5967;
					break;
				case 64:
					result = 5987;
					break;
				case 65:
					result = 6010;
					break;
				case 66:
					result = 6033;
					break;
				case 67:
					result = 6056;
					break;
				case 68:
					result = 6079;
					break;
				case 69:
					result = 6101;
					break;
				case 70:
					result = 6123;
					break;
				}
				break;
			}
		}
		return result;
	}

	public static int GetItemDrop_Lamps(int style)
	{
		int result = 342;
		switch (style)
		{
		case 0:
			result = 342;
			break;
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
			result = 2082 + style - 1;
			break;
		default:
			if (style >= 11 && style <= 16)
			{
				result = 2129 + style - 11;
				break;
			}
			switch (style)
			{
			case 17:
				result = 2225;
				break;
			case 18:
				result = 2533;
				break;
			case 19:
				result = 2547;
				break;
			case 20:
				result = 2563;
				break;
			case 21:
				result = 2578;
				break;
			case 22:
				result = 2643;
				break;
			case 23:
				result = 2644;
				break;
			case 24:
				result = 2645;
				break;
			case 25:
				result = 2646;
				break;
			case 26:
				result = 2647;
				break;
			case 27:
				result = 2819;
				break;
			case 28:
				result = 3135;
				break;
			case 29:
				result = 3137;
				break;
			case 30:
				result = 3136;
				break;
			case 31:
				result = 3892;
				break;
			case 32:
				result = 3942;
				break;
			case 33:
				result = 3969;
				break;
			case 34:
				result = 4156;
				break;
			case 35:
				result = 4177;
				break;
			case 36:
				result = 4198;
				break;
			case 37:
				result = 4219;
				break;
			case 38:
				result = 4308;
				break;
			case 39:
				result = 4577;
				break;
			case 40:
				result = 5159;
				break;
			case 41:
				result = 5180;
				break;
			case 42:
				result = 5201;
				break;
			case 43:
				result = 5559;
				break;
			case 44:
				result = 5612;
				break;
			case 45:
				result = 5700;
				break;
			case 46:
				result = 5723;
				break;
			case 47:
				result = 5748;
				break;
			case 48:
				result = 5767;
				break;
			case 49:
				result = 5788;
				break;
			case 50:
				result = 5809;
				break;
			case 51:
				result = 5830;
				break;
			case 52:
				result = 5849;
				break;
			case 53:
				result = 5869;
				break;
			case 54:
				result = 5889;
				break;
			case 55:
				result = 5909;
				break;
			case 56:
				result = 5943;
				break;
			case 57:
				result = 5966;
				break;
			case 58:
				result = 5986;
				break;
			case 59:
				result = 6009;
				break;
			case 60:
				result = 6032;
				break;
			case 61:
				result = 6055;
				break;
			case 62:
				result = 6078;
				break;
			case 63:
				result = 6100;
				break;
			case 64:
				result = 6122;
				break;
			}
			break;
		}
		return result;
	}

	public static int GetItemDrop_Bottles(int style)
	{
		int result = 31;
		switch (style)
		{
		case 1:
			result = 28;
			break;
		case 2:
			result = 110;
			break;
		case 3:
			result = 350;
			break;
		case 4:
			result = 351;
			break;
		case 5:
			result = 2234;
			break;
		case 6:
			result = 2244;
			break;
		case 7:
			result = 2257;
			break;
		case 8:
			result = 2258;
			break;
		}
		return result;
	}

	public static int GetItemDrop_Pianos(int style)
	{
		int result = 333;
		if (style >= 1 && style <= 3)
		{
			result = 640 + style;
		}
		else
		{
			switch (style)
			{
			case 4:
				result = 919;
				break;
			case 5:
			case 6:
			case 7:
				result = 2245 + style - 5;
				break;
			default:
				if (style >= 8 && style <= 10)
				{
					result = 2254 + style - 8;
					break;
				}
				if (style >= 11 && style <= 20)
				{
					result = 2376 + style - 11;
					break;
				}
				switch (style)
				{
				case 21:
					result = 2531;
					break;
				case 22:
					result = 2548;
					break;
				case 23:
					result = 2565;
					break;
				case 24:
					result = 2580;
					break;
				case 25:
					result = 2671;
					break;
				case 26:
					result = 2821;
					break;
				case 27:
					result = 3141;
					break;
				case 28:
					result = 3143;
					break;
				case 29:
					result = 3142;
					break;
				case 30:
					result = 3915;
					break;
				case 31:
					result = 3916;
					break;
				case 32:
					result = 3944;
					break;
				case 33:
					result = 3971;
					break;
				case 34:
					result = 4158;
					break;
				case 35:
					result = 4179;
					break;
				case 36:
					result = 4200;
					break;
				case 37:
					result = 4221;
					break;
				case 38:
					result = 4310;
					break;
				case 39:
					result = 4579;
					break;
				case 40:
					result = 5161;
					break;
				case 41:
					result = 5182;
					break;
				case 42:
					result = 5203;
					break;
				case 43:
					result = 5561;
					break;
				case 44:
					result = 5614;
					break;
				case 45:
					result = 5702;
					break;
				case 46:
					result = 5725;
					break;
				case 47:
					result = 5750;
					break;
				case 48:
					result = 5769;
					break;
				case 49:
					result = 5790;
					break;
				case 50:
					result = 5811;
					break;
				case 51:
					result = 5832;
					break;
				case 52:
					result = 5851;
					break;
				case 53:
					result = 5871;
					break;
				case 54:
					result = 5891;
					break;
				case 55:
					result = 5911;
					break;
				case 56:
					result = 5945;
					break;
				case 57:
					result = 5968;
					break;
				case 58:
					result = 5988;
					break;
				case 59:
					result = 6011;
					break;
				case 60:
					result = 6034;
					break;
				case 61:
					result = 6057;
					break;
				case 62:
					result = 6080;
					break;
				case 63:
					result = 6102;
					break;
				case 64:
					result = 6124;
					break;
				}
				break;
			}
		}
		return result;
	}

	public static int GetItemDrop_Sinks(int style)
	{
		int result = 2827;
		if (style >= 0 && style <= 28)
		{
			result = 2827 + style;
		}
		else
		{
			switch (style)
			{
			case 29:
				result = 3147;
				break;
			case 30:
				result = 3149;
				break;
			case 31:
				result = 3148;
				break;
			case 32:
				result = 3896;
				break;
			case 33:
				result = 3946;
				break;
			case 34:
				result = 3972;
				break;
			case 35:
				result = 4160;
				break;
			case 36:
				result = 4181;
				break;
			case 37:
				result = 4202;
				break;
			case 38:
				result = 4223;
				break;
			case 39:
				result = 4312;
				break;
			case 40:
				result = 4581;
				break;
			case 41:
				result = 5163;
				break;
			case 42:
				result = 5184;
				break;
			case 43:
				result = 5205;
				break;
			case 44:
				result = 5563;
				break;
			case 45:
				result = 5616;
				break;
			case 46:
				result = 5704;
				break;
			case 47:
				result = 5727;
				break;
			case 48:
				result = 5752;
				break;
			case 49:
				result = 5771;
				break;
			case 50:
				result = 5792;
				break;
			case 51:
				result = 5813;
				break;
			case 52:
				result = 5834;
				break;
			case 53:
				result = 5853;
				break;
			case 54:
				result = 5873;
				break;
			case 55:
				result = 5892;
				break;
			case 56:
				result = 5913;
				break;
			case 57:
				result = 5947;
				break;
			case 58:
				result = 5969;
				break;
			case 59:
				result = 5990;
				break;
			case 60:
				result = 6013;
				break;
			case 61:
				result = 6036;
				break;
			case 62:
				result = 6059;
				break;
			case 63:
				result = 6082;
				break;
			case 64:
				result = 6104;
				break;
			case 65:
				result = 6126;
				break;
			}
		}
		return result;
	}

	public static int GetItemDrop_Chests(int style, bool secondType)
	{
		int num = 0;
		if (secondType)
		{
			num = 3884;
			switch (style)
			{
			case 1:
				num = 3885;
				break;
			case 2:
				num = 3939;
				break;
			case 3:
				num = 3965;
				break;
			case 4:
				num = 3988;
				break;
			case 5:
				num = 4153;
				break;
			case 6:
				num = 4174;
				break;
			case 7:
				num = 4195;
				break;
			case 8:
				num = 4216;
				break;
			case 9:
				num = 4265;
				break;
			case 10:
				num = 4267;
				break;
			case 11:
				num = 4574;
				break;
			case 12:
				num = 4712;
				break;
			case 13:
				num = 4712;
				break;
			case 14:
				num = 5156;
				break;
			case 15:
				num = 5177;
				break;
			case 16:
				num = 5198;
				break;
			case 17:
				num = 5556;
				break;
			case 18:
				num = 5609;
				break;
			case 19:
				num = 5697;
				break;
			case 20:
				num = 5720;
				break;
			case 21:
				num = 5745;
				break;
			case 22:
				num = 5763;
				break;
			case 23:
				num = 5784;
				break;
			case 24:
				num = 5805;
				break;
			case 25:
				num = 5826;
				break;
			case 26:
				num = 5846;
				break;
			case 27:
				num = 5865;
				break;
			case 28:
				num = 5886;
				break;
			case 29:
				num = 5905;
				break;
			case 30:
				num = 5939;
				break;
			case 31:
				num = 5962;
				break;
			case 32:
				num = 5982;
				break;
			case 33:
				num = 6005;
				break;
			case 34:
				num = 6028;
				break;
			case 35:
				num = 6051;
				break;
			case 36:
				num = 6074;
				break;
			case 37:
				num = 6118;
				break;
			}
		}
		else
		{
			num = 48;
			switch (style)
			{
			case 0:
				num = 48;
				break;
			case 1:
				num = 306;
				break;
			case 2:
				num = 306;
				break;
			case 3:
				num = 328;
				break;
			case 4:
				num = 328;
				break;
			case 5:
				num = 343;
				break;
			case 6:
				num = 348;
				break;
			case 7:
				num = 625;
				break;
			case 8:
				num = 626;
				break;
			case 9:
				num = 627;
				break;
			case 10:
				num = 680;
				break;
			case 11:
				num = 681;
				break;
			case 12:
				num = 831;
				break;
			case 13:
				num = 838;
				break;
			case 14:
				num = 914;
				break;
			case 15:
				num = 952;
				break;
			case 16:
				num = 1142;
				break;
			case 17:
				num = 1298;
				break;
			case 18:
				num = 1528;
				break;
			case 19:
				num = 1529;
				break;
			case 20:
				num = 1530;
				break;
			case 21:
				num = 1531;
				break;
			case 22:
				num = 1532;
				break;
			case 23:
				num = 1528;
				break;
			case 24:
				num = 1529;
				break;
			case 25:
				num = 1530;
				break;
			case 26:
				num = 1531;
				break;
			case 27:
				num = 1532;
				break;
			case 28:
				num = 2230;
				break;
			case 29:
				num = 2249;
				break;
			case 30:
				num = 2250;
				break;
			case 31:
				num = 2526;
				break;
			case 32:
				num = 2544;
				break;
			case 33:
				num = 2559;
				break;
			case 34:
				num = 2574;
				break;
			case 35:
				num = 2612;
				break;
			case 36:
				num = 2612;
				break;
			case 37:
				num = 2613;
				break;
			case 38:
				num = 2613;
				break;
			case 39:
				num = 2614;
				break;
			case 40:
				num = 2614;
				break;
			case 41:
				num = 2615;
				break;
			case 42:
				num = 2616;
				break;
			case 43:
				num = 2617;
				break;
			case 44:
				num = 2618;
				break;
			case 45:
				num = 2619;
				break;
			case 46:
				num = 2620;
				break;
			case 47:
				num = 2748;
				break;
			case 48:
				num = 2814;
				break;
			case 49:
				num = 3180;
				break;
			case 50:
				num = 3125;
				break;
			case 51:
				num = 3181;
				break;
			}
		}
		return num;
	}

	public static int GetItemDrop_FakeChests(int style, bool secondType)
	{
		int num = -1;
		if (secondType)
		{
			num = 3886;
			switch (style)
			{
			case 1:
				num = 3887;
				break;
			case 2:
				num = 3950;
				break;
			case 3:
				num = 3976;
				break;
			case 4:
				num = -1;
				break;
			case 5:
				num = 4164;
				break;
			case 6:
				num = 4185;
				break;
			case 7:
				num = 4206;
				break;
			case 8:
				num = 4227;
				break;
			case 9:
				num = 4266;
				break;
			case 10:
				num = 4268;
				break;
			case 11:
				num = 4585;
				break;
			case 12:
				num = 4713;
				break;
			case 13:
				num = -1;
				break;
			case 14:
				num = 5167;
				break;
			case 15:
				num = 5188;
				break;
			case 16:
				num = 5209;
				break;
			case 17:
				num = 5567;
				break;
			case 18:
				num = 5620;
				break;
			case 19:
				num = 5708;
				break;
			case 20:
				num = 5731;
				break;
			case 21:
				num = 5754;
				break;
			case 22:
				num = 5776;
				break;
			case 23:
				num = 5797;
				break;
			case 24:
				num = 5818;
				break;
			case 25:
				num = 5839;
				break;
			case 26:
				num = 5857;
				break;
			case 27:
				num = 5878;
				break;
			case 28:
				num = 5897;
				break;
			case 29:
				num = 5918;
				break;
			case 30:
				num = 5952;
				break;
			case 31:
				num = 5974;
				break;
			case 32:
				num = 5995;
				break;
			case 33:
				num = 6018;
				break;
			case 34:
				num = 6041;
				break;
			case 35:
				num = 6064;
				break;
			case 36:
				num = 6087;
				break;
			case 37:
				num = 6131;
				break;
			}
		}
		else
		{
			num = 3665;
			switch (style)
			{
			case 1:
				num = 3666;
				break;
			case 3:
				num = 3667;
				break;
			case 7:
				num = 3668;
				break;
			case 8:
				num = 3669;
				break;
			case 9:
				num = 3670;
				break;
			case 10:
				num = 3671;
				break;
			case 11:
				num = 3672;
				break;
			case 12:
				num = 3673;
				break;
			case 13:
				num = 3674;
				break;
			case 14:
				num = 3675;
				break;
			case 15:
				num = 3676;
				break;
			case 16:
				num = 3677;
				break;
			case 17:
				num = 3678;
				break;
			case 18:
				num = 3679;
				break;
			case 19:
				num = 3680;
				break;
			case 20:
				num = 3681;
				break;
			case 21:
				num = 3682;
				break;
			case 22:
				num = 3683;
				break;
			case 28:
				num = 3684;
				break;
			case 29:
				num = 3685;
				break;
			case 30:
				num = 3686;
				break;
			case 31:
				num = 3687;
				break;
			case 32:
				num = 3688;
				break;
			case 33:
				num = 3689;
				break;
			case 34:
				num = 3690;
				break;
			case 35:
				num = 3691;
				break;
			case 37:
				num = 3692;
				break;
			case 39:
				num = 3693;
				break;
			case 41:
				num = 3694;
				break;
			case 42:
				num = 3695;
				break;
			case 43:
				num = 3696;
				break;
			case 44:
				num = 3697;
				break;
			case 45:
				num = 3698;
				break;
			case 46:
				num = 3699;
				break;
			case 47:
				num = 3700;
				break;
			case 48:
				num = 3701;
				break;
			case 49:
				num = 3702;
				break;
			case 50:
				num = 3703;
				break;
			case 51:
				num = 3704;
				break;
			}
		}
		return num;
	}

	public static int GetItemDrop_Tables(int style, bool secondType)
	{
		int num = 0;
		if (secondType)
		{
			num = 3920;
			switch (style)
			{
			case 1:
				num = 3948;
				break;
			case 2:
				num = 3974;
				break;
			case 3:
				num = 4162;
				break;
			case 4:
				num = 4183;
				break;
			case 5:
				num = 4204;
				break;
			case 6:
				num = 4225;
				break;
			case 7:
				num = 4314;
				break;
			case 8:
				num = 4583;
				break;
			case 9:
				num = 5165;
				break;
			case 10:
				num = 5186;
				break;
			case 11:
				num = 5207;
				break;
			case 12:
				num = 5565;
				break;
			case 13:
				num = 5618;
				break;
			case 14:
				num = 5706;
				break;
			case 15:
				num = 5729;
				break;
			case 16:
				num = 5773;
				break;
			case 17:
				num = 5794;
				break;
			case 18:
				num = 5815;
				break;
			case 19:
				num = 5836;
				break;
			case 20:
				num = 5875;
				break;
			case 21:
				num = 5894;
				break;
			case 22:
				num = 5915;
				break;
			case 23:
				num = 5949;
				break;
			case 24:
				num = 5971;
				break;
			case 25:
				num = 5992;
				break;
			case 26:
				num = 6015;
				break;
			case 27:
				num = 6038;
				break;
			case 28:
				num = 6061;
				break;
			case 29:
				num = 6084;
				break;
			case 30:
				num = 6106;
				break;
			case 31:
				num = 6128;
				break;
			}
		}
		else
		{
			num = 32;
			if (style >= 1 && style <= 3)
			{
				num = 637 + style;
			}
			else if (style >= 15 && style <= 20)
			{
				num = 1698 + style;
			}
			else if (style >= 4 && style <= 7)
			{
				num = 823 + style;
			}
			else
			{
				switch (style)
				{
				case 8:
					num = 917;
					break;
				case 9:
					num = 1144;
					break;
				case 10:
					num = 1397;
					break;
				case 11:
					num = 1400;
					break;
				case 12:
					num = 1403;
					break;
				case 13:
					num = 1460;
					break;
				case 14:
					num = 1510;
					break;
				case 23:
					num = 1926;
					break;
				case 21:
					num = 1794;
					break;
				case 22:
					num = 1816;
					break;
				case 24:
					num = 2248;
					break;
				case 25:
					num = 2259;
					break;
				case 26:
					num = 2532;
					break;
				case 27:
					num = 2550;
					break;
				case 28:
					num = 677;
					break;
				case 29:
					num = 2583;
					break;
				case 30:
					num = 2743;
					break;
				case 31:
					num = 2824;
					break;
				case 32:
					num = 3153;
					break;
				case 33:
					num = 3155;
					break;
				case 34:
					num = 3154;
					break;
				}
			}
		}
		return num;
	}

	public static int GetItemDrop_Bathtubs(int style)
	{
		int result = 336;
		if (style >= 1 && style <= 10)
		{
			result = 2072 + style - 1;
		}
		else if (style >= 11 && style <= 15)
		{
			result = 2124 + style - 11;
		}
		switch (style)
		{
		case 0:
			result = 336;
			break;
		case 16:
			result = 2232;
			break;
		case 17:
			result = 2519;
			break;
		case 18:
			result = 2537;
			break;
		case 19:
			result = 2552;
			break;
		case 20:
			result = 2567;
			break;
		case 21:
			result = 2658;
			break;
		case 22:
			result = 2659;
			break;
		case 23:
			result = 2660;
			break;
		case 24:
			result = 2661;
			break;
		case 25:
			result = 2662;
			break;
		case 26:
			result = 2663;
			break;
		case 27:
			result = 2810;
			break;
		case 28:
			result = 3159;
			break;
		case 29:
			result = 3161;
			break;
		case 30:
			result = 3160;
			break;
		case 31:
			result = 3895;
			break;
		case 32:
			result = 3931;
			break;
		case 33:
			result = 3958;
			break;
		case 34:
			result = 4145;
			break;
		case 35:
			result = 4166;
			break;
		case 36:
			result = 4187;
			break;
		case 37:
			result = 4208;
			break;
		case 38:
			result = 4298;
			break;
		case 39:
			result = 4566;
			break;
		case 40:
			result = 5148;
			break;
		case 41:
			result = 5169;
			break;
		case 42:
			result = 5190;
			break;
		case 43:
			result = 5548;
			break;
		case 44:
			result = 5601;
			break;
		case 45:
			result = 5689;
			break;
		case 46:
			result = 5712;
			break;
		case 47:
			result = 5739;
			break;
		case 48:
			result = 5756;
			break;
		case 49:
			result = 5777;
			break;
		case 50:
			result = 5798;
			break;
		case 51:
			result = 5819;
			break;
		case 52:
			result = 5840;
			break;
		case 53:
			result = 5858;
			break;
		case 54:
			result = 5879;
			break;
		case 55:
			result = 5898;
			break;
		case 56:
			result = 5932;
			break;
		case 57:
			result = 5955;
			break;
		case 58:
			result = 5975;
			break;
		case 59:
			result = 5998;
			break;
		case 60:
			result = 6021;
			break;
		case 61:
			result = 6044;
			break;
		case 62:
			result = 6067;
			break;
		case 63:
			result = 6090;
			break;
		case 64:
			result = 6111;
			break;
		}
		return result;
	}

	public static int GetItemDrop_Workbenches(int style)
	{
		int result = 36;
		if (style >= 1 && style <= 3)
		{
			result = 634 + style;
		}
		else if (style >= 4 && style <= 8)
		{
			result = 807 + style;
		}
		else
		{
			switch (style)
			{
			case 9:
				result = 916;
				break;
			case 10:
				result = 1145;
				break;
			case 11:
				result = 1398;
				break;
			case 12:
				result = 1401;
				break;
			case 13:
				result = 1404;
				break;
			case 14:
				result = 1461;
				break;
			case 15:
				result = 1511;
				break;
			case 16:
				result = 1795;
				break;
			case 17:
				result = 1817;
				break;
			case 18:
				result = 2229;
				break;
			case 19:
				result = 2251;
				break;
			case 20:
				result = 2252;
				break;
			case 21:
				result = 2253;
				break;
			case 22:
				result = 2534;
				break;
			case 23:
				result = 673;
				break;
			case 24:
				result = 2631;
				break;
			case 25:
				result = 2632;
				break;
			case 26:
				result = 2633;
				break;
			case 27:
				result = 2826;
				break;
			case 28:
				result = 3156;
				break;
			case 29:
				result = 3158;
				break;
			case 30:
				result = 3157;
				break;
			case 31:
				result = 3909;
				break;
			case 32:
				result = 3910;
				break;
			case 33:
				result = 3949;
				break;
			case 34:
				result = 3975;
				break;
			case 35:
				result = 4163;
				break;
			case 36:
				result = 4184;
				break;
			case 37:
				result = 4205;
				break;
			case 38:
				result = 4226;
				break;
			case 39:
				result = 4315;
				break;
			case 40:
				result = 4584;
				break;
			case 41:
				result = 5166;
				break;
			case 42:
				result = 5187;
				break;
			case 43:
				result = 5208;
				break;
			case 44:
				result = 5566;
				break;
			case 45:
				result = 5619;
				break;
			case 46:
				result = 5707;
				break;
			case 47:
				result = 5730;
				break;
			case 48:
				result = 5775;
				break;
			case 49:
				result = 5796;
				break;
			case 50:
				result = 5817;
				break;
			case 51:
				result = 5838;
				break;
			case 52:
				result = 5856;
				break;
			case 53:
				result = 5877;
				break;
			case 54:
				result = 5896;
				break;
			case 55:
				result = 5917;
				break;
			case 56:
				result = 5951;
				break;
			case 57:
				result = 5973;
				break;
			case 58:
				result = 5994;
				break;
			case 59:
				result = 6017;
				break;
			case 60:
				result = 6040;
				break;
			case 61:
				result = 6063;
				break;
			case 62:
				result = 6086;
				break;
			case 63:
				result = 6108;
				break;
			case 64:
				result = 6130;
				break;
			}
		}
		return result;
	}

	public static int GetItemDrop_Chair(int style)
	{
		switch (style)
		{
		default:
			return 34;
		case 1:
			return 358;
		case 2:
			return 628;
		case 3:
			return 629;
		case 4:
			return 630;
		case 5:
			return 806;
		case 6:
			return 807;
		case 7:
			return 808;
		case 8:
			return 809;
		case 9:
			return 810;
		case 10:
			return 826;
		case 11:
			return 915;
		case 12:
			return 1143;
		case 13:
			return 1396;
		case 14:
			return 1399;
		case 15:
			return 1402;
		case 16:
			return 1459;
		case 17:
			return 1509;
		case 18:
		case 19:
		case 20:
		case 21:
		case 22:
		case 23:
			return 1703 + style - 18;
		case 24:
			return 1792;
		case 25:
			return 1814;
		case 26:
			return 1925;
		case 27:
			return 2228;
		case 28:
			return 2288;
		case 29:
			return 2524;
		case 30:
			return 2557;
		case 31:
			return 2572;
		case 32:
			return 2812;
		case 33:
			return 3174;
		case 34:
			return 3176;
		case 35:
			return 3175;
		case 36:
			return 3889;
		case 37:
			return 3937;
		case 38:
			return 3963;
		case 39:
			return 4151;
		case 40:
			return 4172;
		case 41:
			return 4193;
		case 42:
			return 4214;
		case 43:
			return 4304;
		case 44:
			return 4572;
		case 45:
			return 5154;
		case 46:
			return 5175;
		case 47:
			return 5196;
		case 48:
			return 5554;
		case 49:
			return 5607;
		case 50:
			return 5695;
		case 51:
			return 5718;
		case 52:
			return 5761;
		case 53:
			return 5782;
		case 54:
			return 5803;
		case 55:
			return 5824;
		case 56:
			return 5863;
		case 57:
			return 5884;
		case 58:
			return 5903;
		case 59:
			return 5937;
		case 60:
			return 5960;
		case 61:
			return 5980;
		case 62:
			return 6003;
		case 63:
			return 6026;
		case 64:
			return 6049;
		case 65:
			return 6072;
		case 66:
			return 6095;
		case 67:
			return 6116;
		}
	}

	public static int GetItemDrop_Toilet(int style)
	{
		int result = 4096;
		if (style >= 0 && style <= 31)
		{
			result = 4096 + style;
		}
		switch (style)
		{
		case 32:
			result = 4141;
			break;
		case 33:
			result = 4165;
			break;
		case 34:
			result = 4186;
			break;
		case 35:
			result = 4207;
			break;
		case 36:
			result = 4228;
			break;
		case 37:
			result = 4316;
			break;
		case 38:
			result = 4586;
			break;
		case 39:
			result = 4731;
			break;
		case 40:
			result = 5168;
			break;
		case 41:
			result = 5189;
			break;
		case 42:
			result = 5210;
			break;
		case 43:
			result = 5568;
			break;
		case 44:
			result = 5621;
			break;
		case 45:
			result = 5709;
			break;
		case 46:
			result = 5732;
			break;
		case 47:
			result = 5755;
			break;
		case 48:
			result = 5774;
			break;
		case 49:
			result = 5795;
			break;
		case 50:
			result = 5816;
			break;
		case 51:
			result = 5837;
			break;
		case 52:
			result = 5855;
			break;
		case 53:
			result = 5876;
			break;
		case 54:
			result = 5895;
			break;
		case 55:
			result = 5916;
			break;
		case 56:
			result = 5950;
			break;
		case 57:
			result = 5972;
			break;
		case 58:
			result = 5993;
			break;
		case 59:
			result = 6016;
			break;
		case 60:
			result = 6039;
			break;
		case 61:
			result = 6062;
			break;
		case 62:
			result = 6085;
			break;
		case 63:
			result = 6107;
			break;
		case 64:
			result = 6129;
			break;
		}
		return result;
	}

	public static int GetItemDrop_Platforms(int style)
	{
		int result = 94;
		switch (style)
		{
		case 1:
			result = 631;
			break;
		case 2:
			result = 632;
			break;
		case 3:
			result = 633;
			break;
		case 4:
			result = 634;
			break;
		case 5:
			result = 913;
			break;
		case 6:
			result = 1384;
			break;
		case 7:
			result = 1385;
			break;
		case 8:
			result = 1386;
			break;
		case 9:
			result = 1387;
			break;
		case 10:
			result = 1388;
			break;
		case 11:
			result = 1389;
			break;
		case 12:
			result = 1418;
			break;
		case 13:
			result = 1457;
			break;
		case 14:
			result = 1702;
			break;
		case 15:
			result = 1796;
			break;
		case 16:
			result = 1818;
			break;
		case 17:
			result = 2518;
			break;
		case 18:
			result = 2549;
			break;
		case 19:
			result = 2566;
			break;
		case 20:
			result = 2581;
			break;
		case 21:
			result = 2627;
			break;
		case 22:
			result = 2628;
			break;
		case 23:
			result = 2629;
			break;
		case 24:
			result = 2630;
			break;
		case 25:
			result = 2744;
			break;
		case 26:
			result = 2822;
			break;
		case 27:
			result = 3144;
			break;
		case 28:
			result = 3146;
			break;
		case 29:
			result = 3145;
			break;
		case 30:
		case 31:
		case 32:
		case 33:
		case 34:
		case 35:
			result = 3903 + style - 30;
			break;
		default:
			switch (style)
			{
			case 36:
				result = 3945;
				break;
			case 37:
				result = 3957;
				break;
			case 38:
				result = 4159;
				break;
			case 39:
				result = 4180;
				break;
			case 40:
				result = 4201;
				break;
			case 41:
				result = 4222;
				break;
			case 42:
				result = 4311;
				break;
			case 43:
				result = 4416;
				break;
			case 44:
				result = 4580;
				break;
			case 45:
				result = 5162;
				break;
			case 46:
				result = 5183;
				break;
			case 47:
				result = 5204;
				break;
			case 48:
				result = 5292;
				break;
			case 49:
				result = 5544;
				break;
			case 50:
				result = 5562;
				break;
			case 51:
				result = 5615;
				break;
			case 52:
				result = 5703;
				break;
			case 53:
				result = 5726;
				break;
			case 54:
				result = 5751;
				break;
			case 55:
				result = 5770;
				break;
			case 56:
				result = 5791;
				break;
			case 57:
				result = 5812;
				break;
			case 58:
				result = 5833;
				break;
			case 59:
				result = 5852;
				break;
			case 60:
				result = 5872;
				break;
			case 61:
				result = 5912;
				break;
			case 62:
				result = 5946;
				break;
			case 63:
				result = 5989;
				break;
			case 64:
				result = 6012;
				break;
			case 65:
				result = 6035;
				break;
			case 66:
				result = 6058;
				break;
			case 67:
				result = 6081;
				break;
			case 68:
				result = 6103;
				break;
			case 69:
				result = 6125;
				break;
			}
			break;
		}
		return result;
	}

	public static int GetItemDrop_MusicBoxes(int style)
	{
		int result = 576;
		if (style <= 12)
		{
			result = 562 + style;
		}
		else if (style >= 13 && style <= 27)
		{
			result = 1596 + style - 13;
		}
		else
		{
			switch (style)
			{
			case 28:
				result = 1963;
				break;
			case 29:
				result = 1964;
				break;
			case 30:
				result = 1965;
				break;
			case 31:
				result = 2742;
				break;
			case 32:
				result = 3044;
				break;
			case 33:
				result = 3235;
				break;
			case 34:
				result = 3236;
				break;
			case 35:
				result = 3237;
				break;
			case 36:
				result = 3370;
				break;
			case 37:
				result = 3371;
				break;
			case 38:
				result = 3796;
				break;
			case 39:
				result = 3869;
				break;
			case 40:
				result = 4082;
				break;
			case 41:
				result = 4078;
				break;
			case 42:
				result = 4079;
				break;
			case 43:
				result = 4077;
				break;
			case 44:
				result = 4080;
				break;
			case 45:
				result = 4081;
				break;
			case 46:
				result = 4237;
				break;
			case 47:
				result = 4356;
				break;
			case 48:
				result = 4357;
				break;
			case 49:
				result = 4358;
				break;
			case 50:
				result = 4421;
				break;
			case 51:
				result = 4606;
				break;
			case 52:
				result = 4979;
				break;
			case 53:
				result = 4985;
				break;
			case 54:
				result = 4990;
				break;
			case 55:
				result = 4991;
				break;
			case 56:
				result = 4992;
				break;
			case 57:
				result = 5006;
				break;
			case 58:
				result = 5014;
				break;
			case 59:
				result = 5015;
				break;
			case 60:
				result = 5016;
				break;
			case 61:
				result = 5017;
				break;
			case 62:
				result = 5018;
				break;
			case 63:
				result = 5019;
				break;
			case 64:
				result = 5020;
				break;
			case 65:
				result = 5021;
				break;
			case 66:
				result = 5022;
				break;
			case 67:
				result = 5023;
				break;
			case 68:
				result = 5024;
				break;
			case 69:
				result = 5025;
				break;
			case 70:
				result = 5026;
				break;
			case 71:
				result = 5027;
				break;
			case 72:
				result = 5028;
				break;
			case 73:
				result = 5029;
				break;
			case 74:
				result = 5030;
				break;
			case 75:
				result = 5031;
				break;
			case 76:
				result = 5032;
				break;
			case 77:
				result = 5033;
				break;
			case 78:
				result = 5034;
				break;
			case 79:
				result = 5035;
				break;
			case 80:
				result = 5036;
				break;
			case 81:
				result = 5037;
				break;
			case 82:
				result = 5038;
				break;
			case 83:
				result = 5039;
				break;
			case 84:
				result = 5040;
				break;
			case 85:
				result = 5044;
				break;
			case 86:
				result = 5112;
				break;
			case 87:
				result = 5362;
				break;
			case 88:
				result = 5578;
				break;
			case 89:
				result = 5538;
				break;
			case 90:
				result = 5579;
				break;
			case 91:
				result = 5580;
				break;
			case 92:
				result = 5539;
				break;
			case 93:
				result = 5581;
				break;
			case 94:
				result = 5582;
				break;
			case 95:
				result = 5637;
				break;
			case 96:
				result = 5638;
				break;
			case 97:
				result = 5639;
				break;
			case 98:
				result = 6144;
				break;
			}
		}
		return result;
	}

	public static void Check1x2(int x, int j, ushort type)
	{
		if (destroyObject)
		{
			return;
		}
		int num = j;
		bool flag = true;
		if (Main.tile[x, num] == null)
		{
			Main.tile[x, num] = new Tile();
		}
		if (Main.tile[x, num + 1] == null)
		{
			Main.tile[x, num + 1] = new Tile();
		}
		short num2 = Main.tile[x, num].frameY;
		int num3 = 0;
		while (num2 >= 40)
		{
			num2 -= 40;
			num3++;
		}
		if (num2 == 18)
		{
			num--;
		}
		if (Main.tile[x, num] == null)
		{
			Main.tile[x, num] = new Tile();
		}
		int num4 = Main.tile[x, num].frameX / 18;
		if (Main.tile[x, num].frameX == -1)
		{
			num4 = Main.tile[x, num + 1].frameX / 18;
		}
		if (Main.tile[x, num].frameY == 40 * num3 && Main.tile[x, num + 1].frameY == 40 * num3 + 18 && Main.tile[x, num].type == type && Main.tile[x, num + 1].type == type)
		{
			flag = false;
		}
		if (Main.tile[x, num + 2] == null)
		{
			Main.tile[x, num + 2] = new Tile();
		}
		if (!SolidTileAllowBottomSlope(x, num + 2) && !TileID.Sets.Platforms[Main.tile[x, num + 2].type])
		{
			flag = true;
		}
		if (Main.tile[x, num].type == 20)
		{
			int num5 = Main.tile[x, num].frameX / 54;
			ushort type2 = Main.tile[x, num + 2].type;
			int num6 = -1;
			switch (type2)
			{
			case 2:
			case 477:
				num6 = 0;
				break;
			case 147:
				num6 = 1;
				break;
			case 60:
				num6 = 2;
				break;
			case 23:
			case 661:
				num6 = 3;
				break;
			case 199:
			case 662:
				num6 = 4;
				break;
			case 109:
			case 492:
				num6 = 5;
				break;
			case 53:
				num6 = 6;
				break;
			case 116:
				num6 = 7;
				break;
			case 234:
				num6 = 8;
				break;
			case 112:
				num6 = 9;
				break;
			case 633:
				num6 = 10;
				break;
			default:
				flag = true;
				break;
			}
			if (!flag && num5 != num6)
			{
				int num7 = 54 * num6;
				num7 += genRand.Next(3) * 18;
				Main.tile[x, num].frameX = (short)num7;
				Main.tile[x, num + 1].frameX = (short)num7;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		if (Main.tile[x, num].type == type)
		{
			KillTile(x, num);
		}
		if (Main.tile[x, num + 1].type == type)
		{
			KillTile(x, num + 1);
		}
		if (type == 216)
		{
			Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 970 + num3);
		}
		if (type == 338)
		{
			Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 2738);
		}
		if (type == 390)
		{
			Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 16, 32, 3253);
		}
		if (type == 493)
		{
			int num8 = 0;
			switch (num4)
			{
			case 0:
				num8 = 4083;
				break;
			case 1:
				num8 = 4084;
				break;
			case 2:
				num8 = 4085;
				break;
			case 3:
				num8 = 4086;
				break;
			case 4:
				num8 = 4087;
				break;
			case 5:
				num8 = 4088;
				break;
			}
			if (num8 > 0)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, num8);
			}
		}
		if (type == 15)
		{
			int itemDrop_Chair = GetItemDrop_Chair(num3);
			Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, itemDrop_Chair);
		}
		if (type == 497)
		{
			int itemDrop_Toilet = GetItemDrop_Toilet(num3);
			Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, itemDrop_Toilet);
		}
		destroyObject = false;
	}

	public static void CheckOnTable1x1(int x, int y, int type)
	{
		if (Main.tile[x, y + 1] == null)
		{
			return;
		}
		if (Main.tile[x, y + 1].topSlope())
		{
			if (TileID.Sets.Platforms[Main.tile[x, y + 1].type])
			{
				if ((Main.tile[x, y + 1].blockType() != 3 || !Main.tile[x - 1, y + 1].active() || Main.tile[x - 1, y + 1].blockType() != 0 || !TileID.Sets.Platforms[Main.tile[x - 1, y + 1].type]) && (Main.tile[x, y + 1].blockType() != 2 || !Main.tile[x + 1, y + 1].active() || Main.tile[x + 1, y + 1].blockType() != 0 || !TileID.Sets.Platforms[Main.tile[x + 1, y + 1].type]))
				{
					KillTile(x, y);
				}
			}
			else
			{
				KillTile(x, y);
			}
		}
		else
		{
			if (Main.tile[x, y + 1].active() && Main.tileTable[Main.tile[x, y + 1].type] && !Main.tile[x, y + 1].halfBrick())
			{
				return;
			}
			if (type == 78)
			{
				if (!SolidTileAllowBottomSlope(x, y + 1))
				{
					KillTile(x, y);
				}
			}
			else
			{
				KillTile(x, y);
			}
		}
	}

	public static void CheckSign(int x, int y, ushort type)
	{
		if (destroyObject)
		{
			return;
		}
		int num = x - 2;
		int num2 = x + 3;
		int num3 = y - 2;
		int num4 = y + 3;
		if (num < 0 || num2 > Main.maxTilesX || num3 < 0 || num4 > Main.maxTilesY)
		{
			return;
		}
		bool flag = false;
		for (int i = num; i < num2; i++)
		{
			for (int j = num3; j < num4; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = new Tile();
				}
			}
		}
		int num5 = Main.tile[x, y].frameX / 18;
		int num6 = Main.tile[x, y].frameY / 18;
		num5 %= 2;
		num6 %= 2;
		int num7 = x - num5;
		int num8 = y - num6;
		int num9 = Main.tile[num7, num8].frameX / 18 / 2;
		int num10 = Main.tile[num7, num8].frameY / 18 / 2;
		int num11 = Main.tile[x, y].frameX / 18;
		int num12 = 0;
		while (num11 > 1)
		{
			num11 -= 2;
			num12++;
		}
		num = num7;
		num2 = num7 + 2;
		num3 = num8;
		num4 = num8 + 2;
		num5 = 0;
		for (int k = num; k < num2; k++)
		{
			num6 = 0;
			for (int l = num3; l < num4; l++)
			{
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type)
				{
					flag = true;
					break;
				}
				if (Main.tile[k, l].frameX / 18 != num5 + num9 * 2 || Main.tile[k, l].frameY / 18 != num6 + num10 * 2)
				{
					flag = true;
					break;
				}
				num6++;
			}
			num5++;
		}
		if (!flag)
		{
			if (type == 85)
			{
				if (SolidTileAllowBottomSlope(num7, num8 + 2) && SolidTileAllowBottomSlope(num7 + 1, num8 + 2))
				{
					num9 = num12;
				}
				else
				{
					flag = true;
				}
			}
			else
			{
				bool flag2 = false;
				if (num12 switch
				{
					0 => (TopEdgeCanBeAttachedTo(num7, num8 + 2) && TopEdgeCanBeAttachedTo(num7 + 1, num8 + 2)) ? 1 : 0, 
					1 => (BottomEdgeCanBeAttachedTo(num7, num8 - 1) && BottomEdgeCanBeAttachedTo(num7 + 1, num8 - 1)) ? 1 : 0, 
					2 => (RightEdgeCanBeAttachedTo(num7 - 1, num8) && RightEdgeCanBeAttachedTo(num7 - 1, num8 + 1)) ? 1 : 0, 
					3 => (LeftEdgeCanBeAttachedTo(num7 + 2, num8) && LeftEdgeCanBeAttachedTo(num7 + 2, num8 + 1)) ? 1 : 0, 
					4 => (Main.tile[num7, num8].wall > 0 && Main.tile[num7 + 1, num8].wall > 0 && Main.tile[num7, num8 + 1].wall > 0 && Main.tile[num7 + 1, num8 + 1].wall > 0) ? 1 : 0, 
					_ => 0, 
				} == 0)
				{
					if (TopEdgeCanBeAttachedTo(num7, num8 + 2) && TopEdgeCanBeAttachedTo(num7 + 1, num8 + 2))
					{
						num9 = 0;
					}
					else if (BottomEdgeCanBeAttachedTo(num7, num8 - 1) && BottomEdgeCanBeAttachedTo(num7 + 1, num8 - 1))
					{
						num9 = 1;
					}
					else if (RightEdgeCanBeAttachedTo(num7 - 1, num8) && RightEdgeCanBeAttachedTo(num7 - 1, num8 + 1))
					{
						num9 = 2;
					}
					else if (LeftEdgeCanBeAttachedTo(num7 + 2, num8) && LeftEdgeCanBeAttachedTo(num7 + 2, num8 + 1))
					{
						num9 = 3;
					}
					else if (Main.tile[num7, num8].wall > 0 && Main.tile[num7 + 1, num8].wall > 0 && Main.tile[num7, num8 + 1].wall > 0 && Main.tile[num7 + 1, num8 + 1].wall > 0)
					{
						num9 = 4;
					}
					else
					{
						flag = true;
					}
				}
			}
		}
		if (flag)
		{
			if (type == 395 && TileEntity.TryGetAt<TEItemFrame>(num7, num8, out var result) && result.item.stack > 0)
			{
				result.DropItem();
				if (Main.netMode != 2)
				{
					Main.LocalPlayer.InterruptItemUsageIfOverTile(395);
				}
			}
			destroyObject = true;
			for (int m = num; m < num2; m++)
			{
				for (int n = num3; n < num4; n++)
				{
					if (Main.tile[m, n].type == type)
					{
						KillTile(m, n);
					}
				}
			}
			if (type != 395)
			{
				Sign.KillSign(num7, num8);
			}
			switch (type)
			{
			case 85:
			{
				int type2 = 321;
				if (num12 >= 6 && num12 <= 10)
				{
					type2 = 3229 + num12 - 6;
				}
				else if (num12 >= 1 && num12 <= 5)
				{
					type2 = 1173 + num12 - 1;
				}
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, type2);
				if (Main.netMode == 1)
				{
					break;
				}
				int maxValue = 8;
				if (Main.Difficulty == 2f)
				{
					maxValue = 4;
				}
				else if (Main.Difficulty == 3f)
				{
					maxValue = 2;
				}
				if (genRand.Next(maxValue) == 0 && NPC.CountNPCS(316) < 2)
				{
					int num13 = Player.FindClosest(new Vector2(x * 16, y * 16), 16, 16);
					if (Main.player[num13].ZoneGraveyard || !Main.dayTime || (double)y > Main.worldSurface)
					{
						NPC.SpawnOnPlayer(num13, 316, 0f, 0f, 0f, 1f);
					}
				}
				break;
			}
			case 395:
				Item.NewItem(GetItemSource_FromTileBreak(num7, num8), num7 * 16, num8 * 16, 32, 32, 3270);
				TileEntityType<TEItemFrame>.Kill(num7, num8);
				break;
			case 425:
				Item.NewItem(GetItemSource_FromTileBreak(num7, num8), num7 * 16, num8 * 16, 32, 32, 3617);
				break;
			case 573:
				Item.NewItem(GetItemSource_FromTileBreak(num7, num8), num7 * 16, num8 * 16, 32, 32, 4710);
				break;
			case 511:
				Item.NewItem(GetItemSource_FromTileBreak(num7, num8), num7 * 16, num8 * 16, 32, 32, 4320);
				break;
			case 510:
				Item.NewItem(GetItemSource_FromTileBreak(num7, num8), num7 * 16, num8 * 16, 32, 32, 4319);
				break;
			default:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 171);
				break;
			}
			destroyObject = false;
			return;
		}
		int num14 = 36 * num9;
		for (int num15 = 0; num15 < 2; num15++)
		{
			for (int num16 = 0; num16 < 2; num16++)
			{
				Main.tile[num7 + num15, num8 + num16].active(active: true);
				Main.tile[num7 + num15, num8 + num16].type = type;
				Main.tile[num7 + num15, num8 + num16].frameX = (short)(num14 + 18 * num15);
				Main.tile[num7 + num15, num8 + num16].frameY = (short)(18 * num16 + num10 * 36);
			}
		}
	}

	public static bool PlaceSign(int x, int y, ushort type, int Style = 0)
	{
		int num = x - 2;
		int num2 = x + 3;
		int num3 = y - 2;
		int num4 = y + 3;
		if (num < 0)
		{
			return false;
		}
		if (num2 > Main.maxTilesX)
		{
			return false;
		}
		if (num3 < 0)
		{
			return false;
		}
		if (num4 > Main.maxTilesY)
		{
			return false;
		}
		for (int i = num; i < num2; i++)
		{
			for (int j = num3; j < num4; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = new Tile();
				}
			}
		}
		int num5 = x;
		int num6 = y;
		int num7 = 0;
		if (type == 55 || type == 425 || type == 510 || type == 511)
		{
			if (SolidTile2(x, y + 1) && SolidTile2(x + 1, y + 1))
			{
				num6--;
				num7 = 0;
			}
			else if (Main.tile[x, y - 1].nactive() && Main.tileSolid[Main.tile[x, y - 1].type] && !Main.tileSolidTop[Main.tile[x, y - 1].type] && Main.tile[x + 1, y - 1].nactive() && Main.tileSolid[Main.tile[x + 1, y - 1].type] && !Main.tileSolidTop[Main.tile[x + 1, y - 1].type])
			{
				num7 = 1;
			}
			else if (Main.tile[x - 1, y].nactive() && Main.tileSolid[Main.tile[x - 1, y].type] && !Main.tileSolidTop[Main.tile[x - 1, y].type] && !Main.tileNoAttach[Main.tile[x - 1, y].type] && Main.tile[x - 1, y + 1].nactive() && Main.tileSolid[Main.tile[x - 1, y + 1].type] && !Main.tileSolidTop[Main.tile[x - 1, y + 1].type] && !Main.tileNoAttach[Main.tile[x - 1, y + 1].type])
			{
				num7 = 2;
			}
			else if (Main.tile[x + 1, y].nactive() && Main.tileSolid[Main.tile[x + 1, y].type] && !Main.tileSolidTop[Main.tile[x + 1, y].type] && !Main.tileNoAttach[Main.tile[x + 1, y].type] && Main.tile[x + 1, y + 1].nactive() && Main.tileSolid[Main.tile[x + 1, y + 1].type] && !Main.tileSolidTop[Main.tile[x + 1, y + 1].type] && !Main.tileNoAttach[Main.tile[x + 1, y + 1].type])
			{
				num5--;
				num7 = 3;
			}
			else
			{
				if (Main.tile[num5, num6].wall <= 0 || Main.tile[num5 + 1, num6].wall <= 0 || Main.tile[num5, num6 + 1].wall <= 0 || Main.tile[num5 + 1, num6 + 1].wall <= 0)
				{
					return false;
				}
				num7 = 4;
			}
		}
		if (Main.tile[num5, num6].active() || Main.tile[num5 + 1, num6].active() || Main.tile[num5, num6 + 1].active() || Main.tile[num5 + 1, num6 + 1].active())
		{
			return false;
		}
		int num8 = 36 * num7;
		for (int k = 0; k < 2; k++)
		{
			for (int l = 0; l < 2; l++)
			{
				Main.tile[num5 + k, num6 + l].active(active: true);
				Main.tile[num5 + k, num6 + l].type = type;
				Main.tile[num5 + k, num6 + l].frameX = (short)(num8 + 18 * k);
				Main.tile[num5 + k, num6 + l].frameY = (short)(18 * l);
			}
		}
		return true;
	}

	public static bool Place2x2Horizontal(int x, int y, ushort type, int Style = 0)
	{
		int num = x - 2;
		int num2 = x + 3;
		int num3 = y - 2;
		int num4 = y + 3;
		if (num < 0)
		{
			return false;
		}
		if (num2 > Main.maxTilesX)
		{
			return false;
		}
		if (num3 < 0)
		{
			return false;
		}
		if (num4 > Main.maxTilesY)
		{
			return false;
		}
		for (int i = num; i < num2; i++)
		{
			for (int j = num3; j < num4; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = new Tile();
				}
			}
		}
		int num5 = y;
		int num6 = 0;
		if (SolidTile2(x, y + 1) && SolidTile2(x + 1, y + 1))
		{
			num5--;
			num6 = Style;
			if (Main.tile[x, num5].active() || Main.tile[x + 1, num5].active() || Main.tile[x, num5 + 1].active() || Main.tile[x + 1, num5 + 1].active())
			{
				return false;
			}
			int num7 = 36 * num6;
			for (int k = 0; k < 2; k++)
			{
				for (int l = 0; l < 2; l++)
				{
					Main.tile[x + k, num5 + l].active(active: true);
					Main.tile[x + k, num5 + l].type = type;
					Main.tile[x + k, num5 + l].frameX = (short)(num7 + 18 * k);
					Main.tile[x + k, num5 + l].frameY = (short)(18 * l);
				}
			}
			return true;
		}
		return false;
	}

	public static Color paintColor(int color)
	{
		Color white = Color.White;
		if (color == 1 || color == 13)
		{
			white.R = byte.MaxValue;
			white.G = 0;
			white.B = 0;
		}
		if (color == 2 || color == 14)
		{
			white.R = byte.MaxValue;
			white.G = 127;
			white.B = 0;
		}
		if (color == 3 || color == 15)
		{
			white.R = byte.MaxValue;
			white.G = byte.MaxValue;
			white.B = 0;
		}
		if (color == 4 || color == 16)
		{
			white.R = 127;
			white.G = byte.MaxValue;
			white.B = 0;
		}
		if (color == 5 || color == 17)
		{
			white.R = 0;
			white.G = byte.MaxValue;
			white.B = 0;
		}
		if (color == 6 || color == 18)
		{
			white.R = 0;
			white.G = byte.MaxValue;
			white.B = 127;
		}
		if (color == 7 || color == 19)
		{
			white.R = 0;
			white.G = byte.MaxValue;
			white.B = byte.MaxValue;
		}
		if (color == 8 || color == 20)
		{
			white.R = 0;
			white.G = 127;
			white.B = byte.MaxValue;
		}
		if (color == 9 || color == 21)
		{
			white.R = 0;
			white.G = 0;
			white.B = byte.MaxValue;
		}
		if (color == 10 || color == 22)
		{
			white.R = 127;
			white.G = 0;
			white.B = byte.MaxValue;
		}
		if (color == 11 || color == 23)
		{
			white.R = byte.MaxValue;
			white.G = 0;
			white.B = byte.MaxValue;
		}
		if (color == 12 || color == 24)
		{
			white.R = byte.MaxValue;
			white.G = 0;
			white.B = 127;
		}
		if (color == 25)
		{
			white.R = 75;
			white.G = 75;
			white.B = 75;
		}
		if (color == 26)
		{
			white.R = byte.MaxValue;
			white.G = byte.MaxValue;
			white.B = byte.MaxValue;
		}
		if (color == 27)
		{
			white.R = 175;
			white.G = 175;
			white.B = 175;
		}
		if (color == 28)
		{
			white.R = byte.MaxValue;
			white.G = 178;
			white.B = 125;
		}
		if (color == 29)
		{
			white.R = 25;
			white.G = 25;
			white.B = 25;
		}
		if (color == 30)
		{
			white.R = 200;
			white.G = 200;
			white.B = 200;
			white.A = 150;
		}
		return white;
	}

	public static Color coatingColor(int coating)
	{
		return coating switch
		{
			1 => new Color(235, 170, 255, 255), 
			2 => new Color(180, 245, 255, 255), 
			_ => Color.Transparent, 
		};
	}

	public static List<Color> coatingColors(Tile tile, bool block)
	{
		_coatingColors.Clear();
		if (tile == null)
		{
			return _coatingColors;
		}
		if ((block && tile.fullbrightBlock()) || (!block && tile.fullbrightWall()))
		{
			_coatingColors.Add(coatingColor(1));
		}
		if ((block && tile.invisibleBlock()) || (!block && tile.invisibleWall()))
		{
			_coatingColors.Add(coatingColor(2));
		}
		return _coatingColors;
	}

	public static void paintEffect(int x, int y, byte color, byte oldColor)
	{
		int color2 = color;
		if (color == 0)
		{
			color2 = oldColor;
		}
		Color newColor = paintColor(color2);
		for (int i = 0; i < 10; i++)
		{
			int num = Dust.NewDust(new Vector2(x * 16, y * 16), 16, 16, 143, 0f, 0f, 50, newColor);
			if (genRand.Next(2) == 0)
			{
				Main.dust[num].noGravity = true;
				Main.dust[num].scale *= 1.2f;
			}
			else
			{
				Main.dust[num].scale *= 0.5f;
			}
		}
	}

	public static void paintCoatEffect(int x, int y, byte paintCoatId, List<Color> oldColors)
	{
		Color color = coatingColor(paintCoatId);
		for (int i = 0; i < 10; i++)
		{
			Color newColor = color;
			if (paintCoatId == 0 && oldColors.Count > 0)
			{
				newColor = oldColors[Main.rand.Next(oldColors.Count)];
			}
			int num = Dust.NewDust(new Vector2(x * 16, y * 16), 16, 16, 143, 0f, 0f, 50, newColor);
			if (genRand.Next(2) == 0)
			{
				Main.dust[num].noGravity = true;
				Main.dust[num].scale *= 1.2f;
			}
			else
			{
				Main.dust[num].scale *= 0.5f;
			}
		}
	}

	public static bool paintTile(int x, int y, byte color, bool broadCast = false, bool paintEffects = true)
	{
		Tile tile = Main.tile[x, y];
		if (tile == null || !tile.active())
		{
			return false;
		}
		byte b = tile.color();
		if (b == color)
		{
			return false;
		}
		if (paintEffects)
		{
			paintEffect(x, y, color, b);
		}
		tile.color(color);
		if (broadCast)
		{
			NetMessage.SendData(63, -1, -1, null, x, y, (int)color);
		}
		return true;
	}

	public static bool paintCoatTile(int x, int y, byte paintCoatId, bool broadcast = false, bool coatingEffects = true)
	{
		Tile tile = Main.tile[x, y];
		if (tile == null || !tile.active())
		{
			return false;
		}
		List<Color> oldColors = coatingColors(tile, block: true);
		switch (paintCoatId)
		{
		default:
			return false;
		case 0:
			if (!tile.fullbrightBlock() && !tile.invisibleBlock())
			{
				return false;
			}
			tile.fullbrightBlock(fullbrightBlock: false);
			tile.invisibleBlock(invisibleBlock: false);
			SquareTileFrame(x, y, resetFrame: false);
			break;
		case 1:
			if (tile.fullbrightBlock())
			{
				return false;
			}
			tile.fullbrightBlock(fullbrightBlock: true);
			break;
		case 2:
			if (tile.invisibleBlock())
			{
				return false;
			}
			tile.invisibleBlock(invisibleBlock: true);
			SquareTileFrame(x, y, resetFrame: false);
			break;
		}
		if (broadcast)
		{
			NetMessage.SendData(63, -1, -1, null, x, y, (int)paintCoatId, 1f);
		}
		if (coatingEffects)
		{
			paintCoatEffect(x, y, paintCoatId, oldColors);
		}
		return true;
	}

	public static bool paintCoatWall(int x, int y, byte paintCoatId, bool broadcast = false, bool coatingEffects = true)
	{
		Tile tile = Main.tile[x, y];
		if (tile == null || tile.wall == 0)
		{
			return false;
		}
		List<Color> oldColors = coatingColors(tile, block: false);
		switch (paintCoatId)
		{
		default:
			return false;
		case 0:
			if (!tile.fullbrightWall() && !tile.invisibleWall())
			{
				return false;
			}
			tile.fullbrightWall(fullbrightWall: false);
			tile.invisibleWall(invisibleWall: false);
			SquareWallFrame(x, y, resetFrame: false);
			break;
		case 1:
			if (tile.fullbrightWall())
			{
				return false;
			}
			tile.fullbrightWall(fullbrightWall: true);
			break;
		case 2:
			if (tile.invisibleWall())
			{
				return false;
			}
			tile.invisibleWall(invisibleWall: true);
			SquareWallFrame(x, y, resetFrame: false);
			break;
		}
		if (broadcast)
		{
			NetMessage.SendData(64, -1, -1, null, x, y, (int)paintCoatId, 1f);
		}
		if (coatingEffects)
		{
			paintCoatEffect(x, y, paintCoatId, oldColors);
		}
		return true;
	}

	public static bool paintWall(int x, int y, byte color, bool broadCast = false, bool paintEffects = true)
	{
		Tile tile = Main.tile[x, y];
		if (tile == null || tile.wall == 0)
		{
			return false;
		}
		byte b = tile.wallColor();
		if (b == color)
		{
			return false;
		}
		tile.wallColor(color);
		if (broadCast)
		{
			NetMessage.SendData(64, -1, -1, null, x, y, (int)color);
		}
		if (paintEffects)
		{
			paintEffect(x, y, color, b);
		}
		return true;
	}

	public static void Place3x3Wall(int x, int y, ushort type, int style)
	{
		int num = x - 1;
		int num2 = y - 1;
		bool flag = true;
		for (int i = num; i < num + 3; i++)
		{
			for (int j = num2; j < num2 + 3; j++)
			{
				if (Main.tile[i, j].active() || Main.tile[i, j].wall == 0)
				{
					flag = false;
					break;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		int num3 = 0;
		while (style > 35)
		{
			num3++;
			style -= 36;
		}
		int num4 = style * 54;
		int num5 = num3 * 54;
		for (int k = num; k < num + 3; k++)
		{
			for (int l = num2; l < num2 + 3; l++)
			{
				Main.tile[k, l].active(active: true);
				Main.tile[k, l].type = type;
				Main.tile[k, l].frameX = (short)(num4 + 18 * (k - num));
				Main.tile[k, l].frameY = (short)(num5 + 18 * (l - num2));
			}
		}
	}

	public static void Check3x3Wall(int x, int y)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		Tile tile = Main.tile[x, y];
		if (tile == null)
		{
			return;
		}
		int type = tile.type;
		int num = 0;
		int num2 = 0;
		int num3 = tile.frameX / 18;
		while (num3 >= 3)
		{
			num3 -= 3;
			num++;
		}
		int num4 = x - num3;
		int num5 = tile.frameY / 18;
		while (num5 >= 3)
		{
			num5 -= 3;
			num2++;
		}
		int num6 = y - num5;
		num5 = num2 * 54;
		num3 = num * 54;
		for (int i = num4; i < num4 + 3; i++)
		{
			for (int j = num6; j < num6 + 3; j++)
			{
				Tile tile2 = Main.tile[i, j];
				if (tile2 != null && (tile2.type != type || !tile2.active() || tile2.wall <= 0 || tile2.frameX != num3 + (i - num4) * 18 || tile2.frameY != num5 + (j - num6) * 18))
				{
					flag = true;
					break;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		for (int k = num4; k < num4 + 3; k++)
		{
			for (int l = num6; l < num6 + 3; l++)
			{
				if (Main.tile[k, l] != null && Main.tile[k, l].type == type && Main.tile[k, l].active())
				{
					KillTile(k, l);
				}
			}
		}
		switch (type)
		{
		case 240:
			num += num2 * 36;
			switch (num)
			{
			case 37:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1856);
				break;
			case 36:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1855);
				break;
			case 38:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1960);
				break;
			case 39:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1961);
				break;
			case 40:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1962);
				break;
			case 33:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1574);
				break;
			case 34:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1575);
				break;
			case 35:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1576);
				break;
			case 18:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1419);
				break;
			case 19:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1420);
				break;
			case 20:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1427);
				break;
			case 21:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1428);
				break;
			case 54:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2489);
				break;
			case 55:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2589);
				break;
			case 56:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3357);
				break;
			case 57:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3358);
				break;
			case 58:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3359);
				break;
			case 59:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3595);
				break;
			case 60:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3867);
				break;
			case 61:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3866);
				break;
			case 62:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3868);
				break;
			case 69:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4660);
				break;
			case 70:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4723);
				break;
			case 71:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4724);
				break;
			case 72:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4783);
				break;
			case 73:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4958);
				break;
			case 74:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5087);
				break;
			case 75:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5108);
				break;
			case 94:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5527);
				break;
			case 95:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5528);
				break;
			case 96:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5529);
				break;
			case 97:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5632);
				break;
			case 98:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5631);
				break;
			case 99:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5633);
				break;
			case 100:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5929);
				break;
			case 93:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5490);
				break;
			case 92:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5388);
				break;
			case 76:
			case 77:
			case 78:
			case 79:
			case 80:
			case 81:
			case 82:
			case 83:
			case 84:
			case 85:
			case 86:
			case 87:
			case 88:
			case 89:
			case 90:
			case 91:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5218 + num - 76);
				break;
			default:
				if (num >= 63 && num <= 68)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4626 + num - 63);
				}
				else if (num >= 41 && num <= 45)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2114 + num - 41);
				}
				else if (num >= 46 && num <= 53)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2442 + num - 46);
				}
				else if (num >= 22 && num <= 25)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1440 + num - 22);
				}
				else if (num >= 26 && num <= 29)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1496 + num - 26);
				}
				else if (num >= 30 && num <= 32)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1538 + num - 30);
				}
				else
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1360 + num);
				}
				break;
			}
			break;
		case 440:
		{
			int num7 = -1;
			int num8 = -1;
			switch (num)
			{
			case 0:
				num7 = 3644;
				num8 = 1526;
				break;
			case 1:
				num7 = 3645;
				num8 = 1524;
				break;
			case 2:
				num7 = 3646;
				num8 = 1525;
				break;
			case 3:
				num7 = 3647;
				num8 = 1523;
				break;
			case 4:
				num7 = 3648;
				num8 = 1522;
				break;
			case 5:
				num7 = 3649;
				num8 = 1527;
				break;
			case 6:
				num7 = 3650;
				num8 = 3643;
				break;
			}
			if (num7 != -1)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, num7);
			}
			if (num8 != -1 && num2 == 1)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, num8);
			}
			break;
		}
		}
		destroyObject = false;
	}

	public static void Place2x3Wall(int x, int y, ushort type, int style)
	{
		int num = y - 1;
		bool flag = true;
		for (int i = x; i < x + 2; i++)
		{
			for (int j = num; j < num + 3; j++)
			{
				if (Main.tile[i, j].active() || Main.tile[i, j].wall == 0)
				{
					flag = false;
					break;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		int num2 = style * 36;
		int num3 = 0;
		for (int k = x; k < x + 2; k++)
		{
			for (int l = num; l < num + 3; l++)
			{
				Main.tile[k, l].active(active: true);
				Main.tile[k, l].type = type;
				Main.tile[k, l].frameX = (short)(num2 + 18 * (k - x));
				Main.tile[k, l].frameY = (short)(num3 + 18 * (l - num));
			}
		}
	}

	public static void Check2x3Wall(int x, int y)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		Tile tile = Main.tile[x, y];
		if (tile == null)
		{
			return;
		}
		int type = tile.type;
		int num = 0;
		int num2 = tile.frameX / 18;
		while (num2 >= 2)
		{
			num2 -= 2;
			num++;
		}
		int num3 = x - num2;
		int num4 = y - tile.frameY / 18;
		num2 = num * 36;
		for (int i = num3; i < num3 + 2; i++)
		{
			for (int j = num4; j < num4 + 3; j++)
			{
				Tile tile2 = Main.tile[i, j];
				if (tile2 != null && (tile2.type != type || !tile2.active() || tile2.wall <= 0 || tile2.frameX != num2 + (i - num3) * 18 || tile2.frameY != (j - num4) * 18))
				{
					flag = true;
					break;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		for (int k = num3; k < num3 + 2; k++)
		{
			for (int l = num4; l < num4 + 3; l++)
			{
				Tile tile3 = Main.tile[k, l];
				if (tile3 != null && tile3.type == type && tile3.active())
				{
					KillTile(k, l);
				}
			}
		}
		if (type == 245)
		{
			switch (num)
			{
			case 31:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5634);
				break;
			case 30:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5530);
				break;
			case 29:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5488);
				break;
			case 19:
			case 20:
			case 21:
			case 22:
			case 23:
			case 24:
			case 25:
			case 26:
			case 27:
			case 28:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5248 + num - 19);
				break;
			default:
				if (num >= 15 && num <= 18)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5247);
					break;
				}
				switch (num)
				{
				case 14:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5246);
					break;
				case 13:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5086);
					break;
				case 12:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4728);
					break;
				case 11:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4727);
					break;
				case 10:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4726);
					break;
				case 9:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4659);
					break;
				case 8:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4639);
					break;
				case 7:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4638);
					break;
				case 6:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1577);
					break;
				case 5:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1495);
					break;
				default:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1474 + num);
					break;
				}
				break;
			}
		}
		destroyObject = false;
	}

	public static void Place3x2Wall(int x, int y, ushort type, int style)
	{
		int num = x - 1;
		bool flag = true;
		for (int i = num; i < num + 3; i++)
		{
			for (int j = y; j < y + 2; j++)
			{
				if (Main.tile[i, j].active() || Main.tile[i, j].wall == 0)
				{
					flag = false;
					break;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		int num2 = 0;
		int num3 = style * 36;
		for (int k = num; k < num + 3; k++)
		{
			for (int l = y; l < y + 2; l++)
			{
				Main.tile[k, l].active(active: true);
				Main.tile[k, l].type = type;
				Main.tile[k, l].frameX = (short)(num2 + 18 * (k - num));
				Main.tile[k, l].frameY = (short)(num3 + 18 * (l - y));
			}
		}
	}

	public static void Check3x2Wall(int x, int y)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int type = Main.tile[x, y].type;
		int num = 0;
		int num2 = Main.tile[x, y].frameY / 18;
		while (num2 >= 2)
		{
			num2 -= 2;
			num++;
		}
		int num3 = y - num2;
		int num4 = x - Main.tile[x, y].frameX / 18;
		num2 = num * 36;
		for (int i = num4; i < num4 + 3; i++)
		{
			for (int j = num3; j < num3 + 2; j++)
			{
				if (Main.tile[i, j].type != type || !Main.tile[i, j].active() || Main.tile[i, j].wall <= 0 || Main.tile[i, j].frameY != num2 + (j - num3) * 18 || Main.tile[i, j].frameX != (i - num4) * 18)
				{
					flag = true;
					break;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		for (int k = num4; k < num4 + 3; k++)
		{
			for (int l = num3; l < num3 + 2; l++)
			{
				if (Main.tile[k, l].type == type && Main.tile[k, l].active())
				{
					KillTile(k, l);
				}
			}
		}
		if (type == 246)
		{
			switch (num)
			{
			case 16:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1541);
				break;
			case 17:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1542);
				break;
			case 18:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1908);
				break;
			case 19:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4661);
				break;
			case 20:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4729);
				break;
			case 21:
			case 22:
			case 23:
			case 24:
			case 25:
			case 26:
			case 27:
			case 28:
			case 29:
			case 30:
			case 31:
			case 32:
			case 33:
			case 34:
			case 35:
			case 36:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5258 + num - 21);
				break;
			default:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1479 + num);
				break;
			}
		}
		destroyObject = false;
	}

	public static void Place4x3Wall(int x, int y, ushort type, int style)
	{
		int num = x - 1;
		int num2 = y - 1;
		bool flag = true;
		for (int i = num; i < num + 4; i++)
		{
			for (int j = num2; j < num2 + 3; j++)
			{
				if (Main.tile[i, j].active() || Main.tile[i, j].wall == 0)
				{
					flag = false;
					break;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		int num3 = 0;
		int num4 = style * 54;
		for (int k = num; k < num + 4; k++)
		{
			for (int l = num2; l < num2 + 3; l++)
			{
				Main.tile[k, l].active(active: true);
				Main.tile[k, l].type = type;
				Main.tile[k, l].frameX = (short)(num3 + 18 * (k - num));
				Main.tile[k, l].frameY = (short)(num4 + 18 * (l - num2));
			}
		}
	}

	public static void Check4x3Wall(int x, int y)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int type = Main.tile[x, y].type;
		int num = 0;
		int num2 = Main.tile[x, y].frameY / 18;
		while (num2 >= 3)
		{
			num2 -= 3;
			num++;
		}
		int num3 = y - num2;
		int num4 = x - Main.tile[x, y].frameX / 18;
		num2 = num * 54;
		for (int i = num4; i < num4 + 4; i++)
		{
			for (int j = num3; j < num3 + 3; j++)
			{
				if (Main.tile[i, j].type != type || !Main.tile[i, j].active() || Main.tile[i, j].wall <= 0 || Main.tile[i, j].frameY != num2 + (j - num3) * 18 || Main.tile[i, j].frameX != (i - num4) * 18)
				{
					flag = true;
					break;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		for (int k = num4; k < num4 + 4; k++)
		{
			for (int l = num3; l < num3 + 3; l++)
			{
				if (Main.tile[k, l].type == type && Main.tile[k, l].active())
				{
					KillTile(k, l);
				}
			}
		}
		if (type == 241)
		{
			Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1417);
		}
		destroyObject = false;
	}

	public static void Place6x4Wall(int x, int y, ushort type, int style)
	{
		int num = x - 2;
		int num2 = y - 2;
		bool flag = true;
		for (int i = num; i < num + 6; i++)
		{
			for (int j = num2; j < num2 + 4; j++)
			{
				if (Main.tile[i, j].active() || Main.tile[i, j].wall == 0)
				{
					flag = false;
					break;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		int num3 = 27;
		int num4 = style / num3 * 108;
		int num5 = style % num3 * 72;
		for (int k = num; k < num + 6; k++)
		{
			for (int l = num2; l < num2 + 4; l++)
			{
				Main.tile[k, l].active(active: true);
				Main.tile[k, l].type = type;
				Main.tile[k, l].frameX = (short)(num4 + 18 * (k - num));
				Main.tile[k, l].frameY = (short)(num5 + 18 * (l - num2));
			}
		}
	}

	public static void Check6x4Wall(int x, int y)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int type = Main.tile[x, y].type;
		int num = 0;
		int num2 = Main.tile[x, y].frameY / 18;
		int num3 = Main.tile[x, y].frameX / 18;
		num = 27 * (num3 / 6) + (num2 >> 2);
		num2 %= 4;
		num3 %= 6;
		int num4 = y - num2;
		int num5 = x - Main.tile[x, y].frameX / 18 % 6;
		num2 = num % 27 * 72;
		num3 = num / 27 * 108;
		for (int i = num5; i < num5 + 6; i++)
		{
			for (int j = num4; j < num4 + 4; j++)
			{
				if (Main.tile[i, j].type != type || !Main.tile[i, j].active() || Main.tile[i, j].wall <= 0 || Main.tile[i, j].frameY != num2 + (j - num4) * 18 || Main.tile[i, j].frameX != num3 + (i - num5) * 18)
				{
					flag = true;
					break;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		for (int k = num5; k < num5 + 6; k++)
		{
			for (int l = num4; l < num4 + 4; l++)
			{
				if (Main.tile[k, l].type == type && Main.tile[k, l].active())
				{
					KillTile(k, l);
				}
			}
		}
		if (type == 242)
		{
			switch (num)
			{
			case 30:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2995);
				break;
			case 74:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5636);
				break;
			case 73:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5630);
				break;
			case 72:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5635);
				break;
			case 71:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5531);
				break;
			case 70:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5491);
				break;
			case 69:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5489);
				break;
			case 68:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5487);
				break;
			case 67:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5486);
				break;
			case 66:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5483);
				break;
			case 65:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5389);
				break;
			case 64:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5310);
				break;
			case 63:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5308);
				break;
			case 62:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5274);
				break;
			case 50:
			case 51:
			case 52:
			case 53:
			case 54:
			case 55:
			case 56:
			case 57:
			case 58:
			case 59:
			case 60:
			case 61:
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5234 + num - 50);
				break;
			default:
				if (num >= 46 && num <= 49)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5121 + num - 46);
					break;
				}
				switch (num)
				{
				case 45:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5085);
					break;
				case 44:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4725);
					break;
				case 43:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4658);
					break;
				case 37:
				case 38:
				case 39:
				case 40:
				case 41:
				case 42:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4632 + num - 37);
					break;
				default:
					if (num >= 31 && num <= 35)
					{
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3055 + num - 31);
					}
					else if (num >= 27 && num <= 29)
					{
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2865 + num - 27);
					}
					else if (num == 36)
					{
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3596);
					}
					else if (num == 26)
					{
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2497);
					}
					else if (num == 25)
					{
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2495);
					}
					else if (num >= 22)
					{
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2281 + num - 22);
					}
					else if (num >= 17)
					{
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1846 + num - 17);
					}
					else if (num == 16)
					{
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1573);
					}
					else if (num >= 13)
					{
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1500 + num - 13);
					}
					else if (num >= 6)
					{
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1433 + num - 6);
					}
					else
					{
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1421 + num);
					}
					break;
				}
				break;
			}
		}
		destroyObject = false;
	}

	private static int RollRandomSeaShellStyle()
	{
		int result = genRand.Next(2);
		if (genRand.Next(10) == 0)
		{
			result = 2;
		}
		if (genRand.Next(10) == 0)
		{
			result = 3;
		}
		if (genRand.Next(50) == 0)
		{
			result = 4;
		}
		return result;
	}

	public static void Place1x1(int x, int y, int type, int style = 0)
	{
		if (!InWorld(x, y, 2))
		{
			return;
		}
		if (Main.tile[x, y] == null)
		{
			Main.tile[x, y] = new Tile();
		}
		if (Main.tile[x, y + 1] == null)
		{
			Main.tile[x, y + 1] = new Tile();
		}
		Tile tile = Main.tile[x, y];
		Tile tile2 = Main.tile[x, y + 1];
		if (type == 324)
		{
			if (SolidTile2(x, y + 1) || (tile2.nactive() && Main.tileTable[tile2.type]))
			{
				tile.active(active: true);
				tile.type = (ushort)type;
				tile.frameX = (short)(22 * genRand.Next(3));
				tile.frameY = (short)(22 * style);
			}
		}
		else if ((type < 0 || !TileID.Sets.Wiring.IsAMechanism[type] || tile2.type < 0 || !TileID.Sets.Boulders[tile2.type]) && SolidTile2(x, y + 1) && !tile.active())
		{
			tile.active(active: true);
			tile.type = (ushort)type;
			switch (type)
			{
			case 324:
				tile.frameX = (short)(22 * RollRandomSeaShellStyle());
				tile.frameY = (short)(22 * style);
				break;
			case 36:
			case 144:
			case 239:
				tile.frameX = (short)(style * 18);
				tile.frameY = 0;
				break;
			default:
				tile.frameY = (short)(style * 18);
				break;
			}
		}
	}

	public static void Check1x1(int x, int y, int type)
	{
		if (Main.tile[x, y + 1] == null)
		{
			return;
		}
		if (!SolidTileAllowBottomSlope(x, y + 1))
		{
			KillTile(x, y);
			return;
		}
		if (type == 624 && !HasValidGroundForAbigailsFlowerBelowSpot(x, y))
		{
			KillTile(x, y);
			return;
		}
		Tile tile = Main.tile[x, y + 1];
		if (tile.type >= 0 && TileID.Sets.Boulders[tile.type])
		{
			KillTile(x, y);
		}
	}

	public static void CheckGolf1x1(int x, int y, int type)
	{
		Tile tile = Main.tile[x, y];
		bool flag = false;
		if (tile.frameX % 18 != 0)
		{
			flag = true;
		}
		if (tile.frameY % 18 != 0)
		{
			flag = true;
		}
		if (!SolidTileAllowBottomSlope(x, y + 1))
		{
			flag = true;
		}
		if (flag)
		{
			KillTile(x, y);
		}
	}

	public static void CheckLogicTiles(int x, int y, int type)
	{
		if (type == 419)
		{
			Tile tile = Main.tile[x, y + 1];
			if (tile != null && (!tile.active() || (tile.type != 420 && tile.type != 419)))
			{
				KillTile(x, y);
				return;
			}
		}
		Tile tile2 = Main.tile[x, y];
		bool flag = false;
		if (tile2.frameX % 18 != 0)
		{
			flag = true;
		}
		if (tile2.frameY % 18 != 0)
		{
			flag = true;
		}
		if (flag)
		{
			KillTile(x, y);
		}
	}

	public static void PlaceLogicTiles(int x, int y, int type, int style = 0)
	{
		Tile tile = Main.tile[x, y];
		if (Main.tile[x, y] == null)
		{
			tile = new Tile();
			Main.tile[x, y] = tile;
		}
		if (Main.tile[x, y + 1] == null)
		{
			Main.tile[x, y + 1] = new Tile();
		}
		if (type == 419)
		{
			if (Main.tile[x, y + 1].active() && (Main.tile[x, y + 1].type == 419 || Main.tile[x, y + 1].type == 420))
			{
				tile.active(active: true);
				tile.type = (ushort)type;
				tile.frameX = (short)(style * 18);
				tile.frameY = 0;
			}
		}
		else if (!tile.active())
		{
			tile.active(active: true);
			tile.type = (ushort)type;
			tile.frameX = 0;
			tile.frameY = (short)(18 * style);
		}
	}

	public static void PlaceOnTable1x1(int x, int y, int type, int style = 0)
	{
		bool flag = false;
		if (Main.tile[x, y] == null)
		{
			Main.tile[x, y] = new Tile();
		}
		if (Main.tile[x, y + 1] == null)
		{
			Main.tile[x, y + 1] = new Tile();
		}
		if (!Main.tile[x, y].active() && Main.tile[x, y + 1].nactive() && Main.tileTable[Main.tile[x, y + 1].type])
		{
			flag = true;
		}
		if (type == 78 && !Main.tile[x, y].active() && Main.tile[x, y + 1].nactive() && Main.tileSolid[Main.tile[x, y + 1].type] && !Main.tile[x, y + 1].halfBrick() && Main.tile[x, y + 1].slope() == 0)
		{
			flag = true;
		}
		if (flag)
		{
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].type = (ushort)type;
			if (type == 33)
			{
				Main.tile[x, y].frameX = 0;
				Main.tile[x, y].frameY = (short)(style * 22);
			}
			else
			{
				Main.tile[x, y].frameX = (short)(style * 18);
				Main.tile[x, y].frameY = 0;
			}
			if (type == 50)
			{
				Main.tile[x, y].frameX = (short)(18 * genRand.Next(5));
			}
		}
	}

	public static bool PlaceAlch(int x, int y, int style)
	{
		if (Main.tile[x, y] == null)
		{
			Main.tile[x, y] = new Tile();
		}
		if (Main.tile[x, y + 1] == null)
		{
			Main.tile[x, y + 1] = new Tile();
		}
		Tile tile = Main.tile[x, y];
		Tile tile2 = Main.tile[x, y + 1];
		if (!tile.active() && tile2.nactive() && !tile2.halfBrick() && tile2.slope() == 0)
		{
			bool flag = false;
			switch (style)
			{
			case 0:
				if (tile2.type != 2 && tile2.type != 477 && tile2.type != 492 && tile2.type != 78 && tile2.type != 380 && tile2.type != 109)
				{
					flag = true;
				}
				if (tile.liquid > 0)
				{
					flag = true;
				}
				break;
			case 1:
				if (tile2.type != 60 && tile2.type != 78 && tile2.type != 380)
				{
					flag = true;
				}
				if (tile.liquid > 0)
				{
					flag = true;
				}
				break;
			case 2:
				if (tile2.type != 0 && tile2.type != 59 && tile2.type != 78 && tile2.type != 380)
				{
					flag = true;
				}
				if (tile.liquid > 0)
				{
					flag = true;
				}
				break;
			case 3:
				if (tile2.type != 661 && tile2.type != 662 && tile2.type != 203 && tile2.type != 199 && tile2.type != 23 && tile2.type != 25 && tile2.type != 78 && tile2.type != 380)
				{
					flag = true;
				}
				if (tile.liquid > 0)
				{
					flag = true;
				}
				break;
			case 4:
				if (tile2.type != 53 && tile2.type != 78 && tile2.type != 380 && tile2.type != 116)
				{
					flag = true;
				}
				if (tile.liquid > 0 && tile.lava())
				{
					flag = true;
				}
				break;
			case 5:
				if (tile2.type != 57 && tile2.type != 633 && tile2.type != 78 && tile2.type != 380)
				{
					flag = true;
				}
				if (tile.liquid > 0 && !tile.lava())
				{
					flag = true;
				}
				break;
			case 6:
				if (tile2.type != 78 && tile2.type != 380 && tile2.type != 147 && tile2.type != 161 && tile2.type != 163 && tile2.type != 164 && tile2.type != 200)
				{
					flag = true;
				}
				if (tile.liquid > 0 && tile.lava())
				{
					flag = true;
				}
				break;
			}
			if (!flag)
			{
				tile.active(active: true);
				tile.type = 82;
				tile.frameX = (short)(18 * style);
				tile.frameY = 0;
				tile.CopyPaintAndCoating(tile2);
				return true;
			}
		}
		return false;
	}

	public static void GrowSpike(int i, int j, ushort spikeType, ushort landType)
	{
		int num = -1;
		switch (landType)
		{
		case 23:
			num = 661;
			break;
		case 199:
			num = 662;
			break;
		}
		int num2 = i;
		int num3 = j;
		int num4 = 0;
		if (Main.tile[num2 + 1, num3].active() && Main.tile[num2 + 1, num3].type == spikeType)
		{
			num4++;
		}
		if (Main.tile[num2 - 1, num3].active() && Main.tile[num2 - 1, num3].type == spikeType)
		{
			num4++;
		}
		if (Main.tile[num2, num3 + 1].active() && Main.tile[num2, num3 + 1].type == spikeType)
		{
			num4++;
		}
		if (Main.tile[num2, num3 - 1].active() && Main.tile[num2, num3 - 1].type == spikeType)
		{
			num4++;
		}
		if (num4 >= 3 && Main.tile[i, j].type != landType && Main.tile[i, j].type != num)
		{
			return;
		}
		switch (genRand.Next(4))
		{
		case 0:
			num3--;
			break;
		case 1:
			num3++;
			break;
		case 2:
			num2--;
			break;
		case 3:
			num2++;
			break;
		}
		if (Main.tile[num2, num3].active())
		{
			return;
		}
		num4 = 0;
		if (Main.tile[num2 + 1, num3].active() && Main.tile[num2 + 1, num3].type == spikeType)
		{
			num4++;
		}
		if (Main.tile[num2 - 1, num3].active() && Main.tile[num2 - 1, num3].type == spikeType)
		{
			num4++;
		}
		if (Main.tile[num2, num3 + 1].active() && Main.tile[num2, num3 + 1].type == spikeType)
		{
			num4++;
		}
		if (Main.tile[num2, num3 - 1].active() && Main.tile[num2, num3 - 1].type == spikeType)
		{
			num4++;
		}
		if (num4 >= 2)
		{
			return;
		}
		int num5 = 7;
		int num6 = num2 - num5;
		int num7 = num2 + num5;
		int num8 = num3 - num5;
		int num9 = num3 + num5;
		bool flag = false;
		for (int k = num6; k < num7; k++)
		{
			for (int l = num8; l < num9; l++)
			{
				if (Math.Abs(k - num2) * 2 + Math.Abs(l - num3) < 9 && Main.tile[k, l].active() && (Main.tile[k, l].type == landType || Main.tile[k, l].type == num) && Main.tile[k, l - 1].active() && Main.tile[k, l - 1].type == spikeType && Main.tile[k, l - 1].liquid == 0)
				{
					flag = true;
					break;
				}
			}
		}
		if (flag)
		{
			Main.tile[num2, num3].type = spikeType;
			Main.tile[num2, num3].active(active: true);
			Main.tile[num2, num3].CopyPaintAndCoating(Main.tile[i, j]);
			SquareTileFrame(num2, num3);
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, num2, num3, 1);
			}
		}
	}

	private static bool GrowMoreVines(int x, int y)
	{
		if (!InWorld(x, y, 30))
		{
			return false;
		}
		int num = 4;
		int num2 = 6;
		int num3 = 10;
		int num4 = 60;
		int num5 = 0;
		if (Main.tile[x, y].type == 528)
		{
			num4 /= 5;
		}
		for (int i = x - num; i <= x + num; i++)
		{
			for (int j = y - num2; j <= y + num3; j++)
			{
				if (TileID.Sets.IsVine[Main.tile[i, j].type])
				{
					num5++;
					if (j > y && Collision.CanHitLine(new Vector2(x * 16, y * 16), 1, 1, new Vector2(i * 16, j * 16), 1, 1))
					{
						num5 = ((Main.tile[i, j].type != 528) ? (num5 + (j - y) * 2) : (num5 + (j - y) * 20));
					}
					if (num5 > num4)
					{
						return false;
					}
				}
			}
		}
		return true;
	}

	private static void GrowGlowTulips()
	{
		int num = ((Main.maxTilesX > 4200) ? ((Main.maxTilesX <= 6400) ? 1 : 2) : 0);
		int num2 = 100;
		int num3 = 300;
		int num4 = 2;
		num4 = num switch
		{
			1 => 4, 
			2 => 6, 
			_ => 2, 
		};
		int num5 = 0;
		int num6 = 10000;
		int num7 = (int)((double)num6 * 0.75);
		while (num5 < num4)
		{
			num6--;
			if (num6 <= 0)
			{
				break;
			}
			int i = ((num5 >= num4 / 2 && (num6 <= num7 || genRand.Next(2) != 0)) ? genRand.Next(Main.maxTilesX - num3, Main.maxTilesX - num2) : genRand.Next(num2, num3));
			int j = ((!remixWorldGen) ? genRand.Next((int)Main.worldSurface, Main.maxTilesY - 200) : genRand.Next((int)Main.worldSurface, Main.maxTilesY - 350));
			if (TryGrowingGlowTulip(i, j))
			{
				num5++;
			}
		}
	}

	private static void PlaceChilletEggs()
	{
		int worldSize = GetWorldSize();
		int num = 100;
		int num2 = 8;
		num2 = worldSize switch
		{
			1 => 9, 
			2 => 12, 
			_ => 6, 
		};
		int num3 = 0;
		int num4 = 10000;
		while (num3 < num2)
		{
			num4--;
			if (num4 > 0)
			{
				int i = genRand.Next(num, Main.maxTilesX - num);
				int j = ((!remixWorldGen) ? genRand.Next((int)Main.rockLayer, Main.maxTilesY - 200) : genRand.Next((int)Main.rockLayer, Main.maxTilesY - 350));
				if (TryPlacingChilletEgg(i, j))
				{
					num3++;
				}
				continue;
			}
			break;
		}
	}

	private static bool NoNearbyChilletEggs(int i, int j)
	{
		int num = Utils.Clamp(i - 20, 10, Main.maxTilesX - 1 - 10);
		int num2 = Utils.Clamp(i + 20, 10, Main.maxTilesX - 1 - 10);
		int num3 = Utils.Clamp(j - 20, 10, Main.maxTilesY - 1 - 10);
		int num4 = Utils.Clamp(j + 20, 10, Main.maxTilesY - 1 - 10);
		for (int k = num; k <= num2; k++)
		{
			for (int l = num3; l <= num4; l++)
			{
				Tile tile = Main.tile[k, l];
				if (tile.active() && tile.type == 752)
				{
					return false;
				}
			}
		}
		return true;
	}

	private static bool TryPlacingChilletEgg(int i, int j)
	{
		int num = 5;
		for (int k = 0; k < num; k++)
		{
			int num2 = genRand.Next(Math.Max(10, i - 10), Math.Min(Main.maxTilesX - 10, i + 10));
			int num3 = genRand.Next(Math.Max(10, j - 10), Math.Min(Main.maxTilesY - 10, j + 10));
			if (!HasValidGroundForChilletEggBelowSpot(num2, num3) || !NoNearbyChilletEggs(num2, num3))
			{
				continue;
			}
			PlaceTile(num2, num3, 752, mute: true);
			Tile tile = Main.tile[num2, num3];
			if (tile.active() && tile.type == 752)
			{
				if (!generatingWorld && Main.netMode == 2 && Main.tile[num2, num3] != null && Main.tile[num2, num3].active())
				{
					NetMessage.SendTileSquare(-1, num2, num3);
				}
				return true;
			}
		}
		return false;
	}

	private static bool HasValidGroundForChilletEggBelowSpot(int x, int y)
	{
		if (!InWorld(x, y, 2))
		{
			return false;
		}
		Tile tile = Main.tile[x, y + 1];
		if (tile == null || !tile.active())
		{
			return false;
		}
		ushort type = tile.type;
		if (type < 0 || type >= TileID.Count)
		{
			return false;
		}
		if (type != 0 && type != 70 && type != 633 && type != 59 && type != 225 && !TileID.Sets.Conversion.Grass[type] && !TileID.Sets.Conversion.Stone[type] && !Main.tileMoss[type])
		{
			return false;
		}
		return SolidTileAllowBottomSlope(x, y + 1);
	}

	private static void MatureTheHerbPlants()
	{
		for (int i = 10; i < Main.maxTilesX - 10; i++)
		{
			for (int j = 10; j < Main.maxTilesY - 10; j++)
			{
				if ((double)j > Main.rockLayer && (Main.tile[i, j + 1].type == 59 || Main.tile[i, j + 1].type == 0) && SolidTile(i, j + 1) && !Main.tile[i, j].active() && Main.tile[i, j].liquid == 0 && genRand.Next(25) == 0)
				{
					Main.tile[i, j].active(active: true);
					Main.tile[i, j].type = 82;
					Main.tile[i, j].frameX = 36;
					Main.tile[i, j].frameY = 0;
				}
				if (Main.tile[i, j].type == 82 && genRand.Next(3) == 0)
				{
					Main.tile[i, j].type = 83;
					if (Main.tile[i, j].frameX == 36 && genRand.Next(2) == 0)
					{
						Main.tile[i, j].type = 84;
					}
					if (Main.tile[i, j].frameX == 108 && genRand.Next(3) == 0)
					{
						Main.tile[i, j].type = 84;
					}
				}
			}
		}
	}

	public static void GrowAlch(int x, int y)
	{
		if (!Main.tile[x, y].active())
		{
			return;
		}
		if (Main.tile[x, y].liquid > 0)
		{
			int num = Main.tile[x, y].frameX / 18;
			if ((!Main.tile[x, y].lava() || num != 5) && (Main.tile[x, y].liquidType() != 0 || (num != 1 && num != 4)))
			{
				KillTile(x, y);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
				SquareTileFrame(x, y);
			}
		}
		if (Main.tile[x, y].type == 82)
		{
			if (genRand.Next(50) == 0)
			{
				bool flag = false;
				if (Main.tile[x, y].frameX == 108)
				{
					if (genRand.Next(2) == 0)
					{
						flag = true;
					}
				}
				else
				{
					flag = true;
				}
				if (flag)
				{
					Main.tile[x, y].type = 83;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y);
					}
					SquareTileFrame(x, y);
				}
			}
			else if (Main.dayTime && Main.tile[x, y].type == 82 && Main.tile[x, y].frameX == 0 && genRand.Next(50) == 0)
			{
				Main.tile[x, y].type = 83;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
				SquareTileFrame(x, y);
			}
			else if (!Main.dayTime && Main.tile[x, y].type == 82 && Main.tile[x, y].frameX == 18 && genRand.Next(50) == 0)
			{
				Main.tile[x, y].type = 83;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
				SquareTileFrame(x, y);
			}
			else if (Main.raining && Main.tile[x, y].type == 82 && Main.tile[x, y].frameX == 72 && genRand.Next(50) == 0)
			{
				Main.tile[x, y].type = 83;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
				SquareTileFrame(x, y);
			}
			else if ((double)y > Main.worldSurface && Main.tile[x, y].type == 82 && Main.tile[x, y].frameX == 36 && genRand.Next(50) == 0)
			{
				Main.tile[x, y].type = 83;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
				SquareTileFrame(x, y);
			}
			else if (y > Main.maxTilesY - 200 && Main.tile[x, y].type == 82 && Main.tile[x, y].frameX == 90 && genRand.Next(50) == 0)
			{
				Main.tile[x, y].type = 83;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
				SquareTileFrame(x, y);
			}
		}
		else if (Main.tile[x, y].frameX == 36 && genRand.Next(3) != 0)
		{
			if (Main.tile[x, y].type == 83)
			{
				if (genRand.Next(2) == 0)
				{
					Main.tile[x, y].type = 84;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y);
					}
				}
			}
			else if (Main.tile[x, y].type == 84 || genRand.Next(5) == 0)
			{
				Main.tile[x, y].type = 83;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
			}
		}
		else if (Main.tile[x, y].frameX == 108 && Main.tile[x, y].type == 83 && genRand.Next(30) == 0)
		{
			Main.tile[x, y].type = 84;
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, x, y);
			}
			SquareTileFrame(x, y);
		}
	}

	public static void PlantAlch()
	{
		int num = genRand.Next(20, Main.maxTilesX - 20);
		int num2 = 0;
		for (num2 = (Main.remixWorld ? genRand.Next(20, Main.maxTilesY - 20) : ((genRand.Next(40) == 0) ? genRand.Next((int)(Main.rockLayer + (double)Main.maxTilesY) / 2, Main.maxTilesY - 20) : ((genRand.Next(10) != 0) ? genRand.Next((int)Main.worldSurface, Main.maxTilesY - 20) : genRand.Next(20, Main.maxTilesY - 20)))); num2 < Main.maxTilesY - 20 && !Main.tile[num, num2].active(); num2++)
		{
		}
		if (!Main.tile[num, num2].nactive() || Main.tile[num, num2 - 1].active() || Main.tile[num, num2 - 1].liquid != 0)
		{
			return;
		}
		int num3 = 15;
		int num4 = 5;
		int num5 = 0;
		num3 = (int)((double)num3 * ((double)Main.maxTilesX / 4200.0));
		int num6 = Utils.Clamp(num - num3, 4, Main.maxTilesX - 4);
		int num7 = Utils.Clamp(num + num3, 4, Main.maxTilesX - 4);
		int num8 = Utils.Clamp(num2 - num3, 4, Main.maxTilesY - 4);
		int num9 = Utils.Clamp(num2 + num3, 4, Main.maxTilesY - 4);
		for (int i = num6; i <= num7; i++)
		{
			for (int j = num8; j <= num9; j++)
			{
				if (Main.tileAlch[Main.tile[i, j].type])
				{
					num5++;
				}
			}
		}
		if (num5 < num4)
		{
			PlaceSuitableHerbHere(num, num2);
			if (Main.tile[num, num2 - 1].active() && Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, num, num2 - 1);
			}
		}
	}

	public static void PlaceSuitableHerbHere(int x, int y)
	{
		if (Main.tile[x, y].type == 2 || Main.tile[x, y].type == 109)
		{
			PlaceAlch(x, y - 1, 0);
		}
		if (Main.tile[x, y].type == 60)
		{
			PlaceAlch(x, y - 1, 1);
		}
		if (Main.tile[x, y].type == 0 || Main.tile[x, y].type == 59)
		{
			PlaceAlch(x, y - 1, 2);
		}
		if (Main.tile[x, y].type == 23 || Main.tile[x, y].type == 661 || Main.tile[x, y].type == 25 || Main.tile[x, y].type == 203 || Main.tile[x, y].type == 199 || Main.tile[x, y].type == 662)
		{
			PlaceAlch(x, y - 1, 3);
		}
		if ((Main.tile[x, y].type == 53 || Main.tile[x, y].type == 116) && x >= beachDistance && x <= Main.maxTilesX - beachDistance)
		{
			PlaceAlch(x, y - 1, 4);
		}
		if (Main.tile[x, y].type == 57 || Main.tile[x, y].type == 633)
		{
			PlaceAlch(x, y - 1, 5);
		}
		if (Main.tile[x, y].type == 147 || Main.tile[x, y].type == 163 || Main.tile[x, y].type == 164 || Main.tile[x, y].type == 161 || Main.tile[x, y].type == 200)
		{
			PlaceAlch(x, y - 1, 6);
		}
	}

	public static void CheckAlch(int x, int y)
	{
		if (Main.tile[x, y] == null)
		{
			Main.tile[x, y] = new Tile();
		}
		if (Main.tile[x, y + 1] == null)
		{
			Main.tile[x, y + 1] = new Tile();
		}
		bool flag = false;
		if (!Main.tile[x, y + 1].nactive())
		{
			flag = true;
		}
		if (Main.tile[x, y + 1].halfBrick())
		{
			flag = true;
		}
		int num = Main.tile[x, y].frameX / 18;
		Main.tile[x, y].frameY = 0;
		if (!flag)
		{
			switch (num)
			{
			case 0:
				if (Main.tile[x, y + 1].type != 109 && Main.tile[x, y + 1].type != 2 && Main.tile[x, y + 1].type != 477 && Main.tile[x, y + 1].type != 492 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
				{
					flag = true;
				}
				if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
				{
					flag = true;
				}
				break;
			case 1:
				if (Main.tile[x, y + 1].type != 60 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
				{
					flag = true;
				}
				if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
				{
					flag = true;
				}
				break;
			case 2:
				if (Main.tile[x, y + 1].type != 0 && Main.tile[x, y + 1].type != 59 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
				{
					flag = true;
				}
				if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
				{
					flag = true;
				}
				break;
			case 3:
				if (Main.tile[x, y + 1].type != 661 && Main.tile[x, y + 1].type != 662 && Main.tile[x, y + 1].type != 199 && Main.tile[x, y + 1].type != 203 && Main.tile[x, y + 1].type != 23 && Main.tile[x, y + 1].type != 25 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
				{
					flag = true;
				}
				if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
				{
					flag = true;
				}
				break;
			case 4:
				if (Main.tile[x, y + 1].type != 53 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 116)
				{
					flag = true;
				}
				if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
				{
					flag = true;
				}
				break;
			case 5:
				if (Main.tile[x, y + 1].type != 57 && Main.tile[x, y + 1].type != 633 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
				{
					flag = true;
				}
				if (Main.tile[x, y].type == 82 || !Main.tile[x, y].anyLava() || Main.netMode == 1)
				{
					break;
				}
				if (Main.tile[x, y].liquid > 16)
				{
					if (Main.tile[x, y].type == 83)
					{
						Main.tile[x, y].type = 84;
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, x, y);
						}
					}
				}
				else if (Main.tile[x, y].type == 84)
				{
					Main.tile[x, y].type = 83;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y);
					}
				}
				break;
			case 6:
				if (Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 147 && Main.tile[x, y + 1].type != 161 && Main.tile[x, y + 1].type != 163 && Main.tile[x, y + 1].type != 164 && Main.tile[x, y + 1].type != 200)
				{
					flag = true;
				}
				if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
				{
					flag = true;
				}
				break;
			}
		}
		if (flag)
		{
			KillTile(x, y);
		}
	}

	public static void CheckBanner(int x, int j, byte type)
	{
		if (destroyObject)
		{
			return;
		}
		int num = Main.tile[x, j].frameY / 18;
		int num2 = 0;
		while (num >= 3)
		{
			num -= 3;
			num2++;
		}
		num = j - num;
		int frameX = Main.tile[x, j].frameX;
		bool flag = false;
		for (int i = 0; i < 3; i++)
		{
			if (Main.tile[x, num + i] == null)
			{
				Main.tile[x, num + i] = new Tile();
			}
			if (!Main.tile[x, num + i].active())
			{
				flag = true;
			}
			else if (Main.tile[x, num + i].type != type)
			{
				flag = true;
			}
			else if (Main.tile[x, num + i].frameY != i * 18 + num2 * 18 * 3)
			{
				flag = true;
			}
			else if (Main.tile[x, num + i].frameX != frameX)
			{
				flag = true;
			}
		}
		if (Main.tile[x, num - 1] == null)
		{
			Main.tile[x, num - 1] = new Tile();
		}
		Tile tile = Main.tile[x, num - 1];
		if (!tile.nactive())
		{
			flag = true;
		}
		bool num3 = tile.topSlope() || tile.halfBrick() || Main.tileSolid[tile.type];
		bool flag2 = !Main.tileSolidTop[tile.type] || (TileID.Sets.Platforms[tile.type] && (tile.halfBrick() || tile.topSlope()));
		bool flag3 = num3 && flag2 && !TileID.Sets.NotReallySolid[tile.type] && !tile.bottomSlope();
		if (TileID.Sets.Platforms[tile.type] || tile.type == 380)
		{
			flag3 = true;
		}
		if (!flag3)
		{
			flag = true;
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		for (int k = 0; k < 3; k++)
		{
			if (Main.tile[x, num + k].type == type)
			{
				KillTile(x, num + k);
			}
		}
		if (type == 91)
		{
			int num4 = frameX / 18;
			num4 += num2 * 111;
			if (num4 == 315)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 5673);
			}
			else if (num4 == 314)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 5672);
			}
			else if (num4 == 313)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 5651);
			}
			else if (num4 == 312)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 5498);
			}
			else if (num4 == 311)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 5497);
			}
			else if (num4 == 310)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 5352);
			}
			else if (num4 >= 297)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 4668 + num4);
			}
			else if (num4 >= 295)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 4392 + num4);
			}
			else if (num4 >= 294)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 4602);
			}
			else if (num4 >= 288)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 4253 + num4);
			}
			else if (num4 >= 278)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 3559 + num4);
			}
			else if (num4 >= 273)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 3516 + num4);
			}
			else if (num4 >= 272)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 3780);
			}
			else if (num4 >= 270)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 3323 + num4);
			}
			else if (num4 >= 207)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 3183 + num4);
			}
			else if (num4 >= 109)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 2788 + num4);
			}
			else if (num4 >= 22)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 1593 + num4);
			}
			else if (num4 >= 10 && num4 <= 15)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 1441 + num4);
			}
			else if (num4 >= 16 && num4 <= 21)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 1448 + num4);
			}
			else if (num4 >= 7 && num4 <= 9)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 838 + num4);
			}
			else if (num4 >= 4 && num4 <= 6)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 785 + num4);
			}
			else
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 337 + num4);
			}
		}
		destroyObject = false;
	}

	public static void PlaceBanner(int x, int y, ushort type, int style = 0)
	{
		int num = style * 18;
		int num2 = 0;
		int num3 = style;
		while (num3 >= 111)
		{
			num3 -= 111;
			num -= 1998;
			num2 += 54;
		}
		if (Main.tile[x, y - 1] == null)
		{
			Main.tile[x, y - 1] = new Tile();
		}
		if (Main.tile[x, y] == null)
		{
			Main.tile[x, y] = new Tile();
		}
		if (Main.tile[x, y + 1] == null)
		{
			Main.tile[x, y + 1] = new Tile();
		}
		if (Main.tile[x, y + 2] == null)
		{
			Main.tile[x, y + 2] = new Tile();
		}
		if (Main.tile[x, y - 1].nactive() && Main.tileSolid[Main.tile[x, y - 1].type] && !Main.tileSolidTop[Main.tile[x, y - 1].type] && !Main.tile[x, y].active() && !Main.tile[x, y + 1].active() && !Main.tile[x, y + 2].active())
		{
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].frameY = (short)num2;
			Main.tile[x, y].frameX = (short)num;
			Main.tile[x, y].type = type;
			Main.tile[x, y + 1].active(active: true);
			Main.tile[x, y + 1].frameY = (short)(num2 + 18);
			Main.tile[x, y + 1].frameX = (short)num;
			Main.tile[x, y + 1].type = type;
			Main.tile[x, y + 2].active(active: true);
			Main.tile[x, y + 2].frameY = (short)(num2 + 36);
			Main.tile[x, y + 2].frameX = (short)num;
			Main.tile[x, y + 2].type = type;
		}
	}

	public static void PlaceMan(int i, int j, int dir)
	{
		for (int k = i; k <= i + 1; k++)
		{
			for (int l = j - 2; l <= j; l++)
			{
				if (Main.tile[k, l].active())
				{
					return;
				}
			}
		}
		if (SolidTile2(i, j + 1) && SolidTile2(i + 1, j + 1))
		{
			byte b = 0;
			if (dir == 1)
			{
				b = 36;
			}
			Main.tile[i, j - 2].active(active: true);
			Main.tile[i, j - 2].frameY = 0;
			Main.tile[i, j - 2].frameX = b;
			Main.tile[i, j - 2].type = 128;
			Main.tile[i, j - 1].active(active: true);
			Main.tile[i, j - 1].frameY = 18;
			Main.tile[i, j - 1].frameX = b;
			Main.tile[i, j - 1].type = 128;
			Main.tile[i, j].active(active: true);
			Main.tile[i, j].frameY = 36;
			Main.tile[i, j].frameX = b;
			Main.tile[i, j].type = 128;
			Main.tile[i + 1, j - 2].active(active: true);
			Main.tile[i + 1, j - 2].frameY = 0;
			Main.tile[i + 1, j - 2].frameX = (byte)(18 + b);
			Main.tile[i + 1, j - 2].type = 128;
			Main.tile[i + 1, j - 1].active(active: true);
			Main.tile[i + 1, j - 1].frameY = 18;
			Main.tile[i + 1, j - 1].frameX = (byte)(18 + b);
			Main.tile[i + 1, j - 1].type = 128;
			Main.tile[i + 1, j].active(active: true);
			Main.tile[i + 1, j].frameY = 36;
			Main.tile[i + 1, j].frameX = (byte)(18 + b);
			Main.tile[i + 1, j].type = 128;
		}
	}

	public static void PlaceWoman(int i, int j, int dir)
	{
		for (int k = i; k <= i + 1; k++)
		{
			for (int l = j - 2; l <= j; l++)
			{
				if (Main.tile[k, l].active())
				{
					return;
				}
			}
		}
		if (SolidTile2(i, j + 1) && SolidTile2(i + 1, j + 1))
		{
			byte b = 0;
			if (dir == 1)
			{
				b = 36;
			}
			Main.tile[i, j - 2].active(active: true);
			Main.tile[i, j - 2].frameY = 0;
			Main.tile[i, j - 2].frameX = b;
			Main.tile[i, j - 2].type = 269;
			Main.tile[i, j - 1].active(active: true);
			Main.tile[i, j - 1].frameY = 18;
			Main.tile[i, j - 1].frameX = b;
			Main.tile[i, j - 1].type = 269;
			Main.tile[i, j].active(active: true);
			Main.tile[i, j].frameY = 36;
			Main.tile[i, j].frameX = b;
			Main.tile[i, j].type = 269;
			Main.tile[i + 1, j - 2].active(active: true);
			Main.tile[i + 1, j - 2].frameY = 0;
			Main.tile[i + 1, j - 2].frameX = (byte)(18 + b);
			Main.tile[i + 1, j - 2].type = 269;
			Main.tile[i + 1, j - 1].active(active: true);
			Main.tile[i + 1, j - 1].frameY = 18;
			Main.tile[i + 1, j - 1].frameX = (byte)(18 + b);
			Main.tile[i + 1, j - 1].type = 269;
			Main.tile[i + 1, j].active(active: true);
			Main.tile[i + 1, j].frameY = 36;
			Main.tile[i + 1, j].frameX = (byte)(18 + b);
			Main.tile[i + 1, j].type = 269;
		}
	}

	public static void CheckWeaponsRack(int i, int j)
	{
		if (destroyObject)
		{
			return;
		}
		int num = i;
		int num2 = j - Main.tile[i, j].frameY / 18;
		int num3 = Main.tile[i, j].frameX;
		int num4 = 0;
		while (num3 >= 5000)
		{
			num3 -= 5000;
			num4++;
		}
		if (num4 != 0)
		{
			num3 = (num4 - 1) * 18;
		}
		num3 %= 54;
		num -= num3 / 18;
		bool flag = false;
		for (int k = 0; k < 3; k++)
		{
			for (int l = 0; l < 3; l++)
			{
				int num5 = num + k;
				int num6 = num2 + l;
				int num7 = Main.tile[num5, num6].frameX;
				int num8 = 0;
				while (num7 >= 5000)
				{
					num7 -= 5000;
					num8++;
				}
				if (num8 != 0)
				{
					num7 = (num8 - 1) * 18;
				}
				num7 %= 54;
				if (!Main.tile[num5, num6].active() || Main.tile[num5, num6].type != 334 || Main.tile[num5, num6].wall <= 0 || Main.tile[num5, num6].frameY != l * 18 || num7 != k * 18)
				{
					flag = true;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		if (TileEntity.TryGetAt<TEWeaponsRack>(num, num2, out var result) && result.item.stack > 0)
		{
			result.DropItem();
			if (Main.netMode != 2)
			{
				Main.LocalPlayer.InterruptItemUsageIfOverTile(471);
			}
		}
		destroyObject = true;
		Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 48, 48, 2699);
		TileEntityType<TEWeaponsRack>.Kill(num, num2);
		for (int m = 0; m < 3; m++)
		{
			for (int n = 0; n < 3; n++)
			{
				int num9 = num + m;
				int num10 = num2 + n;
				if (Main.tile[num9, num10].active() && Main.tile[num9, num10].type == 334)
				{
					KillTile(num9, num10);
				}
			}
		}
		destroyObject = false;
	}

	public static void ToggleGemLock(int i, int j, bool on)
	{
		Tile tileSafely = Framing.GetTileSafely(i, j);
		if (!tileSafely.active() || tileSafely.type != 440 || (tileSafely.frameY < 54 && !on))
		{
			return;
		}
		bool flag = false;
		int num = -1;
		if (tileSafely.frameY >= 54)
		{
			flag = true;
		}
		int num2 = Main.tile[i, j].frameX / 54;
		int num3 = Main.tile[i, j].frameX % 54 / 18;
		int num4 = Main.tile[i, j].frameY % 54 / 18;
		switch (num2)
		{
		case 0:
			num = 1526;
			break;
		case 1:
			num = 1524;
			break;
		case 2:
			num = 1525;
			break;
		case 3:
			num = 1523;
			break;
		case 4:
			num = 1522;
			break;
		case 5:
			num = 1527;
			break;
		case 6:
			num = 3643;
			break;
		}
		for (int k = i - num3; k < i - num3 + 3; k++)
		{
			for (int l = j - num4; l < j - num4 + 3; l++)
			{
				Main.tile[k, l].frameY = (short)((on ? 54 : 0) + (l - j + num4) * 18);
			}
		}
		if (num != -1 && flag)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, num);
		}
		SquareTileFrame(i, j);
		NetMessage.SendTileSquare(-1, i - num3, j - num4, 3, 3);
		Wiring.HitSwitch(i - num3, j - num4);
		NetMessage.SendData(59, -1, -1, null, i - num3, j - num4);
	}

	public static void CheckMan(int i, int j)
	{
		if (destroyObject)
		{
			return;
		}
		int num = i;
		int num2 = j - Main.tile[i, j].frameY / 18;
		int num3;
		for (num3 = Main.tile[i, j].frameX; num3 >= 100; num3 -= 100)
		{
		}
		while (num3 >= 36)
		{
			num3 -= 36;
		}
		num -= num3 / 18;
		bool flag = false;
		for (int k = 0; k <= 1; k++)
		{
			for (int l = 0; l <= 2; l++)
			{
				int num4 = num + k;
				int num5 = num2 + l;
				int num6;
				for (num6 = Main.tile[num4, num5].frameX; num6 >= 100; num6 -= 100)
				{
				}
				if (num6 >= 36)
				{
					num6 -= 36;
				}
				if (!Main.tile[num4, num5].active() || Main.tile[num4, num5].type != 128 || Main.tile[num4, num5].frameY != l * 18 || num6 != k * 18)
				{
					flag = true;
				}
			}
		}
		if (!SolidTileAllowBottomSlope(num, num2 + 3) || !SolidTileAllowBottomSlope(num + 1, num2 + 3))
		{
			flag = true;
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 498);
		for (int m = 0; m <= 1; m++)
		{
			for (int n = 0; n <= 2; n++)
			{
				int num7 = num + m;
				int num8 = num2 + n;
				if (Main.tile[num7, num8].active() && Main.tile[num7, num8].type == 128)
				{
					KillTile(num7, num8);
				}
			}
		}
		destroyObject = false;
	}

	public static void CheckWoman(int i, int j)
	{
		if (destroyObject)
		{
			return;
		}
		int num = i;
		int num2 = j - Main.tile[i, j].frameY / 18;
		int num3;
		for (num3 = Main.tile[i, j].frameX; num3 >= 100; num3 -= 100)
		{
		}
		while (num3 >= 36)
		{
			num3 -= 36;
		}
		num -= num3 / 18;
		bool flag = false;
		for (int k = 0; k <= 1; k++)
		{
			for (int l = 0; l <= 2; l++)
			{
				int num4 = num + k;
				int num5 = num2 + l;
				int num6;
				for (num6 = Main.tile[num4, num5].frameX; num6 >= 100; num6 -= 100)
				{
				}
				if (num6 >= 36)
				{
					num6 -= 36;
				}
				if (!Main.tile[num4, num5].active() || Main.tile[num4, num5].type != 269 || Main.tile[num4, num5].frameY != l * 18 || num6 != k * 18)
				{
					flag = true;
				}
			}
		}
		if (!SolidTileAllowBottomSlope(num, num2 + 3) || !SolidTileAllowBottomSlope(num + 1, num2 + 3))
		{
			flag = true;
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1989);
		for (int m = 0; m <= 1; m++)
		{
			for (int n = 0; n <= 2; n++)
			{
				int num7 = num + m;
				int num8 = num2 + n;
				if (Main.tile[num7, num8].active() && Main.tile[num7, num8].type == 269)
				{
					KillTile(num7, num8);
				}
			}
		}
		destroyObject = false;
	}

	public static void Place1x2(int x, int y, ushort type, int style)
	{
		short frameX = 0;
		if (type == 20)
		{
			frameX = (short)(genRand.Next(3) * 18);
		}
		if (Main.tile[x, y - 1] == null)
		{
			Main.tile[x, y - 1] = new Tile();
		}
		if (Main.tile[x, y + 1] == null)
		{
			Main.tile[x, y + 1] = new Tile();
		}
		if (SolidTile2(x, y + 1) & !Main.tile[x, y - 1].active())
		{
			short num = (short)(style * 40);
			Main.tile[x, y - 1].active(active: true);
			Main.tile[x, y - 1].frameY = num;
			Main.tile[x, y - 1].frameX = frameX;
			Main.tile[x, y - 1].type = type;
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].frameY = (short)(num + 18);
			Main.tile[x, y].frameX = frameX;
			Main.tile[x, y].type = type;
		}
	}

	public static void Place1x2Top(int x, int y, ushort type, int style)
	{
		short frameX = 0;
		if (Main.tile[x, y - 1] == null)
		{
			Main.tile[x, y - 1] = new Tile();
		}
		if (Main.tile[x, y + 1] == null)
		{
			Main.tile[x, y + 1] = new Tile();
		}
		if (Main.tile[x, y - 1].nactive() && Main.tileSolid[Main.tile[x, y - 1].type] && !Main.tileSolidTop[Main.tile[x, y - 1].type] && !Main.tile[x, y + 1].active())
		{
			short num = (short)(style * 36);
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].frameY = num;
			Main.tile[x, y].frameX = frameX;
			Main.tile[x, y].type = type;
			Main.tile[x, y + 1].active(active: true);
			Main.tile[x, y + 1].frameY = (short)(num + 18);
			Main.tile[x, y + 1].frameX = frameX;
			Main.tile[x, y + 1].type = type;
		}
	}

	public static void Check1x2Top(int x, int j, ushort type)
	{
		if (destroyObject)
		{
			return;
		}
		int num = j;
		bool flag = true;
		int num2 = Main.tile[x, num].frameY / 18;
		int num3 = 0;
		while (num2 >= 2)
		{
			num2 -= 2;
			num3++;
		}
		num -= num2;
		num2 = num3 * 36;
		if (Main.tile[x, num] == null)
		{
			Main.tile[x, num] = new Tile();
		}
		if (Main.tile[x, num + 1] == null)
		{
			Main.tile[x, num + 1] = new Tile();
		}
		if (Main.tile[x, num] == null)
		{
			Main.tile[x, num] = new Tile();
		}
		if (Main.tile[x, num].frameY == num2 && Main.tile[x, num + 1].frameY == num2 + 18 && Main.tile[x, num].type == type && Main.tile[x, num + 1].type == type)
		{
			flag = false;
		}
		if (Main.tile[x, num - 1] == null)
		{
			Main.tile[x, num - 1] = new Tile();
		}
		bool flag2 = false;
		bool flag3 = false;
		switch (type)
		{
		case 42:
		case 270:
		case 271:
		case 572:
		case 581:
		case 660:
			flag2 = true;
			break;
		case 698:
			flag2 = true;
			flag3 = true;
			break;
		}
		bool flag4 = Main.tile[x, num - 1].active() && (TileID.Sets.Platforms[Main.tile[x, num - 1].type] || Main.tile[x, num - 1].type == 380);
		bool flag5 = Main.tile[x, num - 1].active() && Main.tileRope[Main.tile[x, num - 1].type];
		if ((!flag2 || !flag4) && (!flag3 || !flag5) && (!Main.tile[x, num - 1].nactive() || !Main.tileSolid[Main.tile[x, num - 1].type] || Main.tileSolidTop[Main.tile[x, num - 1].type]))
		{
			flag = true;
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		if (type == 698 && TileEntity.TryGetAt<TEDeadCellsDisplayJar>(x, num, out var result) && result.item.stack > 0)
		{
			result.DropItem();
			if (Main.netMode != 2)
			{
				Main.LocalPlayer.InterruptItemUsageIfOverTile(698);
			}
		}
		if (Main.tile[x, num].type == type)
		{
			KillTile(x, num);
		}
		if (Main.tile[x, num + 1].type == type)
		{
			KillTile(x, num + 1);
		}
		switch (type)
		{
		case 42:
		{
			int itemDrop_Lanterns = GetItemDrop_Lanterns(num3);
			Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, itemDrop_Lanterns);
			break;
		}
		case 698:
			Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 5472);
			TileEntityType<TEDeadCellsDisplayJar>.Kill(x, num);
			break;
		case 270:
			Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 1993);
			break;
		case 271:
			Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 2005);
			break;
		case 581:
			Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 4848);
			break;
		case 660:
			Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 5351);
			break;
		case 572:
			Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 4695 + num3);
			break;
		}
		destroyObject = false;
	}

	public static bool PlaceSmallPile(int i, int j, int pileStyle, int pileSize, ushort type = 185)
	{
		short frameY = (short)(pileSize * 18);
		short frameX = (short)(pileStyle * 18);
		if (Main.tile[i, j] == null)
		{
			Main.tile[i, j] = new Tile();
		}
		if (Main.tile[i + 1, j] == null)
		{
			Main.tile[i + 1, j] = new Tile();
		}
		if (Main.tile[i, j + 1] == null)
		{
			Main.tile[i, j + 1] = new Tile();
		}
		if (Main.tile[i + 1, j + 1] == null)
		{
			Main.tile[i + 1, j + 1] = new Tile();
		}
		if (Main.tile[i, j].anyLava())
		{
			return false;
		}
		if (pileSize == 1)
		{
			frameX = (short)(pileStyle * 36);
			bool flag = false;
			if (SolidTile2(i, j + 1) && SolidTile2(i + 1, j + 1) && !Main.tile[i, j].active() && !Main.tile[i + 1, j].active())
			{
				flag = true;
			}
			if (flag && type == 185 && (InvalidTileForPilesOrSpeleothems(i, j + 1) || InvalidTileForPilesOrSpeleothems(i + 1, j + 1)))
			{
				flag = false;
			}
			if (flag)
			{
				Main.tile[i, j].active(active: true);
				Main.tile[i, j].frameY = frameY;
				Main.tile[i, j].frameX = frameX;
				Main.tile[i, j].type = type;
				Main.tile[i + 1, j].active(active: true);
				Main.tile[i + 1, j].frameY = frameY;
				Main.tile[i + 1, j].frameX = (short)(frameX + 18);
				Main.tile[i + 1, j].type = type;
				return true;
			}
		}
		else if (SolidTile2(i, j + 1) && !Main.tile[i, j].active())
		{
			Main.tile[i, j].active(active: true);
			Main.tile[i, j].frameY = frameY;
			Main.tile[i, j].frameX = frameX;
			Main.tile[i, j].type = type;
			return true;
		}
		return false;
	}

	public static void CheckPile(int i, int y)
	{
		if (Main.tile[i, y] == null)
		{
			Main.tile[i, y] = new Tile();
		}
		if (Main.tile[i + 1, y] == null)
		{
			Main.tile[i + 1, y] = new Tile();
		}
		if (Main.tile[i, y + 1] == null)
		{
			Main.tile[i, y + 1] = new Tile();
		}
		if (Main.tile[i + 1, y + 1] == null)
		{
			Main.tile[i + 1, y + 1] = new Tile();
		}
		Tile tile = Main.tile[i, y];
		if (tile.frameY == 18 || tile.type == 649)
		{
			Check2x1(i, y, tile.type);
		}
		else if (!SolidTileAllowBottomSlope(i, y + 1))
		{
			KillTile(i, y);
		}
		else
		{
			if (tile.type != 185)
			{
				return;
			}
			int num = tile.frameX / 18;
			Tile tile2 = Main.tile[i, y + 1];
			if (tile2 == null || !tile2.active() || tile2.type < 0 || tile2.type >= TileID.Count)
			{
				return;
			}
			ushort type = tile2.type;
			switch (num)
			{
			case 36:
			case 37:
			case 38:
			case 39:
			case 40:
			case 41:
			case 42:
			case 43:
			case 44:
			case 45:
			case 46:
			case 47:
				if (!TileID.Sets.Snow[type] && !TileID.Sets.Conversion.Ice[type] && type != 162 && type != 224)
				{
					KillTile(i, y);
				}
				break;
			case 54:
			case 55:
			case 56:
			case 57:
			case 58:
			case 59:
			case 73:
			case 74:
			case 75:
			case 76:
				if (!TileID.Sets.Conversion.Sand[type] && !TileID.Sets.Conversion.HardenedSand[type] && !TileID.Sets.Conversion.Sandstone[type])
				{
					KillTile(i, y);
				}
				break;
			case 48:
			case 49:
			case 50:
			case 51:
			case 52:
			case 53:
			case 60:
			case 61:
			case 62:
			case 63:
			case 64:
			case 65:
			case 66:
			case 67:
			case 68:
			case 69:
			case 70:
			case 71:
			case 72:
				break;
			}
		}
	}

	public static void Check2x1(int i, int y, ushort type)
	{
		if (destroyObject)
		{
			return;
		}
		int num = i;
		bool flag = true;
		if (Main.tile[num, y] == null)
		{
			Main.tile[num, y] = new Tile();
		}
		int num2 = Main.tile[num, y].frameX / 18;
		int num3 = num2 >> 1;
		int num4 = Main.tile[num, y].frameY / 18;
		num2 %= 2;
		num -= num2;
		if (Main.tile[num, y] == null)
		{
			Main.tile[num, y] = new Tile();
		}
		if (Main.tile[num + 1, y] == null)
		{
			Main.tile[num + 1, y] = new Tile();
		}
		if (Main.tile[num, y + 1] == null)
		{
			Main.tile[num, y + 1] = new Tile();
		}
		if (Main.tile[num + 1, y + 1] == null)
		{
			Main.tile[num + 1, y + 1] = new Tile();
		}
		if (Main.tile[num + 1, y].frameX == Main.tile[num, y].frameX + 18 && Main.tile[num, y].type == type && Main.tile[num + 1, y].type == type && Main.tile[num, y].active() && Main.tile[num + 1, y].active())
		{
			flag = false;
		}
		if (type == 29 || type == 103 || type == 462)
		{
			if (!Main.tile[num, y + 1].active() || !Main.tileTable[Main.tile[num, y + 1].type] || Main.tile[num, y + 1].halfBrick() || Main.tile[num, y + 1].topSlope())
			{
				flag = true;
			}
			if (!Main.tile[num + 1, y + 1].active() || !Main.tileTable[Main.tile[num + 1, y + 1].type] || Main.tile[num + 1, y + 1].halfBrick() || Main.tile[num + 1, y + 1].topSlope())
			{
				flag = true;
			}
		}
		else
		{
			if (!SolidTileAllowBottomSlope(num, y + 1))
			{
				flag = true;
			}
			if (!SolidTileAllowBottomSlope(num + 1, y + 1))
			{
				flag = true;
			}
		}
		if (type == 185)
		{
			if (Main.tile[num, y].frameX >= 1368 && Main.tile[num, y].frameX <= 1458 && Main.tile[num, y + 1].type != 2 && Main.tile[num + 1, y + 1].type != 2 && Main.tile[num, y + 1].type != 477 && Main.tile[num + 1, y + 1].type != 477 && Main.tile[num, y + 1].type != 492 && Main.tile[num + 1, y + 1].type != 492)
			{
				Main.tile[num, y].frameX -= 1368;
				Main.tile[num + 1, y].frameX -= 1368;
			}
			Tile tile = Main.tile[num, y];
			int num5 = tile.frameX / 36;
			num5 += (tile.frameY / 18 - 1) * 52;
			for (int j = num; j < num + 2; j++)
			{
				if (InvalidTileForPilesOrSpeleothems(j, y + 1))
				{
					flag = true;
					break;
				}
				Tile tile2 = Main.tile[j, y + 1];
				if (tile2 == null || !tile2.active() || tile2.type < 0 || tile2.type >= TileID.Count)
				{
					continue;
				}
				ushort type2 = tile2.type;
				switch (num5)
				{
				case 25:
				case 26:
				case 27:
				case 28:
				case 29:
				case 30:
					if (!TileID.Sets.Snow[type2] && !TileID.Sets.Conversion.Ice[type2] && type2 != 162 && type2 != 224)
					{
						flag = true;
					}
					break;
				case 41:
				case 42:
				case 43:
				case 44:
				case 45:
				case 46:
				case 62:
				case 63:
				case 64:
					if (!TileID.Sets.Conversion.Sand[type2] && !TileID.Sets.Conversion.HardenedSand[type2] && !TileID.Sets.Conversion.Sandstone[type2])
					{
						flag = true;
					}
					break;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		int frameX = Main.tile[num, y].frameX;
		if (!Main.tile[num, y].active())
		{
			frameX = Main.tile[num + 1, y].frameX;
		}
		destroyObject = true;
		if (Main.tile[num, y].type == type)
		{
			KillTile(num, y);
		}
		if (Main.tile[num + 1, y].type == type)
		{
			KillTile(num + 1, y);
		}
		if (type == 16)
		{
			if (num3 == 1)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 716);
			}
			else
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 35);
			}
		}
		if (type == 18)
		{
			int itemDrop_Workbenches = GetItemDrop_Workbenches(num3);
			Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, itemDrop_Workbenches);
		}
		if (type == 185)
		{
			if (frameX >= 576 && frameX <= 610)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));
				Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));
				if (genRand.Next(3) != 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));
				}
				if (genRand.Next(3) != 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));
				}
				if (genRand.Next(2) == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));
				}
				if (genRand.Next(2) == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));
				}
				if (genRand.Next(3) == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));
				}
				if (genRand.Next(3) == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));
				}
				if (genRand.Next(4) == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));
				}
				if (genRand.Next(4) == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));
				}
				if (genRand.Next(5) == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));
				}
				if (genRand.Next(5) == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));
				}
			}
			if (frameX >= 612 && frameX <= 646)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 72, genRand.Next(10, 100));
				if (genRand.Next(2) == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 72, genRand.Next(20, 100));
				}
				if (genRand.Next(3) == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 72, genRand.Next(30, 100));
				}
			}
			if (frameX >= 648 && frameX <= 682)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 73, genRand.Next(1, 6));
				if (genRand.Next(2) == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 73, genRand.Next(2, 6));
				}
				if (genRand.Next(3) == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 73, genRand.Next(3, 6));
				}
			}
			if (frameX >= 684 && frameX <= 718)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 181, genRand.Next(1, 4));
			}
			if (frameX >= 720 && frameX <= 754)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 180, genRand.Next(1, 4));
			}
			if (frameX >= 756 && frameX <= 790)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 177, genRand.Next(1, 4));
			}
			if (frameX >= 792 && frameX <= 826)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 179, genRand.Next(1, 4));
			}
			if (frameX >= 828 && frameX <= 862)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 178, genRand.Next(1, 4));
			}
			if (frameX >= 864 && frameX <= 898)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 182, genRand.Next(1, 4));
			}
		}
		if (type == 462)
		{
			Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 3795);
		}
		if (type == 29)
		{
			Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 87);
			SoundEngine.PlaySound(13, i * 16, y * 16);
		}
		switch (type)
		{
		case 103:
		{
			int type3 = 356;
			if (num3 == 1)
			{
				type3 = 2235;
			}
			if (num3 == 2)
			{
				type3 = 2242;
			}
			if (num3 == 3)
			{
				type3 = 2243;
			}
			Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, type3);
			SoundEngine.PlaySound(13, i * 16, y * 16);
			break;
		}
		case 134:
			if (num3 == 1)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 1220);
			}
			else
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 525);
			}
			break;
		case 649:
		{
			num3 += num4 * 53;
			int num6 = 0;
			if (num3 < 6)
			{
				num6 = 3;
			}
			else if (num3 < 16)
			{
				num6 = 154;
			}
			else if (num3 < 17)
			{
				num6 = 71;
			}
			else if (num3 < 18)
			{
				num6 = 72;
			}
			else if (num3 < 19)
			{
				num6 = 73;
			}
			else if (num3 < 20)
			{
				num6 = 181;
			}
			else if (num3 < 21)
			{
				num6 = 180;
			}
			else if (num3 < 22)
			{
				num6 = 177;
			}
			else if (num3 < 23)
			{
				num6 = 179;
			}
			else if (num3 < 24)
			{
				num6 = 178;
			}
			else if (num3 < 25)
			{
				num6 = 182;
			}
			else if (num3 < 31)
			{
				num6 = 593;
			}
			else if (num3 < 34)
			{
				num6 = 9;
			}
			else if (num3 < 38)
			{
				num6 = 150;
			}
			else if (num3 < 41)
			{
				num6 = 3;
			}
			else if (num3 < 47)
			{
				num6 = 3271;
			}
			else if (num3 < 53)
			{
				num6 = 3086;
			}
			else if (num3 < 59)
			{
				num6 = 3081;
			}
			else if (num3 < 62)
			{
				num6 = 62;
			}
			else if (num3 < 64)
			{
				num6 = 169;
			}
			else if (num3 == 64)
			{
				num6 = 276;
			}
			if (num6 != 0)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, num6);
			}
			break;
		}
		}
		destroyObject = false;
		SquareTileFrame(num, y);
		SquareTileFrame(num + 1, y);
	}

	public static void Place2x1(int x, int y, ushort type, int style = 0)
	{
		if (Main.tile[x, y] == null)
		{
			Main.tile[x, y] = new Tile();
		}
		if (Main.tile[x + 1, y] == null)
		{
			Main.tile[x + 1, y] = new Tile();
		}
		if (Main.tile[x, y + 1] == null)
		{
			Main.tile[x, y + 1] = new Tile();
		}
		if (Main.tile[x + 1, y + 1] == null)
		{
			Main.tile[x + 1, y + 1] = new Tile();
		}
		bool flag = false;
		if (type != 29 && type != 103 && SolidTile2(x, y + 1) && SolidTile2(x + 1, y + 1) && !Main.tile[x, y].active() && !Main.tile[x + 1, y].active())
		{
			flag = true;
		}
		else if ((type == 29 || type == 103) && Main.tile[x, y + 1].active() && Main.tile[x + 1, y + 1].active() && Main.tileTable[Main.tile[x, y + 1].type] && Main.tileTable[Main.tile[x + 1, y + 1].type] && !Main.tile[x, y].active() && !Main.tile[x + 1, y].active())
		{
			flag = true;
		}
		if (flag)
		{
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].frameY = 0;
			Main.tile[x, y].frameX = (short)(36 * style);
			Main.tile[x, y].type = type;
			Main.tile[x + 1, y].active(active: true);
			Main.tile[x + 1, y].frameY = 0;
			Main.tile[x + 1, y].frameX = (short)(36 * style + 18);
			Main.tile[x + 1, y].type = type;
		}
	}

	public static void Check4x2(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = i;
		num = ((type != 487) ? (num + Main.tile[i, j].frameX / 18 * -1) : (num + Main.tile[i, j].frameX / 18 % 4 * -1));
		if ((type == 79 || type == 90) && Main.tile[i, j].frameX >= 72)
		{
			num += 4;
		}
		int num2 = Main.tile[i, j].frameY / 18;
		int num3 = 0;
		while (num2 > 1)
		{
			num2 -= 2;
			num3++;
		}
		num2 = j - num2;
		if (type == 487)
		{
			num3 = Main.tile[i, j].frameX / 72;
		}
		for (int k = num; k < num + 4; k++)
		{
			for (int l = num2; l < num2 + 2; l++)
			{
				int num4 = (k - num) * 18;
				int num5 = (l - num2) * 18;
				if ((type == 79 || type == 90) && Main.tile[i, j].frameX >= 72)
				{
					num4 = (k - num + 4) * 18;
				}
				if (type == 487)
				{
					num4 += num3 * 72;
				}
				else
				{
					num5 += num3 * 36;
				}
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = new Tile();
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != num4 || Main.tile[k, l].frameY != num5)
				{
					flag = true;
				}
			}
			if (Main.tile[k, num2 + 2] == null)
			{
				Main.tile[k, num2 + 2] = new Tile();
			}
			if (!SolidTileAllowBottomSlope(k, num2 + 2) && (!Main.tile[k, num2 + 2].active() || !TileID.Sets.Platforms[Main.tile[k, num2 + 2].type]))
			{
				flag = true;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		for (int m = num; m < num + 4; m++)
		{
			for (int n = num2; n < num2 + 3; n++)
			{
				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
				{
					KillTile(m, n);
				}
			}
		}
		if (type == 79)
		{
			int itemDrop_Beds = GetItemDrop_Beds(num3);
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, itemDrop_Beds);
		}
		if (type == 487)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, GetItemDrop_PicnicTables(num3));
		}
		if (type == 90)
		{
			int itemDrop_Bathtubs = GetItemDrop_Bathtubs(num3);
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, itemDrop_Bathtubs);
		}
		destroyObject = false;
		for (int num6 = num - 1; num6 < num + 4; num6++)
		{
			for (int num7 = num2 - 1; num7 < num2 + 4; num7++)
			{
				TileFrame(num6, num7);
			}
		}
	}

	private static bool OasisPlantWaterCheck(int x, int y, bool boost = false)
	{
		int num = 45;
		int num2 = 20;
		if (boost)
		{
			num += 4;
			num2 += 3;
		}
		int num3 = 20;
		int num4 = 0;
		for (int i = x - num; i <= x + num; i++)
		{
			if (x <= beachDistance || x >= Main.maxTilesX - beachDistance)
			{
				continue;
			}
			for (int j = y - num2; j <= y + num2; j++)
			{
				if (InWorld(i, j) && !SolidTile(i, j))
				{
					num4 += Main.tile[i, j].liquid;
				}
			}
		}
		if (num4 / 255 >= num3)
		{
			return true;
		}
		return false;
	}

	public static void PlaceOasisPlant(int X, int Y, ushort type = 530)
	{
		int num = genRand.Next(9);
		int num2 = 0;
		if (X < beachDistance || X > Main.maxTilesX - beachDistance || Y < 5 || Y > Main.maxTilesY - 5)
		{
			return;
		}
		bool flag = true;
		for (int i = X - 1; i < X + 2; i++)
		{
			for (int j = Y - 1; j < Y + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = new Tile();
				}
				if (Main.tile[i, j].active() && Main.tile[i, j].type != 529)
				{
					flag = false;
				}
				if (Main.tile[i, j].liquid > 0)
				{
					flag = false;
				}
			}
			if (Main.tile[i, Y + 1] == null)
			{
				Main.tile[i, Y + 1] = new Tile();
			}
			if (!SolidTile(i, Y + 1) || !TileID.Sets.Conversion.Sand[Main.tile[i, Y + 1].type])
			{
				flag = false;
			}
		}
		if (!flag || !OasisPlantWaterCheck(X, Y))
		{
			return;
		}
		for (int k = X - 1; k < X + 2; k++)
		{
			for (int l = Y - 1; l < Y + 1; l++)
			{
				if (Main.tile[k, l] != null && Main.tile[k, l].active())
				{
					KillTile(k, l, fail: false, effectOnly: false, noItem: true);
				}
			}
		}
		short num3 = (short)(54 * num);
		short num4 = (short)(36 * num2);
		Main.tile[X - 1, Y - 1].active(active: true);
		Main.tile[X - 1, Y - 1].frameY = num4;
		Main.tile[X - 1, Y - 1].frameX = num3;
		Main.tile[X - 1, Y - 1].type = type;
		Main.tile[X, Y - 1].active(active: true);
		Main.tile[X, Y - 1].frameY = num4;
		Main.tile[X, Y - 1].frameX = (short)(num3 + 18);
		Main.tile[X, Y - 1].type = type;
		Main.tile[X + 1, Y - 1].active(active: true);
		Main.tile[X + 1, Y - 1].frameY = num4;
		Main.tile[X + 1, Y - 1].frameX = (short)(num3 + 36);
		Main.tile[X + 1, Y - 1].type = type;
		Main.tile[X - 1, Y].active(active: true);
		Main.tile[X - 1, Y].frameY = (short)(num4 + 18);
		Main.tile[X - 1, Y].frameX = num3;
		Main.tile[X - 1, Y].type = type;
		Main.tile[X, Y].active(active: true);
		Main.tile[X, Y].frameY = (short)(num4 + 18);
		Main.tile[X, Y].frameX = (short)(num3 + 18);
		Main.tile[X, Y].type = type;
		Main.tile[X + 1, Y].active(active: true);
		Main.tile[X + 1, Y].frameY = (short)(num4 + 18);
		Main.tile[X + 1, Y].frameX = (short)(num3 + 36);
		Main.tile[X + 1, Y].type = type;
	}

	public static void CheckOasisPlant(int i, int j, int type = 530)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = j;
		Tile tileSafely = Framing.GetTileSafely(i, j);
		int num2 = tileSafely.frameY % 36;
		num += num2 / 18 * -1;
		int num3 = tileSafely.frameX / 18;
		int num4 = 0;
		_ = Framing.GetTileSafely(num3, num).frameY / 36;
		while (num3 > 2)
		{
			num3 -= 3;
			num4++;
		}
		num3 = i - num3;
		int num5 = num4 * 54;
		for (int k = num3; k < num3 + 3; k++)
		{
			for (int l = num; l < num + 2; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = new Tile();
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num3) * 18 + num5 || Main.tile[k, l].frameY != (l - num) * 18)
				{
					flag = true;
				}
			}
			if (Main.tile[k, num + 2] == null)
			{
				Main.tile[k, num + 2] = new Tile();
			}
			if (!SolidTile(k, num + 2) || !TileID.Sets.Conversion.Sand[Main.tile[k, num + 2].type])
			{
				flag = true;
			}
		}
		if (!flag)
		{
			return;
		}
		_ = Main.tile[i, j].frameX;
		destroyObject = true;
		for (int m = num3; m < num3 + 3; m++)
		{
			for (int n = num; n < num + 2; n++)
			{
				if (Main.tile[m, n] == null)
				{
					Main.tile[m, n] = new Tile();
				}
				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
				{
					KillTile(m, n);
				}
			}
		}
		destroyObject = false;
		for (int num6 = num3 - 1; num6 < num3 + 4; num6++)
		{
			for (int num7 = num - 1; num7 < num + 3; num7++)
			{
				TileFrame(num6, num7);
			}
		}
	}

	public static void GetCactusType(int tileX, int tileY, int frameX, int frameY, out bool evil, out bool good, out bool crimson)
	{
		evil = false;
		good = false;
		crimson = false;
		int num = tileX;
		if (frameX == 36)
		{
			num--;
		}
		if (frameX == 54)
		{
			num++;
		}
		if (frameX == 108)
		{
			num = ((frameY != 18) ? (num + 1) : (num - 1));
		}
		int num2 = tileY;
		bool flag = false;
		if (!InWorld(num, num2, 2))
		{
			return;
		}
		Tile tile = Main.tile[num, num2];
		if (tile == null)
		{
			return;
		}
		if (tile.type == 80 && tile.active())
		{
			flag = true;
		}
		while (tile != null && (!tile.active() || !Main.tileSolid[tile.type] || !flag))
		{
			if (tile.type == 80 && tile.active())
			{
				flag = true;
			}
			num2++;
			if (num2 > tileY + 20 || !InWorld(num, num2, 2))
			{
				break;
			}
			tile = Main.tile[num, num2];
		}
		if (tile != null && tile.active())
		{
			if (tile.type == 112)
			{
				evil = true;
			}
			if (tile.type == 116)
			{
				good = true;
			}
			if (tile.type == 234)
			{
				crimson = true;
			}
		}
	}

	public static void GetBiomeInfluence(int startX, int endX, int startY, int endY, out int corruptCount, out int crimsonCount, out int hallowedCount)
	{
		corruptCount = 0;
		crimsonCount = 0;
		hallowedCount = 0;
		for (int i = startX; i <= endX; i++)
		{
			for (int j = startY; j <= endY; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile != null)
				{
					if (TileID.Sets.Corrupt[tile.type])
					{
						corruptCount++;
					}
					if (TileID.Sets.Crimson[tile.type])
					{
						crimsonCount++;
					}
					if (TileID.Sets.Hallow[tile.type])
					{
						hallowedCount++;
					}
				}
			}
		}
	}

	public static void PlaceJunglePlant(int X2, int Y2, ushort type, int styleX, int styleY, bool inheritPaint)
	{
		if (styleY > 0 || type == 236 || type == 238 || type == 702)
		{
			int num = Y2;
			if (type == 95 || type == 126)
			{
				num++;
			}
			if (X2 < 5 || X2 > Main.maxTilesX - 5 || num < 5 || num > Main.maxTilesY - 5)
			{
				return;
			}
			bool flag = true;
			for (int i = X2 - 1; i < X2 + 1; i++)
			{
				for (int j = num - 1; j < num + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					Tile tile = Main.tile[i, j];
					if (tile.active() && tile.type != 61 && tile.type != 703 && tile.type != 62 && tile.type != 655 && tile.type != 69 && tile.type != 74 && (type != 236 || tile.type != 233) && (type != 702 || tile.type != 233) && (type != 238 || tile.type != 233) && (tile.type != 185 || tile.frameY != 0))
					{
						flag = false;
					}
					if (type == 98 && tile.liquid > 0)
					{
						flag = false;
					}
				}
				if (Main.tile[i, num + 1] == null)
				{
					Main.tile[i, num + 1] = new Tile();
				}
				if (!SolidTile(i, num + 1) || Main.tile[i, num + 1].type != 60)
				{
					flag = false;
				}
			}
			if (!flag)
			{
				return;
			}
			for (int k = X2 - 1; k < X2 + 1; k++)
			{
				for (int l = num - 1; l < num + 1; l++)
				{
					if (Main.tile[k, l] != null && Main.tile[k, l].active())
					{
						KillTile(k, l, fail: false, effectOnly: false, noItem: true);
					}
				}
			}
			short num2 = (short)(36 * styleX);
			short num3 = 36;
			if (type == 236 || type == 238 || type == 702)
			{
				num3 = 0;
			}
			Main.tile[X2 - 1, num - 1].active(active: true);
			Main.tile[X2 - 1, num - 1].frameX = num2;
			Main.tile[X2 - 1, num - 1].frameY = num3;
			Main.tile[X2 - 1, num - 1].type = type;
			Main.tile[X2, num - 1].active(active: true);
			Main.tile[X2, num - 1].frameX = (short)(num2 + 18);
			Main.tile[X2, num - 1].frameY = num3;
			Main.tile[X2, num - 1].type = type;
			Main.tile[X2 - 1, num].active(active: true);
			Main.tile[X2 - 1, num].frameX = num2;
			Main.tile[X2 - 1, num].frameY = (short)(num3 + 18);
			Main.tile[X2 - 1, num].type = type;
			Main.tile[X2, num].active(active: true);
			Main.tile[X2, num].frameX = (short)(num2 + 18);
			Main.tile[X2, num].frameY = (short)(num3 + 18);
			Main.tile[X2, num].type = type;
			if (inheritPaint)
			{
				Tile other = Main.tile[X2, num + 1];
				Main.tile[X2 - 1, num - 1].CopyPaintAndCoating(other);
				Main.tile[X2, num - 1].CopyPaintAndCoating(other);
				Main.tile[X2 - 1, num].CopyPaintAndCoating(other);
				Main.tile[X2, num].CopyPaintAndCoating(other);
			}
		}
		else
		{
			if (X2 < 5 || X2 > Main.maxTilesX - 5 || Y2 < 5 || Y2 > Main.maxTilesY - 5)
			{
				return;
			}
			bool flag2 = true;
			for (int m = X2 - 1; m < X2 + 2; m++)
			{
				for (int n = Y2 - 1; n < Y2 + 1; n++)
				{
					if (Main.tile[m, n] == null)
					{
						Main.tile[m, n] = new Tile();
					}
					if (Main.tile[m, n].active() && Main.tile[m, n].type != 61 && Main.tile[m, n].type != 703 && Main.tile[m, n].type != 62 && Main.tile[m, n].type != 69 && Main.tile[m, n].type != 655 && Main.tile[m, n].type != 74 && (Main.tile[m, n].type != 185 || Main.tile[m, n].frameY != 0))
					{
						flag2 = false;
					}
				}
				if (Main.tile[m, Y2 + 1] == null)
				{
					Main.tile[m, Y2 + 1] = new Tile();
				}
				if (!SolidTile(m, Y2 + 1) || Main.tile[m, Y2 + 1].type != 60)
				{
					flag2 = false;
				}
			}
			if (!flag2)
			{
				return;
			}
			for (int num4 = X2 - 1; num4 < X2 + 2; num4++)
			{
				for (int num5 = Y2 - 1; num5 < Y2 + 1; num5++)
				{
					if (Main.tile[num4, num5] != null && Main.tile[num4, num5].active())
					{
						KillTile(num4, num5, fail: false, effectOnly: false, noItem: true);
					}
				}
			}
			short num6 = (short)(54 * styleX);
			Main.tile[X2 - 1, Y2 - 1].active(active: true);
			Main.tile[X2 - 1, Y2 - 1].frameY = 0;
			Main.tile[X2 - 1, Y2 - 1].frameX = num6;
			Main.tile[X2 - 1, Y2 - 1].type = type;
			Main.tile[X2, Y2 - 1].active(active: true);
			Main.tile[X2, Y2 - 1].frameY = 0;
			Main.tile[X2, Y2 - 1].frameX = (short)(num6 + 18);
			Main.tile[X2, Y2 - 1].type = type;
			Main.tile[X2 + 1, Y2 - 1].active(active: true);
			Main.tile[X2 + 1, Y2 - 1].frameY = 0;
			Main.tile[X2 + 1, Y2 - 1].frameX = (short)(num6 + 36);
			Main.tile[X2 + 1, Y2 - 1].type = type;
			Main.tile[X2 - 1, Y2].active(active: true);
			Main.tile[X2 - 1, Y2].frameY = 18;
			Main.tile[X2 - 1, Y2].frameX = num6;
			Main.tile[X2 - 1, Y2].type = type;
			Main.tile[X2, Y2].active(active: true);
			Main.tile[X2, Y2].frameY = 18;
			Main.tile[X2, Y2].frameX = (short)(num6 + 18);
			Main.tile[X2, Y2].type = type;
			Main.tile[X2 + 1, Y2].active(active: true);
			Main.tile[X2 + 1, Y2].frameY = 18;
			Main.tile[X2 + 1, Y2].frameX = (short)(num6 + 36);
			Main.tile[X2 + 1, Y2].type = type;
			if (inheritPaint)
			{
				Tile other2 = Main.tile[X2, Y2 + 1];
				Main.tile[X2 - 1, Y2 - 1].CopyPaintAndCoating(other2);
				Main.tile[X2, Y2 - 1].CopyPaintAndCoating(other2);
				Main.tile[X2 + 1, Y2 - 1].CopyPaintAndCoating(other2);
				Main.tile[X2 - 1, Y2].CopyPaintAndCoating(other2);
				Main.tile[X2, Y2].CopyPaintAndCoating(other2);
				Main.tile[X2 + 1, Y2].CopyPaintAndCoating(other2);
			}
		}
	}

	public static void CheckJunglePlant(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		if (Main.tile[i, j].frameY >= 36 || Main.tile[i, j].type == 236 || Main.tile[i, j].type == 238 || Main.tile[i, j].type == 702)
		{
			bool flag = false;
			int num = Main.tile[i, j].frameX / 18;
			int num2 = 0;
			while (num > 1)
			{
				num -= 2;
				num2++;
			}
			num = i - num;
			int num3 = 36;
			if (type == 236 || type == 238 || type == 702)
			{
				num3 = 0;
			}
			int num4;
			for (num4 = Main.tile[i, j].frameY / 18; num4 > 1; num4 -= 2)
			{
			}
			num4 = j - num4;
			int num5 = num2 * 36;
			for (int k = num; k < num + 2; k++)
			{
				for (int l = num4; l < num4 + 2; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num) * 18 + num5 || Main.tile[k, l].frameY != (l - num4) * 18 + num3)
					{
						flag = true;
					}
				}
				if (Main.tile[k, num4 + 2] == null)
				{
					Main.tile[k, num4 + 2] = new Tile();
				}
				if (type == 702)
				{
					if (!SolidTileAllowBottomSlope(k, num4 + 2))
					{
						flag = true;
					}
				}
				else if (!SolidTile(k, num4 + 2) || Main.tile[k, num4 + 2].type != 60)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			if (type == 238)
			{
				float num6 = i * 16;
				float num7 = j * 16;
				float num8 = -1f;
				int plr = 0;
				for (int m = 0; m < 255; m++)
				{
					float num9 = Math.Abs(Main.player[m].position.X - num6) + Math.Abs(Main.player[m].position.Y - num7);
					if (num9 < num8 || num8 == -1f)
					{
						plr = m;
						num8 = num9;
					}
				}
				if (num8 / 16f < 50f)
				{
					NPC.SpawnOnPlayer(plr, 262);
				}
			}
			if (type == 236)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1291);
			}
			if (type == 702)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1291);
			}
			_ = Main.tile[i, j].frameX;
			destroyObject = true;
			for (int n = num; n < num + 2; n++)
			{
				for (int num10 = num4; num10 < num4 + 2; num10++)
				{
					if (Main.tile[n, num10] == null)
					{
						Main.tile[n, num10] = new Tile();
					}
					if (Main.tile[n, num10].type == type && Main.tile[n, num10].active())
					{
						KillTile(n, num10);
					}
				}
			}
			destroyObject = false;
			return;
		}
		bool flag2 = false;
		int num11 = j;
		num11 += Main.tile[i, j].frameY / 18 * -1;
		int num12 = Main.tile[i, j].frameX / 18;
		int num13 = 0;
		while (num12 > 2)
		{
			num12 -= 3;
			num13++;
		}
		num12 = i - num12;
		int num14 = num13 * 54;
		for (int num15 = num12; num15 < num12 + 3; num15++)
		{
			for (int num16 = num11; num16 < num11 + 2; num16++)
			{
				if (Main.tile[num15, num16] == null)
				{
					Main.tile[num15, num16] = new Tile();
				}
				if (!Main.tile[num15, num16].active() || Main.tile[num15, num16].type != type || Main.tile[num15, num16].frameX != (num15 - num12) * 18 + num14 || Main.tile[num15, num16].frameY != (num16 - num11) * 18)
				{
					flag2 = true;
				}
			}
			if (Main.tile[num15, num11 + 2] == null)
			{
				Main.tile[num15, num11 + 2] = new Tile();
			}
			if (!SolidTile(num15, num11 + 2) || Main.tile[num15, num11 + 2].type != 60)
			{
				flag2 = true;
			}
		}
		if (!flag2)
		{
			return;
		}
		_ = Main.tile[i, j].frameX;
		destroyObject = true;
		for (int num17 = num12; num17 < num12 + 3; num17++)
		{
			for (int num18 = num11; num18 < num11 + 3; num18++)
			{
				if (Main.tile[num17, num18] == null)
				{
					Main.tile[num17, num18] = new Tile();
				}
				if (Main.tile[num17, num18].type == type && Main.tile[num17, num18].active())
				{
					KillTile(num17, num18);
				}
			}
		}
		destroyObject = false;
	}

	public static void CheckSuper(int x, int y, int type)
	{
		if (destroyObject)
		{
			return;
		}
		Tile tile = Main.tile[x, y];
		int num = 0;
		if (type == 376)
		{
			num = tile.frameX / 36;
		}
		if (type == 443)
		{
			num = tile.frameX / 36;
		}
		if (type == 485)
		{
			num = tile.frameX / 36;
		}
		bool flag = type == 376;
		bool flag2 = type == 443;
		bool flag3 = type == 444;
		bool flag4 = type == 485;
		TileObjectData tileData = TileObjectData.GetTileData(type, num);
		bool styleHorizontal = tileData.StyleHorizontal;
		int width = tileData.Width;
		int height = tileData.Height;
		int num2 = x;
		int num3 = y;
		num2 -= tile.frameX / 18 % width;
		num3 -= tile.frameY / 18 % height;
		int num4 = 0;
		int num5 = 0;
		if (styleHorizontal)
		{
			num4 = tile.frameX / tileData.CoordinateFullWidth;
		}
		else
		{
			num5 = tile.frameY / tileData.CoordinateFullHeight;
		}
		bool flag5 = false;
		bool flag6 = false;
		for (int i = 0; i < width; i++)
		{
			for (int j = 0; j < height; j++)
			{
				Tile tileSafely = Framing.GetTileSafely(num2 + i, num3 + j);
				if (!tileSafely.active() || tileSafely.type != type || tileSafely.frameX != num4 * tileData.CoordinateFullWidth + i * (tileData.CoordinateWidth + 2) || tileSafely.frameY != num5 * tileData.CoordinateFullHeight + j * (tileData.CoordinateHeights[0] + 2))
				{
					flag5 = true;
				}
			}
		}
		if (flag)
		{
			for (int k = 0; k < width; k++)
			{
				Tile tileSafely = Framing.GetTileSafely(num2 + k, num3 + height);
				if (!tileSafely.active() || (!Main.tileSolid[tileSafely.type] && !Main.tileTable[tileSafely.type]))
				{
					flag5 = true;
				}
				if (tileSafely.halfBrick())
				{
					flag5 = true;
				}
			}
		}
		if (flag2)
		{
			bool flag7 = true;
			bool flag8 = true;
			for (int l = 0; l < width; l++)
			{
				if (!AnchorValid(Framing.GetTileSafely(num2 + l, num3 + height), AnchorType.SolidTile | AnchorType.SolidWithTop | AnchorType.SolidSide))
				{
					flag8 = false;
				}
				if (!AnchorValid(Framing.GetTileSafely(num2 + l, num3 - 1), AnchorType.SolidBottom))
				{
					flag7 = false;
				}
			}
			if (!flag7 && !flag8)
			{
				flag5 = true;
			}
			if (!flag5)
			{
				int num6 = 0;
				if (flag8)
				{
					for (int m = 0; m < width; m++)
					{
						Framing.GetTileSafely(num2 + m, num3).frameX = (short)(m * 18 + num / 2 * 36 + num6 * 36);
					}
				}
				else
				{
					for (int n = 0; n < width; n++)
					{
						Framing.GetTileSafely(num2 + n, num3).frameX = (short)(n * 18 + (num - 2) / 2 * 36 + 72 + num6 * 36);
					}
				}
			}
		}
		if (flag3)
		{
			bool flag9 = true;
			for (int num7 = 0; num7 < width; num7++)
			{
				if (!AnchorValid(Framing.GetTileSafely(num2 + num7, num3 - 1), AnchorType.SolidTile))
				{
					flag9 = false;
				}
			}
			if (!flag9)
			{
				flag5 = true;
			}
			for (int num8 = 0; num8 < width; num8++)
			{
				for (int num9 = 0; num9 < height; num9++)
				{
					Tile tileSafely = Framing.GetTileSafely(num2 + num8, num3 + num9);
					if (tileSafely.liquid > 0)
					{
						flag5 = true;
						flag6 = true;
					}
				}
			}
		}
		if (flag4)
		{
			bool flag10 = true;
			for (int num10 = 0; num10 < width; num10++)
			{
				if (!AnchorValid(Framing.GetTileSafely(num2 + num10, num3 + height), AnchorType.SolidTile))
				{
					flag10 = false;
				}
			}
			if (!flag10)
			{
				flag5 = true;
			}
		}
		if (!flag5)
		{
			return;
		}
		destroyObject = true;
		for (int num11 = 0; num11 < width; num11++)
		{
			for (int num12 = 0; num12 < height; num12++)
			{
				if (Main.tile[num2 + num11, num3 + num12].type == type && Main.tile[num2 + num11, num3 + num12].active())
				{
					KillTile(num2 + num11, num3 + num12);
				}
			}
		}
		int num13 = 0;
		if (type == 376)
		{
			switch (num)
			{
			case 0:
				num13 = 2334;
				break;
			case 1:
				num13 = 2335;
				break;
			case 2:
				num13 = 2336;
				break;
			case 3:
				num13 = 3203;
				break;
			case 4:
				num13 = 3204;
				break;
			case 5:
				num13 = 3205;
				break;
			case 6:
				num13 = 3206;
				break;
			case 7:
				num13 = 3207;
				break;
			case 8:
				num13 = 3208;
				break;
			case 9:
				num13 = 3979;
				break;
			case 10:
				num13 = 3980;
				break;
			case 11:
				num13 = 3981;
				break;
			case 12:
				num13 = 3982;
				break;
			case 13:
				num13 = 3983;
				break;
			case 14:
				num13 = 3984;
				break;
			case 15:
				num13 = 3985;
				break;
			case 16:
				num13 = 3986;
				break;
			case 17:
				num13 = 3987;
				break;
			case 18:
				num13 = 4405;
				break;
			case 19:
				num13 = 4406;
				break;
			case 20:
				num13 = 4407;
				break;
			case 21:
				num13 = 4408;
				break;
			case 22:
				num13 = 4877;
				break;
			case 23:
				num13 = 4878;
				break;
			case 24:
				num13 = 5002;
				break;
			case 25:
				num13 = 5003;
				break;
			}
		}
		if (type == 443)
		{
			num13 = 3722;
		}
		if (type == 485 && !isGeneratingOrLoadingWorld && Main.netMode != 1)
		{
			int availableAmountOfNPCsToSpawnUpToSlot = NPC.GetAvailableAmountOfNPCsToSpawnUpToSlot(1);
			for (int num14 = 0; num14 < availableAmountOfNPCsToSpawnUpToSlot; num14++)
			{
				int num15 = NPC.NewNPC(GetNPCSource_TileBreak(num2, num3), num2 * 16, num3 * 16 + 32, 582);
				Main.npc[num15].TargetClosest();
				Main.npc[num15].velocity = new Vector2((float)Main.npc[num15].direction * 1.5f, -5f);
				Main.npc[num15].CanBeReplacedByOtherNPCs = true;
				NetMessage.SendData(23, -1, -1, null, num15);
				int num16 = 20;
				int num17 = -1;
				Main.npc[num15].GetImmuneTime(num17, num16);
				NetMessage.SendData(131, -1, -1, null, num15, 1f, num17, num16);
			}
		}
		if (type == 444 && Main.netMode != 1 && !flag6)
		{
			Projectile.NewProjectile(GetProjectileSource_TileBreak(num2, num3), num2 * 16 + 16, num3 * 16 + 16, 0f, 0f, 655, 0, 0f, Main.myPlayer);
		}
		if (num13 != 0)
		{
			Item.NewItem(GetItemSource_FromTileBreak(num2, num3), num2 * 16, num3 * 16, tileData.CoordinateFullWidth, tileData.CoordinateFullHeight, num13);
		}
		destroyObject = false;
		for (int num18 = -1; num18 < width + 1; num18++)
		{
			for (int num19 = -1; num19 < height + 1; num19++)
			{
				TileFrame(num2 + num18, num3 + num19);
			}
		}
	}

	public static void Check2x2(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = 0;
		Tile tile = Main.tile[i, j];
		if (tile == null)
		{
			return;
		}
		int num2 = tile.frameX / 18 * -1;
		if (num2 < -1)
		{
			num2 += 2;
			num = 36;
		}
		num2 += i;
		int num3 = ((type == 172) ? 38 : 36);
		int num4 = tile.frameY;
		int num5 = 0;
		while (num4 >= num3)
		{
			num4 -= num3;
			num5++;
		}
		int num6 = j - num4 / 18;
		int num7 = 0;
		if (type == 652)
		{
			num7 = tile.frameX / 36;
			num2 = tile.frameX % 36 / 18 * -1 + i;
			num = num7 * 36;
		}
		for (int k = num2; k < num2 + 2; k++)
		{
			for (int l = num6; l < num6 + 2; l++)
			{
				Tile tileSafely = Framing.GetTileSafely(k, l);
				if (!tileSafely.active() || tileSafely.type != type || tileSafely.frameX != (k - num2) * 18 + num || tileSafely.frameY != (l - num6) * 18 + num5 * num3)
				{
					flag = true;
					break;
				}
			}
			if (type == 95 || type == 126)
			{
				Framing.GetTileSafely(k, num6 - 1);
				if (!Main.tile[k, num6 - 1].active() || !Main.tileSolid[Main.tile[k, num6 - 1].type] || Main.tileSolidTop[Main.tile[k, num6 - 1].type])
				{
					flag = true;
				}
			}
			else if (!TileID.Sets.Boulders[type] && type != 132)
			{
				Tile tileSafely2 = Framing.GetTileSafely(k, num6 + 2);
				if (!tileSafely2.active() || (!Main.tileSolid[tileSafely2.type] && !Main.tileTable[tileSafely2.type]))
				{
					flag = true;
				}
				if (tileSafely2.halfBrick())
				{
					flag = true;
				}
			}
		}
		if (TileID.Sets.Boulders[type])
		{
			if (Main.tile[num2, num6 - 1] == null)
			{
				Main.tile[num2, num6 - 1] = new Tile();
			}
			if (Main.tile[num2 + 1, num6 - 1] == null)
			{
				Main.tile[num2 + 1, num6 - 1] = new Tile();
			}
			ushort type2 = Main.tile[num2, num6 - 1].type;
			ushort type3 = Main.tile[num2 + 1, num6 - 1].type;
			if (!TileID.Sets.BasicChest[type2] && !TileID.Sets.BasicChest[type3] && type2 != 88 && type3 != 88 && !TileID.Sets.BasicChestFake[type2] && !TileID.Sets.BasicChestFake[type3] && type2 != 470 && type3 != 470 && type2 != 475 && type3 != 475 && !SolidTileAllowBottomSlope(num2, num6 + 2) && !SolidTileAllowBottomSlope(num2 + 1, num6 + 2))
			{
				flag = true;
			}
		}
		else if (type == 132)
		{
			flag = false;
			num6 = tile.frameY / 18 * -1;
			num6 += j;
			num = 0;
			num2 = tile.frameX / 18 * -1;
			while (num2 < -1)
			{
				num2 += 2;
				num += 36;
			}
			num2 += i;
			for (int m = num2; m < num2 + 2; m++)
			{
				for (int n = num6; n < num6 + 2; n++)
				{
					Tile tile2 = Main.tile[m, n];
					if (tile2 != null && (!tile2.active() || tile2.type != type || tile2.frameX != (m - num2) * 18 + num || tile2.frameY != (n - num6) * 18))
					{
						flag = true;
					}
				}
			}
			if (Main.tile[num2, num6 + 2] == null)
			{
				Main.tile[num2, num6 + 2] = new Tile();
			}
			if (Main.tile[num2 + 1, num6 + 2] == null)
			{
				Main.tile[num2 + 1, num6 + 2] = new Tile();
			}
			Tile tile3 = Main.tile[num2, num6 + 2];
			Tile tile4 = Main.tile[num2 + 1, num6 + 2];
			bool flag2 = false;
			ushort type4 = tile3.type;
			ushort type5 = tile4.type;
			if (!tile3.active() || (!Main.tileSolid[type4] && !Main.tileSolidTop[type4]) || tile3.halfBrick() || (tile3.slope() != 0 && !tile3.bottomSlope()))
			{
				flag2 = true;
			}
			if (!tile4.active() || (!Main.tileSolid[type5] && !Main.tileSolidTop[type5]) || tile4.halfBrick() || (tile4.slope() != 0 && !tile4.bottomSlope()))
			{
				flag2 = true;
			}
			if (flag2)
			{
				if (Main.tile[num2, num6].wall < 1 || Main.tile[num2 + 1, num6].wall < 1 || Main.tile[num2, num6 + 1].wall < 1 || Main.tile[num2 + 1, num6 + 1].wall < 1)
				{
					flag = true;
				}
				else if (num < 72)
				{
					for (int num8 = num2; num8 < num2 + 2; num8++)
					{
						for (int num9 = num6; num9 < num6 + 2; num9++)
						{
							Main.tile[num8, num9].frameX += 72;
						}
					}
				}
			}
			else if (num >= 72)
			{
				for (int num10 = num2; num10 < num2 + 2; num10++)
				{
					for (int num11 = num6; num11 < num6 + 2; num11++)
					{
						Main.tile[num10, num11].frameX -= 72;
					}
				}
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		for (int num12 = num2; num12 < num2 + 2; num12++)
		{
			for (int num13 = num6; num13 < num6 + 2; num13++)
			{
				Tile tile5 = Main.tile[num12, num13];
				if (tile5 != null && tile5.type == type && tile5.active())
				{
					KillTile(num12, num13);
				}
			}
		}
		int num14 = 0;
		switch (type)
		{
		case 751:
			num14 = 5667;
			break;
		case 752:
			num14 = 6142;
			break;
		case 521:
			num14 = 4327;
			break;
		case 522:
			num14 = 4328;
			break;
		case 523:
			num14 = 4329;
			break;
		case 524:
			num14 = 4330;
			break;
		case 525:
			num14 = 4331;
			break;
		case 526:
			num14 = 4332;
			break;
		case 527:
			num14 = 4333;
			break;
		case 564:
			num14 = 4553;
			break;
		case 565:
			num14 = 4552;
			break;
		case 594:
			num14 = 4869;
			break;
		case 621:
			num14 = 3750;
			break;
		case 622:
			num14 = 5008;
			break;
		}
		if (type == 598)
		{
			num14 = 4880;
		}
		if (type == 360)
		{
			num14 = 3072;
		}
		if (type == 580)
		{
			num14 = 4846;
		}
		if (type == 620)
		{
			num14 = 4964;
		}
		if (type == 505)
		{
			num14 = 4275;
		}
		if (type == 543)
		{
			num14 = 4398;
		}
		if (type == 568)
		{
			num14 = 4655;
		}
		if (type == 569)
		{
			num14 = 4656;
		}
		if (type == 570)
		{
			num14 = 4657;
		}
		if (type >= 288 && type <= 295)
		{
			num14 = 2178 + type - 288;
		}
		if (type >= 316 && type <= 318)
		{
			num14 = 2439 + type - 316;
		}
		if (type == 85)
		{
			num14 = 321;
		}
		if (type == 94)
		{
			num14 = 352;
		}
		if (type == 95)
		{
			num14 = 344;
		}
		if (type == 96)
		{
			num14 = 345;
		}
		if (type == 97)
		{
			num14 = 346;
		}
		if (type == 98)
		{
			num14 = 347;
		}
		if (type == 99)
		{
			num14 = 348;
		}
		if (type == 335)
		{
			num14 = 2700;
		}
		if (type == 411)
		{
			num14 = 3545;
		}
		if (type == 652)
		{
			num14 = ((num7 < 3) ? 195 : ((num7 >= 6) ? 331 : 62));
		}
		if (type == 100)
		{
			num14 = GetItemDrop_Candelabras(num5);
		}
		if (type == 173)
		{
			num14 = 714;
		}
		if (type == 125)
		{
			num14 = 487;
		}
		if (type == 287)
		{
			num14 = 2177;
		}
		if (type == 126)
		{
			num14 = 488;
		}
		if (type == 132)
		{
			num14 = 513;
		}
		if (type == 142)
		{
			num14 = 581;
		}
		if (type == 143)
		{
			num14 = 582;
		}
		if (type == 282)
		{
			num14 = 250;
		}
		if (type == 319)
		{
			num14 = 2490;
		}
		if (type == 490)
		{
			num14 = 4075;
		}
		if (type == 172)
		{
			num14 = GetItemDrop_Sinks(num5);
		}
		if (num14 != 0)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, num14);
		}
		if (!isGeneratingOrLoadingWorld && Main.netMode != 1)
		{
			switch (type)
			{
			case 138:
				Projectile.NewProjectile(GetProjectileSource_TileBreak(num2, num6), (float)(num2 * 16) + 15.5f, num6 * 16 + 16, 0f, 0f, 99, 70, 10f, Main.myPlayer);
				break;
			case 484:
				Projectile.NewProjectile(GetProjectileSource_TileBreak(num2, num6), (float)(num2 * 16) + 15.5f, num6 * 16 + 16, 0f, 0f, 727, 35, 10f, Main.myPlayer);
				break;
			case 654:
				Projectile.NewProjectile(GetProjectileSource_TileBreak(num2, num6), num2 * 16 + 8, num6 * 16 + 8, 0f, 0f, 1002, 400, 10f, Main.myPlayer);
				break;
			case 664:
				Projectile.NewProjectile(GetProjectileSource_TileBreak(num2, num6), (float)(num2 * 16) + 15.5f, num6 * 16 + 16, 0f, 0f, 1013, 70, 10f, Main.myPlayer);
				break;
			case 711:
				Projectile.NewProjectile(GetProjectileSource_TileBreak(num2, num6), (float)(num2 * 16) + 15.5f, num6 * 16 + 16, 0f, 0f, 1047, 100, 10f, Main.myPlayer);
				break;
			case 665:
				Projectile.NewProjectile(GetProjectileSource_TileBreak(num2, num6), (float)(num2 * 16) + 15.5f, num6 * 16 + 16, 0f, 0f, 1014, 70, 10f, Main.myPlayer);
				break;
			case 712:
				Projectile.NewProjectile(GetProjectileSource_TileBreak(num2, num6), (float)(num2 * 16) + 15.5f, num6 * 16 + 16, 0f, 0f, 1048, 50, 10f, Main.myPlayer);
				break;
			case 713:
				Projectile.NewProjectile(GetProjectileSource_TileBreak(num2, num6), (float)(num2 * 16) + 15.5f, num6 * 16 + 16, 0f, 0f, 1053, 70, 10f, Main.myPlayer);
				break;
			case 714:
				Projectile.NewProjectile(GetProjectileSource_TileBreak(num2, num6), (float)(num2 * 16) + 15.5f, num6 * 16 + 16, 0f, 0f, 1054, 50, 10f, Main.myPlayer);
				break;
			case 715:
				Projectile.NewProjectile(GetProjectileSource_TileBreak(num2, num6), (float)(num2 * 16) + 15.5f, num6 * 16 + 16, 0f, 0f, 1055, 70, 10f, Main.myPlayer);
				break;
			case 716:
				Projectile.NewProjectile(GetProjectileSource_TileBreak(num2, num6), (float)(num2 * 16) + 15.5f, num6 * 16 + 16, 0f, 0f, 1057, 70, 10f, Main.myPlayer);
				break;
			}
		}
		destroyObject = false;
		for (int num15 = num2 - 1; num15 < num2 + 3; num15++)
		{
			for (int num16 = num6 - 1; num16 < num6 + 3; num16++)
			{
				TileFrame(num15, num16);
			}
		}
	}

	public static bool CheckBoulderChest(int i, int j)
	{
		int num = Main.tile[i, j].frameX / 18 * -1;
		if (num < -1)
		{
			num += 2;
		}
		num += i;
		int num2;
		for (num2 = Main.tile[i, j].frameY; num2 >= 36; num2 -= 36)
		{
		}
		num2 = j - num2 / 18;
		ushort type = Main.tile[i, j].type;
		if (CheckTileBreakability_HasReasonToReturnEarly(type, Main.tile[num, num2 - 1], scanForContainer: true) || CheckTileBreakability_HasReasonToReturnEarly(type, Main.tile[num + 1, num2 - 1], scanForContainer: true))
		{
			return true;
		}
		return false;
	}

	public static bool IsAContainer(Tile t)
	{
		if (!TileID.Sets.BasicDresser[t.type] && t.type != 470 && t.type != 475 && !TileID.Sets.BasicChest[t.type])
		{
			return TileID.Sets.BasicChestFake[t.type];
		}
		return true;
	}

	public static void OreRunner(int i, int j, double strength, int steps, int tileType = -1, int wallType = -1, Rectangle? stayInArea = null, int onlyReplaceTileType = -1, int onlyReplaceWallType = -1)
	{
		double num = strength;
		double num2 = steps;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-10, 11) * 0.1;
		vector2D2.Y = (double)genRand.Next(-10, 11) * 0.1;
		while (num > 0.0 && num2 > 0.0)
		{
			if (vector2D.Y < 0.0 && num2 > 0.0 && tileType == 59)
			{
				num2 = 0.0;
			}
			num = strength * (num2 / (double)steps);
			num2 -= 1.0;
			int num3 = (int)(vector2D.X - num * 0.5);
			int num4 = (int)(vector2D.X + num * 0.5);
			int num5 = (int)(vector2D.Y - num * 0.5);
			int num6 = (int)(vector2D.Y + num * 0.5);
			if (num3 < 0)
			{
				num3 = 0;
			}
			if (num4 > Main.maxTilesX)
			{
				num4 = Main.maxTilesX;
			}
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesY)
			{
				num6 = Main.maxTilesY;
			}
			for (int k = num3; k < num4; k++)
			{
				for (int l = num5; l < num6; l++)
				{
					if (!(Math.Abs((double)k - vector2D.X) + Math.Abs((double)l - vector2D.Y) < strength * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015)) || (stayInArea.HasValue && !stayInArea.Value.Contains(k, l)))
					{
						continue;
					}
					Tile tile = Main.tile[k, l];
					if (tileType != -1 && tile.active())
					{
						if (onlyReplaceTileType != -1 && tile.type != onlyReplaceTileType)
						{
							continue;
						}
						if (tile.type == 0 || tile.type == 1 || tile.type == 23 || tile.type == 25 || tile.type == 40 || tile.type == 53 || tile.type == 57 || tile.type == 59 || tile.type == 60 || tile.type == 70 || tile.type == 109 || tile.type == 112 || tile.type == 116 || tile.type == 117 || tile.type == 147 || tile.type == 161 || tile.type == 163 || tile.type == 164 || Main.tileMoss[tile.type] || tile.type == 199 || tile.type == 200 || tile.type == 203 || tile.type == 234 || tile.type == 396 || tile.type == 397 || tile.type == 401 || tile.type == 403 || tile.type == 400 || tile.type == 398 || tile.type == 399 || tile.type == 402 || (Main.notTheBeesWorld && tile.type == 230) || (tile.type == 225 && tile.wall != 108))
						{
							Main.tile[k, l].type = (ushort)tileType;
							paintTile(k, l, 0, !generatingWorld && Main.netMode == 2, paintEffects: false);
							if (!generatingWorld)
							{
								SquareTileFrame(k, l);
								if (Main.netMode == 2)
								{
									NetMessage.SendTileSquare(-1, k, l);
								}
							}
						}
					}
					if (wallType == -1 || (onlyReplaceWallType != -1 && tile.wall != onlyReplaceWallType))
					{
						continue;
					}
					Main.tile[k, l].wall = (ushort)wallType;
					paintWall(k, l, 0, !generatingWorld && Main.netMode == 2, paintEffects: false);
					if (!generatingWorld)
					{
						SquareWallFrame(k, l);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, k, l);
						}
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
		}
	}

	public static void SmashAltar(int i, int j)
	{
		if (Main.netMode == 1 || !Main.hardMode || generatingWorld || isGeneratingOrLoadingWorld)
		{
			return;
		}
		int num = altarCount % 3;
		int num2 = altarCount / 3 + 1;
		double num3 = (double)Main.maxTilesX / 4200.0;
		int num4 = 1;
		num3 = num3 * 310.0 - (double)(85 * num);
		num3 *= 0.85;
		num3 /= (double)num2;
		bool flag = false;
		if (Main.drunkWorld)
		{
			if (SavedOreTiers.Adamantite == 111)
			{
				SavedOreTiers.Adamantite = 223;
			}
			else if (SavedOreTiers.Adamantite == 223)
			{
				SavedOreTiers.Adamantite = 111;
			}
		}
		switch (num)
		{
		case 0:
		{
			if (SavedOreTiers.Cobalt == -1)
			{
				flag = true;
				SavedOreTiers.Cobalt = 107;
				if (genRand.Next(2) == 0)
				{
					SavedOreTiers.Cobalt = 221;
				}
			}
			int num6 = 12;
			if (SavedOreTiers.Cobalt == 221)
			{
				num6 += 9;
				num3 *= 0.8999999761581421;
			}
			if (Main.netMode == 0)
			{
				Main.NewText(Lang.misc[num6].Value, 50, byte.MaxValue, 130);
			}
			else if (Main.netMode == 2)
			{
				ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[num6].Key), new Color(50, 255, 130));
			}
			num = SavedOreTiers.Cobalt;
			num3 *= 1.0499999523162842;
			break;
		}
		case 1:
		{
			if (Main.drunkWorld)
			{
				if (SavedOreTiers.Mythril == 108)
				{
					SavedOreTiers.Mythril = 222;
				}
				else if (SavedOreTiers.Mythril == 222)
				{
					SavedOreTiers.Mythril = 108;
				}
			}
			if (SavedOreTiers.Mythril == -1)
			{
				flag = true;
				SavedOreTiers.Mythril = 108;
				if (genRand.Next(2) == 0)
				{
					SavedOreTiers.Mythril = 222;
				}
			}
			int num7 = 13;
			if (SavedOreTiers.Mythril == 222)
			{
				num7 += 9;
				num3 *= 0.8999999761581421;
			}
			if (Main.netMode == 0)
			{
				Main.NewText(Lang.misc[num7].Value, 50, byte.MaxValue, 130);
			}
			else if (Main.netMode == 2)
			{
				ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[num7].Key), new Color(50, 255, 130));
			}
			num = SavedOreTiers.Mythril;
			break;
		}
		default:
		{
			if (Main.drunkWorld)
			{
				if (SavedOreTiers.Cobalt == 107)
				{
					SavedOreTiers.Cobalt = 221;
				}
				else if (SavedOreTiers.Cobalt == 221)
				{
					SavedOreTiers.Cobalt = 107;
				}
			}
			if (SavedOreTiers.Adamantite == -1)
			{
				flag = true;
				SavedOreTiers.Adamantite = 111;
				if (genRand.Next(2) == 0)
				{
					SavedOreTiers.Adamantite = 223;
				}
			}
			int num5 = 14;
			if (SavedOreTiers.Adamantite == 223)
			{
				num5 += 9;
				num3 *= 0.8999999761581421;
			}
			if (Main.netMode == 0)
			{
				Main.NewText(Lang.misc[num5].Value, 50, byte.MaxValue, 130);
			}
			else if (Main.netMode == 2)
			{
				ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[num5].Key), new Color(50, 255, 130));
			}
			num = SavedOreTiers.Adamantite;
			break;
		}
		}
		if (flag)
		{
			NetMessage.SendData(7);
		}
		for (int k = 0; (double)k < num3; k++)
		{
			int i2 = genRand.Next(100, Main.maxTilesX - 100);
			double num8 = Main.worldSurface;
			if (num == 108 || num == 222)
			{
				num8 = Main.rockLayer;
			}
			if (num == 111 || num == 223)
			{
				num8 = (Main.rockLayer + Main.rockLayer + (double)Main.maxTilesY) / 3.0;
			}
			int j2 = genRand.Next((int)num8, Main.maxTilesY - 150);
			if (Main.remixWorld)
			{
				double num9 = Main.maxTilesX - 350;
				if (num == 108 || num == 222)
				{
					num9 = (Main.rockLayer + Main.rockLayer + (double)Main.maxTilesY - 350.0) / 3.0;
				}
				if (num == 111 || num == 223)
				{
					num9 = Main.rockLayer - 25.0;
				}
				j2 = genRand.Next((int)Main.worldSurface + 15, (int)num9);
			}
			if (Main.tenthAnniversaryWorld)
			{
				OreRunner(i2, j2, genRand.Next(5, 11 + num4), genRand.Next(5, 11 + num4), (ushort)num);
			}
			else
			{
				OreRunner(i2, j2, genRand.Next(5, 9 + num4), genRand.Next(5, 9 + num4), (ushort)num);
			}
		}
		if (Main.netMode != 1)
		{
			int num10 = Main.rand.Next(2) + 1;
			for (int l = 0; l < num10; l++)
			{
				NPC.SpawnOnPlayer(Player.FindClosest(new Vector2(i * 16, j * 16), 16, 16), 82);
			}
		}
		altarCount++;
		AchievementsHelper.NotifyProgressionEvent(6);
	}

	public static void Check3x1(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		if (Main.tile[i, j] == null)
		{
			Main.tile[i, j] = new Tile();
		}
		int num = Main.tile[i, j].frameX / 18;
		int num2 = 0;
		while (num > 2)
		{
			num -= 3;
			num2++;
		}
		num = i - num;
		int num3 = num2 * 54;
		for (int k = num; k < num + 3; k++)
		{
			if (Main.tile[k, j] == null)
			{
				Main.tile[k, j] = new Tile();
			}
			if (!Main.tile[k, j].active() || Main.tile[k, j].type != type || Main.tile[k, j].frameX != (k - num) * 18 + num3 || Main.tile[k, j].frameY != 0)
			{
				flag = true;
			}
			if (!SolidTileAllowBottomSlope(k, j + 1))
			{
				flag = true;
			}
		}
		if (flag && type == 235)
		{
			for (int l = num; l < num + 3; l++)
			{
				if (CheckTileBreakability(l, j) != 0)
				{
					flag = false;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		_ = Main.tile[i, j].frameX;
		destroyObject = true;
		if (type == 235)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1263);
		}
		for (int m = num; m < num + 3; m++)
		{
			if (Main.tile[m, j] == null)
			{
				Main.tile[m, j] = new Tile();
			}
			if (Main.tile[m, j].type == type && Main.tile[m, j].active())
			{
				KillTile(m, j);
			}
		}
		destroyObject = false;
		for (int n = num - 1; n < num + 4; n++)
		{
			for (int num4 = j - 1; num4 < j + 2; num4++)
			{
				TileFrame(n, num4);
			}
		}
	}

	public static void Check3x2(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		bool flag2 = false;
		int num = j;
		if (Main.tile[i, j] == null)
		{
			Main.tile[i, j] = new Tile();
		}
		int num2 = 36;
		int num3 = Main.tile[i, j].frameY / num2;
		int num4 = Main.tile[i, j].frameY % num2;
		num -= num4 / 18;
		int num5 = Main.tile[i, j].frameX / 18;
		int num6 = 0;
		while (num5 > 2)
		{
			num5 -= 3;
			num6++;
		}
		num5 = i - num5;
		int num7 = num6 * 54;
		if (type == 14 && num6 == 25)
		{
			flag2 = true;
		}
		int num8 = num + 2;
		if (flag2)
		{
			num8--;
		}
		for (int k = num5; k < num5 + 3; k++)
		{
			for (int l = num; l < num8; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = new Tile();
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num5) * 18 + num7 || Main.tile[k, l].frameY != (l - num) * 18 + num3 * 36)
				{
					flag = true;
				}
			}
			if (type == 285 || type == 286 || type == 298 || type == 299 || type == 310 || type == 339 || type == 538 || (type >= 361 && type <= 364) || type == 532 || type == 544 || type == 533 || type == 555 || type == 556 || type == 582 || type == 619 || type == 629)
			{
				if (!SolidTileAllowBottomSlope(k, num8) && (Main.tile[k, num8] == null || !Main.tile[k, num8].nactive() || !Main.tileSolidTop[Main.tile[k, num8].type] || Main.tile[k, num8].frameY != 0) && (Main.tile[k, num8] == null || !Main.tile[k, num8].active() || !TileID.Sets.Platforms[Main.tile[k, num8].type]))
				{
					flag = true;
				}
			}
			else
			{
				switch (type)
				{
				case 704:
				case 705:
					if (!SolidTileAllowBottomSlope(k, num8))
					{
						flag = true;
					}
					break;
				case 488:
				{
					int num9 = 0;
					if (Main.tile[k, num8] != null && Main.tile[k, num8].active())
					{
						num9 = Main.tile[k, num8].type;
					}
					bool flag3 = num9 == 2 || num9 == 477 || num9 == 109 || num9 == 492 || num9 == 147 || num9 == 53 || num9 == 60 || num9 == 70;
					if (Main.infectedSeed && (num9 == 23 || num9 == 199))
					{
						flag3 = true;
					}
					if (!flag3)
					{
						flag = true;
					}
					break;
				}
				case 26:
				case 695:
				{
					Tile tile2 = Main.tile[k, num8];
					if (!SolidTileAllowBottomSlope(k, num8) || (tile2 != null && tile2.active() && TileID.Sets.Boulders[tile2.type]))
					{
						flag = true;
					}
					break;
				}
				case 186:
				{
					if (!SolidTileAllowBottomSlope(k, num8))
					{
						flag = true;
						break;
					}
					if (InvalidTileForPilesOrSpeleothems(k, num8))
					{
						flag = true;
						break;
					}
					Tile tile = Main.tile[k, num8];
					if (tile == null || !tile.active())
					{
						break;
					}
					switch (num6)
					{
					case 26:
					case 27:
					case 28:
					case 29:
					case 30:
					case 31:
						if (!TileID.Sets.Snow[tile.type] && !TileID.Sets.Conversion.Ice[tile.type] && tile.type != 162 && tile.type != 224)
						{
							flag = true;
						}
						break;
					case 32:
					case 33:
					case 34:
						if (!TileID.Sets.Mud[tile.type] && tile.type != 70)
						{
							flag = true;
						}
						break;
					}
					break;
				}
				}
			}
			if (type == 187)
			{
				if (!SolidTileAllowBottomSlope(k, num8))
				{
					flag = true;
					continue;
				}
				if (InvalidTileForPilesOrSpeleothems(k, num8))
				{
					flag = true;
					continue;
				}
				Tile tile3 = Main.tile[k, num8];
				if (tile3 == null || !tile3.active())
				{
					continue;
				}
				switch (num6)
				{
				case 0:
				case 1:
				case 2:
				case 3:
				case 4:
				case 5:
					if (!TileID.Sets.Mud[tile3.type] && tile3.type != 60 && tile3.type != 226)
					{
						flag = true;
					}
					break;
				case 6:
				case 7:
				case 8:
					if (tile3.type != 57 && tile3.type != 58 && tile3.type != 75 && tile3.type != 76)
					{
						flag = true;
					}
					break;
				case 29:
				case 30:
				case 31:
				case 32:
				case 33:
				case 34:
					if (!TileID.Sets.Conversion.Sand[tile3.type] && !TileID.Sets.Conversion.HardenedSand[tile3.type] && !TileID.Sets.Conversion.Sandstone[tile3.type])
					{
						flag = true;
					}
					break;
				}
			}
			else if (!SolidTileAllowBottomSlope(k, num8))
			{
				flag = true;
			}
		}
		if (type == 187 && Main.tile[num5, num] != null && Main.tile[num5, num].frameX >= 756 && Main.tile[num5, num].frameX <= 900 && Main.tile[num5, num + 2].type != 2 && Main.tile[num5 + 1, num + 2].type != 2 && Main.tile[num5 + 2, num + 2].type != 2 && Main.tile[num5, num + 2].type != 477 && Main.tile[num5 + 1, num + 2].type != 477 && Main.tile[num5 + 2, num + 2].type != 477 && Main.tile[num5, num + 2].type != 492 && Main.tile[num5 + 1, num + 2].type != 492 && Main.tile[num5 + 2, num + 2].type != 492)
		{
			Main.tile[num5, num].frameX -= 378;
			Main.tile[num5 + 1, num].frameX -= 378;
			Main.tile[num5 + 2, num].frameX -= 378;
			Main.tile[num5, num + 1].frameX -= 378;
			Main.tile[num5 + 1, num + 1].frameX -= 378;
			Main.tile[num5 + 2, num + 1].frameX -= 378;
			Main.tile[num5, num].type = 186;
			Main.tile[num5 + 1, num].type = 186;
			Main.tile[num5 + 2, num].type = 186;
			Main.tile[num5, num + 1].type = 186;
			Main.tile[num5 + 1, num + 1].type = 186;
			Main.tile[num5 + 2, num + 1].type = 186;
		}
		if (flag && type == 488 && isGeneratingOrLoadingWorld)
		{
			for (int m = num5; m < num5 + 3; m++)
			{
				for (int n = num; n < num + 2; n++)
				{
					Main.tile[m, n].active(active: true);
					Main.tile[m, n].type = 488;
					Main.tile[m, n].frameX = (short)((m - num5) * 18);
					Main.tile[m, n].frameY = (short)((n - num) * 18);
				}
				Main.tile[m, num + 2].active(active: true);
				Main.tile[m, num + 2].type = 2;
				Main.tile[m, num + 2].slope(0);
				Main.tile[m, num + 2].halfBrick(halfBrick: false);
			}
			flag = false;
		}
		if (!flag)
		{
			return;
		}
		int frameX = Main.tile[i, j].frameX;
		destroyObject = true;
		for (int num10 = num5; num10 < num5 + 3; num10++)
		{
			for (int num11 = num; num11 < num8; num11++)
			{
				if (Main.tile[num10, num11] == null)
				{
					Main.tile[num10, num11] = new Tile();
				}
				if (Main.tile[num10, num11].type == type && Main.tile[num10, num11].active())
				{
					KillTile(num10, num11);
				}
			}
		}
		if (type == 14)
		{
			int itemDrop_Tables = GetItemDrop_Tables(num6, secondType: false);
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, itemDrop_Tables);
		}
		switch (type)
		{
		case 469:
		{
			int itemDrop_Tables2 = GetItemDrop_Tables(num6, secondType: true);
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, itemDrop_Tables2);
			break;
		}
		case 114:
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 398);
			break;
		case 26:
			if (!generatingWorld && !TransformingWorld)
			{
				SmashAltar(i, j);
			}
			break;
		case 705:
		{
			num6 += num3 * 9;
			short num15 = 276;
			num15 = (short)((num6 >= 0 && num6 <= 8) ? 276 : ((num6 >= 9 && num6 <= 17) ? 369 : ((num6 < 18 || num6 > 26) ? 59 : 2171)));
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 48, 32, num15);
			break;
		}
		case 695:
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, (num6 == 0) ? 5467 : 5468);
			break;
		case 298:
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2190);
			break;
		default:
			switch (type)
			{
			case 298:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2190);
				break;
			case 299:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2191);
				break;
			case 361:
			case 362:
			case 363:
			case 364:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3073 + type - 361);
				break;
			default:
				if (type >= 391 && type <= 394)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 48, 32, 3254 + type - 391);
					break;
				}
				switch (type)
				{
				case 285:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2174);
					break;
				case 286:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2175);
					break;
				case 582:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4850);
					break;
				case 619:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4963);
					break;
				case 310:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2207);
					break;
				case 339:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2741);
					break;
				case 538:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4380);
					break;
				case 544:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4399);
					break;
				case 532:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4364);
					break;
				case 533:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4376);
					break;
				case 555:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4475);
					break;
				case 556:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4476);
					break;
				case 629:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5133);
					break;
				case 217:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 995);
					break;
				case 218:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 996);
					break;
				case 219:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 997);
					break;
				case 642:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5296);
					break;
				case 220:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 998);
					break;
				case 377:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3198);
					break;
				case 228:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1120);
					break;
				case 405:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3364);
					break;
				case 486:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4063);
					break;
				case 488:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 9, genRand.Next(10, 21));
					break;
				case 704:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 501);
					break;
				case 215:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, GetCampfireItemDrop(num6));
					break;
				case 244:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1449);
					break;
				case 647:
				{
					int num13 = 0;
					if (num6 < 7)
					{
						num13 = 154;
					}
					else if (num6 < 13)
					{
						num13 = 3;
					}
					else if (num6 < 16)
					{
						num13 = 3;
					}
					else if (num6 < 18)
					{
						num13 = 71;
					}
					else if (num6 < 20)
					{
						num13 = 72;
					}
					else if (num6 < 22)
					{
						num13 = 73;
					}
					else if (num6 < 26)
					{
						num13 = 9;
					}
					else if (num6 < 32)
					{
						num13 = 593;
					}
					else if (num6 < 35)
					{
						num13 = 183;
					}
					if (num13 != 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, num13);
					}
					break;
				}
				case 648:
				{
					num6 += num3 * 35;
					int num14 = 0;
					if (num6 < 6)
					{
						num14 = 195;
					}
					else if (num6 < 9)
					{
						num14 = 174;
					}
					else if (num6 < 14)
					{
						num14 = 150;
					}
					else if (num6 < 17)
					{
						num14 = 3;
					}
					else if (num6 < 18)
					{
						num14 = 989;
					}
					else if (num6 < 21)
					{
						num14 = 1101;
					}
					else if (num6 < 29)
					{
						num14 = 9;
					}
					else if (num6 < 35)
					{
						num14 = 3271;
					}
					else if (num6 < 41)
					{
						num14 = 3086;
					}
					else if (num6 < 47)
					{
						num14 = 3081;
					}
					else if (num6 < 52)
					{
						num14 = 62;
					}
					else if (num6 < 55)
					{
						num14 = 154;
					}
					if (num14 != 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, num14);
					}
					break;
				}
				case 706:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4144);
					break;
				case 651:
				{
					int num12 = 0;
					num12 = ((num6 < 3) ? 195 : ((num6 >= 6) ? 331 : 62));
					if (num12 != 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, num12);
					}
					break;
				}
				case 17:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 33);
					break;
				case 77:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 221);
					break;
				case 86:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 332);
					break;
				case 237:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1292);
					break;
				case 87:
				{
					int itemDrop_Pianos = GetItemDrop_Pianos(num6);
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, itemDrop_Pianos);
					break;
				}
				case 88:
				{
					int itemDrop_Dressers = GetItemDrop_Dressers(num6);
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, itemDrop_Dressers);
					break;
				}
				case 89:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, GetItemDrop_Benches(num6));
					break;
				case 133:
					if (frameX >= 54)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1221);
					}
					else
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 524);
					}
					break;
				case 186:
					if (frameX < 864)
					{
						break;
					}
					if (frameX <= 954)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));
						if (genRand.Next(3) != 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));
						}
						if (genRand.Next(3) != 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));
						}
						if (genRand.Next(3) != 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));
						}
						if (genRand.Next(2) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));
						}
						if (genRand.Next(2) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));
						}
						if (genRand.Next(2) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));
						}
						if (genRand.Next(3) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));
						}
						if (genRand.Next(3) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));
						}
						if (genRand.Next(3) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));
						}
						if (genRand.Next(4) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));
						}
						if (genRand.Next(4) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));
						}
						if (genRand.Next(4) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));
						}
						if (genRand.Next(5) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));
						}
						if (genRand.Next(5) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));
						}
						if (genRand.Next(5) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));
						}
					}
					else if (frameX <= 1062)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 72, genRand.Next(10, 100));
						if (genRand.Next(2) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 72, genRand.Next(20, 100));
						}
						if (genRand.Next(3) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 72, genRand.Next(30, 100));
						}
						if (genRand.Next(4) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 72, genRand.Next(40, 100));
						}
						if (genRand.Next(5) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 72, genRand.Next(50, 100));
						}
					}
					else if (frameX <= 1170)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73, genRand.Next(1, 7));
						if (genRand.Next(2) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73, genRand.Next(2, 7));
						}
						if (genRand.Next(3) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73, genRand.Next(3, 7));
						}
						if (genRand.Next(4) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73, genRand.Next(4, 7));
						}
						if (genRand.Next(5) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73, genRand.Next(5, 7));
						}
					}
					break;
				case 187:
					if (frameX >= 918 && frameX <= 970)
					{
						if (Main.rand.Next(30) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4144);
						}
						else
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 989);
						}
					}
					break;
				}
				break;
			}
			break;
		}
		destroyObject = false;
		for (int num16 = num5 - 1; num16 < num5 + 4; num16++)
		{
			for (int num17 = num - 1; num17 < num + 4; num17++)
			{
				TileFrame(num16, num17);
			}
		}
		if (type == 488)
		{
			mysticLogsEvent.FallenLogDestroyed();
		}
	}

	public static int GetItemDrop_Dressers(int style)
	{
		int result = 334;
		if (style >= 1 && style <= 3)
		{
			result = 646 + style;
		}
		else
		{
			switch (style)
			{
			case 4:
				result = 918;
				break;
			case 5:
			case 6:
			case 7:
			case 8:
			case 9:
			case 10:
			case 11:
			case 12:
			case 13:
			case 14:
			case 15:
				result = 2386 + style - 5;
				break;
			default:
				switch (style)
				{
				case 16:
					result = 2529;
					break;
				case 17:
					result = 2545;
					break;
				case 18:
					result = 2562;
					break;
				case 19:
					result = 2577;
					break;
				case 20:
					result = 2637;
					break;
				case 21:
					result = 2638;
					break;
				case 22:
					result = 2639;
					break;
				case 23:
					result = 2640;
					break;
				case 24:
					result = 2816;
					break;
				case 25:
					result = 3132;
					break;
				case 26:
					result = 3134;
					break;
				case 27:
					result = 3133;
					break;
				case 28:
					result = 3911;
					break;
				case 29:
					result = 3912;
					break;
				case 30:
					result = 3913;
					break;
				case 31:
					result = 3914;
					break;
				case 32:
					result = 3934;
					break;
				case 33:
					result = 3968;
					break;
				case 34:
					result = 4148;
					break;
				case 35:
					result = 4169;
					break;
				case 36:
					result = 4190;
					break;
				case 37:
					result = 4211;
					break;
				case 38:
					result = 4301;
					break;
				case 39:
					result = 4569;
					break;
				case 40:
					result = 5151;
					break;
				case 41:
					result = 5172;
					break;
				case 42:
					result = 5193;
					break;
				case 43:
					result = 5551;
					break;
				case 44:
					result = 5604;
					break;
				case 45:
					result = 5692;
					break;
				case 46:
					result = 5715;
					break;
				case 47:
					result = 5741;
					break;
				case 48:
					result = 5766;
					break;
				case 49:
					result = 5787;
					break;
				case 50:
					result = 5808;
					break;
				case 51:
					result = 5829;
					break;
				case 52:
					result = 5848;
					break;
				case 53:
					result = 5868;
					break;
				case 54:
					result = 5888;
					break;
				case 55:
					result = 5908;
					break;
				case 56:
					result = 5942;
					break;
				case 57:
					result = 5965;
					break;
				case 58:
					result = 5985;
					break;
				case 59:
					result = 6008;
					break;
				case 60:
					result = 6031;
					break;
				case 61:
					result = 6054;
					break;
				case 62:
					result = 6077;
					break;
				case 63:
					result = 6099;
					break;
				case 64:
					result = 6121;
					break;
				}
				break;
			}
		}
		return result;
	}

	private static int GetCampfireItemDrop(int style)
	{
		switch (style)
		{
		case 0:
			return 966;
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
			return 3046 + style - 1;
		default:
			switch (style)
			{
			case 6:
				return 3723;
			case 7:
				return 3724;
			case 8:
			case 9:
			case 10:
			case 11:
			case 12:
			case 13:
				return 4689 + style - 8;
			default:
				return style switch
				{
					14 => 5299, 
					15 => 5357, 
					_ => 966, 
				};
			}
		}
	}

	public static void Check3x4(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = i;
		int num2 = j;
		int num3 = 0;
		int num4 = 0;
		int num5 = Main.tile[i, j].frameX / 18;
		int num6 = Main.tile[i, j].frameY / 18;
		while (num5 >= 3)
		{
			num3++;
			num5 -= 3;
		}
		while (num6 >= 4)
		{
			num4++;
			num6 -= 4;
		}
		num -= num5;
		num2 -= num6;
		for (int k = num; k < num + 3; k++)
		{
			for (int l = num2; l < num2 + 4; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = new Tile();
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != num3 * 54 + (k - num) * 18 || Main.tile[k, l].frameY != num4 * 72 + (l - num2) * 18)
				{
					flag = true;
				}
			}
			if (Main.tile[k, num2 + 4] == null)
			{
				Main.tile[k, num2 + 4] = new Tile();
			}
			if (!SolidTileAllowBottomSlope(k, num2 + 4))
			{
				flag = true;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		for (int m = num; m < num + 3; m++)
		{
			for (int n = num2; n < num2 + 4; n++)
			{
				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
				{
					KillTile(m, n);
				}
			}
		}
		switch (type)
		{
		case 101:
		{
			int itemDrop_Bookcases = GetItemDrop_Bookcases(num3);
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, itemDrop_Bookcases);
			break;
		}
		case 102:
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 355);
			break;
		case 463:
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3813);
			break;
		case 617:
			if (num3 == 27)
			{
				short type2 = 5110;
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, type2);
			}
			else
			{
				int type3 = 4924 + num3;
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, type3);
			}
			break;
		}
		destroyObject = false;
		for (int num7 = num - 1; num7 < num + 4; num7++)
		{
			for (int num8 = num2 - 1; num8 < num2 + 4; num8++)
			{
				TileFrame(num7, num8);
			}
		}
	}

	public static void Check5x4(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = i;
		int num2 = j;
		int num3 = 0;
		int num4;
		for (num4 = Main.tile[i, j].frameX / 18; num4 >= 5; num4 -= 5)
		{
			num3++;
		}
		num -= num4;
		num2 += Main.tile[i, j].frameY / 18 * -1;
		for (int k = num; k < num + 5; k++)
		{
			for (int l = num2; l < num2 + 4; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = new Tile();
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != num3 * 90 + (k - num) * 18 || Main.tile[k, l].frameY != (l - num2) * 18)
				{
					flag = true;
				}
			}
			if (Main.tile[k, num2 + 4] == null)
			{
				Main.tile[k, num2 + 4] = new Tile();
			}
			if (!SolidTileAllowBottomSlope(k, num2 + 4))
			{
				flag = true;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		for (int m = num; m < num + 5; m++)
		{
			for (int n = num2; n < num2 + 4; n++)
			{
				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
				{
					KillTile(m, n);
				}
			}
		}
		if (type == 464)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3814);
		}
		if (type == 466)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3816);
		}
		destroyObject = false;
		for (int num5 = num - 1; num5 < num + 6; num5++)
		{
			for (int num6 = num2 - 1; num6 < num2 + 5; num6++)
			{
				TileFrame(num5, num6);
			}
		}
	}

	public static void Check6x3(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = i;
		int num2 = j;
		num += Main.tile[i, j].frameX / 18 * -1;
		num2 += Main.tile[i, j].frameY / 18 * -1;
		for (int k = num; k < num + 6; k++)
		{
			for (int l = num2; l < num2 + 3; l++)
			{
				int num3 = (k - num) * 18;
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = new Tile();
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != num3 || Main.tile[k, l].frameY != (l - num2) * 18)
				{
					flag = true;
				}
			}
			if (Main.tile[k, num2 + 3] == null)
			{
				Main.tile[k, num2 + 3] = new Tile();
			}
			if (!SolidTileAllowBottomSlope(k, num2 + 3) && (!Main.tile[k, num2 + 3].nactive() || !Main.tileSolidTop[Main.tile[k, num2 + 3].type] || Main.tile[k, num2 + 3].frameY != 0))
			{
				flag = true;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		for (int m = num; m < num + 6; m++)
		{
			for (int n = num2; n < num2 + 3; n++)
			{
				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
				{
					KillTile(m, n);
				}
			}
		}
		if (type == 275)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2162);
		}
		if (type == 413)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3565);
		}
		if (type == 414)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3566);
		}
		if (type == 276)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2163);
		}
		if (type == 277)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2164);
		}
		if (type == 278)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2165);
		}
		if (type == 279)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2166);
		}
		if (type == 280)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2167);
		}
		if (type == 281)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2168);
		}
		if (type == 296)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2186);
		}
		if (type == 297)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2187);
		}
		if (type == 309)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2206);
		}
		if (type == 358)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3070);
		}
		if (type == 359)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3071);
		}
		if (type == 542)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4396);
		}
		if (type == 550)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4461);
		}
		if (type == 551)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4462);
		}
		if (type == 553)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4473);
		}
		if (type == 554)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4474);
		}
		if (type == 558)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4481);
		}
		if (type == 559)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4483);
		}
		if (type == 599)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4882);
		}
		if (type == 600)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4883);
		}
		if (type == 601)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4884);
		}
		if (type == 602)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4885);
		}
		if (type == 603)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4886);
		}
		if (type == 604)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4887);
		}
		if (type == 605)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4888);
		}
		if (type == 606)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4889);
		}
		if (type == 607)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4890);
		}
		if (type == 608)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4891);
		}
		if (type == 609)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4892);
		}
		if (type == 610)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4893);
		}
		if (type == 611)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4894);
		}
		if (type == 612)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4895);
		}
		if (type == 632)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5213);
		}
		if (type == 640)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5301);
		}
		if (type == 643)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5314);
		}
		if (type == 644)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5315);
		}
		if (type == 645)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5316);
		}
		if (type == 710)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5512);
		}
		destroyObject = false;
		for (int num4 = num - 1; num4 < num + 7; num4++)
		{
			for (int num5 = num2 - 1; num5 < num2 + 4; num5++)
			{
				TileFrame(num4, num5);
			}
		}
	}

	public static void Place6x3(int x, int y, ushort type, int direction = -1, int style = 0)
	{
		if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
		{
			return;
		}
		bool flag = true;
		for (int i = x - 3; i < x + 3; i++)
		{
			for (int j = y - 2; j <= y; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = new Tile();
				}
				if (Main.tile[i, j].active())
				{
					flag = false;
				}
			}
			if (Main.tile[i, y + 1] == null)
			{
				Main.tile[i, y + 1] = new Tile();
			}
			if (!SolidTile2(i, y + 1) && (!Main.tile[i, y + 1].nactive() || !Main.tileSolidTop[Main.tile[i, y + 1].type] || Main.tile[i, y + 1].frameY != 0))
			{
				flag = false;
			}
		}
		if (!flag)
		{
			return;
		}
		int num = 0;
		for (int k = x - 3; k < x + 3; k++)
		{
			int num2 = 0;
			for (int l = y - 2; l <= y; l++)
			{
				Main.tile[k, l].active(active: true);
				Main.tile[k, l].frameY = (short)num2;
				Main.tile[k, l].frameX = (short)num;
				Main.tile[k, l].type = type;
				num2 += 18;
			}
			num += 18;
		}
	}

	public static void Place4x2(int x, int y, ushort type, int direction = -1, int style = 0)
	{
		if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
		{
			return;
		}
		bool flag = true;
		for (int i = x - 1; i < x + 3; i++)
		{
			for (int j = y - 1; j < y + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = new Tile();
				}
				if (Main.tile[i, j].active())
				{
					flag = false;
				}
			}
			if (Main.tile[i, y + 1] == null)
			{
				Main.tile[i, y + 1] = new Tile();
			}
			if (!SolidTile2(i, y + 1))
			{
				flag = false;
			}
		}
		short num = 0;
		if (direction == 1)
		{
			num = 72;
		}
		int num2 = 36 * style;
		if (flag)
		{
			Main.tile[x - 1, y - 1].active(active: true);
			Main.tile[x - 1, y - 1].frameY = (short)num2;
			Main.tile[x - 1, y - 1].frameX = num;
			Main.tile[x - 1, y - 1].type = type;
			Main.tile[x, y - 1].active(active: true);
			Main.tile[x, y - 1].frameY = (short)num2;
			Main.tile[x, y - 1].frameX = (short)(18 + num);
			Main.tile[x, y - 1].type = type;
			Main.tile[x + 1, y - 1].active(active: true);
			Main.tile[x + 1, y - 1].frameY = (short)num2;
			Main.tile[x + 1, y - 1].frameX = (short)(36 + num);
			Main.tile[x + 1, y - 1].type = type;
			Main.tile[x + 2, y - 1].active(active: true);
			Main.tile[x + 2, y - 1].frameY = (short)num2;
			Main.tile[x + 2, y - 1].frameX = (short)(54 + num);
			Main.tile[x + 2, y - 1].type = type;
			Main.tile[x - 1, y].active(active: true);
			Main.tile[x - 1, y].frameY = (short)(num2 + 18);
			Main.tile[x - 1, y].frameX = num;
			Main.tile[x - 1, y].type = type;
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].frameY = (short)(num2 + 18);
			Main.tile[x, y].frameX = (short)(18 + num);
			Main.tile[x, y].type = type;
			Main.tile[x + 1, y].active(active: true);
			Main.tile[x + 1, y].frameY = (short)(num2 + 18);
			Main.tile[x + 1, y].frameX = (short)(36 + num);
			Main.tile[x + 1, y].type = type;
			Main.tile[x + 2, y].active(active: true);
			Main.tile[x + 2, y].frameY = (short)(num2 + 18);
			Main.tile[x + 2, y].frameX = (short)(54 + num);
			Main.tile[x + 2, y].type = type;
		}
	}

	public static void ShootFromCannon(int x, int y, int angle, int ammo, int Damage, float KnockBack, int owner, bool fromWire)
	{
		float num = 14f;
		float num2 = 0f;
		float num3 = 0f;
		int type = 162;
		if (ammo == 2)
		{
			type = 281;
		}
		if (ammo == 3)
		{
			type = 178;
		}
		if (ammo == 4)
		{
			type = 601;
			num = 3f;
		}
		if (ammo == 5)
		{
			type = 601;
			num = 3f;
		}
		int num4 = 0;
		int num5 = 0;
		if (ammo == 5)
		{
			num4 = 1;
		}
		if (ammo == 2)
		{
			num5 = owner + 1;
		}
		if (angle == 0)
		{
			num2 = 10f;
			num3 = 0f;
		}
		if (angle == 1)
		{
			num2 = 7.5f;
			num3 = -2.5f;
		}
		if (angle == 2)
		{
			num2 = 5f;
			num3 = -5f;
		}
		if (angle == 3)
		{
			num2 = 2.75f;
			num3 = -6f;
		}
		if (angle == 4)
		{
			num2 = 0f;
			num3 = -10f;
		}
		if (angle == 5)
		{
			num2 = -2.75f;
			num3 = -6f;
		}
		if (angle == 6)
		{
			num2 = -5f;
			num3 = -5f;
		}
		if (angle == 7)
		{
			num2 = -7.5f;
			num3 = -2.5f;
		}
		if (angle == 8)
		{
			num2 = -10f;
			num3 = 0f;
		}
		Vector2 vector = new Vector2((x + 2) * 16, (y + 2) * 16);
		float num6 = num2;
		float num7 = num3;
		float num8 = (float)Math.Sqrt(num6 * num6 + num7 * num7);
		if (ammo == 4 || ammo == 5)
		{
			if (angle == 4)
			{
				vector.X += 5f;
			}
			vector.Y += 5f;
		}
		bool flag = true;
		if (ammo == 2 && !BunnyCannonCanFire())
		{
			flag = false;
		}
		if (!flag)
		{
			return;
		}
		num8 = num / num8;
		num6 *= num8;
		num7 *= num8;
		if (Main.myPlayer != owner && Main.netMode == 2 && (ammo == 4 || ammo == 5))
		{
			NetMessage.SendData(108, owner, -1, null, Damage, KnockBack, x, y, angle, ammo, owner);
			return;
		}
		if (Main.netMode == 2)
		{
			owner = Main.myPlayer;
		}
		int num9 = Projectile.NewProjectile(GetProjectileSource_PlayerOrWires(x, y, fromWire, Main.player[owner]), vector.X, vector.Y, num6, num7, type, Damage, KnockBack, owner, num4, num5);
		Main.projectile[num9].originatedFromActivableTile = true;
	}

	public static bool BunnyCannonCanFire()
	{
		int num = 1;
		int num2 = 0;
		int num3 = 0;
		int num4 = 4;
		int num5 = 100;
		for (int i = 0; i < num5; i++)
		{
			NPC nPC = Main.npc[i];
			if (nPC == null || !nPC.active)
			{
				num2++;
			}
			else if (nPC.type == 614)
			{
				num3++;
				if (num3 >= num4)
				{
					return false;
				}
			}
		}
		for (int j = 0; j < Main.projectile.Length; j++)
		{
			Projectile projectile = Main.projectile[j];
			if (projectile != null && projectile.active && projectile.type == 281)
			{
				num3++;
				if (num3 >= num4)
				{
					return false;
				}
				num2--;
				if (num2 <= 0)
				{
					return false;
				}
			}
		}
		return num2 >= num;
	}

	public static void SwitchCannon(int i, int j)
	{
		int num;
		for (num = Main.tile[i, j].frameX / 18; num >= 4; num -= 4)
		{
		}
		int num2;
		for (num2 = Main.tile[i, j].frameY / 18; num2 >= 3; num2 -= 3)
		{
		}
		int num3 = 1;
		if (num < 2)
		{
			num3 = -1;
		}
		num = i - num;
		num2 = j - num2;
		if ((num3 == 1 && Main.tile[num, num2].frameY <= 52) || (num3 == -1 && Main.tile[num, num2].frameY >= 432))
		{
			return;
		}
		num3 *= -54;
		for (int k = num; k < num + 4; k++)
		{
			for (int l = num2; l < num2 + 3; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = new Tile();
				}
				if (Main.tile[k, l].active() && Main.tile[k, l].type == 209)
				{
					Main.tile[k, l].frameY = (short)(Main.tile[k, l].frameY + num3);
				}
			}
		}
		NetMessage.SendTileSquare(-1, num, num2, 4, 3);
	}

	public static void CheckCannon(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = Main.tile[i, j].frameX / 18;
		int num2 = 0;
		while (num >= 4)
		{
			num2++;
			num -= 4;
		}
		num = i - num;
		int num3 = Main.tile[i, j].frameY / 18;
		int num4 = 0;
		while (num3 >= 3)
		{
			num4 += 54;
			num3 -= 3;
		}
		num3 = j - num3;
		int num5 = 72 * num2;
		for (int k = num; k < num + 4; k++)
		{
			int num6 = num4;
			for (int l = num3; l < num3 + 3; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = new Tile();
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != num5 || Main.tile[k, l].frameY != num6)
				{
					flag = true;
				}
				num6 += 18;
			}
			if (Main.tile[k, num3 + 3] == null)
			{
				Main.tile[k, num3 + 3] = new Tile();
			}
			if (!SolidTileAllowBottomSlope(k, num3 + 3) && k != num && k != num + 3)
			{
				flag = true;
			}
			num5 += 18;
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		for (int m = num; m < num + 4; m++)
		{
			for (int n = num3; n < num3 + 3; n++)
			{
				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
				{
					KillTile(m, n);
				}
			}
		}
		int type2 = 928;
		switch (num2)
		{
		case 1:
			type2 = 1337;
			break;
		case 2:
			type2 = 3369;
			break;
		case 3:
		case 4:
			type2 = 3664;
			break;
		}
		Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, type2);
		destroyObject = false;
		for (int num7 = num; num7 < num + 4; num7++)
		{
			for (int num8 = num3; num8 < num3 + 3; num8++)
			{
				TileFrame(num7, num8);
			}
		}
	}

	public static void PlaceCannon(int x, int y, ushort type, int style = 0)
	{
		if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
		{
			return;
		}
		bool flag = true;
		for (int i = x - 1; i < x + 3; i++)
		{
			for (int j = y - 2; j < y + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = new Tile();
				}
				if (Main.tile[i, j].active())
				{
					flag = false;
				}
			}
			if (Main.tile[i, y + 1] == null)
			{
				Main.tile[i, y + 1] = new Tile();
			}
			if (!SolidTile2(i, y + 1) && i != x - 1 && i != x + 2)
			{
				flag = false;
			}
		}
		int num = 72 * style;
		int num2 = 0;
		if (flag)
		{
			Main.tile[x - 1, y - 2].active(active: true);
			Main.tile[x - 1, y - 2].frameY = (short)num2;
			Main.tile[x - 1, y - 2].frameX = (short)num;
			Main.tile[x - 1, y - 2].type = type;
			Main.tile[x, y - 2].active(active: true);
			Main.tile[x, y - 2].frameY = (short)num2;
			Main.tile[x, y - 2].frameX = (short)(18 + num);
			Main.tile[x, y - 2].type = type;
			Main.tile[x + 1, y - 2].active(active: true);
			Main.tile[x + 1, y - 2].frameY = (short)num2;
			Main.tile[x + 1, y - 2].frameX = (short)(36 + num);
			Main.tile[x + 1, y - 2].type = type;
			Main.tile[x + 2, y - 2].active(active: true);
			Main.tile[x + 2, y - 2].frameY = (short)num2;
			Main.tile[x + 2, y - 2].frameX = (short)(54 + num);
			Main.tile[x + 2, y - 2].type = type;
			Main.tile[x - 1, y - 1].active(active: true);
			Main.tile[x - 1, y - 1].frameY = (short)(num2 + 18);
			Main.tile[x - 1, y - 1].frameX = (short)num;
			Main.tile[x - 1, y - 1].type = type;
			Main.tile[x, y - 1].active(active: true);
			Main.tile[x, y - 1].frameY = (short)(num2 + 18);
			Main.tile[x, y - 1].frameX = (short)(18 + num);
			Main.tile[x, y - 1].type = type;
			Main.tile[x + 1, y - 1].active(active: true);
			Main.tile[x + 1, y - 1].frameY = (short)(num2 + 18);
			Main.tile[x + 1, y - 1].frameX = (short)(36 + num);
			Main.tile[x + 1, y - 1].type = type;
			Main.tile[x + 2, y - 1].active(active: true);
			Main.tile[x + 2, y - 1].frameY = (short)(num2 + 18);
			Main.tile[x + 2, y - 1].frameX = (short)(54 + num);
			Main.tile[x + 2, y - 1].type = type;
			Main.tile[x - 1, y].active(active: true);
			Main.tile[x - 1, y].frameY = (short)(num2 + 36);
			Main.tile[x - 1, y].frameX = (short)num;
			Main.tile[x - 1, y].type = type;
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].frameY = (short)(num2 + 36);
			Main.tile[x, y].frameX = (short)(18 + num);
			Main.tile[x, y].type = type;
			Main.tile[x + 1, y].active(active: true);
			Main.tile[x + 1, y].frameY = (short)(num2 + 36);
			Main.tile[x + 1, y].frameX = (short)(36 + num);
			Main.tile[x + 1, y].type = type;
			Main.tile[x + 2, y].active(active: true);
			Main.tile[x + 2, y].frameY = (short)(num2 + 36);
			Main.tile[x + 2, y].frameX = (short)(54 + num);
			Main.tile[x + 2, y].type = type;
		}
	}

	public static void SwitchMB(int i, int j)
	{
		int num = i;
		int num2 = j;
		int num3;
		for (num3 = Main.tile[i, j].frameY / 18; num3 >= 2; num3 -= 2)
		{
		}
		int num4 = Main.tile[i, j].frameX / 18;
		if (num4 >= 2)
		{
			num4 -= 2;
		}
		num = i - num4;
		num2 = j - num3;
		for (int k = num; k < num + 2; k++)
		{
			for (int l = num2; l < num2 + 2; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = new Tile();
				}
				if (Main.tile[k, l].active() && (Main.tile[k, l].type == 139 || Main.tile[k, l].type == 35))
				{
					if (Main.tile[k, l].frameX < 36)
					{
						Main.tile[k, l].frameX += 36;
					}
					else
					{
						Main.tile[k, l].frameX -= 36;
					}
				}
			}
		}
		if (Wiring.running)
		{
			Wiring.SkipWire(num, num2);
			Wiring.SkipWire(num + 1, num2);
			Wiring.SkipWire(num, num2 + 1);
			Wiring.SkipWire(num + 1, num2 + 1);
		}
		NetMessage.SendTileSquare(-1, num, num2, 2, 2);
	}

	public static void SwitchMonolith(int i, int j)
	{
		int num = 2;
		int num2 = 3;
		ushort type = Main.tile[i, j].type;
		if (type == 733)
		{
			num = 3;
		}
		int num3 = i;
		int num4 = j;
		int num5;
		for (num5 = Main.tile[i, j].frameX / 18; num5 >= num; num5 -= num)
		{
		}
		int num6;
		for (num6 = Main.tile[i, j].frameY / 18; num6 >= num2; num6 -= num2)
		{
		}
		num3 = i - num5;
		num4 = j - num6;
		for (int k = num3; k < num3 + num; k++)
		{
			for (int l = num4; l < num4 + num2; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = new Tile();
				}
				Tile tile = Main.tile[k, l];
				if (!tile.active())
				{
					continue;
				}
				if (tile.type == 410)
				{
					if (tile.frameY < 56)
					{
						tile.frameY += 56;
					}
					else
					{
						tile.frameY -= 56;
					}
				}
				else if (tile.type == 480)
				{
					if (tile.frameY < 54)
					{
						tile.frameY += 54;
					}
					else
					{
						tile.frameY -= 54;
					}
				}
				else if (tile.type == 509)
				{
					if (tile.frameY < 54)
					{
						tile.frameY += 54;
					}
					else
					{
						tile.frameY -= 54;
					}
				}
				else if (tile.type == 657)
				{
					if (tile.frameY < 54)
					{
						tile.frameY += 54;
					}
					else
					{
						tile.frameY -= 54;
					}
				}
				else if (tile.type == 658)
				{
					short num7 = 54;
					short num8 = 3;
					short num9 = (short)(num7 * num8);
					tile.frameY += num7;
					if (tile.frameY >= num9)
					{
						tile.frameY -= num9;
					}
				}
				else if (tile.type == 720)
				{
					if (tile.frameY < 54)
					{
						tile.frameY += 54;
					}
					else
					{
						tile.frameY -= 54;
					}
				}
				else if (tile.type == 721)
				{
					if (tile.frameY < 54)
					{
						tile.frameY += 54;
					}
					else
					{
						tile.frameY -= 54;
					}
				}
				else if (tile.type == 725)
				{
					if (tile.frameY < 54)
					{
						tile.frameY += 54;
					}
					else
					{
						tile.frameY -= 54;
					}
				}
				else if (tile.type == 733)
				{
					if (tile.frameY < 54)
					{
						tile.frameY += 54;
					}
					else
					{
						tile.frameY -= 54;
					}
				}
			}
		}
		if (Wiring.running)
		{
			for (int m = num3; m < num3 + num; m++)
			{
				for (int n = num4; n < num4 + num2; n++)
				{
					Wiring.SkipWire(m, n);
				}
			}
		}
		NetMessage.SendTileSquare(-1, num3, num4, num, num2);
	}

	public static void SwitchFountain(int i, int j)
	{
		int num = i;
		int num2 = j;
		int num3;
		for (num3 = Main.tile[i, j].frameX / 18; num3 >= 2; num3 -= 2)
		{
		}
		int num4 = Main.tile[i, j].frameY / 18;
		if (num4 >= 4)
		{
			num4 -= 4;
		}
		num = i - num3;
		num2 = j - num4;
		for (int k = num; k < num + 2; k++)
		{
			for (int l = num2; l < num2 + 4; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = new Tile();
				}
				if (Main.tile[k, l].active() && Main.tile[k, l].type == 207)
				{
					if (Main.tile[k, l].frameY < 72)
					{
						Main.tile[k, l].frameY += 72;
					}
					else
					{
						Main.tile[k, l].frameY -= 72;
					}
				}
			}
		}
		if (Wiring.running)
		{
			Wiring.SkipWire(num, num2);
			Wiring.SkipWire(num, num2 + 1);
			Wiring.SkipWire(num, num2 + 2);
			Wiring.SkipWire(num, num2 + 3);
			Wiring.SkipWire(num + 1, num2);
			Wiring.SkipWire(num + 1, num2 + 1);
			Wiring.SkipWire(num + 1, num2 + 2);
			Wiring.SkipWire(num + 1, num2 + 3);
		}
		NetMessage.SendTileSquare(-1, num, num2, 2, 4);
	}

	public static void CheckMB(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = i;
		int num2 = j;
		int num3 = 0;
		int num4;
		for (num4 = Main.tile[i, j].frameY / 18; num4 >= 2; num4 -= 2)
		{
			num3++;
		}
		int num5 = Main.tile[i, j].frameX / 18;
		int num6 = 0;
		if (num5 >= 2)
		{
			num5 -= 2;
			num6++;
		}
		num = i - num5;
		num2 = j - num4;
		for (int k = num; k < num + 2; k++)
		{
			for (int l = num2; l < num2 + 2; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = new Tile();
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num) * 18 + num6 * 36 || Main.tile[k, l].frameY != (l - num2) * 18 + num3 * 36)
				{
					flag = true;
				}
			}
			if (!Main.tile[k, num2 + 2].nactive())
			{
				flag = true;
			}
			else if (!Main.tileSolid[Main.tile[k, num2 + 2].type] && !Main.tileTable[Main.tile[k, num2 + 2].type])
			{
				flag = true;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		for (int m = num; m < num + 2; m++)
		{
			for (int n = num2; n < num2 + 3; n++)
			{
				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
				{
					KillTile(m, n);
				}
			}
		}
		if (type == 35)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1813);
		}
		else
		{
			int itemDrop_MusicBoxes = GetItemDrop_MusicBoxes(num3);
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, itemDrop_MusicBoxes);
		}
		for (int num7 = num - 1; num7 < num + 3; num7++)
		{
			for (int num8 = num2 - 1; num8 < num2 + 3; num8++)
			{
				TileFrame(num7, num8);
			}
		}
		destroyObject = false;
	}

	public static void PlaceMB(int X, int y, ushort type, int style)
	{
		int num = X + 1;
		if (num < 5 || num > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
		{
			return;
		}
		bool flag = true;
		for (int i = num - 1; i < num + 1; i++)
		{
			for (int j = y - 1; j < y + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = new Tile();
				}
				if (Main.tile[i, j].active())
				{
					flag = false;
				}
			}
			if (Main.tile[i, y + 1] == null)
			{
				Main.tile[i, y + 1] = new Tile();
			}
			if (!Main.tile[i, y + 1].active() || Main.tile[i, y + 1].halfBrick() || (!Main.tileSolid[Main.tile[i, y + 1].type] && !Main.tileTable[Main.tile[i, y + 1].type]))
			{
				flag = false;
			}
		}
		if (flag)
		{
			Main.tile[num - 1, y - 1].active(active: true);
			Main.tile[num - 1, y - 1].frameY = (short)(style * 36);
			Main.tile[num - 1, y - 1].frameX = 0;
			Main.tile[num - 1, y - 1].type = type;
			Main.tile[num, y - 1].active(active: true);
			Main.tile[num, y - 1].frameY = (short)(style * 36);
			Main.tile[num, y - 1].frameX = 18;
			Main.tile[num, y - 1].type = type;
			Main.tile[num - 1, y].active(active: true);
			Main.tile[num - 1, y].frameY = (short)(style * 36 + 18);
			Main.tile[num - 1, y].frameX = 0;
			Main.tile[num - 1, y].type = type;
			Main.tile[num, y].active(active: true);
			Main.tile[num, y].frameY = (short)(style * 36 + 18);
			Main.tile[num, y].frameX = 18;
			Main.tile[num, y].type = type;
		}
	}

	public static void Place2x2(int x, int y, ushort type, int style)
	{
		if (type == 95 || type == 126)
		{
			y++;
		}
		if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
		{
			return;
		}
		if (type == 172)
		{
			if (!CanPlaceSink(x, y, type, style))
			{
				return;
			}
		}
		else
		{
			for (int i = x - 1; i < x + 1; i++)
			{
				for (int j = y - 1; j < y + 1; j++)
				{
					Tile tileSafely = Framing.GetTileSafely(i, j);
					if (tileSafely.active() || (type == 98 && tileSafely.liquid > 0))
					{
						return;
					}
				}
				switch (type)
				{
				case 95:
				case 126:
				{
					Tile tileSafely = Framing.GetTileSafely(i, y - 2);
					if (!tileSafely.nactive() || !Main.tileSolid[tileSafely.type] || Main.tileSolidTop[tileSafely.type])
					{
						return;
					}
					break;
				}
				default:
				{
					Tile tileSafely = Framing.GetTileSafely(i, y + 1);
					if (!tileSafely.nactive() || (!SolidTile2(tileSafely) && !Main.tileTable[tileSafely.type]))
					{
						return;
					}
					break;
				}
				case 132:
					break;
				}
			}
		}
		if (type == 132)
		{
			bool flag = true;
			if (Main.tile[x - 1, y + 1] == null)
			{
				Main.tile[x - 1, y + 1] = new Tile();
			}
			if (Main.tile[x, y + 1] == null)
			{
				Main.tile[x, y + 1] = new Tile();
			}
			if (!Main.tile[x - 1, y + 1].nactive() || (!SolidTile2(x - 1, y + 1) && !Main.tileTable[Main.tile[x - 1, y + 1].type]))
			{
				flag = false;
			}
			if (!Main.tile[x, y + 1].nactive() || (!SolidTile2(x, y + 1) && !Main.tileTable[Main.tile[x, y + 1].type]))
			{
				flag = false;
			}
			if (!flag && (Main.tile[x - 1, y - 1].wall < 1 || Main.tile[x, y - 1].wall < 1 || Main.tile[x - 1, y].wall < 1 || Main.tile[x - 1, y].wall < 1))
			{
				return;
			}
		}
		x--;
		y--;
		int num = ((type == 172) ? 38 : 36);
		for (int k = 0; k < 2; k++)
		{
			for (int l = 0; l < 2; l++)
			{
				Tile tileSafely = Main.tile[x + k, y + l];
				tileSafely.active(active: true);
				tileSafely.frameX = (short)(k * 18);
				tileSafely.frameY = (short)(style * num + l * 18);
				tileSafely.type = type;
			}
		}
	}

	public static bool PlaceObject(int x, int y, int type, bool mute = false, int style = 0, int alternate = 0, int random = -1, int direction = -1)
	{
		if (type >= TileID.Count)
		{
			return false;
		}
		if (!TileObject.CanPlace(x, y, type, style, direction, out var objectData))
		{
			return false;
		}
		objectData.random = random;
		if (TileObject.Place(objectData))
		{
			SquareTileFrame(x, y);
			if (!mute)
			{
				SoundEngine.PlaySound(0, x * 16, y * 16);
			}
		}
		return true;
	}

	public static bool ShiftTrapdoor(int x, int y, bool playerAbove, int onlyCloseOrOpen = -1)
	{
		Tile tileSafely = Framing.GetTileSafely(x, y);
		if (tileSafely.type == 386 && onlyCloseOrOpen != 1)
		{
			Point topLeftAndStyles = GetTopLeftAndStyles(ref x, ref y, 2, 2, 18, 18);
			if (topLeftAndStyles.X == 0)
			{
				if (!ValidateTileSquareIsActiveAndOfType(x, y, 2, 2, 386))
				{
					return false;
				}
				if (Main.netMode != 1 && Wiring.running)
				{
					Wiring.SkipWire(x, y);
					Wiring.SkipWire(x, y + 1);
					Wiring.SkipWire(x + 1, y);
					Wiring.SkipWire(x + 1, y + 1);
				}
				if (!Collision.EmptyTile(x, y + 1, ignoreTiles: true) || !Collision.EmptyTile(x + 1, y + 1, ignoreTiles: true))
				{
					return false;
				}
				SoundEngine.PlaySound(8, x * 16 + 16, y * 16 + 16);
				for (int i = 0; i < 2; i++)
				{
					tileSafely = Framing.GetTileSafely(x + i, y);
					if (tileSafely.active() && tileSafely.type == 386)
					{
						tileSafely.ClearTile();
					}
				}
				for (int j = 0; j < 2; j++)
				{
					tileSafely = Framing.GetTileSafely(x + j, y + 1);
					tileSafely.type = 387;
					tileSafely.frameX = (short)(j * 18);
					tileSafely.frameY = (short)(topLeftAndStyles.Y * 18);
				}
				for (int k = -1; k < 3; k++)
				{
					for (int l = 0; l < 3; l++)
					{
						TileFrame(x + k, y + l);
					}
				}
				return true;
			}
			if (topLeftAndStyles.X == 1)
			{
				if (!ValidateTileSquareIsActiveAndOfType(x, y, 2, 2, 386))
				{
					return false;
				}
				if (Main.netMode != 1 && Wiring.running)
				{
					Wiring.SkipWire(x, y - 1);
					Wiring.SkipWire(x, y);
					Wiring.SkipWire(x + 1, y - 1);
					Wiring.SkipWire(x + 1, y);
				}
				if (!Collision.EmptyTile(x, y, ignoreTiles: true) || !Collision.EmptyTile(x + 1, y, ignoreTiles: true))
				{
					return false;
				}
				SoundEngine.PlaySound(8, x * 16 + 16, y * 16);
				for (int m = 0; m < 2; m++)
				{
					tileSafely = Framing.GetTileSafely(x + m, y + 1);
					tileSafely.ClearTile();
				}
				for (int n = 0; n < 2; n++)
				{
					tileSafely = Framing.GetTileSafely(x + n, y);
					tileSafely.type = 387;
					tileSafely.frameX = (short)(n * 18);
					tileSafely.frameY = (short)(topLeftAndStyles.Y * 18);
				}
				for (int num = -1; num < 3; num++)
				{
					for (int num2 = -1; num2 < 2; num2++)
					{
						TileFrame(x + num, y + num2);
					}
				}
				return true;
			}
		}
		if (tileSafely.type == 387 && onlyCloseOrOpen != 0)
		{
			GetTopLeftAndStyles(ref x, ref y, 2, 1, 18, 18);
			Tile tileSafely2 = Framing.GetTileSafely(x, y);
			Tile tileSafely3 = Framing.GetTileSafely(x + 1, y);
			if ((tileSafely2.active() && tileSafely2.type == 387 && !CanKillTile(x, y)) || (tileSafely3.active() && tileSafely3.type == 387 && !CanKillTile(x + 1, y)))
			{
				return false;
			}
			if (!ValidateTileSquareIsActiveAndOfType(x, y, 2, 1, 387))
			{
				return false;
			}
			int num3 = playerAbove.ToDirectionInt();
			for (int num4 = 0; num4 < 2; num4++)
			{
				tileSafely = Framing.GetTileSafely(x + num4, y + num3);
				if (tileSafely.active() && !Main.tileCut[tileSafely.type] && !TileID.Sets.IsADripTile[tileSafely.type])
				{
					return false;
				}
			}
			if (Main.netMode != 1 && Wiring.running)
			{
				Wiring.SkipWire(x, y);
				Wiring.SkipWire(x, y + num3);
				Wiring.SkipWire(x + 1, y);
				Wiring.SkipWire(x + 1, y + num3);
			}
			SoundEngine.PlaySound(8, x * 16 + 16, y * 16);
			for (int num5 = 0; num5 < 2; num5++)
			{
				tileSafely = Framing.GetTileSafely(x + num5, y + num3);
				if (tileSafely.active() && (Main.tileCut[tileSafely.type] || TileID.Sets.IsADripTile[tileSafely.type]))
				{
					KillTile(x + num5, y + num3);
				}
			}
			for (int num6 = 0; num6 < 2; num6++)
			{
				tileSafely = Framing.GetTileSafely(x + num6, y);
				TileColorCache cache = tileSafely.BlockColorAndCoating();
				for (int num7 = 0; num7 < 2; num7++)
				{
					tileSafely = Framing.GetTileSafely(x + num6, y + num7 - (!playerAbove).ToInt());
					tileSafely.type = 386;
					tileSafely.frameX = (short)(num6 * 18 + playerAbove.ToInt() * 36);
					tileSafely.frameY = (short)(num7 * 18);
					tileSafely.UseBlockColors(cache);
					tileSafely.active(active: true);
				}
			}
			for (int num8 = -1; num8 < 3; num8++)
			{
				for (int num9 = -1; num9 < 3; num9++)
				{
					TileFrame(x + num8, y + num9 - (!playerAbove).ToInt() * 2);
				}
			}
			return true;
		}
		SoundEngine.PlaySound(9, x * 16, y * 16);
		return false;
	}

	public static void CheckTrapDoor(int x, int y, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = 0;
		int num2 = 0;
		Point point = default(Point);
		if (type == 387)
		{
			num = 2;
			num2 = 1;
			point = GetTopLeftAndStyles(ref x, ref y, num, num2, 18, 18);
			flag = flag || !CheckTileFrames(type, x, y, num, num2, point.X, 18, point.Y, 18) || !CheckTileAnchors(x, y, num, num2, 1, AnchorType.SolidTile);
		}
		if (type == 386)
		{
			num = 2;
			num2 = 2;
			point = GetTopLeftAndStyles(ref x, ref y, num, num2, 18, 18);
			flag = flag || !CheckTileFrames(type, x, y, num, num2, point.X, 18, point.Y, 18);
			if (point.X == 0)
			{
				flag = flag || !CheckTileAnchors(x, y + 1, num, 1, 1, AnchorType.SolidTile);
			}
			else if (point.X == 1)
			{
				flag = flag || !CheckTileAnchors(x, y, num, 1, 1, AnchorType.SolidTile);
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		for (int i = x; i < x + num; i++)
		{
			for (int j = y; j < y + num2; j++)
			{
				KillTile(i, j);
			}
		}
		int type2 = 3239;
		if (point.Y == 0)
		{
			type2 = 3239;
		}
		Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, num * 16, num2 * 16, type2);
		destroyObject = false;
		for (int k = x - 1; k < x + num + 1; k++)
		{
			for (int l = y - 1; l < y + num2 + 1; l++)
			{
				TileFrame(k, l);
			}
		}
		CheckExploitDestroyQueue();
	}

	public static void CheckTallGate(int x, int y, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		Tile tileSafely = Framing.GetTileSafely(x, y);
		Point point = new Point(tileSafely.frameX / 18, 0);
		TileObjectData tileData = TileObjectData.GetTileData(type, point.X);
		point.Y = tileSafely.frameY / tileData.CoordinateFullHeight;
		int width = tileData.Width;
		int height = tileData.Height;
		int i = 0;
		for (int num = tileSafely.frameY % tileData.CoordinateFullHeight; i < height && num - tileData.CoordinateHeights[i] >= 0; i++)
		{
			num -= tileData.CoordinateHeights[i];
		}
		_ = tileData.CoordinateFullHeight;
		y -= i;
		int num2 = point.Y * tileData.CoordinateFullHeight;
		for (int j = 0; j < height; j++)
		{
			tileSafely = Framing.GetTileSafely(x, y + j);
			if (tileSafely.frameX != point.X * tileData.CoordinateFullWidth || tileSafely.frameY != num2)
			{
				flag = true;
				break;
			}
			num2 += tileData.CoordinateHeights[j] + tileData.CoordinatePadding;
		}
		if (!flag && CheckTileAnchors(x, y, width, height, 2, AnchorType.SolidTile))
		{
			return;
		}
		destroyObject = true;
		for (int k = x; k < x + width; k++)
		{
			for (int l = y; l < y + height; l++)
			{
				Tile tile = Main.tile[k, l];
				if (tile != null && tile.active() && tile.type == type)
				{
					KillTile(k, l);
				}
			}
		}
		int type2 = 3240;
		if (point.Y == 0)
		{
			type2 = 3240;
		}
		Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, width * 16, height * 16, type2);
		destroyObject = false;
		for (int m = x - 1; m < x + width + 1; m++)
		{
			for (int n = y - 1; n < y + height + 1; n++)
			{
				TileFrame(m, n);
			}
		}
		CheckExploitDestroyQueue();
	}

	public static bool ShiftTallGate(int x, int y, bool closing, bool forced = false)
	{
		ushort type = (ushort)(closing ? 388 : 389);
		ushort num = (ushort)(closing ? 389 : 388);
		Tile tileSafely = Framing.GetTileSafely(x, y);
		if (tileSafely.type != num)
		{
			return false;
		}
		Point point = new Point(tileSafely.frameX / 18, 0);
		TileObjectData tileData = TileObjectData.GetTileData(388, point.X);
		point.Y = tileSafely.frameY / tileData.CoordinateFullHeight;
		int width = tileData.Width;
		int height = tileData.Height;
		int i = 0;
		for (int num2 = tileSafely.frameY % tileData.CoordinateFullHeight; i < height && num2 - tileData.CoordinateHeights[i] >= 0; i++)
		{
			num2 -= tileData.CoordinateHeights[i];
		}
		_ = tileData.CoordinateFullHeight;
		y -= i;
		if (!ValidateTileSquareIsActiveAndOfType(x, y, width, height, num))
		{
			return false;
		}
		if (Main.netMode != 1 && Wiring.running)
		{
			for (int j = 0; j < height; j++)
			{
				Wiring.SkipWire(x, y + j);
			}
		}
		for (int k = 0; k < height; k++)
		{
			if (!forced && !Collision.EmptyTile(x, y + k, ignoreTiles: true))
			{
				return false;
			}
		}
		SoundEngine.PlaySound(8, x * 16 + 16, y * 16 + 16);
		for (int l = 0; l < height; l++)
		{
			tileSafely = Framing.GetTileSafely(x, y + l);
			tileSafely.type = type;
		}
		for (int m = -1; m < 2; m++)
		{
			for (int n = -1; n < height + 1; n++)
			{
				TileFrame(x + m, y + n);
			}
		}
		return true;
	}

	public static Point GetTopLeftAndStyles(ref int x, ref int y, int w, int h, int frameXinc, int frameYinc)
	{
		Tile tileSafely = Framing.GetTileSafely(x, y);
		Point result = new Point(tileSafely.frameX / (w * frameXinc), tileSafely.frameY / (h * frameYinc));
		if (frameXinc != 0)
		{
			x -= tileSafely.frameX / frameXinc % w;
		}
		if (frameYinc != 0)
		{
			y -= tileSafely.frameY / frameYinc % h;
		}
		return result;
	}

	public static bool CheckTileFrames(int type, int sx, int sy, int w, int h, int styleX, int frameXinc, int styleY, int frameYinc)
	{
		for (int i = 0; i < w; i++)
		{
			for (int j = 0; j < h; j++)
			{
				Tile tileSafely = Framing.GetTileSafely(sx + i, sy + j);
				if (!tileSafely.active() || tileSafely.type != type || tileSafely.frameX != styleX * w * frameXinc + i * frameXinc || tileSafely.frameY != styleY * h * frameYinc + j * frameYinc)
				{
					return false;
				}
			}
		}
		return true;
	}

	public static bool CheckTileAnchors(int sx, int sy, int w, int h, int mode, AnchorType anchor)
	{
		if ((mode & 1) == 1)
		{
			for (int i = sy; i < sy + h; i++)
			{
				if (!AnchorValid(Framing.GetTileSafely(sx - 1, i), anchor))
				{
					return false;
				}
				if (!AnchorValid(Framing.GetTileSafely(sx + w, i), anchor))
				{
					return false;
				}
			}
		}
		if ((mode & 2) == 2)
		{
			for (int j = sx; j < sx + w; j++)
			{
				if (!AnchorValid(Framing.GetTileSafely(j, sy - 1), anchor))
				{
					return false;
				}
				if (!AnchorValid(Framing.GetTileSafely(j, sy + h), anchor))
				{
					return false;
				}
			}
		}
		return true;
	}

	public static bool AnchorValid(Tile tileCache, AnchorType anchor)
	{
		bool flag = false;
		if (tileCache.nactive())
		{
			if ((anchor & AnchorType.SolidTile) == AnchorType.SolidTile && Main.tileSolid[tileCache.type] && !Main.tileSolidTop[tileCache.type] && !Main.tileNoAttach[tileCache.type] && tileCache.blockType() == 0)
			{
				flag = true;
			}
			if ((anchor & AnchorType.SolidBottom) == AnchorType.SolidBottom && ((Main.tileSolid[tileCache.type] && (!Main.tileSolidTop[tileCache.type] || (TileID.Sets.Platforms[tileCache.type] && (tileCache.halfBrick() || tileCache.topSlope())))) || tileCache.topSlope() || tileCache.halfBrick()) && !TileID.Sets.NotReallySolid[tileCache.type] && !tileCache.bottomSlope())
			{
				flag = true;
			}
			if (!flag && ((anchor & AnchorType.SolidWithTop) == AnchorType.SolidWithTop || (anchor & AnchorType.Table) == AnchorType.Table))
			{
				if (TileID.Sets.Platforms[tileCache.type])
				{
					int num = tileCache.frameX / TileObjectData.PlatformFrameWidth();
					if ((!tileCache.halfBrick() && num >= 0 && num <= 7) || (num >= 12 && num <= 16) || (num >= 25 && num <= 26))
					{
						flag = true;
					}
				}
				else if (Main.tileSolid[tileCache.type] && Main.tileSolidTop[tileCache.type])
				{
					flag = true;
				}
			}
			if (!flag && (anchor & AnchorType.Table) == AnchorType.Table && !TileID.Sets.Platforms[tileCache.type] && Main.tileTable[tileCache.type] && tileCache.blockType() == 0)
			{
				flag = true;
			}
			if (!flag && (anchor & AnchorType.SolidSide) == AnchorType.SolidSide && Main.tileSolid[tileCache.type] && !Main.tileSolidTop[tileCache.type])
			{
				int num2 = tileCache.blockType();
				if ((uint)(num2 - 4) <= 1u)
				{
					flag = true;
				}
			}
		}
		else if (!flag && (anchor & AnchorType.EmptyTile) == AnchorType.EmptyTile)
		{
			flag = true;
		}
		return flag;
	}

	public static bool CanPlaceSink(int x, int y, ushort type, int style)
	{
		if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
		{
			return false;
		}
		bool result = true;
		x--;
		y--;
		for (int i = 0; i < 2; i++)
		{
			Tile tileSafely;
			for (int j = 0; j < 2; j++)
			{
				tileSafely = Framing.GetTileSafely(x + i, y + j);
				if (tileSafely.active())
				{
					result = false;
				}
			}
			tileSafely = Framing.GetTileSafely(x + i, y + 2);
			if (!tileSafely.nactive() || !SolidTile(tileSafely))
			{
				result = false;
			}
		}
		return result;
	}

	public static void Place3x4(int x, int y, ushort type, int style)
	{
		if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
		{
			return;
		}
		bool flag = true;
		for (int i = x - 1; i < x + 2; i++)
		{
			for (int j = y - 3; j < y + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = new Tile();
				}
				if (Main.tile[i, j].active())
				{
					flag = false;
				}
			}
			if (Main.tile[i, y + 1] == null)
			{
				Main.tile[i, y + 1] = new Tile();
			}
			if (!SolidTile2(i, y + 1))
			{
				flag = false;
			}
		}
		if (flag)
		{
			int num = style * 54;
			for (int k = -3; k <= 0; k++)
			{
				short frameY = (short)((3 + k) * 18);
				Main.tile[x - 1, y + k].active(active: true);
				Main.tile[x - 1, y + k].frameY = frameY;
				Main.tile[x - 1, y + k].frameX = (short)num;
				Main.tile[x - 1, y + k].type = type;
				Main.tile[x, y + k].active(active: true);
				Main.tile[x, y + k].frameY = frameY;
				Main.tile[x, y + k].frameX = (short)(num + 18);
				Main.tile[x, y + k].type = type;
				Main.tile[x + 1, y + k].active(active: true);
				Main.tile[x + 1, y + k].frameY = frameY;
				Main.tile[x + 1, y + k].frameX = (short)(num + 36);
				Main.tile[x + 1, y + k].type = type;
			}
		}
	}

	public static void Place5x4(int x, int y, ushort type, int style)
	{
		if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
		{
			return;
		}
		bool flag = true;
		for (int i = x - 2; i < x + 3; i++)
		{
			for (int j = y - 3; j < y + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = new Tile();
				}
				if (Main.tile[i, j].active())
				{
					flag = false;
				}
			}
			if (Main.tile[i, y + 1] == null)
			{
				Main.tile[i, y + 1] = new Tile();
			}
			if (!SolidTile2(i, y + 1))
			{
				flag = false;
			}
		}
		if (flag)
		{
			int num = style * 54;
			for (int k = -3; k <= 0; k++)
			{
				short frameY = (short)((3 + k) * 18);
				Main.tile[x - 2, y + k].active(active: true);
				Main.tile[x - 2, y + k].frameY = frameY;
				Main.tile[x - 2, y + k].frameX = (short)(num - 36);
				Main.tile[x - 2, y + k].type = type;
				Main.tile[x - 1, y + k].active(active: true);
				Main.tile[x - 1, y + k].frameY = frameY;
				Main.tile[x - 1, y + k].frameX = (short)(num - 18);
				Main.tile[x - 1, y + k].type = type;
				Main.tile[x, y + k].active(active: true);
				Main.tile[x, y + k].frameY = frameY;
				Main.tile[x, y + k].frameX = (short)num;
				Main.tile[x, y + k].type = type;
				Main.tile[x + 1, y + k].active(active: true);
				Main.tile[x + 1, y + k].frameY = frameY;
				Main.tile[x + 1, y + k].frameX = (short)(num + 18);
				Main.tile[x + 1, y + k].type = type;
				Main.tile[x + 1, y + k].active(active: true);
				Main.tile[x + 1, y + k].frameY = frameY;
				Main.tile[x + 1, y + k].frameX = (short)(num + 36);
				Main.tile[x + 1, y + k].type = type;
			}
		}
	}

	public static void Place3x1(int x, int y, ushort type, int style = 0)
	{
		if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
		{
			return;
		}
		bool flag = true;
		for (int i = x - 1; i < x + 2; i++)
		{
			if (Main.tile[i, y] == null)
			{
				Main.tile[i, y] = new Tile();
			}
			if (Main.tile[i, y].active())
			{
				flag = false;
			}
			if (Main.tile[i, y + 1] == null)
			{
				Main.tile[i, y + 1] = new Tile();
			}
			if (!SolidTile2(i, y + 1))
			{
				flag = false;
			}
		}
		if (flag)
		{
			short num = (short)(54 * style);
			Main.tile[x - 1, y].active(active: true);
			Main.tile[x - 1, y].frameY = 0;
			Main.tile[x - 1, y].frameX = num;
			Main.tile[x - 1, y].type = type;
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].frameY = 0;
			Main.tile[x, y].frameX = (short)(num + 18);
			Main.tile[x, y].type = type;
			Main.tile[x + 1, y].active(active: true);
			Main.tile[x + 1, y].frameY = 0;
			Main.tile[x + 1, y].frameX = (short)(num + 36);
			Main.tile[x + 1, y].type = type;
		}
	}

	public static void Place3x2(int x, int y, ushort type, int style = 0)
	{
		if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
		{
			return;
		}
		bool flag = false;
		bool flag2 = true;
		if (type == 14 && style == 25)
		{
			flag = true;
		}
		int num = y - 1;
		if (flag)
		{
			num = y;
		}
		for (int i = x - 1; i < x + 2; i++)
		{
			for (int j = num; j < y + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = new Tile();
				}
				Tile tile = Main.tile[i, j];
				if (tile.active())
				{
					flag2 = false;
				}
				if (TileID.Sets.Campfires[type] && tile.liquid > 0)
				{
					flag2 = false;
				}
			}
			if (Main.tile[i, y + 1] == null)
			{
				Main.tile[i, y + 1] = new Tile();
			}
			switch (type)
			{
			default:
				if (type != 582 && type != 619)
				{
					if ((type == 186 || type == 187) && InvalidTileForPilesOrSpeleothems(i, y + 1))
					{
						flag2 = false;
					}
					if (type == 26 && TileID.Sets.Boulders[Main.tile[i, y + 1].type])
					{
						flag2 = false;
					}
					if (!SolidTile2(i, y + 1))
					{
						flag2 = false;
					}
					break;
				}
				goto case 285;
			case 285:
			case 286:
			case 298:
			case 299:
			case 310:
			case 361:
			case 362:
			case 363:
			case 364:
				if (!SolidTile2(i, y + 1) && (!Main.tile[i, y + 1].nactive() || !Main.tileSolidTop[Main.tile[i, y + 1].type] || Main.tile[i, y + 1].frameY != 0))
				{
					flag2 = false;
				}
				break;
			}
		}
		if (type == 88)
		{
			if (Chest.CreateChest(x - 1, y - 1) == -1)
			{
				flag2 = false;
			}
			else if (Main.netMode == 1)
			{
				NetMessage.SendData(34, -1, -1, null, 2, x, y, style);
			}
		}
		if (flag2)
		{
			short num2 = (short)(54 * style);
			if (flag)
			{
				Main.tile[x - 1, y].active(active: true);
				Main.tile[x - 1, y].frameY = 0;
				Main.tile[x - 1, y].frameX = num2;
				Main.tile[x - 1, y].type = type;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = 0;
				Main.tile[x, y].frameX = (short)(num2 + 18);
				Main.tile[x, y].type = type;
				Main.tile[x + 1, y].active(active: true);
				Main.tile[x + 1, y].frameY = 0;
				Main.tile[x + 1, y].frameX = (short)(num2 + 36);
				Main.tile[x + 1, y].type = type;
				return;
			}
			Main.tile[x - 1, y - 1].active(active: true);
			Main.tile[x - 1, y - 1].frameY = 0;
			Main.tile[x - 1, y - 1].frameX = num2;
			Main.tile[x - 1, y - 1].type = type;
			Main.tile[x, y - 1].active(active: true);
			Main.tile[x, y - 1].frameY = 0;
			Main.tile[x, y - 1].frameX = (short)(num2 + 18);
			Main.tile[x, y - 1].type = type;
			Main.tile[x + 1, y - 1].active(active: true);
			Main.tile[x + 1, y - 1].frameY = 0;
			Main.tile[x + 1, y - 1].frameX = (short)(num2 + 36);
			Main.tile[x + 1, y - 1].type = type;
			Main.tile[x - 1, y].active(active: true);
			Main.tile[x - 1, y].frameY = 18;
			Main.tile[x - 1, y].frameX = num2;
			Main.tile[x - 1, y].type = type;
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].frameY = 18;
			Main.tile[x, y].frameX = (short)(num2 + 18);
			Main.tile[x, y].type = type;
			Main.tile[x + 1, y].active(active: true);
			Main.tile[x + 1, y].frameY = 18;
			Main.tile[x + 1, y].frameX = (short)(num2 + 36);
			Main.tile[x + 1, y].type = type;
		}
	}

	public static void Place2x2Style(int x, int y, ushort type, int style = 0)
	{
		if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
		{
			return;
		}
		short num = 0;
		if (type == 254)
		{
			num = (short)(x % 12 / 2);
			num *= 36;
		}
		bool flag = true;
		for (int i = x - 1; i < x + 1; i++)
		{
			for (int j = y - 1; j < y + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = new Tile();
				}
				if (Main.tile[i, j].active())
				{
					flag = false;
				}
			}
			if (Main.tile[i, y + 1] == null)
			{
				Main.tile[i, y + 1] = new Tile();
			}
			if (!SolidTile(i, y + 1))
			{
				flag = false;
			}
			if (type == 254 && Main.tile[i, y + 1].type != 2 && Main.tile[i, y + 1].type != 477 && Main.tile[i, y + 1].type != 492 && Main.tile[i, y + 1].type != 109)
			{
				flag = false;
			}
		}
		if (flag)
		{
			short num2 = (short)(36 * style);
			Main.tile[x - 1, y - 1].active(active: true);
			Main.tile[x - 1, y - 1].frameY = num;
			Main.tile[x - 1, y - 1].frameX = num2;
			Main.tile[x - 1, y - 1].type = type;
			Main.tile[x, y - 1].active(active: true);
			Main.tile[x, y - 1].frameY = num;
			Main.tile[x, y - 1].frameX = (short)(num2 + 18);
			Main.tile[x, y - 1].type = type;
			Main.tile[x - 1, y].active(active: true);
			Main.tile[x - 1, y].frameY = (short)(num + 18);
			Main.tile[x - 1, y].frameX = num2;
			Main.tile[x - 1, y].type = type;
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].frameY = (short)(num + 18);
			Main.tile[x, y].frameX = (short)(num2 + 18);
			Main.tile[x, y].type = type;
		}
	}

	public static bool NearFriendlyWall(int x, int y)
	{
		try
		{
			if (x < 2 || x >= Main.maxTilesX - 2 || y < 2 || y >= Main.maxTilesY - 2)
			{
				return true;
			}
			if (Main.tile[x, y].wall == 0 || Main.wallHouse[Main.tile[x, y].wall])
			{
				return true;
			}
			if (Main.tile[x - 1, y].wall == 0 || Main.wallHouse[Main.tile[x - 1, y].wall])
			{
				return true;
			}
			if (Main.tile[x + 1, y].wall == 0 || Main.wallHouse[Main.tile[x + 1, y].wall])
			{
				return true;
			}
			if (Main.tile[x, y - 1].wall == 0 || Main.wallHouse[Main.tile[x, y - 1].wall])
			{
				return true;
			}
			if (Main.tile[x, y + 1].wall == 0 || Main.wallHouse[Main.tile[x, y + 1].wall])
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static void Check2x2Style(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = j;
		int num2;
		for (num2 = Main.tile[i, j].frameY / 18; num2 > 1; num2 -= 2)
		{
		}
		num -= num2;
		int num3 = Main.tile[i, j].frameX / 18;
		int num4 = 0;
		while (num3 > 1)
		{
			num3 -= 2;
			num4++;
		}
		num3 = i - num3;
		int num5 = num4 * 36;
		for (int k = num3; k < num3 + 2; k++)
		{
			for (int l = num; l < num + 2; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = new Tile();
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num3) * 18 + num5)
				{
					flag = true;
				}
			}
			if (!SolidTileAllowBottomSlope(k, num + 2))
			{
				flag = true;
			}
			else
			{
				if (type != 254)
				{
					continue;
				}
				Tile tile = Main.tile[k, num + 2];
				if (tile != null && tile.active() && tile.type >= 0 && tile.type < TileID.Count)
				{
					ushort type2 = tile.type;
					if (type2 != 2 && type2 != 109 && type2 != 477 && type2 != 492)
					{
						flag = true;
					}
				}
			}
		}
		if (!flag)
		{
			return;
		}
		int frameX = Main.tile[i, j].frameX;
		destroyObject = true;
		for (int m = num3; m < num3 + 2; m++)
		{
			for (int n = num; n < num + 2; n++)
			{
				if (Main.tile[m, n] == null)
				{
					Main.tile[m, n] = new Tile();
				}
				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
				{
					KillTile(m, n);
				}
			}
		}
		switch (type)
		{
		case 254:
			if (frameX < 72)
			{
				break;
			}
			if (frameX < 108)
			{
				if (genRand.Next(2) == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1725, genRand.Next(1, 3));
				}
				break;
			}
			if (frameX < 144)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1725, genRand.Next(2, 6));
				break;
			}
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1725, genRand.Next(5, 11));
			if (Main.halloween && genRand.Next(200) == 0)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1799);
			}
			break;
		case 457:
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3749);
			break;
		case 96:
			switch (num4)
			{
			case 0:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 345);
				break;
			case 1:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1791);
				break;
			}
			break;
		case 441:
		{
			int itemDrop_FakeChests2 = GetItemDrop_FakeChests(num4, secondType: false);
			if (itemDrop_FakeChests2 != -1)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, itemDrop_FakeChests2);
			}
			break;
		}
		case 468:
		{
			int itemDrop_FakeChests = GetItemDrop_FakeChests(num4, secondType: true);
			if (itemDrop_FakeChests != -1)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, itemDrop_FakeChests);
			}
			break;
		}
		}
		destroyObject = false;
		for (int num6 = num3 - 1; num6 < num3 + 3; num6++)
		{
			for (int num7 = num - 1; num7 < num + 3; num7++)
			{
				TileFrame(num6, num7);
			}
		}
	}

	public static void PlacePumpkin(int x, int superY)
	{
		ushort type = 254;
		int num = genRand.Next(6) * 36;
		if (x < 5 || x > Main.maxTilesX - 5 || superY < 5 || superY > Main.maxTilesY - 5)
		{
			return;
		}
		bool flag = true;
		for (int i = x - 1; i < x + 1; i++)
		{
			for (int j = superY - 1; j < superY + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = new Tile();
				}
				if (Main.tile[i, j].active() && Main.tile[i, j].type != 3 && Main.tile[i, j].type != 73 && Main.tile[i, j].type != 113 && Main.tile[i, j].type != 110 && (Main.tile[i, j].type != 185 || Main.tile[i, j].frameY != 0))
				{
					flag = false;
				}
				if (Main.tile[i, j].liquid > 0)
				{
					flag = false;
				}
			}
			if (!SolidTile(i, superY + 1) || (Main.tile[i, superY + 1].type != 2 && Main.tile[i, superY + 1].type != 109))
			{
				flag = false;
			}
		}
		if (flag)
		{
			Main.tile[x - 1, superY - 1].active(active: true);
			Main.tile[x - 1, superY - 1].frameY = (short)num;
			Main.tile[x - 1, superY - 1].frameX = 0;
			Main.tile[x - 1, superY - 1].type = type;
			Main.tile[x, superY - 1].active(active: true);
			Main.tile[x, superY - 1].frameY = (short)num;
			Main.tile[x, superY - 1].frameX = 18;
			Main.tile[x, superY - 1].type = type;
			Main.tile[x - 1, superY].active(active: true);
			Main.tile[x - 1, superY].frameY = (short)(num + 18);
			Main.tile[x - 1, superY].frameX = 0;
			Main.tile[x - 1, superY].type = type;
			Main.tile[x, superY].active(active: true);
			Main.tile[x, superY].frameY = (short)(num + 18);
			Main.tile[x, superY].frameX = 18;
			Main.tile[x, superY].type = type;
		}
	}

	public static void GrowPumpkin(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = j;
		int num2;
		for (num2 = Main.tile[i, j].frameY / 18; num2 > 1; num2 -= 2)
		{
		}
		num -= num2;
		int num3 = Main.tile[i, j].frameX / 18;
		int num4 = 0;
		while (num3 > 1)
		{
			num3 -= 2;
			num4++;
		}
		num3 = i - num3;
		int num5 = num4 * 36;
		if (num4 >= 4)
		{
			return;
		}
		for (int k = num3; k < num3 + 2; k++)
		{
			for (int l = num; l < num + 2; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = new Tile();
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num3) * 18 + num5)
				{
					flag = true;
				}
			}
			if (!SolidTile(k, num + 2) || (Main.tile[k, num + 2].type != 2 && Main.tile[k, num + 2].type != 477 && Main.tile[k, num + 2].type != 492 && Main.tile[k, num + 2].type != 109))
			{
				flag = true;
			}
		}
		if (!flag)
		{
			for (int m = num3; m < num3 + 2; m++)
			{
				for (int n = num; n < num + 2; n++)
				{
					if (Main.tile[m, n] == null)
					{
						Main.tile[m, n] = new Tile();
					}
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
					{
						Main.tile[m, n].frameX += 36;
					}
				}
			}
		}
		if (Main.netMode == 2)
		{
			NetMessage.SendTileSquare(-1, num3, num, 2, 2);
		}
	}

	public static void FixHearts()
	{
		for (int i = 0; i < Main.maxTilesX; i++)
		{
			for (int j = 0; j < Main.maxTilesY; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile.active() && tile.type == 12 && tile.frameX == 0 && tile.frameY == 0)
				{
					FixHeart(i, j);
				}
			}
		}
	}

	public static void DestroyHeart(int i, int j)
	{
		destroyObject = true;
		for (int k = i; k < i + 2; k++)
		{
			for (int l = j; l < j + 2; l++)
			{
				if (k < Main.maxTilesX && l < Main.maxTilesY)
				{
					Tile tile = Main.tile[k, l];
					if (tile.active() && tile.type == 12)
					{
						KillTile(k, l);
					}
				}
			}
		}
		destroyObject = false;
	}

	public static void FixHeart(int i, int j)
	{
		if (i < Main.offLimitBorderTiles || i >= Main.maxTilesX - Main.offLimitBorderTiles || j < Main.offLimitBorderTiles || j >= Main.maxTilesY - Main.offLimitBorderTiles)
		{
			DestroyHeart(i, j);
			return;
		}
		Tile tile = Main.tile[i, j + 2];
		Tile tile2 = Main.tile[i + 1, j + 2];
		if (tile.active() && !Main.tileSolid[tile.type] && Main.tileCut[tile.type])
		{
			KillTile(i, j + 2);
		}
		if (tile2.active() && !Main.tileSolid[tile2.type] && Main.tileCut[tile2.type])
		{
			KillTile(i + 1, j + 2);
		}
		if (!tile.active())
		{
			if (!tile2.active())
			{
				DestroyHeart(i, j);
				return;
			}
			if (Main.tileSolid[tile2.type])
			{
				tile.type = tile2.type;
				tile.active(active: true);
			}
		}
		if (!tile2.active() && Main.tileSolid[tile.type])
		{
			tile2.type = tile.type;
			tile2.active(active: true);
		}
		if (!tile.nactive() || !Main.tileSolid[tile.type] || !tile2.nactive() || !Main.tileSolid[tile2.type])
		{
			DestroyHeart(i, j);
			return;
		}
		if (tile.blockType() != 0)
		{
			tile.slope(0);
			tile.halfBrick(halfBrick: false);
		}
		if (tile2.blockType() != 0)
		{
			tile2.slope(0);
			tile2.halfBrick(halfBrick: false);
		}
	}

	public static void FixChands()
	{
		for (int i = 5; i < Main.maxTilesX - 5; i++)
		{
			for (int j = 5; j < Main.maxTilesY - 5; j++)
			{
				if (Main.tile[i, j].active())
				{
					int type = Main.tile[i, j].type;
					if (Main.tile[i, j].active() && (type == 35 || type == 36 || type == 170 || type == 171 || type == 172))
					{
						FixChand(i, j);
					}
				}
			}
		}
	}

	public static void FixChand(int i, int j)
	{
		int num = 0;
		int type = Main.tile[i, j].type;
		if (Main.tile[i, j].active())
		{
			if (type == 35)
			{
				num = 1;
			}
			if (type == 36)
			{
				num = 2;
			}
			if (type == 170)
			{
				num = 3;
			}
			if (type == 171)
			{
				num = 4;
			}
			if (type == 172)
			{
				num = 5;
			}
		}
		if (num <= 0)
		{
			return;
		}
		int num2 = i;
		int num3 = j;
		for (num2 = Main.tile[i, j].frameX / 18; num2 >= 3; num2 -= 3)
		{
		}
		if (num2 >= 3)
		{
			num2 -= 3;
		}
		num2 = i - num2;
		num3 += Main.tile[i, j].frameY / 18 * -1;
		for (int k = num2; k < num2 + 3; k++)
		{
			for (int l = num3; l < num3 + 3; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = new Tile();
				}
				if (Main.tile[k, l].active() && Main.tile[k, l].type == type)
				{
					Main.tile[k, l].type = 34;
					Main.tile[k, l].frameY = (short)(Main.tile[k, l].frameY + num * 54);
				}
			}
		}
	}

	public static void PlaceChand(int x, int y, ushort type, int style = 0)
	{
		bool flag = true;
		int num = 0;
		for (int i = x - 1; i < x + 2; i++)
		{
			for (int j = y; j < y + 3; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = new Tile();
				}
				if (Main.tile[i, j].active())
				{
					flag = false;
				}
			}
		}
		if (Main.tile[x, y - 1] == null)
		{
			Main.tile[x, y - 1] = new Tile();
		}
		if (!Main.tile[x, y - 1].nactive() || !Main.tileSolid[Main.tile[x, y - 1].type] || Main.tileSolidTop[Main.tile[x, y - 1].type])
		{
			flag = false;
		}
		if (flag)
		{
			int num2 = style / 36 * 18 * 6;
			int num3 = style * 18 * 3;
			if (num2 >= 108)
			{
				num3 -= 54 * (num2 / 108) * 37;
			}
			Main.tile[x - 1, y + num].active(active: true);
			Main.tile[x - 1, y + num].frameY = (short)num3;
			Main.tile[x - 1, y + num].frameX = (short)num2;
			Main.tile[x - 1, y + num].type = type;
			Main.tile[x, y + num].active(active: true);
			Main.tile[x, y + num].frameY = (short)num3;
			Main.tile[x, y + num].frameX = (short)(num2 + 18);
			Main.tile[x, y + num].type = type;
			Main.tile[x + 1, y + num].active(active: true);
			Main.tile[x + 1, y + num].frameY = (short)num3;
			Main.tile[x + 1, y + num].frameX = (short)(num2 + 36);
			Main.tile[x + 1, y + num].type = type;
			Main.tile[x - 1, y + 1 + num].active(active: true);
			Main.tile[x - 1, y + 1 + num].frameY = (short)(num3 + 18);
			Main.tile[x - 1, y + 1 + num].frameX = (short)num2;
			Main.tile[x - 1, y + 1 + num].type = type;
			Main.tile[x, y + 1 + num].active(active: true);
			Main.tile[x, y + 1 + num].frameY = (short)(num3 + 18);
			Main.tile[x, y + 1 + num].frameX = (short)(num2 + 18);
			Main.tile[x, y + 1 + num].type = type;
			Main.tile[x + 1, y + 1 + num].active(active: true);
			Main.tile[x + 1, y + 1 + num].frameY = (short)(num3 + 18);
			Main.tile[x + 1, y + 1 + num].frameX = (short)(num2 + 36);
			Main.tile[x + 1, y + 1 + num].type = type;
			Main.tile[x - 1, y + 2 + num].active(active: true);
			Main.tile[x - 1, y + 2 + num].frameY = (short)(num3 + 36);
			Main.tile[x - 1, y + 2 + num].frameX = (short)num2;
			Main.tile[x - 1, y + 2 + num].type = type;
			Main.tile[x, y + 2 + num].active(active: true);
			Main.tile[x, y + 2 + num].frameY = (short)(num3 + 36);
			Main.tile[x, y + 2 + num].frameX = (short)(num2 + 18);
			Main.tile[x, y + 2 + num].type = type;
			Main.tile[x + 1, y + 2 + num].active(active: true);
			Main.tile[x + 1, y + 2 + num].frameY = (short)(num3 + 36);
			Main.tile[x + 1, y + 2 + num].frameX = (short)(num2 + 36);
			Main.tile[x + 1, y + 2 + num].type = type;
		}
	}

	public static void CheckChand(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = i;
		int num2 = j;
		int num3 = 3;
		if (type == 454)
		{
			num3 = 4;
		}
		num = Main.tile[i, j].frameX / 18;
		int num4 = 0;
		while (num >= num3)
		{
			num4++;
			num -= num3;
		}
		int num5 = i - num;
		int num6 = 18 * num3 * num4;
		if (num >= num3)
		{
			num -= num3;
		}
		num = i - num;
		num2 = Main.tile[i, j].frameY / 18;
		int num7 = 0;
		while (num2 >= 3)
		{
			num7++;
			num2 -= 3;
		}
		if (num6 >= 108)
		{
			num7 += 37 * (num6 / 108);
		}
		int num8 = 54 * num7;
		if (num6 >= 108)
		{
			num8 -= 54 * (num6 / 108) * 37;
		}
		if (num2 >= 3)
		{
			num2 -= 3;
		}
		num2 = j - num2;
		for (int k = num; k < num + num3; k++)
		{
			for (int l = num2; l < num2 + 3; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = new Tile();
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num5) * 18 + num6 || Main.tile[k, l].frameY != (l - num2) * 18 + num8)
				{
					flag = true;
				}
			}
		}
		if (Main.tile[num + 1, num2 - 1] == null)
		{
			Main.tile[num + 1, num2 - 1] = new Tile();
		}
		if (!Main.tile[num + 1, num2 - 1].nactive() || !Main.tileSolid[Main.tile[num + 1, num2 - 1].type] || Main.tileSolidTop[Main.tile[num + 1, num2 - 1].type])
		{
			flag = true;
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		for (int m = num; m < num + num3; m++)
		{
			for (int n = num2; n < num2 + 3; n++)
			{
				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
				{
					KillTile(m, n);
				}
			}
		}
		if (type == 454)
		{
			switch (Main.rand.Next(9))
			{
			case 2:
			case 3:
			case 4:
			{
				int num13 = Main.rand.Next(10, 31);
				while (num13 > 0)
				{
					int num14 = Main.rand.Next(2, 11);
					if (num14 > num13)
					{
						num14 = num13;
					}
					num13 -= num14;
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 72, num14);
				}
				break;
			}
			case 5:
			case 6:
			{
				int num17 = Main.rand.Next(60, 80);
				while (num17 > 0)
				{
					int num18 = Main.rand.Next(3, 16);
					if (num18 > num17)
					{
						num18 = num17;
					}
					num17 -= num18;
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16 - 10, j * 16 - 10, 52, 52, 72, num18);
				}
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1358);
				break;
			}
			case 7:
			{
				int num15 = Main.rand.Next(10, 31);
				while (num15 > 0)
				{
					int num16 = Main.rand.Next(2, 9);
					if (num16 > num15)
					{
						num16 = num15;
					}
					num15 -= num16;
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16 - 10, j * 16 - 10, 52, 52, 72, num16);
				}
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73);
				break;
			}
			case 8:
			{
				int num9 = 100;
				while (num9 > 0)
				{
					int num10 = Main.rand.Next(3, 16);
					if (num10 > num9)
					{
						num10 = num9;
					}
					num9 -= num10;
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16 - 10, j * 16 - 10, 52, 52, 72, num10);
				}
				int num11 = Main.rand.Next(30, 91);
				while (num11 > 0)
				{
					int num12 = Main.rand.Next(7, 14);
					if (num12 > num11)
					{
						num12 = num11;
					}
					num11 -= num12;
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16 - 10, j * 16 - 10, 52, 52, 1349, num12);
				}
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1358);
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73);
				break;
			}
			}
		}
		if (type == 34)
		{
			int itemDrop_Chandeliers = GetItemDrop_Chandeliers(num7);
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, itemDrop_Chandeliers);
		}
		destroyObject = false;
		for (int num19 = num - 1; num19 < num + num3 + 1; num19++)
		{
			for (int num20 = num2 - 1; num20 < num2 + 4; num20++)
			{
				TileFrame(num19, num20);
			}
		}
	}

	public static void Check4x4(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = i;
		int num2 = j;
		num = Main.tile[i, j].frameX / 18;
		int num3 = 0;
		while (num >= 4)
		{
			num3++;
			num -= 4;
		}
		int num4 = i - num;
		int num5 = 72 * num3;
		int num6 = Main.tile[i, j].frameY / 72;
		int num7 = Main.tile[i, j].frameY % 72 / 18;
		if (num >= 4)
		{
			num -= 4;
		}
		num = i - num;
		num2 -= num7;
		for (int k = num; k < num + 4; k++)
		{
			for (int l = num2; l < num2 + 4; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = new Tile();
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num4) * 18 + num5 || Main.tile[k, l].frameY != (l - num2) * 18 + num6 * 72)
				{
					flag = true;
				}
			}
		}
		for (int m = num; m < num + 4; m++)
		{
			if (Main.tile[m, num2 + 4] == null)
			{
				Main.tile[m, num2 + 4] = new Tile();
			}
			if (!SolidTileAllowBottomSlope(m, num2 + 4))
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		for (int n = num; n < num + 4; n++)
		{
			for (int num8 = num2; num8 < num2 + 4; num8++)
			{
				if (Main.tile[n, num8].type == type && Main.tile[n, num8].active())
				{
					KillTile(n, num8);
				}
			}
		}
		if (type == 699)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 40, 32, 5482);
		}
		destroyObject = false;
		for (int num9 = num - 1; num9 < num + 5; num9++)
		{
			for (int num10 = num2 - 1; num10 < num2 + 5; num10++)
			{
				TileFrame(num9, num10);
			}
		}
	}

	public static void Check3x3(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = i;
		int num2 = j;
		num = Main.tile[i, j].frameX / 18;
		int num3 = 0;
		while (num >= 3)
		{
			num3++;
			num -= 3;
		}
		int num4 = i - num;
		int num5 = 54 * num3;
		int num6 = Main.tile[i, j].frameY / 54;
		int num7 = Main.tile[i, j].frameY % 54 / 18;
		if (num >= 3)
		{
			num -= 3;
		}
		num = i - num;
		num2 -= num7;
		for (int k = num; k < num + 3; k++)
		{
			for (int l = num2; l < num2 + 3; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = new Tile();
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num4) * 18 + num5 || Main.tile[k, l].frameY != (l - num2) * 18 + num6 * 54)
				{
					flag = true;
				}
			}
		}
		if (type == 106 || type == 212 || type == 219 || type == 220 || type == 228 || type == 231 || type == 243 || type == 247 || type == 283 || (type >= 300 && type <= 308) || type == 354 || type == 355 || type == 499 || type == 406 || type == 412 || type == 452 || type == 455 || type == 491 || type == 642 || type == 733)
		{
			for (int m = num; m < num + 3; m++)
			{
				if (Main.tile[m, num2 + 3] == null)
				{
					Main.tile[m, num2 + 3] = new Tile();
				}
				if (!SolidTileAllowBottomSlope(m, num2 + 3))
				{
					flag = true;
					break;
				}
			}
		}
		else
		{
			if (Main.tile[num + 1, num2 - 1] == null)
			{
				Main.tile[num + 1, num2 - 1] = new Tile();
			}
			if (!Main.tile[num + 1, num2 - 1].nactive() || !Main.tileSolid[Main.tile[num + 1, num2 - 1].type] || Main.tileSolidTop[Main.tile[num + 1, num2 - 1].type])
			{
				flag = true;
			}
		}
		if (generatingWorld && !Main.tileSolid[225] && type == 231)
		{
			flag = false;
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		for (int n = num; n < num + 3; n++)
		{
			for (int num8 = num2; num8 < num2 + 3; num8++)
			{
				if (Main.tile[n, num8].type == type && Main.tile[n, num8].active())
				{
					KillTile(n, num8);
				}
			}
		}
		switch (type)
		{
		case 106:
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 363);
			break;
		case 243:
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1430);
			break;
		case 212:
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 951);
			break;
		case 219:
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 997);
			break;
		case 642:
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5296);
			break;
		case 220:
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 998);
			break;
		case 228:
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1120);
			break;
		case 247:
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1551);
			break;
		case 283:
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2172);
			break;
		case 300:
		case 301:
		case 302:
		case 303:
		case 304:
		case 305:
		case 306:
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2192 + type - 300);
			break;
		default:
			switch (type)
			{
			case 307:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2203);
				break;
			case 308:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2204);
				break;
			case 406:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3365);
				break;
			case 452:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3742);
				break;
			case 354:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2999);
				break;
			case 355:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3000);
				break;
			case 499:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4142);
				break;
			case 412:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3549);
				break;
			case 455:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3747);
				break;
			case 491:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4076);
				break;
			case 231:
			{
				int num9 = (i + 1) * 16 + 8;
				int num10 = j * 16;
				Gore.NewGore(new Vector2(num9, num10), default(Vector2), 300);
				Gore.NewGore(new Vector2(num9, num10 + 8), default(Vector2), 301);
				Gore.NewGore(new Vector2(num9, num10 + 16), default(Vector2), 302);
				float num11 = i * 16;
				float num12 = j * 16;
				float num13 = -1f;
				int plr = 0;
				for (int num14 = 0; num14 < 255; num14++)
				{
					if (Main.player[num14].active && !Main.player[num14].dead)
					{
						float num15 = Math.Abs(Main.player[num14].position.X - num11) + Math.Abs(Main.player[num14].position.Y - num12);
						if (num15 < num13 || num13 == -1f)
						{
							plr = num14;
							num13 = num15;
						}
					}
				}
				if (num13 < 4800f && !Main.gameMenu)
				{
					NPC.SpawnOnPlayer(plr, 222);
				}
				break;
			}
			case 733:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5113);
				break;
			}
			break;
		}
		destroyObject = false;
		for (int num16 = num - 1; num16 < num + 4; num16++)
		{
			for (int num17 = num2 - 1; num17 < num2 + 4; num17++)
			{
				TileFrame(num16, num17);
			}
		}
	}

	public static void Check2x5(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = i;
		int num2 = j;
		num = Main.tile[i, j].frameX / 18;
		int num3 = 0;
		while (num >= 2)
		{
			num3++;
			num -= 2;
		}
		int num4 = i - num;
		int num5 = 36 * num3;
		int num6 = Main.tile[i, j].frameY % 80 / 18;
		if (num >= 3)
		{
			num -= 2;
		}
		num = i - num;
		num2 -= num6;
		for (int k = num; k < num + 2; k++)
		{
			for (int l = num2; l < num2 + 5; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = new Tile();
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num4) * 18 + num5 || Main.tile[k, l].frameY != (l - num2) * 18)
				{
					flag = true;
				}
			}
		}
		for (int m = num; m < num + 2; m++)
		{
			if (Main.tile[m, num2 + 5] == null)
			{
				Main.tile[m, num2 + 5] = new Tile();
			}
			if (!SolidTileAllowBottomSlope(m, num2 + 5))
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		for (int n = num; n < num + 2; n++)
		{
			for (int num7 = num2; num7 < num2 + 5; num7++)
			{
				if (Main.tile[n, num7].type == type && Main.tile[n, num7].active())
				{
					KillTile(n, num7);
				}
			}
		}
		switch (type)
		{
		case 547:
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4430 + num3);
			break;
		case 623:
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5081 + num3);
			break;
		}
		destroyObject = false;
		for (int num8 = num - 1; num8 < num + 3; num8++)
		{
			for (int num9 = num2 - 1; num9 < num2 + 6; num9++)
			{
				TileFrame(num8, num9);
			}
		}
	}

	public static void Check3x5(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = i;
		int num2 = j;
		num = Main.tile[i, j].frameX / 18;
		int num3 = 0;
		while (num >= 3)
		{
			num3++;
			num -= 3;
		}
		int num4 = i - num;
		int num5 = 54 * num3;
		int num6 = Main.tile[i, j].frameY % 90 / 18;
		if (num >= 4)
		{
			num -= 3;
		}
		num = i - num;
		num2 -= num6;
		for (int k = num; k < num + 3; k++)
		{
			for (int l = num2; l < num2 + 5; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = new Tile();
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num4) * 18 + num5 || Main.tile[k, l].frameY != (l - num2) * 18)
				{
					flag = true;
				}
			}
		}
		for (int m = num; m < num + 3; m++)
		{
			if (Main.tile[m, num2 + 5] == null)
			{
				Main.tile[m, num2 + 5] = new Tile();
			}
			if (!SolidTileAllowBottomSlope(m, num2 + 5))
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		for (int n = num; n < num + 3; n++)
		{
			for (int num7 = num2; num7 < num2 + 5; num7++)
			{
				if (Main.tile[n, num7].type == type && Main.tile[n, num7].active())
				{
					KillTile(n, num7);
				}
			}
		}
		if (type == 613)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4904 + num3);
		}
		destroyObject = false;
		for (int num8 = num - 1; num8 < num + 4; num8++)
		{
			for (int num9 = num2 - 1; num9 < num2 + 6; num9++)
			{
				TileFrame(num8, num9);
			}
		}
	}

	public static void Check3x6(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = i;
		int num2 = j;
		num = Main.tile[i, j].frameX / 18;
		int num3 = 0;
		while (num >= 3)
		{
			num3++;
			num -= 3;
		}
		int num4 = i - num;
		int num5 = 54 * num3;
		int num6 = Main.tile[i, j].frameY % 96 / 18;
		if (num >= 4)
		{
			num -= 3;
		}
		num = i - num;
		num2 -= num6;
		for (int k = num; k < num + 3; k++)
		{
			for (int l = num2; l < num2 + 6; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = new Tile();
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num4) * 18 + num5 || Main.tile[k, l].frameY != (l - num2) * 18)
				{
					flag = true;
				}
			}
		}
		for (int m = num; m < num + 3; m++)
		{
			if (Main.tile[m, num2 + 6] == null)
			{
				Main.tile[m, num2 + 6] = new Tile();
			}
			if (!SolidTileAllowBottomSlope(m, num2 + 6))
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		for (int n = num; n < num + 3; n++)
		{
			for (int num7 = num2; num7 < num2 + 6; num7++)
			{
				if (Main.tile[n, num7].type == type && Main.tile[n, num7].active())
				{
					KillTile(n, num7);
				}
			}
		}
		if (type == 548)
		{
			if (num3 >= 7)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4902 + num3 - 7);
			}
			else
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4435 + num3);
			}
		}
		if (type == 614)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4906);
		}
		destroyObject = false;
		for (int num8 = num - 1; num8 < num + 4; num8++)
		{
			for (int num9 = num2 - 1; num9 < num2 + 7; num9++)
			{
				TileFrame(num8, num9);
			}
		}
	}

	public static void Place3x3(int x, int y, ushort type, int style = 0)
	{
		bool flag = true;
		int num = 0;
		if (type == 106 || type == 212 || type == 219 || type == 220 || type == 228 || type == 231 || type == 243 || type == 247 || type == 283 || (type >= 300 && type <= 308) || type == 354 || type == 355 || type == 642 || type == 733)
		{
			num = -2;
			for (int i = x - 1; i < x + 2; i++)
			{
				for (int j = y - 2; j < y + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active())
					{
						flag = false;
					}
				}
			}
			for (int k = x - 1; k < x + 2; k++)
			{
				if (Main.tile[k, y + 1] == null)
				{
					Main.tile[k, y + 1] = new Tile();
				}
				if (!SolidTile2(k, y + 1))
				{
					flag = false;
					break;
				}
			}
		}
		else
		{
			for (int l = x - 1; l < x + 2; l++)
			{
				for (int m = y; m < y + 3; m++)
				{
					if (Main.tile[l, m] == null)
					{
						Main.tile[l, m] = new Tile();
					}
					if (Main.tile[l, m].active())
					{
						flag = false;
					}
				}
			}
			if (Main.tile[x, y - 1] == null)
			{
				Main.tile[x, y - 1] = new Tile();
			}
			if (!Main.tile[x, y - 1].nactive() || !Main.tileSolid[Main.tile[x, y - 1].type] || Main.tileSolidTop[Main.tile[x, y - 1].type])
			{
				flag = false;
			}
		}
		if (flag)
		{
			int num2 = style * 18 * 3;
			Main.tile[x - 1, y + num].active(active: true);
			Main.tile[x - 1, y + num].frameY = 0;
			Main.tile[x - 1, y + num].frameX = (short)num2;
			Main.tile[x - 1, y + num].type = type;
			Main.tile[x, y + num].active(active: true);
			Main.tile[x, y + num].frameY = 0;
			Main.tile[x, y + num].frameX = (short)(num2 + 18);
			Main.tile[x, y + num].type = type;
			Main.tile[x + 1, y + num].active(active: true);
			Main.tile[x + 1, y + num].frameY = 0;
			Main.tile[x + 1, y + num].frameX = (short)(num2 + 36);
			Main.tile[x + 1, y + num].type = type;
			Main.tile[x - 1, y + 1 + num].active(active: true);
			Main.tile[x - 1, y + 1 + num].frameY = 18;
			Main.tile[x - 1, y + 1 + num].frameX = (short)num2;
			Main.tile[x - 1, y + 1 + num].type = type;
			Main.tile[x, y + 1 + num].active(active: true);
			Main.tile[x, y + 1 + num].frameY = 18;
			Main.tile[x, y + 1 + num].frameX = (short)(num2 + 18);
			Main.tile[x, y + 1 + num].type = type;
			Main.tile[x + 1, y + 1 + num].active(active: true);
			Main.tile[x + 1, y + 1 + num].frameY = 18;
			Main.tile[x + 1, y + 1 + num].frameX = (short)(num2 + 36);
			Main.tile[x + 1, y + 1 + num].type = type;
			Main.tile[x - 1, y + 2 + num].active(active: true);
			Main.tile[x - 1, y + 2 + num].frameY = 36;
			Main.tile[x - 1, y + 2 + num].frameX = (short)num2;
			Main.tile[x - 1, y + 2 + num].type = type;
			Main.tile[x, y + 2 + num].active(active: true);
			Main.tile[x, y + 2 + num].frameY = 36;
			Main.tile[x, y + 2 + num].frameX = (short)(num2 + 18);
			Main.tile[x, y + 2 + num].type = type;
			Main.tile[x + 1, y + 2 + num].active(active: true);
			Main.tile[x + 1, y + 2 + num].frameY = 36;
			Main.tile[x + 1, y + 2 + num].frameX = (short)(num2 + 36);
			Main.tile[x + 1, y + 2 + num].type = type;
		}
	}

	public static void PlaceSunflower(int x, int y, ushort type = 27)
	{
		if ((double)y > Main.worldSurface - 1.0 && !Main.remixWorld)
		{
			return;
		}
		bool flag = true;
		for (int i = x; i < x + 2; i++)
		{
			for (int j = y - 3; j < y + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = new Tile();
				}
				if (Main.tile[i, j].active() || Main.tile[i, j].wall > 0)
				{
					flag = false;
				}
			}
			if (Main.tile[i, y + 1] == null)
			{
				Main.tile[i, y + 1] = new Tile();
			}
			if (!Main.tile[i, y + 1].nactive() || Main.tile[i, y + 1].halfBrick() || Main.tile[i, y + 1].slope() != 0 || (Main.tile[i, y + 1].type != 2 && Main.tile[i, y + 1].type != 109))
			{
				flag = false;
			}
		}
		if (!flag)
		{
			return;
		}
		int num = genRand.Next(3);
		for (int k = 0; k < 2; k++)
		{
			for (int l = -3; l < 1; l++)
			{
				int num2 = k * 18 + genRand.Next(3) * 36;
				if (l <= -2)
				{
					num2 = k * 18 + num * 36;
				}
				int num3 = (l + 3) * 18;
				Main.tile[x + k, y + l].active(active: true);
				Main.tile[x + k, y + l].frameX = (short)num2;
				Main.tile[x + k, y + l].frameY = (short)num3;
				Main.tile[x + k, y + l].type = type;
			}
		}
	}

	public static void FixSunflowers()
	{
		for (int i = 5; i < Main.maxTilesX - 5; i++)
		{
			for (int j = 5; (double)j < Main.worldSurface; j++)
			{
				if (Main.tile[i, j].active() && Main.tile[i, j].type == 27)
				{
					FixSunflower(i, j);
				}
			}
		}
	}

	public static void FixSunflower(int i, int j)
	{
		if (Main.tile[i, j].type != 27)
		{
			return;
		}
		int num = 0;
		int num2 = j;
		num += Main.tile[i, j].frameX / 18;
		num2 += Main.tile[i, j].frameY / 18 * -1;
		while (num > 1)
		{
			num -= 2;
		}
		num *= -1;
		num += i;
		int num3 = genRand.Next(3) * 36;
		int num4 = 0;
		for (int k = num; k < num + 2; k++)
		{
			for (int l = num2; l < num2 + 4; l++)
			{
				Main.tile[k, l].frameX = (short)(num4 + num3);
			}
			num4 += 18;
		}
	}

	public static void CheckSunflower(int i, int j, int type = 27)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = 0;
		int num2 = j;
		num += Main.tile[i, j].frameX / 18;
		num2 += Main.tile[i, j].frameY / 18 * -1;
		while (num > 1)
		{
			num -= 2;
		}
		num *= -1;
		num += i;
		for (int k = num; k < num + 2; k++)
		{
			for (int l = num2; l < num2 + 4; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = new Tile();
				}
				int num3;
				for (num3 = Main.tile[k, l].frameX / 18; num3 > 1; num3 -= 2)
				{
				}
				if (!Main.tile[k, l].nactive() || Main.tile[k, l].type != type || num3 != k - num || Main.tile[k, l].frameY != (l - num2) * 18)
				{
					flag = true;
				}
			}
			if (Main.tile[k, num2 + 4] == null)
			{
				Main.tile[k, num2 + 4] = new Tile();
			}
			if (!Main.tile[k, num2 + 4].nactive() || (Main.tile[k, num2 + 4].type != 2 && Main.tile[k, num2 + 4].type != 477 && Main.tile[k, num2 + 4].type != 492 && Main.tile[k, num2 + 4].type != 109 && Main.tile[k, num2 + 4].type != 60 && Main.tile[k, num2 + 4].type != 633))
			{
				flag = true;
			}
			if (!SolidTile(k, num2 + 4))
			{
				flag = true;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		for (int m = num; m < num + 2; m++)
		{
			for (int n = num2; n < num2 + 4; n++)
			{
				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
				{
					KillTile(m, n);
				}
			}
		}
		Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 63);
		destroyObject = false;
	}

	public static void CheckDye(int x, int y)
	{
		switch (Main.tile[x, y].frameX / 34)
		{
		case 7:
			if (!SolidTile(x, y - 1))
			{
				KillTile(x, y);
			}
			break;
		case 6:
			if (!Main.tile[x, y + 1].nactive() || Main.tile[x, y + 1].type != 80)
			{
				KillTile(x, y);
			}
			break;
		default:
			if (!SolidTile(x, y + 1))
			{
				KillTile(x, y);
			}
			break;
		}
	}

	public static void CheckRockGolemHead(int x, int y)
	{
		if (!SolidTileAllowBottomSlope(x, y + 1))
		{
			KillTile(x, y);
		}
	}

	public static void CheckKiteAnchor(int x, int y)
	{
		Tile tileSafely = Framing.GetTileSafely(x, y);
		int num = tileSafely.frameX / 18;
		int style = num;
		if (ValidateOrAttemptReorientingKiteAnchor(x, y, tileSafely.wall, ref style))
		{
			if (style != num)
			{
				tileSafely.frameX = (short)(style * 18);
			}
		}
		else
		{
			KillTile(x, y);
		}
	}

	public static bool ValidateOrAttemptReorientingKiteAnchor(int x, int y, int wall, ref int style)
	{
		if (style == 0 && !SolidTileAllowBottomSlope(x, y + 1))
		{
			style = -1;
		}
		if (style == 1 && !SolidTileAllowTopSlope(x, y - 1))
		{
			style = -1;
		}
		if (style == 2 && !SolidTileAllowLeftSlope(x - 1, y))
		{
			style = -1;
		}
		if (style == 3 && !SolidTileAllowRightSlope(x + 1, y))
		{
			style = -1;
		}
		if (style == 4 && wall <= 0)
		{
			style = -1;
		}
		if (style == -1 && SolidTileAllowBottomSlope(x, y + 1))
		{
			style = 0;
		}
		if (style == -1 && SolidTileAllowTopSlope(x, y - 1))
		{
			style = 1;
		}
		if (style == -1 && SolidTileAllowLeftSlope(x - 1, y))
		{
			style = 2;
		}
		if (style == -1 && SolidTileAllowRightSlope(x + 1, y))
		{
			style = 3;
		}
		if (style == -1 && wall > 0)
		{
			style = 4;
		}
		return style > -1;
	}

	public static void CheckStinkbugBlocker(int x, int y)
	{
		Tile tileSafely = Framing.GetTileSafely(x, y);
		int num = tileSafely.frameX / 18;
		int style = num;
		if (ValidateOrAttemptReorientingStinkbugBlocker(x, y, tileSafely.wall, ref style))
		{
			if (style != num)
			{
				tileSafely.frameX = (short)(style * 18);
			}
		}
		else
		{
			KillTile(x, y);
		}
	}

	public static bool ValidateOrAttemptReorientingStinkbugBlocker(int x, int y, int wall, ref int style)
	{
		if (style == 0 && !SolidTileAllowBottomSlope(x, y + 1))
		{
			style = -1;
		}
		if (style == 1 && !SolidTileAllowTopSlope(x, y - 1))
		{
			style = -1;
		}
		if (style == 2 && !SolidTileAllowRightSlope(x + 1, y))
		{
			style = -1;
		}
		if (style == 3 && !SolidTileAllowLeftSlope(x - 1, y))
		{
			style = -1;
		}
		if (style == 4 && wall <= 0)
		{
			style = -1;
		}
		if (style == -1 && SolidTileAllowBottomSlope(x, y + 1))
		{
			style = 0;
		}
		if (style == -1 && SolidTileAllowTopSlope(x, y - 1))
		{
			style = 1;
		}
		if (style == -1 && SolidTileAllowRightSlope(x + 1, y))
		{
			style = 2;
		}
		if (style == -1 && SolidTileAllowLeftSlope(x - 1, y))
		{
			style = 3;
		}
		if (style == -1 && wall > 0)
		{
			style = 4;
		}
		return style > -1;
	}

	public static void CheckGnome(int x, int j)
	{
		if (destroyObject)
		{
			return;
		}
		int num = 567;
		int num2 = j;
		bool flag = true;
		Tile tileSafely = Framing.GetTileSafely(x, num2);
		Tile tileSafely2 = Framing.GetTileSafely(x, num2 + 1);
		if (tileSafely.frameY > 0)
		{
			num2--;
			tileSafely = Framing.GetTileSafely(x, num2);
			tileSafely2 = Framing.GetTileSafely(x, num2 + 1);
		}
		_ = tileSafely.frameX / 28;
		if (tileSafely.frameY == 0 && tileSafely2.frameY == 20 && tileSafely.type == num && tileSafely2.type == num)
		{
			flag = false;
		}
		if (Main.tile[x, num2 + 2] == null)
		{
			Main.tile[x, num2 + 2] = new Tile();
		}
		if (!SolidTileAllowBottomSlope(x, num2 + 2) && !TileID.Sets.Platforms[Main.tile[x, num2 + 2].type])
		{
			flag = true;
		}
		if (flag)
		{
			destroyObject = true;
			if (tileSafely.type == num)
			{
				KillTile(x, num2);
			}
			if (tileSafely2.type == num)
			{
				KillTile(x, num2 + 1);
			}
			Item.NewItem(GetItemSource_FromTileBreak(x, num2), x * 16, num2 * 16, 16, 32, 4609);
			destroyObject = false;
		}
	}

	public static void PlaceGnome(int x, int y, int style)
	{
		PlaceObject(x, y, 567, mute: false, style);
	}

	public static void PlaceDye(int x, int y, int style)
	{
		bool flag = false;
		if (Main.tile[x, y + 1] == null || Main.tile[x, y - 1] == null)
		{
			return;
		}
		if (style == 7)
		{
			if (Main.tile[x, y + 1].active() && Main.tile[x, y + 1].type != 3 && Main.tile[x, y + 1].type != 51 && Main.tile[x, y + 1].type != 697 && Main.tile[x, y + 1].type != 61 && Main.tile[x, y + 1].type != 703 && Main.tile[x, y + 1].type != 73 && Main.tile[x, y + 1].type != 74 && Main.tile[x, y + 1].type != 184)
			{
				return;
			}
			if (SolidTile(x, y - 1) && !Main.tile[x, y + 1].active())
			{
				flag = true;
			}
		}
		else
		{
			if (Main.tile[x, y - 1].active() && Main.tile[x, y - 1].type != 3 && Main.tile[x, y - 1].type != 51 && Main.tile[x, y - 1].type != 697 && Main.tile[x, y - 1].type != 61 && Main.tile[x, y - 1].type != 703 && Main.tile[x, y - 1].type != 73 && Main.tile[x, y - 1].type != 74 && Main.tile[x, y - 1].type != 184)
			{
				return;
			}
			if (style == 6)
			{
				if (Main.tile[x, y + 1].nactive() && Main.tile[x, y + 1].type == 80 && !Main.tile[x - 1, y + 1].active() && !Main.tile[x + 1, y + 1].active())
				{
					flag = true;
				}
			}
			else if (SolidTile(x, y + 1) && !Main.tile[x, y - 1].active())
			{
				switch (style)
				{
				case 5:
					if (Main.tile[x, y].liquid == byte.MaxValue && !Main.tile[x, y].lava() && !Main.tile[x, y].honey() && !Main.tile[x, y].shimmer())
					{
						flag = true;
					}
					break;
				case 8:
				case 9:
				case 10:
				case 11:
					flag = true;
					break;
				default:
					if (Main.tile[x, y].liquid != 0)
					{
						break;
					}
					if (style == 3 || style == 4)
					{
						if (Main.tile[x, y].wall == 0)
						{
							flag = true;
						}
					}
					else
					{
						flag = true;
					}
					break;
				}
			}
		}
		if (flag)
		{
			Main.tile[x, y].type = 227;
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].halfBrick(halfBrick: false);
			Main.tile[x, y].slope(0);
			Main.tile[x, y].frameY = 0;
			Main.tile[x, y].frameX = (short)(34 * style);
		}
	}

	public static bool PlacePot(int x, int y, ushort type = 28, int style = 0)
	{
		bool flag = true;
		if (remixWorldGen && (double)x > (double)Main.maxTilesX * 0.48 && (double)x < (double)Main.maxTilesX * 0.52 && y > Main.maxTilesY - 220)
		{
			flag = false;
		}
		for (int i = x; i < x + 2; i++)
		{
			for (int j = y - 1; j < y + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = new Tile();
				}
				if (Main.tile[i, j].active())
				{
					flag = false;
				}
			}
			if (Main.tile[i, y + 1] == null)
			{
				Main.tile[i, y + 1] = new Tile();
			}
			if (!Main.tile[i, y + 1].nactive() || Main.tile[i, y + 1].halfBrick() || Main.tile[i, y + 1].slope() != 0 || !Main.tileSolid[Main.tile[i, y + 1].type])
			{
				flag = false;
			}
		}
		if (flag)
		{
			int num = genRand.Next(3) * 36;
			for (int k = 0; k < 2; k++)
			{
				for (int l = -1; l < 1; l++)
				{
					int num2 = k * 18 + num;
					int num3 = (l + 1) * 18;
					Main.tile[x + k, y + l].active(active: true);
					Main.tile[x + k, y + l].frameX = (short)num2;
					Main.tile[x + k, y + l].frameY = (short)(num3 + style * 36);
					Main.tile[x + k, y + l].type = type;
					Main.tile[x + k, y + l].halfBrick(halfBrick: false);
				}
			}
			return true;
		}
		return false;
	}

	public static bool CheckCactus(int i, int j)
	{
		int num = j;
		int num2 = i;
		while (Main.tile[num2, num] != null && Main.tile[num2, num].active() && Main.tile[num2, num].type == 80)
		{
			num++;
			if (Main.tile[num2, num] == null)
			{
				return false;
			}
			if (!Main.tile[num2, num].active() || Main.tile[num2, num].type != 80)
			{
				if (Main.tile[num2 - 1, num] != null && Main.tile[num2 - 1, num].active() && Main.tile[num2 - 1, num].type == 80 && Main.tile[num2 - 1, num - 1] != null && Main.tile[num2 - 1, num - 1].active() && Main.tile[num2 - 1, num - 1].type == 80 && num2 >= i)
				{
					num2--;
				}
				if (Main.tile[num2 + 1, num] != null && Main.tile[num2 + 1, num].active() && Main.tile[num2 + 1, num].type == 80 && Main.tile[num2 + 1, num - 1] != null && Main.tile[num2 + 1, num - 1].active() && Main.tile[num2 + 1, num - 1].type == 80 && num2 <= i)
				{
					num2++;
				}
			}
		}
		if (!Main.tile[num2, num].nactive() || Main.tile[num2, num].halfBrick() || Main.tile[num2, num].slope() != 0 || (Main.tile[num2, num].type != 53 && Main.tile[num2, num].type != 112 && Main.tile[num2, num].type != 116 && Main.tile[num2, num].type != 234))
		{
			KillTile(i, j);
			return true;
		}
		if (i != num2)
		{
			if ((!Main.tile[i, j + 1].active() || Main.tile[i, j + 1].type != 80) && (!Main.tile[i - 1, j].active() || Main.tile[i - 1, j].type != 80) && (!Main.tile[i + 1, j].active() || Main.tile[i + 1, j].type != 80))
			{
				KillTile(i, j);
				return true;
			}
		}
		else if (i == num2 && (!Main.tile[i, j + 1].active() || (Main.tile[i, j + 1].type != 80 && Main.tile[i, j + 1].type != 53 && Main.tile[i, j + 1].type != 112 && Main.tile[i, j + 1].type != 116 && Main.tile[i, j + 1].type != 234)))
		{
			KillTile(i, j);
			return true;
		}
		return false;
	}

	public static void PlantCactus(int i, int j)
	{
		GrowCactus(i, j);
		for (int k = 0; k < 150; k++)
		{
			int i2 = genRand.Next(i - 1, i + 2);
			int j2 = genRand.Next(j - 10, j + 2);
			GrowCactus(i2, j2);
		}
	}

	public static void CheckOrb(int i, int j, int type)
	{
		if (Main.tile[i, j] == null)
		{
			return;
		}
		short frameX = Main.tile[i, j].frameX;
		bool flag = false;
		if (frameX >= 36)
		{
			flag = true;
		}
		if (destroyObject)
		{
			return;
		}
		int num = i;
		int num2 = j;
		num = ((Main.tile[i, j].frameX != 0 && Main.tile[i, j].frameX != 36) ? (i - 1) : i);
		num2 = ((Main.tile[i, j].frameY != 0) ? (j - 1) : j);
		for (int k = 0; k < 2; k++)
		{
			for (int l = 0; l < 2; l++)
			{
				Tile tile = Main.tile[num + k, num2 + l];
				if (tile != null && (!tile.nactive() || tile.type != type))
				{
					destroyObject = true;
					break;
				}
			}
			if (destroyObject)
			{
				break;
			}
			if (type == 12 || type == 639)
			{
				Tile tile = Main.tile[num + k, num2 + 2];
				if (tile != null && !SolidTileAllowBottomSlope(num + k, num2 + 2))
				{
					destroyObject = true;
					break;
				}
			}
		}
		if (!destroyObject)
		{
			return;
		}
		for (int m = num; m < num + 2; m++)
		{
			for (int n = num2; n < num2 + 2; n++)
			{
				if (Main.tile[m, n] != null && Main.tile[m, n].type == type)
				{
					KillTile(m, n);
				}
			}
		}
		if (Main.netMode != 1 && !generatingWorld)
		{
			switch (type)
			{
			case 696:
				Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, (!flag) ? 5469 : 5470);
				break;
			case 12:
				Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 29);
				break;
			case 639:
				Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 109);
				break;
			case 31:
				if (flag)
				{
					int num3 = Main.rand.Next(5);
					if (!shadowOrbSmashed)
					{
						num3 = 0;
					}
					switch (num3)
					{
					case 0:
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 800, 1, noBroadcast: false, -1);
						int stack = genRand.Next(100, 101);
						Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 97, stack);
						break;
					}
					case 1:
						Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 1256, 1, noBroadcast: false, -1);
						break;
					case 2:
						Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 802, 1, noBroadcast: false, -1);
						break;
					case 3:
						Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 3062, 1, noBroadcast: false, -1);
						break;
					case 4:
						Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 1290, 1, noBroadcast: false, -1);
						break;
					}
				}
				else
				{
					int num4 = Main.rand.Next(5);
					if (!shadowOrbSmashed)
					{
						num4 = 0;
					}
					switch (num4)
					{
					case 0:
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 96, 1, noBroadcast: false, -1);
						int stack2 = genRand.Next(100, 101);
						Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 97, stack2);
						break;
					}
					case 1:
						Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 64, 1, noBroadcast: false, -1);
						break;
					case 2:
						Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 162, 1, noBroadcast: false, -1);
						break;
					case 3:
						Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 115, 1, noBroadcast: false, -1);
						break;
					case 4:
						Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 111, 1, noBroadcast: false, -1);
						break;
					}
				}
				shadowOrbSmashed = true;
				shadowOrbCount++;
				if (shadowOrbCount >= 3 || (Main.dontStarveWorld && Main.getGoodWorld && !Main.remixWorld))
				{
					if (!(NPC.AnyNPCs(266) && flag) && (!NPC.AnyNPCs(13) || flag))
					{
						shadowOrbCount = 0;
						float num5 = num * 16;
						float num6 = num2 * 16;
						float num7 = -1f;
						int plr = 0;
						for (int num8 = 0; num8 < 255; num8++)
						{
							float num9 = Math.Abs(Main.player[num8].position.X - num5) + Math.Abs(Main.player[num8].position.Y - num6);
							if (num9 < num7 || num7 == -1f)
							{
								plr = num8;
								num7 = num9;
							}
						}
						if (flag)
						{
							NPC.SpawnOnPlayer(plr, 266);
						}
						else
						{
							NPC.SpawnOnPlayer(plr, 13);
						}
					}
				}
				else
				{
					LocalizedText localizedText = Lang.misc[10];
					if (shadowOrbCount == 2)
					{
						localizedText = Lang.misc[11];
					}
					if (Main.netMode == 0)
					{
						Main.NewText(localizedText.ToString(), 50, byte.MaxValue, 130);
					}
					else if (Main.netMode == 2)
					{
						ChatHelper.BroadcastChatMessage(NetworkText.FromKey(localizedText.Key), new Color(50, 255, 130));
					}
				}
				AchievementsHelper.NotifyProgressionEvent(7);
				break;
			}
		}
		if (flag)
		{
			SoundEngine.PlaySound(4, i * 16, j * 16);
		}
		else
		{
			SoundEngine.PlaySound(13, i * 16, j * 16);
		}
		destroyObject = false;
	}

	public static void CheckPalmTree(int i, int j)
	{
		int num = -1;
		int num2 = -1;
		int type = Main.tile[i, j].type;
		int frameX = Main.tile[i, j].frameX;
		int frameY = Main.tile[i, j].frameY;
		if (Main.tile[i, j - 1] != null && Main.tile[i, j - 1].active())
		{
			num = Main.tile[i, j - 1].type;
		}
		if (Main.tile[i, j + 1] != null && Main.tile[i, j + 1].active())
		{
			num2 = Main.tile[i, j + 1].type;
		}
		if (num2 == 53)
		{
			num2 = 53;
		}
		if (num2 == 234)
		{
			num2 = 53;
		}
		if (num2 == 116)
		{
			num2 = 53;
		}
		if (num2 == 112)
		{
			num2 = 53;
		}
		if (num2 != 53 && num2 != type)
		{
			KillTile(i, j);
		}
		if ((Main.tile[i, j].frameX == 66 || Main.tile[i, j].frameX == 220) && num2 != 53)
		{
			KillTile(i, j);
		}
		if (num != type && Main.tile[i, j].frameX <= 44)
		{
			Main.tile[i, j].frameX = (short)(genRand.Next(7, 10) * 22);
		}
		else if (num != type && Main.tile[i, j].frameX == 66)
		{
			Main.tile[i, j].frameX = 220;
		}
		if (Main.tile[i, j].frameX != frameX && Main.tile[i, j].frameY != frameY && frameX >= 0 && frameY >= 0)
		{
			TileFrame(i - 1, j);
			TileFrame(i + 1, j);
			TileFrame(i, j - 1);
			TileFrame(i, j + 1);
		}
	}

	public static void CheckTreeWithSettings(int x, int y, CheckTreeSettings settings)
	{
		int num = -1;
		int num2 = -1;
		int num3 = -1;
		int num4 = -1;
		Tile tile = Main.tile[x, y];
		int type = tile.type;
		int frameX = tile.frameX;
		int frameY = tile.frameY;
		if (Main.tile[x - 1, y] != null && Main.tile[x - 1, y].active())
		{
			num2 = Main.tile[x - 1, y].type;
		}
		if (Main.tile[x + 1, y] != null && Main.tile[x + 1, y].active())
		{
			num3 = Main.tile[x + 1, y].type;
		}
		if (Main.tile[x, y - 1] != null && Main.tile[x, y - 1].active())
		{
			num = Main.tile[x, y - 1].type;
		}
		if (Main.tile[x, y + 1] != null && Main.tile[x, y + 1].active())
		{
			num4 = Main.tile[x, y + 1].type;
		}
		bool flag = settings.IsGroundValid(num4);
		bool flag2 = num3 == type;
		bool flag3 = num2 == type;
		if (!flag && num4 != type && ((tile.frameX == 0 && tile.frameY <= 130) || (tile.frameX == 22 && tile.frameY <= 130) || (tile.frameX == 44 && tile.frameY <= 130)))
		{
			KillTile(x, y);
		}
		if (tile.frameX >= 22 && tile.frameX <= 44 && tile.frameY >= 132 && tile.frameY <= 176)
		{
			if (!flag)
			{
				KillTile(x, y);
			}
			else if (!(tile.frameX == 22 && flag3) && !(tile.frameX == 44 && flag2))
			{
				KillTile(x, y);
			}
		}
		else if ((tile.frameX == 88 && tile.frameY >= 0 && tile.frameY <= 44) || (tile.frameX == 66 && tile.frameY >= 66 && tile.frameY <= 130) || (tile.frameX == 110 && tile.frameY >= 66 && tile.frameY <= 110) || (tile.frameX == 132 && tile.frameY >= 0 && tile.frameY <= 176))
		{
			int num5 = tile.frameY % 66;
			if (flag3 && flag2)
			{
				tile.frameX = 110;
				tile.frameY = (short)(66 + num5);
			}
			else if (flag3)
			{
				tile.frameX = 88;
				tile.frameY = (short)num5;
			}
			else if (flag2)
			{
				tile.frameX = 66;
				tile.frameY = (short)(66 + num5);
			}
			else
			{
				tile.frameX = 0;
				tile.frameY = (short)num5;
			}
		}
		if (tile.frameY >= 132 && tile.frameY <= 176 && (tile.frameX == 0 || tile.frameX == 66 || tile.frameX == 88))
		{
			int num6 = tile.frameY % 66;
			if (!flag)
			{
				KillTile(x, y);
			}
			else if (!flag3 && !flag2)
			{
				tile.frameX = 0;
				tile.frameY = (short)num6;
			}
			else if (!flag3)
			{
				tile.frameX = 0;
				tile.frameY = (short)(132 + num6);
			}
			else if (!flag2)
			{
				tile.frameX = 66;
				tile.frameY = (short)(132 + num6);
			}
			else
			{
				tile.frameX = 88;
				tile.frameY = (short)(132 + num6);
			}
		}
		if ((tile.frameX == 66 && (tile.frameY == 0 || tile.frameY == 22 || tile.frameY == 44)) || (tile.frameX == 44 && (tile.frameY == 198 || tile.frameY == 220 || tile.frameY == 242)))
		{
			if (!flag2)
			{
				KillTile(x, y);
			}
		}
		else if ((tile.frameX == 88 && (tile.frameY == 66 || tile.frameY == 88 || tile.frameY == 110)) || (tile.frameX == 66 && (tile.frameY == 198 || tile.frameY == 220 || tile.frameY == 242)))
		{
			if (!flag3)
			{
				KillTile(x, y);
			}
		}
		else if (num4 == -1)
		{
			KillTile(x, y);
		}
		else if (num != type && tile.frameY < 198 && ((tile.frameX != 22 && tile.frameX != 44) || tile.frameY < 132))
		{
			int num7 = tile.frameY % 66;
			if (flag3 || flag2)
			{
				if (num4 == type)
				{
					if (flag3 && flag2)
					{
						tile.frameX = 132;
						tile.frameY = (short)(132 + num7);
					}
					else if (flag3)
					{
						tile.frameX = 132;
						tile.frameY = (short)num7;
					}
					else if (flag2)
					{
						tile.frameX = 132;
						tile.frameY = (short)(66 + num7);
					}
				}
				else if (flag3 && flag2)
				{
					tile.frameX = 154;
					tile.frameY = (short)(132 + num7);
				}
				else if (flag3)
				{
					tile.frameX = 154;
					tile.frameY = (short)num7;
				}
				else if (flag2)
				{
					tile.frameX = 154;
					tile.frameY = (short)(66 + num7);
				}
			}
			else
			{
				tile.frameX = 110;
				tile.frameY = (short)num7;
			}
		}
		if (tile.frameX != frameX && tile.frameY != frameY && frameX >= 0 && frameY >= 0)
		{
			TileFrame(x - 1, y);
			TileFrame(x + 1, y);
			TileFrame(x, y - 1);
			TileFrame(x, y + 1);
		}
	}

	public static void CheckTree(int i, int j)
	{
		int num = -1;
		int num2 = -1;
		int num3 = -1;
		int num4 = -1;
		int type = Main.tile[i, j].type;
		int frameX = Main.tile[i, j].frameX;
		int frameY = Main.tile[i, j].frameY;
		if (Main.tile[i - 1, j] != null && Main.tile[i - 1, j].active())
		{
			num2 = Main.tile[i - 1, j].type;
		}
		if (Main.tile[i + 1, j] != null && Main.tile[i + 1, j].active())
		{
			num3 = Main.tile[i + 1, j].type;
		}
		if (Main.tile[i, j - 1] != null && Main.tile[i, j - 1].active())
		{
			num = Main.tile[i, j - 1].type;
		}
		if (Main.tile[i, j + 1] != null && Main.tile[i, j + 1].active())
		{
			num4 = Main.tile[i, j + 1].type;
		}
		if (Main.tile[i - 1, j - 1] != null && Main.tile[i - 1, j - 1].active())
		{
			_ = Main.tile[i - 1, j - 1].type;
		}
		if (Main.tile[i + 1, j - 1] != null && Main.tile[i + 1, j - 1].active())
		{
			_ = Main.tile[i + 1, j - 1].type;
		}
		if (Main.tile[i - 1, j + 1] != null && Main.tile[i - 1, j + 1].active())
		{
			_ = Main.tile[i - 1, j + 1].type;
		}
		if (Main.tile[i + 1, j + 1] != null && Main.tile[i + 1, j + 1].active())
		{
			_ = Main.tile[i + 1, j + 1].type;
		}
		if (num4 == 23 || num4 == 661)
		{
			num4 = 2;
		}
		if (num4 == 477)
		{
			num4 = 2;
		}
		if (num4 == 60)
		{
			num4 = 2;
		}
		if (num4 == 70)
		{
			num4 = 2;
		}
		if (num4 == 109)
		{
			num4 = 2;
		}
		if (num4 == 147)
		{
			num4 = 2;
		}
		if (num4 == 199 || num4 == 662)
		{
			num4 = 2;
		}
		if (num4 == 492)
		{
			num4 = 2;
		}
		if (num4 != 2 && num4 != type && ((Main.tile[i, j].frameX == 0 && Main.tile[i, j].frameY <= 130) || (Main.tile[i, j].frameX == 22 && Main.tile[i, j].frameY <= 130) || (Main.tile[i, j].frameX == 44 && Main.tile[i, j].frameY <= 130)))
		{
			KillTile(i, j);
		}
		if (Main.tile[i, j].frameX >= 22 && Main.tile[i, j].frameX <= 44 && Main.tile[i, j].frameY >= 132 && Main.tile[i, j].frameY <= 176)
		{
			if (num4 != 2)
			{
				KillTile(i, j);
			}
			else if ((Main.tile[i, j].frameX != 22 || num2 != type) && (Main.tile[i, j].frameX != 44 || num3 != type))
			{
				KillTile(i, j);
			}
		}
		else if ((Main.tile[i, j].frameX == 88 && Main.tile[i, j].frameY >= 0 && Main.tile[i, j].frameY <= 44) || (Main.tile[i, j].frameX == 66 && Main.tile[i, j].frameY >= 66 && Main.tile[i, j].frameY <= 130) || (Main.tile[i, j].frameX == 110 && Main.tile[i, j].frameY >= 66 && Main.tile[i, j].frameY <= 110) || (Main.tile[i, j].frameX == 132 && Main.tile[i, j].frameY >= 0 && Main.tile[i, j].frameY <= 176))
		{
			int num5 = Main.tile[i, j].frameY % 66;
			if (num2 == type && num3 == type)
			{
				Main.tile[i, j].frameX = 110;
				Main.tile[i, j].frameY = (short)(66 + num5);
			}
			else if (num2 == type)
			{
				Main.tile[i, j].frameX = 88;
				Main.tile[i, j].frameY = (short)num5;
			}
			else if (num3 == type)
			{
				Main.tile[i, j].frameX = 66;
				Main.tile[i, j].frameY = (short)(66 + num5);
			}
			else
			{
				Main.tile[i, j].frameX = 0;
				Main.tile[i, j].frameY = (short)num5;
			}
		}
		if (Main.tile[i, j].frameY >= 132 && Main.tile[i, j].frameY <= 176 && (Main.tile[i, j].frameX == 0 || Main.tile[i, j].frameX == 66 || Main.tile[i, j].frameX == 88))
		{
			int num6 = Main.tile[i, j].frameY % 66;
			if (num4 != 2)
			{
				KillTile(i, j);
			}
			if (num2 != type && num3 != type)
			{
				Main.tile[i, j].frameX = 0;
				Main.tile[i, j].frameY = (short)num6;
			}
			else if (num2 != type)
			{
				Main.tile[i, j].frameX = 0;
				Main.tile[i, j].frameY = (short)(132 + num6);
			}
			else if (num3 != type)
			{
				Main.tile[i, j].frameX = 66;
				Main.tile[i, j].frameY = (short)(132 + num6);
			}
			else
			{
				Main.tile[i, j].frameX = 88;
				Main.tile[i, j].frameY = (short)(132 + num6);
			}
		}
		if ((Main.tile[i, j].frameX == 66 && (Main.tile[i, j].frameY == 0 || Main.tile[i, j].frameY == 22 || Main.tile[i, j].frameY == 44)) || (Main.tile[i, j].frameX == 44 && (Main.tile[i, j].frameY == 198 || Main.tile[i, j].frameY == 220 || Main.tile[i, j].frameY == 242)))
		{
			if (num3 != type)
			{
				KillTile(i, j);
			}
		}
		else if ((Main.tile[i, j].frameX == 88 && (Main.tile[i, j].frameY == 66 || Main.tile[i, j].frameY == 88 || Main.tile[i, j].frameY == 110)) || (Main.tile[i, j].frameX == 66 && (Main.tile[i, j].frameY == 198 || Main.tile[i, j].frameY == 220 || Main.tile[i, j].frameY == 242)))
		{
			if (num2 != type)
			{
				KillTile(i, j);
			}
		}
		else if (num4 == -1 || num4 == 23)
		{
			KillTile(i, j);
		}
		else if (num != type && Main.tile[i, j].frameY < 198 && ((Main.tile[i, j].frameX != 22 && Main.tile[i, j].frameX != 44) || Main.tile[i, j].frameY < 132))
		{
			int num7 = Main.tile[i, j].frameY % 66;
			if (num2 == type || num3 == type)
			{
				if (num4 == type)
				{
					if (num2 == type && num3 == type)
					{
						Main.tile[i, j].frameX = 132;
						Main.tile[i, j].frameY = (short)(132 + num7);
					}
					else if (num2 == type)
					{
						Main.tile[i, j].frameX = 132;
						Main.tile[i, j].frameY = (short)num7;
					}
					else if (num3 == type)
					{
						Main.tile[i, j].frameX = 132;
						Main.tile[i, j].frameY = (short)(66 + num7);
					}
				}
				else if (num2 == type && num3 == type)
				{
					Main.tile[i, j].frameX = 154;
					Main.tile[i, j].frameY = (short)(132 + num7);
				}
				else if (num2 == type)
				{
					Main.tile[i, j].frameX = 154;
					Main.tile[i, j].frameY = (short)num7;
				}
				else if (num3 == type)
				{
					Main.tile[i, j].frameX = 154;
					Main.tile[i, j].frameY = (short)(66 + num7);
				}
			}
			else
			{
				Main.tile[i, j].frameX = 110;
				Main.tile[i, j].frameY = (short)num7;
			}
		}
		if (Main.tile[i, j].frameX != frameX && Main.tile[i, j].frameY != frameY && frameX >= 0 && frameY >= 0)
		{
			TileFrame(i - 1, j);
			TileFrame(i + 1, j);
			TileFrame(i, j - 1);
			TileFrame(i, j + 1);
		}
	}

	public static bool TileIsExposedToAir(int x, int y)
	{
		if (!InWorld(x, y, 2))
		{
			return false;
		}
		for (int i = x - 1; i <= x + 1; i++)
		{
			for (int j = y - 1; j <= y + 1; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile != null && (!tile.active() || !Main.tileSolid[tile.type] || TileID.Sets.Platforms[tile.type]))
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool TryConvertingOrKillingTreesAboveIfTheyWouldBecomeInvalid(int i, int j, int newFloorType)
	{
		if (newFloorType < 0 || newFloorType >= TileID.Count)
		{
			return false;
		}
		if (!InWorld(i, j, 2))
		{
			return false;
		}
		Tile tile = Main.tile[i, j];
		if (tile == null || !tile.active())
		{
			return false;
		}
		Tile tile2 = Main.tile[i, j - 1];
		if (tile2 == null || !tile2.active())
		{
			return false;
		}
		ushort type = tile2.type;
		if (!IsTreeType(tile2.type) && tile2.type != 323)
		{
			return false;
		}
		bool flag = true;
		if (flag)
		{
			switch (type)
			{
			case 5:
				flag = TileID.Sets.Conversion.Grass[newFloorType] || TileID.Sets.Conversion.JungleGrass[newFloorType] || TileID.Sets.Conversion.Snow[newFloorType] || TileID.Sets.Conversion.MushroomGrass[newFloorType];
				break;
			case 323:
				flag = TileID.Sets.Conversion.Sand[newFloorType];
				break;
			}
		}
		if (flag && GrowTreeSettings.Profiles.TryGetFromTreeId(type, out var profile))
		{
			flag = profile.GroundTest(newFloorType);
		}
		if (!flag)
		{
			switch (type)
			{
			default:
				KillTile(i, j - 1);
				if (Main.netMode == 1)
				{
					NetMessage.SendData(17, -1, -1, null, 0, i, j - 1);
				}
				break;
			case 596:
			case 616:
				if (TileID.Sets.Conversion.Grass[newFloorType] || TileID.Sets.Conversion.JungleGrass[newFloorType] || TileID.Sets.Conversion.Snow[newFloorType] || TileID.Sets.Conversion.MushroomGrass[newFloorType])
				{
					ConvertTreeAndGround(i, j - 1, newFloorType, type, 5);
					break;
				}
				if (TileID.Sets.Conversion.Sand[newFloorType])
				{
					ConvertTreeAndGround(i, j - 1, newFloorType, type, 323);
					break;
				}
				KillTile(i, j - 1);
				if (Main.netMode == 1)
				{
					NetMessage.SendData(17, -1, -1, null, 0, i, j - 1);
				}
				break;
			case 5:
				if (TileID.Sets.Conversion.Sand[newFloorType])
				{
					ConvertTreeAndGround(i, j - 1, newFloorType, type, 323);
					break;
				}
				KillTile(i, j - 1);
				if (Main.netMode == 1)
				{
					NetMessage.SendData(17, -1, -1, null, 0, i, j - 1);
				}
				break;
			case 323:
				if (TileID.Sets.Conversion.Grass[newFloorType] || TileID.Sets.Conversion.JungleGrass[newFloorType] || TileID.Sets.Conversion.Snow[newFloorType] || TileID.Sets.Conversion.MushroomGrass[newFloorType])
				{
					ConvertTreeAndGround(i, j - 1, newFloorType, type, 5);
					break;
				}
				KillTile(i, j - 1);
				if (Main.netMode == 1)
				{
					NetMessage.SendData(17, -1, -1, null, 0, i, j - 1);
				}
				break;
			}
		}
		return true;
	}

	public static void ConvertTreeAndGround(int x, int y, int newFloorType, int oldTreeType, int newTreeType)
	{
		if (!InWorld(x, y, 5))
		{
			return;
		}
		Tile tile = Main.tile[x, y + 1];
		if (tile == null || !tile.active())
		{
			return;
		}
		int num = 100;
		int num2 = 1;
		int offsetToTrunk = 0;
		while (num > 0)
		{
			num--;
			if (!InWorld(x, y - 1 - num2, 5))
			{
				break;
			}
			Tile tile2 = Main.tile[x, y - 1 - num2];
			if (tile2 == null || !tile2.active() || (tile2.type != 323 && !TileID.Sets.IsATreeTrunk[tile2.type]) || IsTileATreeBranch(x, y - 1, out offsetToTrunk))
			{
				break;
			}
			num2++;
		}
		if (IsTileATreeBranch(x, y, out offsetToTrunk) || IsTileATreeRoot(x, y, out offsetToTrunk))
		{
			KillTile(x, y);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 0, x, y);
			}
			return;
		}
		if (newTreeType == 323)
		{
			for (int i = 0; i <= num2; i++)
			{
				Tile tile3 = Main.tile[x, y - i];
				if (tile3 != null && tile3.active())
				{
					int offsetToTrunk2 = 0;
					if ((IsTileATreeBranch(x - 1, y - i, out offsetToTrunk2) && offsetToTrunk2 == 1) || (IsTileATreeRoot(x - 1, y - i, out offsetToTrunk2) && offsetToTrunk2 == 1))
					{
						KillTile(x - 1, y - i);
					}
					if ((IsTileATreeBranch(x + 1, y - i, out offsetToTrunk2) && offsetToTrunk2 == -1) || (IsTileATreeRoot(x + 1, y - i, out offsetToTrunk2) && offsetToTrunk2 == -1))
					{
						KillTile(x + 1, y - i);
					}
				}
			}
		}
		for (int j = 0; j <= num2; j++)
		{
			Tile tile4 = Main.tile[x, y - j];
			if (tile4 == null || !tile4.active())
			{
				continue;
			}
			tile4.type = (ushort)newTreeType;
			bool num3 = j == 0;
			bool flag = j == num2;
			if (num3)
			{
				switch (newTreeType)
				{
				case 5:
				case 596:
				case 616:
					if (oldTreeType == 323)
					{
						tile4.frameX = 0;
						tile4.frameY = (short)(22 * genRand.Next(0, 3));
					}
					else
					{
						ConvertTreeAndGround_Branches(x, y - j, newTreeType);
					}
					break;
				case 323:
					tile4.frameX = 66;
					tile4.frameY = 0;
					break;
				}
				continue;
			}
			if (flag)
			{
				switch (newTreeType)
				{
				case 5:
				case 596:
				case 616:
					if (oldTreeType == 323)
					{
						tile4.frameX = 22;
						tile4.frameY = (short)(22 * genRand.Next(9, 12));
					}
					else
					{
						ConvertTreeAndGround_Branches(x, y - j, newTreeType);
					}
					break;
				case 323:
					tile4.frameX = (short)(22 * genRand.Next(4, 7));
					tile4.frameY = 0;
					break;
				}
				continue;
			}
			switch (newTreeType)
			{
			case 5:
			case 596:
			case 616:
				if (oldTreeType == 323)
				{
					if (genRand.Next(2) == 0)
					{
						tile4.frameX = 44;
						tile4.frameY = (short)(22 * genRand.Next(3, 6));
					}
					else if (genRand.Next(2) == 0)
					{
						tile4.frameX = 22;
						tile4.frameY = (short)(22 * genRand.Next(0, 6));
					}
					else
					{
						tile4.frameX = 0;
						tile4.frameY = (short)(22 * genRand.Next(0, 6));
					}
				}
				else
				{
					ConvertTreeAndGround_Branches(x, y - j, newTreeType);
				}
				break;
			case 323:
				tile4.frameX = (short)(22 * genRand.Next(0, 3));
				tile4.frameY = 0;
				break;
			}
		}
		tile.type = (ushort)newFloorType;
		NetMessage.SendTileSquare(-1, x - 1, y - num2 - 1, 3, num2 + 3);
	}

	private static void ConvertTreeAndGround_Branches(int x, int y, int newType)
	{
		int offsetToTrunk = 0;
		if ((IsTileATreeBranch(x - 1, y, out offsetToTrunk) && offsetToTrunk == 1) || (IsTileATreeRoot(x - 1, y, out offsetToTrunk) && offsetToTrunk == 1))
		{
			Main.tile[x - 1, y].type = (ushort)newType;
		}
		if ((IsTileATreeBranch(x + 1, y, out offsetToTrunk) && offsetToTrunk == -1) || (IsTileATreeRoot(x + 1, y, out offsetToTrunk) && offsetToTrunk == -1))
		{
			Main.tile[x + 1, y].type = (ushort)newType;
		}
	}

	public static void Convert(int i, int j, int conversionType, int size, bool tiles = true, bool walls = true)
	{
		if (!tiles && !walls)
		{
			return;
		}
		for (int k = i - size; k <= i + size; k++)
		{
			for (int l = j - size; l <= j + size; l++)
			{
				if (InWorld(k, l, 1) && Math.Abs(k - i) + Math.Abs(l - j) < 6)
				{
					Convert(k, l, conversionType, tiles, walls);
				}
			}
		}
	}

	public static void Convert(int i2, int j2, int conversionType, bool tiles = true, bool walls = true)
	{
		if (!InWorld(i2, j2, 1) || (!tiles && !walls))
		{
			return;
		}
		Tile theTile = Main.tile[i2, j2];
		ushort type = theTile.type;
		ushort wall = theTile.wall;
		if (!theTile.active() && wall <= 0)
		{
			return;
		}
		switch (conversionType)
		{
		case 4:
			if (walls)
			{
				if (WallID.Sets.Conversion.Grass[wall] && wall != 81)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 81);
				}
				else if (WallID.Sets.Conversion.Stone[wall] && wall != 83)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 83);
				}
				else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 218)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 218);
				}
				else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 221)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 221);
				}
				else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 192)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 192);
				}
				else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 193)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 193);
				}
				else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 194)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 194);
				}
				else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 195)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 195);
				}
			}
			if (tiles)
			{
				if (type == 4 && TileID.Sets.Conversion.Torch(theTile, conversionType))
				{
					Convert_ActuallyConvertTorch(conversionType, i2, j2, ref theTile, 19);
				}
				else if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type]) && type != 203)
				{
					Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 203);
				}
				else if (TileID.Sets.Conversion.JungleGrass[type] && type != 662)
				{
					Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 662);
				}
				else if (TileID.Sets.Conversion.Grass[type] && type != 199)
				{
					Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 199);
				}
				else if (TileID.Sets.Conversion.Ice[type] && type != 200)
				{
					Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 200);
				}
				else if (TileID.Sets.Conversion.Sand[type] && type != 234)
				{
					Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 234);
				}
				else if (TileID.Sets.Conversion.HardenedSand[type] && type != 399)
				{
					Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 399);
				}
				else if (TileID.Sets.Conversion.Sandstone[type] && type != 401)
				{
					Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 401);
				}
				else if (TileID.Sets.Conversion.Thorn[type] && type != 352)
				{
					Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 352);
				}
			}
			break;
		case 2:
			if (walls)
			{
				if (WallID.Sets.Conversion.Grass[wall] && wall != 70)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 70);
				}
				else if (WallID.Sets.Conversion.Stone[wall] && wall != 28)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 28);
				}
				else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 219)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 219);
				}
				else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 222)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 222);
				}
				else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 200)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 200);
				}
				else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 201)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 201);
				}
				else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 202)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 202);
				}
				else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 203)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 203);
				}
			}
			if (!tiles)
			{
				break;
			}
			if (type == 4 && TileID.Sets.Conversion.Torch(theTile, conversionType))
			{
				Convert_ActuallyConvertTorch(conversionType, i2, j2, ref theTile, 20);
			}
			else if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type]) && type != 117)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 117);
			}
			else if (TileID.Sets.Conversion.GolfGrass[type] && type != 492)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 492);
			}
			else if (TileID.Sets.Conversion.Grass[type] && type != 109 && type != 492)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 109);
			}
			else if (TileID.Sets.Conversion.Ice[type] && type != 164)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 164);
			}
			else if (TileID.Sets.Conversion.Sand[type] && type != 116)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 116);
			}
			else if (TileID.Sets.Conversion.HardenedSand[type] && type != 402)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 402);
			}
			else if (TileID.Sets.Conversion.Sandstone[type] && type != 403)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 403);
			}
			else if (TileID.Sets.Conversion.Thorn[type])
			{
				KillTile(i2, j2);
				if (Main.netMode != 0)
				{
					NetMessage.SendData(17, -1, -1, null, 0, i2, j2);
				}
			}
			if (type == 59 && (Main.tile[i2 - 1, j2].type == 109 || Main.tile[i2 + 1, j2].type == 109 || Main.tile[i2, j2 - 1].type == 109 || Main.tile[i2, j2 + 1].type == 109))
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 0);
			}
			break;
		case 1:
			if (walls)
			{
				if (WallID.Sets.Conversion.Grass[wall] && wall != 69)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 69);
				}
				else if (WallID.Sets.Conversion.Stone[wall] && wall != 3)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 3);
				}
				else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 217)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 217);
				}
				else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 220)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 220);
				}
				else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 188)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 188);
				}
				else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 189)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 189);
				}
				else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 190)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 190);
				}
				else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 191)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 191);
				}
			}
			if (tiles)
			{
				if (type == 4 && TileID.Sets.Conversion.Torch(theTile, conversionType))
				{
					Convert_ActuallyConvertTorch(conversionType, i2, j2, ref theTile, 18);
				}
				else if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type]) && type != 25)
				{
					Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 25);
				}
				else if (TileID.Sets.Conversion.JungleGrass[type] && type != 661)
				{
					Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 661);
				}
				else if (TileID.Sets.Conversion.Grass[type] && type != 23)
				{
					Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 23);
				}
				else if (TileID.Sets.Conversion.Ice[type] && type != 163)
				{
					Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 163);
				}
				else if (TileID.Sets.Conversion.Sand[type] && type != 112)
				{
					Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 112);
				}
				else if (TileID.Sets.Conversion.HardenedSand[type] && type != 398)
				{
					Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 398);
				}
				else if (TileID.Sets.Conversion.Sandstone[type] && type != 400)
				{
					Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 400);
				}
				else if (TileID.Sets.Conversion.Thorn[type] && type != 32)
				{
					Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 32);
				}
			}
			break;
		case 3:
			if (walls && WallID.Sets.CanBeConvertedToGlowingMushroom[wall])
			{
				Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 80);
			}
			if (!tiles)
			{
				break;
			}
			if (type == 4 && TileID.Sets.Conversion.Torch(theTile, conversionType))
			{
				Convert_ActuallyConvertTorch(conversionType, i2, j2, ref theTile, 22);
			}
			else if (theTile.type == 60)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 70);
			}
			else if (TileID.Sets.Conversion.Thorn[type])
			{
				KillTile(i2, j2);
				if (Main.netMode != 0)
				{
					NetMessage.SendData(17, -1, -1, null, 0, i2, j2);
				}
			}
			break;
		case 5:
			if (walls)
			{
				if ((WallID.Sets.Conversion.Stone[wall] || WallID.Sets.Conversion.NewWall1[wall] || WallID.Sets.Conversion.NewWall2[wall] || WallID.Sets.Conversion.NewWall3[wall] || WallID.Sets.Conversion.NewWall4[wall] || WallID.Sets.Conversion.Ice[wall] || WallID.Sets.Conversion.Sandstone[wall]) && wall != 187)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 187);
				}
				else if ((WallID.Sets.Conversion.HardenedSand[wall] || WallID.Sets.Conversion.Dirt[wall] || WallID.Sets.Conversion.Snow[wall]) && wall != 216)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 216);
				}
			}
			if (!tiles)
			{
				break;
			}
			if (type == 4 && TileID.Sets.Conversion.Torch(theTile, conversionType))
			{
				Convert_ActuallyConvertTorch(conversionType, i2, j2, ref theTile, 16);
			}
			else if ((TileID.Sets.Conversion.Grass[type] || TileID.Sets.Conversion.Sand[type] || TileID.Sets.Conversion.Snow[type] || TileID.Sets.Conversion.Dirt[type]) && type != 53)
			{
				int newType8 = 53;
				if (BlockBelowMakesSandConvertIntoHardenedSand(i2, j2))
				{
					newType8 = 397;
				}
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, newType8);
			}
			else if (TileID.Sets.Conversion.HardenedSand[type] && type != 397)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 397);
			}
			else if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type] || TileID.Sets.Conversion.Ice[type] || TileID.Sets.Conversion.Sandstone[type]) && type != 396)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 396);
			}
			else if (TileID.Sets.Conversion.Thorn[type] && type != 69)
			{
				KillTile(i2, j2);
				if (Main.netMode != 0)
				{
					NetMessage.SendData(17, -1, -1, null, 0, i2, j2);
				}
			}
			break;
		case 6:
			if (walls)
			{
				if ((WallID.Sets.Conversion.Stone[wall] || WallID.Sets.Conversion.NewWall1[wall] || WallID.Sets.Conversion.NewWall2[wall] || WallID.Sets.Conversion.NewWall3[wall] || WallID.Sets.Conversion.NewWall4[wall] || WallID.Sets.Conversion.Ice[wall] || WallID.Sets.Conversion.Sandstone[wall]) && wall != 71)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 71);
				}
				else if ((WallID.Sets.Conversion.HardenedSand[wall] || WallID.Sets.Conversion.Dirt[wall] || WallID.Sets.Conversion.Snow[wall]) && wall != 40)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 40);
				}
			}
			if (!tiles)
			{
				break;
			}
			if (type == 4 && TileID.Sets.Conversion.Torch(theTile, conversionType))
			{
				Convert_ActuallyConvertTorch(conversionType, i2, j2, ref theTile, 9);
			}
			else if ((TileID.Sets.Conversion.Grass[type] || TileID.Sets.Conversion.Sand[type] || TileID.Sets.Conversion.HardenedSand[type] || TileID.Sets.Conversion.Snow[type] || TileID.Sets.Conversion.Dirt[type]) && type != 147)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 147);
			}
			else if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type] || TileID.Sets.Conversion.Ice[type] || TileID.Sets.Conversion.Sandstone[type]) && type != 161)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 161);
			}
			else if (TileID.Sets.Conversion.Thorn[type] && type != 69)
			{
				KillTile(i2, j2);
				if (Main.netMode != 0)
				{
					NetMessage.SendData(17, -1, -1, null, 0, i2, j2);
				}
			}
			break;
		case 7:
			if (walls)
			{
				bool flag2 = wall == 61 || wall == 185 || wall == 262 || wall == 274;
				if ((WallID.Sets.Conversion.Stone[wall] || WallID.Sets.Conversion.Ice[wall] || WallID.Sets.Conversion.Sandstone[wall]) && wall != 349 && !flag2)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 349);
				}
				else
				{
					switch (wall)
					{
					case 262:
						Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 61);
						break;
					case 274:
						Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 185);
						break;
					default:
						if ((WallID.Sets.Conversion.HardenedSand[wall] || WallID.Sets.Conversion.Snow[wall] || WallID.Sets.Conversion.Dirt[wall]) && wall != 2)
						{
							Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 2);
						}
						else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 212)
						{
							Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 212);
						}
						else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 213)
						{
							Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 213);
						}
						else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 214)
						{
							Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 214);
						}
						else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 215)
						{
							Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 215);
						}
						break;
					}
				}
			}
			if (!tiles)
			{
				break;
			}
			if (type == 4 && TileID.Sets.Conversion.Torch(theTile, conversionType))
			{
				Convert_ActuallyConvertTorch(conversionType, i2, j2, ref theTile, 0);
			}
			else if ((TileID.Sets.Conversion.Stone[type] || TileID.Sets.Conversion.Ice[type] || TileID.Sets.Conversion.Sandstone[type]) && type != 1)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 1);
			}
			else if (TileID.Sets.Conversion.GolfGrass[type] && type != 477)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 477);
			}
			else if (TileID.Sets.Conversion.Grass[type] && type != 2 && type != 477)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 2);
			}
			else if ((TileID.Sets.Conversion.Sand[type] || TileID.Sets.Conversion.HardenedSand[type] || TileID.Sets.Conversion.Snow[type] || TileID.Sets.Conversion.Dirt[type]) && type != 0)
			{
				int newType7 = 0;
				if (TileIsExposedToAir(i2, j2))
				{
					newType7 = 2;
				}
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, newType7);
			}
			else if (tiles && TileID.Sets.Conversion.Thorn[type] && type != 69)
			{
				KillTile(i2, j2);
				if (Main.netMode != 0)
				{
					NetMessage.SendData(17, -1, -1, null, 0, i2, j2);
				}
			}
			break;
		case 0:
			if (walls)
			{
				if (theTile.wall == 69 || theTile.wall == 70 || theTile.wall == 81)
				{
					ushort newType5 = 64;
					if ((double)j2 < Main.worldSurface)
					{
						newType5 = (ushort)((genRand.Next(10) != 0) ? 63 : 65);
					}
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, newType5);
				}
				else
				{
					switch (wall)
					{
					case 262:
						Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 61);
						break;
					case 274:
						Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 185);
						break;
					case 292:
						Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 204);
						break;
					case 293:
						Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 205);
						break;
					case 294:
						Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 206);
						break;
					case 295:
						Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 207);
						break;
					default:
						if (WallID.Sets.Conversion.Stone[wall] && wall != 349)
						{
							Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 349);
						}
						else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 212)
						{
							Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 212);
						}
						else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 213)
						{
							Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 213);
						}
						else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 214)
						{
							Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 214);
						}
						else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 215)
						{
							Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 215);
						}
						else if (theTile.wall == 80)
						{
							if ((double)j2 < Main.worldSurface + 4.0 + (double)genRand.Next(3) || (double)j2 > ((double)Main.maxTilesY + Main.rockLayer) / 2.0 - 3.0 + (double)genRand.Next(3))
							{
								Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 15);
							}
							else
							{
								Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 64);
							}
						}
						else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 216)
						{
							Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 216);
						}
						else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 187)
						{
							Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 187);
						}
						break;
					case 61:
					case 185:
					case 204:
					case 205:
					case 206:
					case 207:
						break;
					}
				}
			}
			if (!tiles)
			{
				break;
			}
			if (type == 4 && TileID.Sets.Conversion.Torch(theTile, conversionType))
			{
				Convert_ActuallyConvertTorch(conversionType, i2, j2, ref theTile, 0);
			}
			else if (theTile.type == 492)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 477);
			}
			else if (TileID.Sets.Conversion.JungleGrass[type] && type != 60)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 60);
			}
			else if (TileID.Sets.Conversion.Grass[type] && type != 2 && type != 477)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 2);
			}
			else if (TileID.Sets.Conversion.Stone[type] && type != 1)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 1);
			}
			else if (TileID.Sets.Conversion.Sand[type] && type != 53)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 53);
			}
			else if (TileID.Sets.Conversion.HardenedSand[type] && type != 397)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 397);
			}
			else if (TileID.Sets.Conversion.Sandstone[type] && type != 396)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 396);
			}
			else if (TileID.Sets.Conversion.Ice[type] && type != 161)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 161);
			}
			else if (TileID.Sets.Conversion.MushroomGrass[type])
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 60);
			}
			else if (theTile.type == 32 || Main.tile[i2, j2].type == 352)
			{
				KillTile(i2, j2);
				if (Main.netMode != 0)
				{
					NetMessage.SendData(17, -1, -1, null, 0, i2, j2);
				}
			}
			break;
		case 8:
			if (tiles && (type == 59 || type == 60))
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 211);
			}
			break;
		case 9:
			if (!tiles)
			{
				break;
			}
			switch (type)
			{
			case 2:
			case 23:
			case 109:
			case 199:
			case 477:
			case 492:
			case 661:
			case 662:
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 60);
				break;
			case 0:
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 59);
				break;
			case 25:
			case 203:
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 1);
				break;
			case 112:
			case 234:
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 53);
				break;
			case 398:
			case 399:
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 397);
				break;
			case 400:
			case 401:
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 396);
				break;
			case 24:
			case 32:
			case 201:
			case 205:
			case 352:
			case 636:
				KillTile(i2, j2);
				if (Main.netMode != 0)
				{
					NetMessage.SendData(17, -1, -1, null, 0, i2, j2);
				}
				break;
			}
			break;
		case 10:
			if (!tiles)
			{
				break;
			}
			switch (type)
			{
			case 23:
			case 199:
			case 661:
			case 662:
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 60);
				break;
			case 25:
			case 203:
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 1);
				break;
			case 112:
			case 234:
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 53);
				break;
			case 398:
			case 399:
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 397);
				break;
			case 400:
			case 401:
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 396);
				break;
			case 24:
			case 32:
			case 201:
			case 205:
			case 352:
			case 636:
				KillTile(i2, j2);
				if (Main.netMode != 0)
				{
					NetMessage.SendData(17, -1, -1, null, 0, i2, j2);
				}
				break;
			}
			break;
		case 11:
			if (walls)
			{
				bool flag = wall == 61 || wall == 185 || wall == 262 || wall == 274;
				if (WallID.Sets.Conversion.Stone[wall] && wall != 349 && !flag)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 349);
				}
				else
				{
					switch (wall)
					{
					case 69:
					case 70:
					case 81:
					{
						ushort newType6 = 64;
						if ((double)j2 < Main.worldSurface)
						{
							newType6 = (ushort)((genRand.Next(10) != 0) ? 63 : 65);
						}
						Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, newType6);
						break;
					}
					case 262:
						Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 61);
						break;
					case 274:
						Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 185);
						break;
					default:
						if (WallID.Sets.Conversion.Dirt[wall] && wall != 2)
						{
							Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 2);
						}
						else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 212)
						{
							Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 212);
						}
						else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 213)
						{
							Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 213);
						}
						else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 214)
						{
							Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 214);
						}
						else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 215)
						{
							Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 215);
						}
						else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 216)
						{
							Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 216);
						}
						else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 187)
						{
							Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 187);
						}
						break;
					}
				}
			}
			if (type == 4 && TileID.Sets.Conversion.Torch(theTile, conversionType))
			{
				Convert_ActuallyConvertTorch(conversionType, i2, j2, ref theTile, 0);
			}
			else if (TileID.Sets.Conversion.JungleGrass[type] && type != 60)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 60);
			}
			else if (TileID.Sets.Conversion.GolfGrass[type] && type != 477)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 477);
			}
			else if (TileID.Sets.Conversion.Grass[type] && type != 2 && type != 477)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 2);
			}
			else if (TileID.Sets.Conversion.Stone[type] && type != 1)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 1);
			}
			else if (TileID.Sets.Ices[type] && type != 161)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 161);
			}
			else if (TileID.Sets.Conversion.Sand[type] && type != 53)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 53);
			}
			else if (TileID.Sets.Conversion.HardenedSand[type] && type != 397)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 397);
			}
			else if (TileID.Sets.Conversion.Sandstone[type] && type != 396)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 396);
			}
			break;
		case 12:
			if (walls)
			{
				if (WallID.Sets.Conversion.NewWall1[wall] && wall != 188)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 188);
				}
				else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 189)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 189);
				}
				else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 190)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 190);
				}
				else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 191)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 191);
				}
				else if (wall != 0 && wall != 3)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 3);
				}
			}
			if (tiles)
			{
				if (type == 4 && TileID.Sets.Conversion.Torch(theTile, conversionType))
				{
					Convert_ActuallyConvertTorch(conversionType, i2, j2, ref theTile, 18);
				}
				else if (TileID.Sets.Conversion.Thorn[type] && type != 32)
				{
					Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 32);
				}
				else if (type != 25 && !Main.tileFrameImportant[type])
				{
					Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 25);
				}
			}
			break;
		case 13:
			if (walls)
			{
				if (WallID.Sets.Conversion.NewWall1[wall] && wall != 192)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 192);
				}
				else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 193)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 193);
				}
				else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 194)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 194);
				}
				else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 195)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 195);
				}
				else if (wall != 0 && wall != 83)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 83);
				}
			}
			if (tiles)
			{
				if (type == 4 && TileID.Sets.Conversion.Torch(theTile, conversionType))
				{
					Convert_ActuallyConvertTorch(conversionType, i2, j2, ref theTile, 19);
				}
				else if (TileID.Sets.Conversion.Thorn[type] && type != 352)
				{
					Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 352);
				}
				else if (type != 203 && !Main.tileFrameImportant[type])
				{
					Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 203);
				}
			}
			break;
		case 14:
			if (walls)
			{
				if (WallID.Sets.Conversion.NewWall1[wall] && wall != 200)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 200);
				}
				else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 201)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 201);
				}
				else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 202)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 202);
				}
				else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 203)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 203);
				}
				else if (wall != 0 && wall != 28)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 28);
				}
			}
			if (!tiles)
			{
				break;
			}
			if (type == 4 && TileID.Sets.Conversion.Torch(theTile, conversionType))
			{
				Convert_ActuallyConvertTorch(conversionType, i2, j2, ref theTile, 20);
			}
			else if (TileID.Sets.Conversion.Thorn[type])
			{
				KillTile(i2, j2);
				if (Main.netMode != 0)
				{
					NetMessage.SendData(17, -1, -1, null, 0, i2, j2);
				}
			}
			else if (type != 117 && !Main.tileFrameImportant[type])
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 117);
			}
			break;
		case 15:
			if (walls)
			{
				Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 80);
			}
			if (!tiles)
			{
				break;
			}
			if (type == 4 && TileID.Sets.Conversion.Torch(theTile, conversionType))
			{
				Convert_ActuallyConvertTorch(conversionType, i2, j2, ref theTile, 22);
			}
			else if (TileID.Sets.Conversion.Thorn[type])
			{
				KillTile(i2, j2);
				if (Main.netMode != 0)
				{
					NetMessage.SendData(17, -1, -1, null, 0, i2, j2);
				}
			}
			if (!Main.tileFrameImportant[type])
			{
				if (TileIsExposedToAir(i2, j2))
				{
					Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 70);
				}
				else
				{
					Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 59);
				}
			}
			break;
		case 16:
			if (walls)
			{
				if ((WallID.Sets.Conversion.HardenedSand[wall] || WallID.Sets.Conversion.Dirt[wall] || WallID.Sets.Conversion.Snow[wall]) && wall != 216)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 216);
				}
				else if (wall != 187)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 187);
				}
			}
			if (!tiles)
			{
				break;
			}
			if (type == 4 && TileID.Sets.Conversion.Torch(theTile, conversionType))
			{
				Convert_ActuallyConvertTorch(conversionType, i2, j2, ref theTile, 16);
			}
			else if ((TileID.Sets.Conversion.Grass[type] || TileID.Sets.Conversion.Sand[type] || TileID.Sets.Conversion.Snow[type] || TileID.Sets.Conversion.Dirt[type]) && type != 53)
			{
				int newType3 = 53;
				if (BlockBelowMakesSandConvertIntoHardenedSand(i2, j2))
				{
					newType3 = 397;
				}
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, newType3);
			}
			else if (TileID.Sets.Conversion.HardenedSand[type] && type != 397)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 397);
			}
			else if (TileID.Sets.Conversion.Thorn[type] && type != 69)
			{
				KillTile(i2, j2);
				if (Main.netMode != 0)
				{
					NetMessage.SendData(17, -1, -1, null, 0, i2, j2);
				}
			}
			else if (type != 396 && !Main.tileFrameImportant[type])
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 396);
			}
			break;
		case 17:
			if (walls)
			{
				if ((WallID.Sets.Conversion.Stone[wall] || WallID.Sets.Conversion.NewWall1[wall] || WallID.Sets.Conversion.NewWall2[wall] || WallID.Sets.Conversion.NewWall3[wall] || WallID.Sets.Conversion.NewWall4[wall] || WallID.Sets.Conversion.Ice[wall] || WallID.Sets.Conversion.Sandstone[wall]) && wall != 71)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 71);
				}
				else if (wall != 40)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 40);
				}
			}
			if (!tiles)
			{
				break;
			}
			if (type == 4 && TileID.Sets.Conversion.Torch(theTile, conversionType))
			{
				Convert_ActuallyConvertTorch(conversionType, i2, j2, ref theTile, 9);
			}
			else if ((TileID.Sets.Conversion.Grass[type] || TileID.Sets.Conversion.Sand[type] || TileID.Sets.Conversion.HardenedSand[type] || TileID.Sets.Conversion.Snow[type] || TileID.Sets.Conversion.Dirt[type]) && type != 147)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 147);
			}
			else if (TileID.Sets.Conversion.Thorn[type] && type != 69)
			{
				KillTile(i2, j2);
				if (Main.netMode != 0)
				{
					NetMessage.SendData(17, -1, -1, null, 0, i2, j2);
				}
			}
			else if (type != 161 && !Main.tileFrameImportant[type])
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 161);
			}
			break;
		case 18:
			if (walls)
			{
				if ((WallID.Sets.Conversion.HardenedSand[wall] || WallID.Sets.Conversion.Snow[wall] || WallID.Sets.Conversion.Dirt[wall]) && wall != 2)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 2);
				}
				else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 212)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 212);
				}
				else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 213)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 213);
				}
				else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 214)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 214);
				}
				else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 215)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 215);
				}
				else if (wall != 349)
				{
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 349);
				}
			}
			if (!tiles)
			{
				break;
			}
			if (type == 4 && TileID.Sets.Conversion.Torch(theTile, conversionType))
			{
				Convert_ActuallyConvertTorch(conversionType, i2, j2, ref theTile, 0);
			}
			else if (TileID.Sets.Conversion.GolfGrass[type] && type != 477)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 477);
			}
			else if (TileID.Sets.Conversion.Grass[type] && type != 2 && type != 477)
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 2);
			}
			else if ((TileID.Sets.Conversion.Sand[type] || TileID.Sets.Conversion.HardenedSand[type] || TileID.Sets.Conversion.Snow[type] || TileID.Sets.Conversion.Dirt[type]) && type != 0)
			{
				int newType4 = 0;
				if (TileIsExposedToAir(i2, j2))
				{
					newType4 = 2;
				}
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, newType4);
			}
			else if (TileID.Sets.Conversion.Thorn[type])
			{
				KillTile(i2, j2);
				if (Main.netMode != 0)
				{
					NetMessage.SendData(17, -1, -1, null, 0, i2, j2);
				}
			}
			else if (type != 1 && !Main.tileFrameImportant[type])
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 1);
			}
			break;
		case 19:
			if (walls && wall > 0)
			{
				switch (wall)
				{
				case 63:
				case 69:
				case 70:
				case 81:
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 64);
					break;
				default:
					Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 15);
					break;
				case 15:
					break;
				}
			}
			if (!tiles)
			{
				break;
			}
			if (type == 4 && TileID.Sets.Conversion.Torch(theTile, conversionType))
			{
				Convert_ActuallyConvertTorch(conversionType, i2, j2, ref theTile, 21);
			}
			else if (TileID.Sets.Conversion.Thorn[type])
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 69);
			}
			if (!Main.tileFrameImportant[type])
			{
				if (TileIsExposedToAir(i2, j2))
				{
					Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 60);
				}
				else
				{
					Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 59);
				}
			}
			break;
		case 20:
			if (walls)
			{
				Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, 87);
			}
			if (tiles)
			{
				if (type == 4 && TileID.Sets.Conversion.Torch(theTile, conversionType))
				{
					Convert_ActuallyConvertTorch(conversionType, i2, j2, ref theTile, 21);
				}
				else if (type != 69 && TileID.Sets.Conversion.Thorn[type])
				{
					Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 69);
				}
				if (!Main.tileFrameImportant[type])
				{
					Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, 226);
				}
			}
			break;
		case 21:
		{
			DungeonGenVars currentDungeonGenVars = GenVars.CurrentDungeonGenVars;
			ushort newType = currentDungeonGenVars?.brickTileType ?? 41;
			ushort newType2 = currentDungeonGenVars?.brickWallType ?? 17;
			if (walls)
			{
				Convert_ActuallyConvertWall(conversionType, i2, j2, ref theTile, newType2);
			}
			if (!tiles)
			{
				break;
			}
			if (type == 4 && TileID.Sets.Conversion.Torch(theTile, conversionType))
			{
				Convert_ActuallyConvertTorch(conversionType, i2, j2, ref theTile, 21);
			}
			else if (TileID.Sets.Conversion.Thorn[type])
			{
				KillTile(i2, j2);
				if (Main.netMode != 0)
				{
					NetMessage.SendData(17, -1, -1, null, 0, i2, j2);
				}
			}
			if (!Main.tileFrameImportant[type])
			{
				Convert_ActuallyConvertTile(conversionType, i2, j2, ref theTile, newType);
			}
			break;
		}
		}
	}

	public static void Convert_ActuallyConvertTorch(int conversionType, int x, int y, ref Tile theTile, int newStyle)
	{
		if (!theTile.active() || theTile.type != 4)
		{
			return;
		}
		int num = theTile.frameY / 22;
		if (conversionType == 0 && num == 22)
		{
			newStyle = 21;
		}
		if (num != newStyle)
		{
			bool num2 = conversionType == 1 || conversionType == 4 || conversionType == 2;
			theTile.frameY = (short)(newStyle * 22);
			if (num2 && SpecialSeedFeatures.RainbowSandAndBlackSandWalls)
			{
				paintTile(x, y, 0, broadCast: true);
				paintCoatTile(x, y, 0, broadcast: true);
			}
			SquareTileFrame(x, y);
			NetMessage.SendTileSquare(-1, x, y);
		}
	}

	private static void Convert_ActuallyConvertTile(int conversionType, int x, int y, ref Tile theTile, int newType)
	{
		if (theTile.active() && theTile.type != newType)
		{
			bool num = conversionType == 1 || conversionType == 4 || conversionType == 2;
			TryConvertingOrKillingTreesAboveIfTheyWouldBecomeInvalid(x, y, newType);
			theTile.type = (ushort)newType;
			if (num && SpecialSeedFeatures.RainbowSandAndBlackSandWalls)
			{
				paintTile(x, y, 0, broadCast: true);
				paintCoatTile(x, y, 0, broadcast: true);
			}
			SquareTileFrame(x, y);
			NetMessage.SendTileSquare(-1, x, y);
		}
	}

	private static void Convert_ActuallyConvertWall(int conversionType, int x, int y, ref Tile theTile, int newType)
	{
		if (theTile.wall != 0 && theTile.wall != newType)
		{
			bool num = conversionType == 1 || conversionType == 4 || conversionType == 2;
			theTile.wall = (ushort)newType;
			if (num && SpecialSeedFeatures.RainbowSandAndBlackSandWalls)
			{
				paintWall(x, y, 0, broadCast: true);
				paintCoatWall(x, y, 0, broadcast: true);
			}
			SquareWallFrame(x, y);
			NetMessage.SendTileSquare(-1, x, y);
		}
	}

	public static void CactusFrame(int i, int j)
	{
		try
		{
			int num = j;
			int num2 = i;
			if (CheckCactus(i, j))
			{
				return;
			}
			while (Main.tile[num2, num].active() && Main.tile[num2, num].type == 80)
			{
				num++;
				if (Main.tile[num2, num] == null)
				{
					return;
				}
				if (!Main.tile[num2, num].active() || Main.tile[num2, num].type != 80)
				{
					if (Main.tile[num2 - 1, num] != null && Main.tile[num2 - 1, num].active() && Main.tile[num2 - 1, num].type == 80 && Main.tile[num2 - 1, num - 1].active() && Main.tile[num2 - 1, num - 1].type == 80 && num2 >= i)
					{
						num2--;
					}
					if (Main.tile[num2 + 1, num] != null && Main.tile[num2 + 1, num].active() && Main.tile[num2 + 1, num].type == 80 && Main.tile[num2 + 1, num - 1].active() && Main.tile[num2 + 1, num - 1].type == 80 && num2 <= i)
					{
						num2++;
					}
				}
			}
			num--;
			int num3 = i - num2;
			num2 = i;
			num = j;
			if (Main.tile[i - 2, j] == null)
			{
				return;
			}
			int num4 = Main.tile[i - 2, j].type;
			if (Main.tile[i - 1, j] == null)
			{
				return;
			}
			int num5 = Main.tile[i - 1, j].type;
			if (Main.tile[i + 1, j] == null)
			{
				return;
			}
			int num6 = Main.tile[i + 1, j].type;
			if (Main.tile[i, j - 1] == null)
			{
				return;
			}
			int num7 = Main.tile[i, j - 1].type;
			if (num7 == 227)
			{
				num7 = 80;
			}
			int num8 = Main.tile[i, j + 1].type;
			int num9 = Main.tile[i - 1, j + 1].type;
			int num10 = Main.tile[i + 1, j + 1].type;
			if (!Main.tile[i - 2, j].active())
			{
				num4 = -1;
			}
			if (!Main.tile[i - 1, j].active())
			{
				num5 = -1;
			}
			if (!Main.tile[i + 1, j].active())
			{
				num6 = -1;
			}
			if (!Main.tile[i, j - 1].active())
			{
				num7 = -1;
			}
			if (!Main.tile[i, j + 1].active())
			{
				num8 = -1;
			}
			if (!Main.tile[i - 1, j + 1].active())
			{
				num9 = -1;
			}
			if (!Main.tile[i + 1, j + 1].active())
			{
				num10 = -1;
			}
			short num11 = Main.tile[i, j].frameX;
			short num12 = Main.tile[i, j].frameY;
			switch (num3)
			{
			case 0:
				if (num7 != 80)
				{
					if (num5 == 80 && num6 == 80 && num9 != 80 && num10 != 80 && num4 != 80)
					{
						num11 = 90;
						num12 = 0;
					}
					else if (num5 == 80 && num9 != 80 && num4 != 80)
					{
						num11 = 72;
						num12 = 0;
					}
					else if (num6 == 80 && num10 != 80)
					{
						num11 = 18;
						num12 = 0;
					}
					else
					{
						num11 = 0;
						num12 = 0;
					}
				}
				else if (num5 == 80 && num6 == 80 && num9 != 80 && num10 != 80 && num4 != 80)
				{
					num11 = 90;
					num12 = 36;
				}
				else if (num5 == 80 && num9 != 80 && num4 != 80)
				{
					num11 = 72;
					num12 = 36;
				}
				else if (num6 == 80 && num10 != 80)
				{
					num11 = 18;
					num12 = 36;
				}
				else if (num8 >= 0 && Main.tileSolid[num8])
				{
					num11 = 0;
					num12 = 36;
				}
				else
				{
					num11 = 0;
					num12 = 18;
				}
				break;
			case -1:
				if (num6 == 80)
				{
					if (num7 != 80 && num8 != 80)
					{
						num11 = 108;
						num12 = 36;
					}
					else if (num8 != 80)
					{
						num11 = 54;
						num12 = 36;
					}
					else if (num7 != 80)
					{
						num11 = 54;
						num12 = 0;
					}
					else
					{
						num11 = 54;
						num12 = 18;
					}
				}
				else if (num7 != 80)
				{
					num11 = 54;
					num12 = 0;
				}
				else
				{
					num11 = 54;
					num12 = 18;
				}
				break;
			case 1:
				if (num5 == 80)
				{
					if (num7 != 80 && num8 != 80)
					{
						num11 = 108;
						num12 = 18;
					}
					else if (num8 != 80)
					{
						num11 = 36;
						num12 = 36;
					}
					else if (num7 != 80)
					{
						num11 = 36;
						num12 = 0;
					}
					else
					{
						num11 = 36;
						num12 = 18;
					}
				}
				else if (num7 != 80)
				{
					num11 = 36;
					num12 = 0;
				}
				else
				{
					num11 = 36;
					num12 = 18;
				}
				break;
			}
			if (num11 != Main.tile[i, j].frameX || num12 != Main.tile[i, j].frameY)
			{
				Main.tile[i, j].frameX = num11;
				Main.tile[i, j].frameY = num12;
				TileFrameCosmetic(i - 1, j, Main.tile[i - 1, j]);
				TileFrameCosmetic(i, j - 1, Main.tile[i, j - 1]);
				TileFrameCosmetic(i, j + 1, Main.tile[i, j + 1]);
				TileFrameCosmetic(i + 1, j, Main.tile[i + 1, j]);
			}
		}
		catch
		{
			Main.tile[i, j].frameX = 0;
			Main.tile[i, j].frameY = 0;
		}
	}

	public static void GrowCactus(int i, int j)
	{
		if (j <= 0)
		{
			return;
		}
		int num = i;
		int num2 = j;
		Tile tile = Main.tile[i, j];
		Tile tile2 = Main.tile[i, j - 1];
		if (!tile.nactive() || tile.halfBrick() || (!isGeneratingOrLoadingWorld && tile.slope() != 0) || (tile.type != 80 && !TileID.Sets.Conversion.Sand[tile.type]) || tile2.liquid > 0)
		{
			return;
		}
		int num3 = 0;
		for (int k = i - cactusWaterWidth; k < i + cactusWaterWidth; k++)
		{
			for (int l = j - cactusWaterHeight; l < j + cactusWaterHeight; l++)
			{
				if (InWorld(k, l))
				{
					num3 += Main.tile[k, l].liquid;
				}
			}
		}
		if ((!Main.remixWorld || !((double)j > Main.worldSurface)) && num3 / 255 > cactusWaterLimit)
		{
			return;
		}
		if (TileID.Sets.Conversion.Sand[tile.type])
		{
			if (tile2.active() || Main.tile[i - 1, j - 1].active() || Main.tile[i + 1, j - 1].active())
			{
				return;
			}
			int num4 = 0;
			int num5 = 0;
			for (int m = i - 6; m <= i + 6; m++)
			{
				for (int n = j - 3; n <= j + 1; n++)
				{
					if (!InWorld(m, n, 5))
					{
						continue;
					}
					try
					{
						if (!Main.tile[m, n].active())
						{
							continue;
						}
						if (Main.tile[m, n].type == 80)
						{
							num4++;
							if (num4 >= 4)
							{
								return;
							}
						}
						if (TileID.Sets.Conversion.Sand[Main.tile[m, n].type])
						{
							num5++;
							if (num5 > 10)
							{
								break;
							}
						}
					}
					catch
					{
					}
				}
				if (num5 > 10)
				{
					break;
				}
			}
			if (num5 > 10)
			{
				if (isGeneratingOrLoadingWorld && genRand.Next(2) == 0)
				{
					tile.slope(0);
				}
				tile2.active(active: true);
				tile2.type = 80;
				tile2.CopyPaintAndCoating(tile);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, j - 1);
				}
				SquareTileFrame(num, num2 - 1);
			}
		}
		else
		{
			if (tile.type != 80)
			{
				return;
			}
			while (Main.tile[num, num2].active() && Main.tile[num, num2].type == 80)
			{
				num2++;
				if (!Main.tile[num, num2].active() || Main.tile[num, num2].type != 80)
				{
					if (Main.tile[num - 1, num2].active() && Main.tile[num - 1, num2].type == 80 && Main.tile[num - 1, num2 - 1].active() && Main.tile[num - 1, num2 - 1].type == 80 && num >= i)
					{
						num--;
					}
					if (Main.tile[num + 1, num2].active() && Main.tile[num + 1, num2].type == 80 && Main.tile[num + 1, num2 - 1].active() && Main.tile[num + 1, num2 - 1].type == 80 && num <= i)
					{
						num++;
					}
				}
			}
			num2--;
			int num6 = num2 - j;
			int num7 = i - num;
			num = i - num7;
			num2 = j;
			int num8 = 11 - num6;
			int num9 = 0;
			for (int num10 = num - 2; num10 <= num + 2; num10++)
			{
				for (int num11 = num2 - num8; num11 <= num2 + num6; num11++)
				{
					if (Main.tile[num10, num11].active() && Main.tile[num10, num11].type == 80)
					{
						num9++;
					}
				}
			}
			if (Main.drunkWorld)
			{
				if (num9 >= genRand.Next(11, 20))
				{
					return;
				}
			}
			else if (num9 >= genRand.Next(11, 13))
			{
				return;
			}
			num = i;
			num2 = j;
			if (num7 == 0)
			{
				if (num6 == 0)
				{
					if (!Main.tile[num, num2 - 1].active())
					{
						Main.tile[num, num2 - 1].active(active: true);
						Main.tile[num, num2 - 1].type = 80;
						Main.tile[num, num2 - 1].CopyPaintAndCoating(tile);
						SquareTileFrame(num, num2 - 1);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, num, num2 - 1);
						}
					}
					return;
				}
				bool flag = false;
				bool flag2 = false;
				if (Main.tile[num, num2 - 1].active() && Main.tile[num, num2 - 1].type == 80)
				{
					if (!Main.tile[num - 1, num2].active() && !Main.tile[num - 2, num2 + 1].active() && !Main.tile[num - 1, num2 - 1].active() && !Main.tile[num - 1, num2 + 1].active() && !Main.tile[num - 2, num2].active())
					{
						flag = true;
					}
					if (!Main.tile[num + 1, num2].active() && !Main.tile[num + 2, num2 + 1].active() && !Main.tile[num + 1, num2 - 1].active() && !Main.tile[num + 1, num2 + 1].active() && !Main.tile[num + 2, num2].active())
					{
						flag2 = true;
					}
				}
				int num12 = genRand.Next(3);
				if (num12 == 0 && flag)
				{
					Main.tile[num - 1, num2].active(active: true);
					Main.tile[num - 1, num2].type = 80;
					Main.tile[num - 1, num2].CopyPaintAndCoating(tile);
					SquareTileFrame(num - 1, num2);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, num - 1, num2);
					}
				}
				else if (num12 == 1 && flag2)
				{
					Main.tile[num + 1, num2].active(active: true);
					Main.tile[num + 1, num2].type = 80;
					Main.tile[num + 1, num2].CopyPaintAndCoating(tile);
					SquareTileFrame(num + 1, num2);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, num + 1, num2);
					}
				}
				else if (num6 < genRand.Next(2, 8) && (!Main.tile[num - 1, num2 - 1].active() || Main.tile[num - 1, num2 - 1].type != 80) && (!Main.tile[num + 1, num2 - 1].active() || Main.tile[num + 1, num2 - 1].type != 80) && !Main.tile[num, num2 - 1].active())
				{
					Main.tile[num, num2 - 1].active(active: true);
					Main.tile[num, num2 - 1].type = 80;
					Main.tile[num, num2 - 1].CopyPaintAndCoating(tile);
					SquareTileFrame(num, num2 - 1);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, num, num2 - 1);
					}
				}
			}
			else if (!Main.tile[num, num2 - 1].active() && !Main.tile[num, num2 - 2].active() && !Main.tile[num + num7, num2 - 1].active() && Main.tile[num - num7, num2 - 1].active() && Main.tile[num - num7, num2 - 1].type == 80)
			{
				Main.tile[num, num2 - 1].active(active: true);
				Main.tile[num, num2 - 1].type = 80;
				Main.tile[num, num2 - 1].CopyPaintAndCoating(tile);
				SquareTileFrame(num, num2 - 1);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, num, num2 - 1);
				}
			}
		}
	}

	public static void CheckPot(int i, int j, int type = 28)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = 0;
		int num2 = j;
		for (num += Main.tile[i, j].frameX / 18; num > 1; num -= 2)
		{
		}
		num *= -1;
		num += i;
		int num3 = Main.tile[i, j].frameY / 18;
		int num4 = 0;
		while (num3 > 1)
		{
			num3 -= 2;
			num4++;
		}
		num2 -= num3;
		for (int k = num; k < num + 2; k++)
		{
			for (int l = num2; l < num2 + 2; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = new Tile();
				}
				int num5;
				for (num5 = Main.tile[k, l].frameX / 18; num5 > 1; num5 -= 2)
				{
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || num5 != k - num || Main.tile[k, l].frameY != (l - num2) * 18 + num4 * 36)
				{
					flag = true;
				}
			}
			if (Main.tile[k, num2 + 2] == null)
			{
				Main.tile[k, num2 + 2] = new Tile();
			}
			if (type == 653)
			{
				if (!SolidTileAllowBottomSlope(k, num2 + 2))
				{
					flag = true;
				}
			}
			else if (!SolidTile2(k, num2 + 2))
			{
				flag = true;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		if (num4 >= 7 && num4 <= 9)
		{
			SoundEngine.PlaySound(6, i * 16, j * 16);
		}
		else if (num4 >= 16 && num4 <= 24)
		{
			SoundEngine.PlaySound(4, i * 16, j * 16);
		}
		else
		{
			SoundEngine.PlaySound(13, i * 16, j * 16);
		}
		for (int m = num; m < num + 2; m++)
		{
			for (int n = num2; n < num2 + 2; n++)
			{
				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
				{
					KillTile(m, n);
				}
			}
		}
		switch (num4)
		{
		case 0:
			Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 51);
			Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 52);
			Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 53);
			break;
		case 1:
			Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 166);
			Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 167);
			Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 168);
			break;
		case 2:
			Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 169);
			Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 170);
			Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 171);
			break;
		case 3:
			Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 172);
			Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 173);
			Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 174);
			break;
		case 4:
		case 5:
		case 6:
			Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 197);
			Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 198);
			break;
		default:
			if (num4 >= 7 && num4 <= 9)
			{
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 199);
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 200);
			}
			else if (num4 >= 10 && num4 <= 12)
			{
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 201);
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 202);
			}
			else if (num4 >= 13 && num4 <= 15)
			{
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 203);
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 204);
			}
			else
			{
				if ((num4 >= 16 && num4 <= 18) || (num4 >= 19 && num4 <= 21) || (num4 >= 22 && num4 <= 24))
				{
					break;
				}
				if (num4 >= 25 && num4 <= 27)
				{
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), genRand.Next(217, 220));
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), genRand.Next(217, 220));
				}
				else if (num4 >= 28 && num4 <= 30)
				{
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), genRand.Next(315, 317));
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), genRand.Next(315, 317));
				}
				else if (num4 >= 31 && num4 <= 33)
				{
					int num6 = genRand.Next(2, 5);
					for (int num7 = 0; num7 < num6; num7++)
					{
						Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 698 + genRand.Next(6));
					}
				}
				else if (num4 >= 34 && num4 <= 36)
				{
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 1122);
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 1123);
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 1124);
				}
			}
			break;
		}
		if (type == 653)
		{
			int num8 = 0;
			if (num4 <= 3)
			{
				num8 = 133;
			}
			else if (num4 <= 6)
			{
				num8 = 664;
			}
			else if (num4 <= 9)
			{
				num8 = 4564;
			}
			else if (num4 <= 12)
			{
				num8 = 154;
			}
			else if (num4 <= 15)
			{
				num8 = 173;
			}
			else if (num4 <= 18)
			{
				num8 = 61;
			}
			else if (num4 <= 21)
			{
				num8 = 150;
			}
			else if (num4 <= 24)
			{
				num8 = 836;
			}
			else if (num4 <= 27)
			{
				num8 = 3272;
			}
			else if (num4 <= 30)
			{
				num8 = 1101;
			}
			else if (num4 <= 33)
			{
				num8 = 3081;
			}
			else if (num4 <= 36)
			{
				num8 = 3271;
			}
			if (num8 != 0)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, num8);
			}
		}
		if (Main.netMode != 1 && type != 653)
		{
			SpawnThingsFromPot(i, j, num, num2, num4);
		}
		destroyObject = false;
	}

	public static int GetFruitForPot(int x, int y, int potStyle)
	{
		if (!InWorld(x, y, 2))
		{
			return -1;
		}
		bool num = potStyle >= 4 && potStyle <= 6;
		bool flag = (potStyle >= 7 && potStyle <= 9) || (potStyle >= 28 && potStyle <= 30);
		bool flag2 = potStyle >= 13 && potStyle <= 15;
		bool flag3 = potStyle >= 16 && potStyle <= 18;
		bool flag4 = potStyle >= 22 && potStyle <= 24;
		bool flag5 = (potStyle >= 25 && potStyle <= 27) || (potStyle >= 34 && potStyle <= 36);
		int num2 = -1;
		if (num)
		{
			if (genRand.Next(2) == 0)
			{
				return 4286;
			}
			return 4295;
		}
		if (flag)
		{
			if (genRand.Next(2) == 0)
			{
				return 4294;
			}
			return 4292;
		}
		if (flag5)
		{
			if (genRand.Next(2) == 0)
			{
				return 4283;
			}
			return 4287;
		}
		if (flag3)
		{
			if (genRand.Next(2) == 0)
			{
				return 4284;
			}
			return 4289;
		}
		if (flag4)
		{
			if (genRand.Next(2) == 0)
			{
				return 4296;
			}
			return 4285;
		}
		if (flag2)
		{
			if (genRand.Next(2) == 0)
			{
				return 5277;
			}
			return 5278;
		}
		return genRand.Next(5) switch
		{
			0 => 4009, 
			1 => 4293, 
			2 => 4282, 
			3 => 4290, 
			_ => 4291, 
		};
	}

	private static void SpawnThingsFromPot(int i, int j, int x2, int y2, int style)
	{
		bool flag = (double)j < Main.rockLayer;
		bool flag2 = j < Main.UnderworldLayer;
		if (Main.remixWorld)
		{
			flag = (double)j > Main.rockLayer && j < Main.UnderworldLayer;
			flag2 = (double)j > Main.worldSurface && (double)j < Main.rockLayer;
		}
		bool flag3 = (double)j > Main.worldSurface && Main.dontStarveWorld && !Main.remixWorld;
		float num = 1f;
		bool flag4 = style >= 34 && style <= 36;
		switch (style)
		{
		case 4:
		case 5:
		case 6:
			num = 1.25f;
			break;
		default:
			if (style >= 7 && style <= 9)
			{
				num = 1.75f;
			}
			else if (style >= 10 && style <= 12)
			{
				num = 1.9f;
			}
			else if (style >= 13 && style <= 15)
			{
				num = 2.1f;
			}
			else if (style >= 16 && style <= 18)
			{
				num = 1.6f;
			}
			else if (style >= 19 && style <= 21)
			{
				num = 3.5f;
			}
			else if (style >= 22 && style <= 24)
			{
				num = 1.6f;
			}
			else if (style >= 25 && style <= 27)
			{
				num = 10f;
			}
			else if (style >= 28 && style <= 30)
			{
				if (Main.hardMode)
				{
					num = 4f;
				}
			}
			else if (style >= 31 && style <= 33)
			{
				num = 2f;
			}
			else if (style >= 34 && style <= 36)
			{
				num = 1.25f;
			}
			break;
		case 0:
		case 1:
		case 2:
		case 3:
			break;
		}
		num = (num * 2f + 1f) / 3f;
		int num2 = 6;
		int type = 28;
		if (Main.tenthAnniversaryWorld && !Main.remixWorld)
		{
			num2 *= 2;
			type = 75;
		}
		if (!isGeneratingOrLoadingWorld && Main.tenthAnniversaryWorld && Main.notTheBeesWorld && !Main.drunkWorld && genRand.Next(50) == 0)
		{
			int stack = Main.rand.Next(12, 21);
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 1130, stack);
		}
		int range = (int)(500f / ((num + 1f) / 2f));
		if (isGeneratingOrLoadingWorld)
		{
			return;
		}
		if (Player.GetClosestRollLuck(i, j, range) == 0f)
		{
			if (Main.netMode != 1)
			{
				Projectile.NewProjectile(GetProjectileSource_TileBreak(i, j), i * 16 + 16, j * 16 + 16, 0f, -12f, 518, 0, 0f, Main.myPlayer);
			}
			return;
		}
		if (genRand.Next(35) == 0 && Main.wallDungeon[Main.tile[i, j].wall] && (double)j > Main.worldSurface)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 327);
			return;
		}
		if (flag3 && genRand.Next(20) == 0)
		{
			int fruitForPot = GetFruitForPot(i, j, style);
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, fruitForPot, genRand.Next(1, 3));
			return;
		}
		if (Main.getGoodWorld && genRand.Next(num2) == 0)
		{
			Projectile.NewProjectile(GetProjectileSource_TileBreak(i, j), i * 16 + 16, j * 16 + 8, (float)Main.rand.Next(-100, 101) * 0.002f, 0f, type, 0, 0f, Main.myPlayer, 16f, 16f);
			return;
		}
		if (Main.remixWorld && Main.netMode != 1 && genRand.Next(5) == 0)
		{
			Player player = Main.player[Player.FindClosest(new Vector2(i * 16, j * 16), 16, 16)];
			if (Main.rand.Next(2) == 0)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 75);
			}
			else if (player.ZoneJungle)
			{
				int num3 = -1;
				num3 = NPC.NewNPC(GetNPCSource_FromTileBreak(i, j), x2 * 16 + 16, y2 * 16 + 32, -10);
				if (num3 > -1)
				{
					Main.npc[num3].ai[1] = 75f;
					Main.npc[num3].netUpdate = true;
				}
			}
			else if ((double)j > Main.rockLayer && j < Main.maxTilesY - 350)
			{
				int num4 = -1;
				num4 = ((Main.rand.Next(9) == 0) ? NPC.NewNPC(GetNPCSource_FromTileBreak(i, j), x2 * 16 + 16, y2 * 16 + 32, -7) : ((Main.rand.Next(7) == 0) ? NPC.NewNPC(GetNPCSource_FromTileBreak(i, j), x2 * 16 + 16, y2 * 16 + 32, -8) : ((Main.rand.Next(6) == 0) ? NPC.NewNPC(GetNPCSource_FromTileBreak(i, j), x2 * 16 + 16, y2 * 16 + 32, -9) : ((Main.rand.Next(3) != 0) ? NPC.NewNPC(GetNPCSource_FromTileBreak(i, j), x2 * 16 + 16, y2 * 16 + 32, 1) : NPC.NewNPC(GetNPCSource_FromTileBreak(i, j), x2 * 16 + 16, y2 * 16 + 32, -3)))));
				if (num4 > -1)
				{
					Main.npc[num4].ai[1] = 75f;
					Main.npc[num4].netUpdate = true;
				}
			}
			else if ((double)j > Main.worldSurface && (double)j <= Main.rockLayer)
			{
				int num5 = -1;
				num5 = NPC.NewNPC(GetNPCSource_FromTileBreak(i, j), x2 * 16 + 16, y2 * 16 + 32, -6);
				if (num5 > -1)
				{
					Main.npc[num5].ai[1] = 75f;
					Main.npc[num5].netUpdate = true;
				}
			}
			else
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 75);
			}
			return;
		}
		if (Main.remixWorld && (double)i > (double)Main.maxTilesX * 0.37 && (double)i < (double)Main.maxTilesX * 0.63 && j > Main.maxTilesY - 220)
		{
			int stack2 = Main.rand.Next(20, 41);
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 965, stack2);
			return;
		}
		if (genRand.Next(45) == 0 || (Main.rand.Next(45) == 0 && Main.expertMode))
		{
			if ((double)j < Main.worldSurface)
			{
				int num6 = genRand.Next(10);
				if (num6 == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 292);
				}
				if (num6 == 1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 298);
				}
				if (num6 == 2)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 299);
				}
				if (num6 == 3)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 290);
				}
				if (num6 == 4)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2322);
				}
				if (num6 == 5)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2324);
				}
				if (num6 == 6)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2325);
				}
				if (num6 >= 7)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2350, genRand.Next(1, 3));
				}
			}
			else if (flag)
			{
				int num7 = genRand.Next(11);
				if (num7 == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 289);
				}
				if (num7 == 1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 298);
				}
				if (num7 == 2)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 299);
				}
				if (num7 == 3)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 290);
				}
				if (num7 == 4)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 303);
				}
				if (num7 == 5)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 291);
				}
				if (num7 == 6)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 304);
				}
				if (num7 == 7)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2322);
				}
				if (num7 == 8)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2329);
				}
				if (num7 >= 7)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2350, genRand.Next(1, 3));
				}
			}
			else if (flag2)
			{
				int num8 = genRand.Next(15);
				if (num8 == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 296);
				}
				if (num8 == 1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 295);
				}
				if (num8 == 2)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 299);
				}
				if (num8 == 3)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 302);
				}
				if (num8 == 4)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 303);
				}
				if (num8 == 5)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 305);
				}
				if (num8 == 6)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 301);
				}
				if (num8 == 7)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 302);
				}
				if (num8 == 8)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 297);
				}
				if (num8 == 9)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 304);
				}
				if (num8 == 10)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2322);
				}
				if (num8 == 11)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2323);
				}
				if (num8 == 12)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2327);
				}
				if (num8 == 13)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2329);
				}
				if (num8 >= 7)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2350, genRand.Next(1, 3));
				}
				if (genRand.Next(15) == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 4870);
				}
			}
			else
			{
				int num9 = genRand.Next(14);
				if (num9 == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 296);
				}
				if (num9 == 1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 295);
				}
				if (num9 == 2)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 293);
				}
				if (num9 == 3)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 288);
				}
				if (num9 == 4)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 294);
				}
				if (num9 == 5)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 297);
				}
				if (num9 == 6)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 304);
				}
				if (num9 == 7)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 305);
				}
				if (num9 == 8)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 301);
				}
				if (num9 == 9)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 302);
				}
				if (num9 == 10)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 288);
				}
				if (num9 == 11)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 300);
				}
				if (num9 == 12)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2323);
				}
				if (num9 == 13)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2326);
				}
				if (genRand.Next(5) == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 4870);
				}
			}
			return;
		}
		if (Main.netMode == 2 && Main.rand.Next(30) == 0)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2997);
			return;
		}
		int num10 = Main.rand.Next(7);
		if (Main.expertMode)
		{
			num10--;
		}
		Player player2 = Main.player[Player.FindClosest(new Vector2(i * 16, j * 16), 16, 16)];
		int num11 = 0;
		int num12 = 20;
		if (Main.vampireSeed)
		{
			num12 = 30;
		}
		for (int k = 0; k < 50; k++)
		{
			Item item = player2.inventory[k];
			if (!item.IsAir && item.createTile >= 0 && (item.createTile < 0 || TileID.Sets.Torches[item.createTile]))
			{
				num11 += item.stack;
				if (num11 >= num12)
				{
					break;
				}
			}
		}
		bool flag5 = num11 < num12;
		if (flag5 && Main.vampireSeed)
		{
			num10 = 1;
		}
		if (num10 == 0 && player2.statLife < player2.statLifeMax2)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 58);
			if (Main.rand.Next(2) == 0)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 58);
			}
			if (Main.expertMode)
			{
				if (Main.rand.Next(2) == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 58);
				}
				if (Main.rand.Next(2) == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 58);
				}
			}
			return;
		}
		if (Main.vampireSeed && (flag2 || flag) && genRand.Next(6) == 0)
		{
			int type2 = 9;
			if (style >= 4 && style <= 6)
			{
				type2 = 2503;
			}
			else if (style >= 7 && style <= 9)
			{
				type2 = 620;
			}
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, type2, Main.rand.Next(10, 31));
			return;
		}
		if (num10 == 1 || (num10 == 0 && flag5))
		{
			int num13 = Main.rand.Next(2, 7);
			if (Main.expertMode)
			{
				num13 += Main.rand.Next(1, 7);
			}
			if (Main.vampireSeed)
			{
				num13 += Main.rand.Next(2, 7);
			}
			int type3 = 8;
			int type4 = 282;
			if (player2.ZoneHallow)
			{
				num13 += Main.rand.Next(2, 7);
				type3 = 4387;
			}
			else if ((style >= 22 && style <= 24) || player2.ZoneCrimson)
			{
				num13 += Main.rand.Next(2, 7);
				type3 = 4386;
			}
			else if ((style >= 16 && style <= 18) || player2.ZoneCorrupt)
			{
				num13 += Main.rand.Next(2, 7);
				type3 = 4385;
			}
			else if (style >= 7 && style <= 9)
			{
				num13 += Main.rand.Next(2, 7);
				num13 = (int)((float)num13 * 1.5f);
				type3 = 4388;
			}
			else if (style >= 4 && style <= 6)
			{
				type3 = 974;
				type4 = 286;
			}
			else if (style >= 34 && style <= 36)
			{
				num13 += Main.rand.Next(2, 7);
				type3 = 4383;
			}
			else if (player2.ZoneGlowshroom)
			{
				num13 += Main.rand.Next(2, 7);
				type3 = 5293;
			}
			if (Main.tile[i, j].liquid > 0)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, type4, num13);
			}
			else
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, type3, num13);
			}
			return;
		}
		switch (num10)
		{
		case 2:
		{
			int stack3 = Main.rand.Next(10, 21);
			int type6 = 40;
			if (flag && genRand.Next(2) == 0)
			{
				type6 = ((!Main.hardMode) ? 42 : 168);
			}
			if (j > Main.UnderworldLayer)
			{
				type6 = 265;
			}
			else if (Main.hardMode)
			{
				type6 = ((Main.rand.Next(2) != 0) ? 47 : ((SavedOreTiers.Silver != 168) ? 278 : 4915));
			}
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, type6, stack3);
			return;
		}
		case 3:
		{
			int type7 = 28;
			if (j > Main.UnderworldLayer || Main.hardMode)
			{
				type7 = 188;
			}
			int num15 = 1;
			if (Main.expertMode && Main.rand.Next(3) != 0)
			{
				num15++;
			}
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, type7, num15);
			return;
		}
		case 4:
			if (flag4 || flag2)
			{
				int type5 = 166;
				if (flag4)
				{
					type5 = 4423;
				}
				int num14 = Main.rand.Next(4) + 1;
				if (Main.expertMode)
				{
					num14 += Main.rand.Next(4);
				}
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, type5, num14);
				return;
			}
			break;
		}
		if ((num10 == 4 || num10 == 5) && j < Main.UnderworldLayer && !Main.hardMode)
		{
			int stack4 = Main.rand.Next(20, 41);
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 965, stack4);
			return;
		}
		float num16 = 200 + genRand.Next(-100, 101);
		if ((double)j < Main.worldSurface)
		{
			num16 *= 0.5f;
		}
		else if (flag)
		{
			num16 *= 0.75f;
		}
		else if (j > Main.maxTilesY - 250)
		{
			num16 *= 1.25f;
		}
		num16 *= 1f + (float)Main.rand.Next(-20, 21) * 0.01f;
		if (Main.rand.Next(4) == 0)
		{
			num16 *= 1f + (float)Main.rand.Next(5, 11) * 0.01f;
		}
		if (Main.rand.Next(8) == 0)
		{
			num16 *= 1f + (float)Main.rand.Next(10, 21) * 0.01f;
		}
		if (Main.rand.Next(12) == 0)
		{
			num16 *= 1f + (float)Main.rand.Next(20, 41) * 0.01f;
		}
		if (Main.rand.Next(16) == 0)
		{
			num16 *= 1f + (float)Main.rand.Next(40, 81) * 0.01f;
		}
		if (Main.rand.Next(20) == 0)
		{
			num16 *= 1f + (float)Main.rand.Next(50, 101) * 0.01f;
		}
		if (Main.expertMode)
		{
			num16 *= 2.5f;
		}
		if (Main.expertMode && Main.rand.Next(2) == 0)
		{
			num16 *= 1.25f;
		}
		if (Main.expertMode && Main.rand.Next(3) == 0)
		{
			num16 *= 1.5f;
		}
		if (Main.expertMode && Main.rand.Next(4) == 0)
		{
			num16 *= 1.75f;
		}
		num16 *= num;
		if (NPC.downedBoss1)
		{
			num16 *= 1.1f;
		}
		if (NPC.downedBoss2)
		{
			num16 *= 1.1f;
		}
		if (NPC.downedBoss3)
		{
			num16 *= 1.1f;
		}
		if (NPC.downedMechBoss1)
		{
			num16 *= 1.1f;
		}
		if (NPC.downedMechBoss2)
		{
			num16 *= 1.1f;
		}
		if (NPC.downedMechBoss3)
		{
			num16 *= 1.1f;
		}
		if (NPC.downedPlantBoss)
		{
			num16 *= 1.1f;
		}
		if (NPC.downedQueenBee)
		{
			num16 *= 1.1f;
		}
		if (NPC.downedGolemBoss)
		{
			num16 *= 1.1f;
		}
		if (NPC.downedPirates)
		{
			num16 *= 1.1f;
		}
		if (NPC.downedGoblins)
		{
			num16 *= 1.1f;
		}
		if (NPC.downedFrost)
		{
			num16 *= 1.1f;
		}
		while ((int)num16 > 0)
		{
			if (num16 > 1000000f)
			{
				int num17 = (int)(num16 / 1000000f);
				if (num17 > 50 && Main.rand.Next(2) == 0)
				{
					num17 /= Main.rand.Next(3) + 1;
				}
				if (Main.rand.Next(2) == 0)
				{
					num17 /= Main.rand.Next(3) + 1;
				}
				num16 -= (float)(1000000 * num17);
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 74, num17);
				continue;
			}
			if (num16 > 10000f)
			{
				int num18 = (int)(num16 / 10000f);
				if (num18 > 50 && Main.rand.Next(2) == 0)
				{
					num18 /= Main.rand.Next(3) + 1;
				}
				if (Main.rand.Next(2) == 0)
				{
					num18 /= Main.rand.Next(3) + 1;
				}
				num16 -= (float)(10000 * num18);
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 73, num18);
				continue;
			}
			if (num16 > 100f)
			{
				int num19 = (int)(num16 / 100f);
				if (num19 > 50 && Main.rand.Next(2) == 0)
				{
					num19 /= Main.rand.Next(3) + 1;
				}
				if (Main.rand.Next(2) == 0)
				{
					num19 /= Main.rand.Next(3) + 1;
				}
				num16 -= (float)(100 * num19);
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 72, num19);
				continue;
			}
			int num20 = (int)num16;
			if (num20 > 50 && Main.rand.Next(2) == 0)
			{
				num20 /= Main.rand.Next(3) + 1;
			}
			if (Main.rand.Next(2) == 0)
			{
				num20 /= Main.rand.Next(4) + 1;
			}
			if (num20 < 1)
			{
				num20 = 1;
			}
			num16 -= (float)num20;
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 71, num20);
		}
	}

	public static int PlaceChest(int x, int y, ushort type = 21, bool notNearOtherChests = false, int style = 0)
	{
		int num = -1;
		if (TileID.Sets.Boulders[Main.tile[x, y + 1].type] || TileID.Sets.Boulders[Main.tile[x + 1, y + 1].type])
		{
			return -1;
		}
		if (TileObject.CanPlace(x, y, type, style, 1, out var objectData))
		{
			bool flag = true;
			if (notNearOtherChests && Chest.NearOtherChests(x - 1, y - 1))
			{
				flag = false;
			}
			if (flag)
			{
				TileObject.Place(objectData);
				num = Chest.CreateChest(objectData.xCoord, objectData.yCoord);
			}
		}
		else
		{
			num = -1;
		}
		if (num != -1 && Main.netMode == 1 && type == 21)
		{
			NetMessage.SendData(34, -1, -1, null, 0, x, y, style);
		}
		if (num != -1 && Main.netMode == 1 && type == 467)
		{
			NetMessage.SendData(34, -1, -1, null, 4, x, y, style);
		}
		return num;
	}

	public static void PlaceChestDirect(int x, int y, ushort type, int style, int id)
	{
		Chest.CreateChest(x, y - 1, id);
		for (int i = 0; i <= 1; i++)
		{
			for (int j = -1; j <= 0; j++)
			{
				if (Main.tile[x + i, y + j] == null)
				{
					Main.tile[x + i, y + j] = new Tile();
				}
			}
		}
		Main.tile[x, y - 1].active(active: true);
		Main.tile[x, y - 1].frameY = 0;
		Main.tile[x, y - 1].frameX = (short)(36 * style);
		Main.tile[x, y - 1].type = type;
		Main.tile[x, y - 1].halfBrick(halfBrick: false);
		Main.tile[x + 1, y - 1].active(active: true);
		Main.tile[x + 1, y - 1].frameY = 0;
		Main.tile[x + 1, y - 1].frameX = (short)(18 + 36 * style);
		Main.tile[x + 1, y - 1].type = type;
		Main.tile[x + 1, y - 1].halfBrick(halfBrick: false);
		Main.tile[x, y].active(active: true);
		Main.tile[x, y].frameY = 18;
		Main.tile[x, y].frameX = (short)(36 * style);
		Main.tile[x, y].type = type;
		Main.tile[x, y].halfBrick(halfBrick: false);
		Main.tile[x + 1, y].active(active: true);
		Main.tile[x + 1, y].frameY = 18;
		Main.tile[x + 1, y].frameX = (short)(18 + 36 * style);
		Main.tile[x + 1, y].type = type;
		Main.tile[x + 1, y].halfBrick(halfBrick: false);
	}

	public static void PlaceDresserDirect(int x, int y, ushort type, int style, int id)
	{
		Chest.CreateChest(x - 1, y - 1, id);
		for (int i = -1; i <= 1; i++)
		{
			for (int j = -1; j <= 0; j++)
			{
				if (Main.tile[x + i, y + j] == null)
				{
					Main.tile[x + i, y + j] = new Tile();
				}
			}
		}
		short num = (short)(style * 54);
		Main.tile[x - 1, y - 1].active(active: true);
		Main.tile[x - 1, y - 1].frameY = 0;
		Main.tile[x - 1, y - 1].frameX = num;
		Main.tile[x - 1, y - 1].type = type;
		Main.tile[x, y - 1].active(active: true);
		Main.tile[x, y - 1].frameY = 0;
		Main.tile[x, y - 1].frameX = (short)(num + 18);
		Main.tile[x, y - 1].type = type;
		Main.tile[x + 1, y - 1].active(active: true);
		Main.tile[x + 1, y - 1].frameY = 0;
		Main.tile[x + 1, y - 1].frameX = (short)(num + 36);
		Main.tile[x + 1, y - 1].type = type;
		Main.tile[x - 1, y].active(active: true);
		Main.tile[x - 1, y].frameY = 18;
		Main.tile[x - 1, y].frameX = num;
		Main.tile[x - 1, y].type = type;
		Main.tile[x, y].active(active: true);
		Main.tile[x, y].frameY = 18;
		Main.tile[x, y].frameX = (short)(num + 18);
		Main.tile[x, y].type = type;
		Main.tile[x + 1, y].active(active: true);
		Main.tile[x + 1, y].frameY = 18;
		Main.tile[x + 1, y].frameX = (short)(num + 36);
		Main.tile[x + 1, y].type = type;
	}

	public static void CheckChest(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = 0;
		int num2 = j;
		num += Main.tile[i, j].frameX / 18;
		num2 += Main.tile[i, j].frameY / 18 * -1;
		while (num > 1)
		{
			num -= 2;
		}
		num *= -1;
		num += i;
		for (int k = num; k < num + 2; k++)
		{
			for (int l = num2; l < num2 + 2; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = new Tile();
				}
				int num3;
				for (num3 = Main.tile[k, l].frameX / 18; num3 > 1; num3 -= 2)
				{
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || num3 != k - num || Main.tile[k, l].frameY != (l - num2) * 18)
				{
					flag = true;
				}
			}
			if (Main.tile[k, num2 + 2] == null)
			{
				Main.tile[k, num2 + 2] = new Tile();
			}
			if ((!Main.tile[k, num2 + 2].active() || !Main.tileSolid[Main.tile[k, num2 + 2].type]) && Chest.CanDestroyChest(num, num2))
			{
				flag = true;
			}
		}
		if (!flag)
		{
			return;
		}
		int itemDrop_Chests = GetItemDrop_Chests(i, j, type);
		destroyObject = true;
		for (int m = num; m < num + 2; m++)
		{
			for (int n = num2; n < num2 + 3; n++)
			{
				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
				{
					Chest.DestroyChest(m, n);
					KillTile(m, n);
				}
			}
		}
		if (itemDrop_Chests > 0)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, itemDrop_Chests);
		}
		destroyObject = false;
	}

	public static int GetChestIcon(int chestStyle, bool containers2)
	{
		int result = 0;
		if (containers2)
		{
			if (chestStyle >= 0 && chestStyle < 38)
			{
				result = Chest.chestTypeToIcon2[chestStyle];
			}
		}
		else if (chestStyle >= 0 && chestStyle < 52)
		{
			result = Chest.chestTypeToIcon[chestStyle];
		}
		return result;
	}

	private static int GetItemDrop_Chests(int x, int y, int type)
	{
		return GetItemDrop_Chests(Main.tile[x, y].frameX / 36, type == 467);
	}

	public static bool PlaceActuator(int i, int j)
	{
		if (!Main.tile[i, j].actuator())
		{
			SoundEngine.PlaySound(0, i * 16, j * 16);
			Main.tile[i, j].actuator(actuator: true);
			return true;
		}
		return false;
	}

	public static bool KillActuator(int i, int j)
	{
		if (Main.tile[i, j].actuator())
		{
			SoundEngine.PlaySound(0, i * 16, j * 16);
			Main.tile[i, j].actuator(actuator: false);
			if (Main.netMode != 1)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 849);
			}
			for (int k = 0; k < 5; k++)
			{
				Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 50);
			}
			return true;
		}
		return false;
	}

	public static void AddWire(int x, int y, int color = 0)
	{
		switch (color)
		{
		case 0:
			Main.tile[x, y].wire(wire: true);
			break;
		case 1:
			Main.tile[x, y].wire2(wire2: true);
			break;
		case 2:
			Main.tile[x, y].wire3(wire3: true);
			break;
		case 3:
			Main.tile[x, y].wire4(wire4: true);
			break;
		}
	}

	public static bool AddWireFromPointToPoint(Point a, Point b, int wireColor = 0, bool debugPaint = false)
	{
		return AddWireFromPointToPoint(a.X, a.Y, b.X, b.Y, wireColor, debugPaint);
	}

	public static bool AddWireFromPointToPoint(int x, int y, int x2, int y2, int wireColor = 0, bool debugPaint = false)
	{
		if (!InWorld(x, y) || !InWorld(x2, y2))
		{
			return false;
		}
		while (x2 != x || y2 != y)
		{
			AddWire(x2, y2, wireColor);
			if (debugPaint)
			{
				paintWall(x2, y2, 21, broadCast: false, paintEffects: false);
				paintTile(x2, y2, 21, broadCast: false, paintEffects: false);
			}
			if (x2 > x)
			{
				x2--;
			}
			if (x2 < x)
			{
				x2++;
			}
			AddWire(x2, y2, wireColor);
			if (debugPaint)
			{
				paintWall(x2, y2, 21, broadCast: false, paintEffects: false);
				paintTile(x2, y2, 21, broadCast: false, paintEffects: false);
			}
			if (y2 > y)
			{
				y2--;
			}
			if (y2 < y)
			{
				y2++;
			}
			AddWire(x2, y2, wireColor);
			if (debugPaint)
			{
				paintWall(x2, y2, 21, broadCast: false, paintEffects: false);
				paintTile(x2, y2, 21, broadCast: false, paintEffects: false);
			}
		}
		return true;
	}

	public static bool PlaceWire(int i, int j)
	{
		if (!Main.tile[i, j].wire())
		{
			SoundEngine.PlaySound(0, i * 16, j * 16);
			Main.tile[i, j].wire(wire: true);
			return true;
		}
		return false;
	}

	public static bool KillWire(int i, int j)
	{
		if (Main.tile[i, j].wire())
		{
			SoundEngine.PlaySound(0, i * 16, j * 16);
			Main.tile[i, j].wire(wire: false);
			if (Main.netMode != 1)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 530);
			}
			for (int k = 0; k < 5; k++)
			{
				Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 50);
			}
			return true;
		}
		return false;
	}

	public static bool PlaceWire2(int i, int j)
	{
		if (!Main.tile[i, j].wire2())
		{
			SoundEngine.PlaySound(0, i * 16, j * 16);
			Main.tile[i, j].wire2(wire2: true);
			return true;
		}
		return false;
	}

	public static bool KillWire2(int i, int j)
	{
		if (Main.tile[i, j].wire2())
		{
			SoundEngine.PlaySound(0, i * 16, j * 16);
			Main.tile[i, j].wire2(wire2: false);
			if (Main.netMode != 1)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 530);
			}
			for (int k = 0; k < 5; k++)
			{
				Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 50);
			}
			return true;
		}
		return false;
	}

	public static bool PlaceWire3(int i, int j)
	{
		if (!Main.tile[i, j].wire3())
		{
			SoundEngine.PlaySound(0, i * 16, j * 16);
			Main.tile[i, j].wire3(wire3: true);
			return true;
		}
		return false;
	}

	public static bool KillWire3(int i, int j)
	{
		if (Main.tile[i, j].wire3())
		{
			SoundEngine.PlaySound(0, i * 16, j * 16);
			Main.tile[i, j].wire3(wire3: false);
			if (Main.netMode != 1)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 530);
			}
			for (int k = 0; k < 5; k++)
			{
				Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 50);
			}
			return true;
		}
		return false;
	}

	public static bool PlaceWire4(int i, int j)
	{
		if (!Main.tile[i, j].wire4())
		{
			SoundEngine.PlaySound(0, i * 16, j * 16);
			Main.tile[i, j].wire4(wire4: true);
			return true;
		}
		return false;
	}

	public static bool KillWire4(int i, int j)
	{
		if (Main.tile[i, j].wire4())
		{
			SoundEngine.PlaySound(0, i * 16, j * 16);
			Main.tile[i, j].wire4(wire4: false);
			if (Main.netMode != 1)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 530);
			}
			for (int k = 0; k < 5; k++)
			{
				Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 50);
			}
			return true;
		}
		return false;
	}

	public static bool IsFitToPlaceFlowerIn(int x, int y, int typeAttemptedToPlace)
	{
		if (y < 1 || y > Main.maxTilesY - 1)
		{
			return false;
		}
		Tile tile = Main.tile[x, y + 1];
		if (tile.active() && tile.slope() == 0 && !tile.halfBrick())
		{
			if (((tile.type != 2 && tile.type != 78 && tile.type != 380 && tile.type != 477 && tile.type != 579) || typeAttemptedToPlace != 3) && ((tile.type != 23 && tile.type != 661) || typeAttemptedToPlace != 24) && ((tile.type != 109 && tile.type != 492) || typeAttemptedToPlace != 110) && ((tile.type != 199 && tile.type != 662) || typeAttemptedToPlace != 201))
			{
				if (tile.type == 633)
				{
					return typeAttemptedToPlace == 637;
				}
				return false;
			}
			return true;
		}
		return false;
	}

	private static bool SeaOatWaterCheck(int x, int y)
	{
		int num = 45;
		int num2 = 20;
		int num3 = 20;
		int num4 = -1;
		int num5 = num + 1;
		int num6 = 0;
		bool flag = false;
		if (x <= beachDistance || x >= Main.maxTilesX - beachDistance)
		{
			flag = true;
			num4 = 40;
			num = 65;
			num2 += 5;
		}
		for (int i = x - num; i <= x + num; i++)
		{
			for (int j = y - num2; j <= y + num2; j++)
			{
				if (InWorld(i, j) && !SolidTile(i, j) && Main.tile[i, j].liquid > 0)
				{
					num6 += Main.tile[i, j].liquid;
					int num7 = Math.Abs(i - x);
					if (num7 < num5)
					{
						num5 = num7;
					}
				}
			}
		}
		if (num6 / 255 >= num3)
		{
			if (flag)
			{
				return false;
			}
			return true;
		}
		if (flag)
		{
			return true;
		}
		return false;
	}

	private static bool PlantSeaOat(int x, int y)
	{
		if (Main.tile[x, y].wall > 0 || Main.tile[x, y].active() || Main.tile[x, y].liquid > 0 || !SolidTileAllowBottomSlope(x, y + 1) || !TileID.Sets.Conversion.Sand[Main.tile[x, y + 1].type])
		{
			return false;
		}
		if (!SeaOatWaterCheck(x, y))
		{
			return false;
		}
		if (Main.tile[x, y + 1] == null)
		{
			return false;
		}
		TileColorCache cache = Main.tile[x, y + 1].BlockColorAndCoating();
		Main.tile[x, y].active(active: true);
		Main.tile[x, y].slope(0);
		Main.tile[x, y].halfBrick(halfBrick: false);
		Main.tile[x, y].type = 529;
		Main.tile[x, y].UseBlockColors(cache);
		Main.tile[x, y].frameX = (short)(genRand.Next(5) * 18);
		int num = 0;
		Main.tile[x, y].frameY = (short)(num * 34);
		if (Main.netMode == 2)
		{
			NetMessage.SendTileSquare(-1, x, y);
		}
		return true;
	}

	private static bool CheckSeaOat(int x, int y)
	{
		if (!SeaOatWaterCheck(x, y))
		{
			KillTile(x, y);
			if (Main.netMode == 2)
			{
				NetMessage.SendData(17, -1, -1, null, 0, x, y);
			}
			return false;
		}
		return true;
	}

	private static bool GrowSeaOat(int x, int y)
	{
		if (Main.tile[x, y].frameX < 180)
		{
			Main.tile[x, y].frameX += 90;
		}
		if (Main.netMode == 2)
		{
			NetMessage.SendTileSquare(-1, x, y);
		}
		return false;
	}

	private static int GetWaterDepth(int x, int y)
	{
		int num = y;
		while (!SolidTile(x, num))
		{
			num++;
			if (num > Main.maxTilesY - 1)
			{
				return 0;
			}
		}
		num--;
		int num2 = num;
		while (Main.tile[x, num2].liquid > 0 && !SolidTile(x, num2))
		{
			num2--;
		}
		return num - num2;
	}

	private static int CountGrowingPlantTiles(int x, int y, int range, int type)
	{
		int num = 0;
		for (int i = x - range; i <= x + range; i++)
		{
			for (int j = y - range * 3; j <= y + range * 3; j++)
			{
				if (Main.tile[i, j].active() && Main.tile[i, j].type == type)
				{
					num++;
				}
			}
		}
		return num;
	}

	private static bool PlaceBamboo(int x, int y)
	{
		int num = 2;
		int num2 = 5;
		int num3 = genRand.Next(1, 21);
		Tile tile = Main.tile[x, y];
		if (tile.wall > 0 && (double)y <= Main.worldSurface)
		{
			return false;
		}
		if (tile.active() && tile.type == 314)
		{
			return false;
		}
		Tile tile2 = Main.tile[x, y + 1];
		if (tile2.active() && (tile2.type == 571 || tile2.type == 60))
		{
			int waterDepth = GetWaterDepth(x, y);
			if (waterDepth < num || waterDepth > num2)
			{
				return false;
			}
			int num4 = CountGrowingPlantTiles(x, y, 5, 571);
			int i = 1;
			if (tile2.type == 571)
			{
				for (; !SolidTile(x, y + i); i++)
				{
				}
				if (i + num4 / genRand.Next(1, 21) > num3)
				{
					return false;
				}
			}
			else
			{
				num4 += 25;
			}
			num4 += i * 2;
			if (num4 > genRand.Next(40, 61))
			{
				return false;
			}
			TileColorCache cache = tile2.BlockColorAndCoating();
			tile = Main.tile[x, y];
			tile.active(active: true);
			tile.type = 571;
			tile.frameX = 0;
			tile.frameY = 0;
			tile.slope(0);
			tile.halfBrick(halfBrick: false);
			tile.UseBlockColors(cache);
			SquareTileFrame(x, y);
			return true;
		}
		return false;
	}

	public static void CheckBamboo(int x, int y)
	{
		Tile tile = Main.tile[x, y + 1];
		if (tile == null)
		{
			return;
		}
		if (!tile.active() || (tile.type != 60 && tile.type != 571))
		{
			KillTile(x, y);
			if (Main.netMode == 2)
			{
				NetMessage.SendData(17, -1, -1, null, 0, x, y);
			}
			SquareTileFrame(x, y);
			return;
		}
		Tile tile2 = Main.tile[x, y - 1];
		if (tile2 == null)
		{
			return;
		}
		Tile tile3 = Main.tile[x, y];
		if (tile3 == null)
		{
			return;
		}
		bool num = tile2.active() && tile2.type == 571;
		bool flag = tile.active() && tile.type == 571;
		int num2 = tile3.frameX / 18;
		tile3.frameY = 0;
		if (num)
		{
			if (flag)
			{
				if (num2 < 5 || num2 > 14)
				{
					tile3.frameX = (short)(genRand.Next(5, 15) * 18);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y);
					}
				}
			}
			else if (num2 < 1 || num2 > 4)
			{
				tile3.frameX = (short)(genRand.Next(1, 5) * 18);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
			}
		}
		else if (flag)
		{
			if (num2 < 15 || num2 > 19)
			{
				tile3.frameX = (short)(genRand.Next(15, 20) * 18);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
			}
		}
		else if (num2 != 0)
		{
			tile3.frameX = 0;
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, x, y);
			}
		}
	}

	public static void PlaceUnderwaterPlant(ushort type, int x, int y)
	{
		if (CanUnderwaterPlantGrowHere(type, x, y, ignoreSelf: false))
		{
			Tile tileSafely = Framing.GetTileSafely(x, y + 1);
			tileSafely.slope(0);
			tileSafely.halfBrick(halfBrick: false);
			TileColorCache cache = tileSafely.BlockColorAndCoating();
			Tile tileSafely2 = Framing.GetTileSafely(x, y);
			tileSafely2.active(active: true);
			tileSafely2.type = type;
			tileSafely2.frameX = 0;
			tileSafely2.frameY = 0;
			tileSafely2.slope(0);
			tileSafely2.halfBrick(halfBrick: false);
			tileSafely2.UseBlockColors(cache);
			SquareTileFrame(x, y);
		}
	}

	public static bool CanUnderwaterPlantGrowHere(ushort type, int x, int y, bool ignoreSelf)
	{
		if (!InWorld(x, y, 50))
		{
			return false;
		}
		Tile tileSafely = Framing.GetTileSafely(x, y);
		if (!ignoreSelf && tileSafely.active())
		{
			return false;
		}
		for (int i = 0; i < 3; i++)
		{
			tileSafely = Framing.GetTileSafely(x, y - i);
			if (tileSafely.liquid == 0 || tileSafely.liquidType() != 0)
			{
				return false;
			}
		}
		Tile tileSafely2 = Framing.GetTileSafely(x, y + 1);
		if (!tileSafely2.nactive())
		{
			return false;
		}
		if ((!TileID.Sets.Conversion.Sand[tileSafely2.type] || !TopEdgeCanBeAttachedTo(x, y + 1)) && type != tileSafely2.type)
		{
			return false;
		}
		tileSafely = Framing.GetTileSafely(x, y);
		ushort wall = tileSafely.wall;
		if (wall != 0 && (uint)(wall - 63) > 6u && (uint)(wall - 80) > 1u)
		{
			return false;
		}
		return true;
	}

	public static void CheckUnderwaterPlant(ushort type, int x, int y)
	{
		if (!CanUnderwaterPlantGrowHere(type, x, y, ignoreSelf: true))
		{
			KillTile(x, y);
			if (Main.netMode == 2)
			{
				NetMessage.SendData(17, -1, -1, null, 0, x, y);
			}
			SquareTileFrame(x, y);
			return;
		}
		Tile tileSafely = Framing.GetTileSafely(x, y - 1);
		Tile tileSafely2 = Framing.GetTileSafely(x, y);
		Tile tileSafely3 = Framing.GetTileSafely(x, y + 1);
		bool num = tileSafely.active() && tileSafely.type == type;
		bool flag = tileSafely3.active() && tileSafely3.type == type;
		int num2 = tileSafely2.frameX / 18;
		tileSafely2.frameY = 0;
		if (num)
		{
			if (1 > num2 || num2 > 7)
			{
				tileSafely2.frameX = (short)(genRand.Next(1, 8) * 18);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
			}
		}
		else if (flag)
		{
			if (7 > num2 || num2 > 12)
			{
				tileSafely2.frameX = (short)(genRand.Next(7, 13) * 18);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
			}
		}
		else if (num2 != 0)
		{
			tileSafely2.frameX = 0;
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, x, y);
			}
		}
	}

	public static Point PlaceCatTail(int x, int j)
	{
		int num = j;
		Point result = new Point(-1, -1);
		if (x < 50 || x > Main.maxTilesX - 50 || num < 50 || num > Main.maxTilesY - 50)
		{
			return result;
		}
		if ((Main.tile[x, num].active() && Main.tile[x, num].type != 71) || Main.tile[x, num].liquid == 0 || Main.tile[x, num].liquidType() != 0)
		{
			return result;
		}
		while (Main.tile[x, num].liquid > 0 && num > 50)
		{
			num--;
		}
		num++;
		if (Main.tile[x, num].active() || Main.tile[x, num - 1].active() || Main.tile[x, num].liquid == 0 || Main.tile[x, num].liquidType() != 0)
		{
			return result;
		}
		if (Main.tile[x, num].wall != 0 && Main.tile[x, num].wall != 80 && Main.tile[x, num].wall != 81 && Main.tile[x, num].wall != 69 && (Main.tile[x, num].wall < 63 || Main.tile[x, num].wall > 68))
		{
			return result;
		}
		int num2 = 7;
		int num3 = 0;
		for (int i = x - num2; i <= x + num2; i++)
		{
			for (int k = num - num2; k <= num + num2; k++)
			{
				if (Main.tile[i, k].active() && Main.tile[i, k].type == 519)
				{
					num3++;
					break;
				}
			}
		}
		if (num3 > 3)
		{
			return result;
		}
		int l;
		for (l = num; (!Main.tile[x, l].active() || !Main.tileSolid[Main.tile[x, l].type] || Main.tileSolidTop[Main.tile[x, l].type]) && l < Main.maxTilesY - 50; l++)
		{
			if (Main.tile[x, l].active() && Main.tile[x, l].type != 71)
			{
				return result;
			}
		}
		int num4 = catTailDistance - 1;
		if (l - num > num4)
		{
			return result;
		}
		if (l - num < 2)
		{
			return result;
		}
		int type = Main.tile[x, l].type;
		if (!Main.tile[x, l].nactive())
		{
			return result;
		}
		int num5 = -1;
		switch (type)
		{
		case 2:
		case 477:
			num5 = 0;
			break;
		case 53:
			if (x < beachDistance || x > Main.maxTilesX - beachDistance)
			{
				return result;
			}
			num5 = 18;
			break;
		case 199:
		case 234:
		case 662:
			num5 = 54;
			break;
		case 23:
		case 112:
		case 661:
			num5 = 72;
			break;
		case 70:
			num5 = 90;
			break;
		}
		if (num5 < 0)
		{
			return result;
		}
		if (Main.tile[x, l].topSlope() && isGeneratingOrLoadingWorld && genRand.Next(3) != 0)
		{
			Main.tile[x, l].slope(0);
		}
		else if (Main.tile[x, l].topSlope() || Main.tile[x, l].halfBrick())
		{
			return result;
		}
		num = l - 1;
		Main.tile[x, num].active(active: true);
		Main.tile[x, num].type = 519;
		Main.tile[x, num].frameX = 0;
		Main.tile[x, num].frameY = (short)num5;
		Main.tile[x, num].halfBrick(halfBrick: false);
		Main.tile[x, num].slope(0);
		Main.tile[x, num].CopyPaintAndCoating(Main.tile[x, num + 1]);
		SquareTileFrame(x, num);
		return new Point(x, num);
	}

	public static void CheckCatTail(int x, int j)
	{
		if (Main.tile[x, j] == null)
		{
			return;
		}
		int num = j;
		bool flag = false;
		int num2 = num;
		while ((!Main.tile[x, num2].active() || !Main.tileSolid[Main.tile[x, num2].type] || Main.tileSolidTop[Main.tile[x, num2].type]) && num2 < Main.maxTilesY - 50)
		{
			if (Main.tile[x, num2].active() && Main.tile[x, num2].type != 519)
			{
				flag = true;
			}
			if (!Main.tile[x, num2].active())
			{
				break;
			}
			num2++;
			if (Main.tile[x, num2] == null)
			{
				return;
			}
		}
		num = num2 - 1;
		if (Main.tile[x, num] == null)
		{
			return;
		}
		while (Main.tile[x, num] != null && Main.tile[x, num].liquid > 0 && num > 50)
		{
			if ((Main.tile[x, num].active() && Main.tile[x, num].type != 519) || Main.tile[x, num].liquidType() != 0)
			{
				flag = true;
			}
			num--;
			if (Main.tile[x, num] == null)
			{
				return;
			}
		}
		num++;
		if (Main.tile[x, num] == null)
		{
			return;
		}
		int num3 = num;
		int num4 = catTailDistance;
		if (num2 - num3 > num4)
		{
			flag = true;
		}
		int type = Main.tile[x, num2].type;
		int num5 = -1;
		switch (type)
		{
		case 2:
		case 477:
			num5 = 0;
			break;
		case 53:
			num5 = 18;
			break;
		case 199:
		case 234:
		case 662:
			num5 = 54;
			break;
		case 23:
		case 112:
		case 661:
			num5 = 72;
			break;
		case 70:
			num5 = 90;
			break;
		}
		if (!Main.tile[x, num2].nactive())
		{
			flag = true;
		}
		if (num5 < 0)
		{
			flag = true;
		}
		num = num2 - 1;
		if (Main.tile[x, num] != null && !Main.tile[x, num].active())
		{
			for (int num6 = num; num6 >= num3; num6--)
			{
				if (Main.tile[x, num6] == null)
				{
					return;
				}
				if (Main.tile[x, num6].active() && Main.tile[x, num6].type == 519)
				{
					num = num6;
					break;
				}
			}
		}
		while (Main.tile[x, num] != null && Main.tile[x, num].active() && Main.tile[x, num].type == 519)
		{
			num--;
		}
		num++;
		if (Main.tile[x, num2 - 1] != null && Main.tile[x, num2 - 1].liquid < 127 && (isGeneratingOrLoadingWorld || genRand.Next(4) == 0))
		{
			flag = true;
		}
		if (Main.tile[x, num] != null && Main.tile[x, num].frameX >= 180 && Main.tile[x, num].liquid > 127 && (isGeneratingOrLoadingWorld || genRand.Next(4) == 0))
		{
			flag = true;
		}
		if (Main.tile[x, num] != null && Main.tile[x, num2 - 1] != null && Main.tile[x, num].frameX > 18)
		{
			if (Main.tile[x, num2 - 1].frameX < 36 || Main.tile[x, num2 - 1].frameX > 72)
			{
				flag = true;
			}
			else if (Main.tile[x, num].frameX < 90)
			{
				flag = true;
			}
			else if (Main.tile[x, num].frameX >= 108 && Main.tile[x, num].frameX <= 162)
			{
				Main.tile[x, num].frameX = 90;
			}
		}
		if (num2 > num + 4 && Main.tile[x, num + 4] != null && Main.tile[x, num + 3] != null && Main.tile[x, num + 4].liquid == 0 && Main.tile[x, num + 3].type == 519)
		{
			flag = true;
		}
		if (flag)
		{
			int num7 = num3;
			if (num < num3)
			{
				num7 = num;
			}
			num7 -= 4;
			for (int i = num7; i <= num2; i++)
			{
				if (Main.tile[x, i] != null && Main.tile[x, i].active() && Main.tile[x, i].type == 519)
				{
					KillTile(x, i);
					if (Main.netMode == 2)
					{
						NetMessage.SendData(17, -1, -1, null, 0, x, i);
					}
					SquareTileFrame(x, i);
				}
			}
		}
		else
		{
			if (num5 == Main.tile[x, num].frameY)
			{
				return;
			}
			for (int k = num; k < num2; k++)
			{
				if (Main.tile[x, k] != null && Main.tile[x, k].active() && Main.tile[x, k].type == 519)
				{
					Main.tile[x, k].frameY = (short)num5;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, num);
					}
				}
			}
		}
	}

	public static void GrowCheckSeaweed(int x, int y)
	{
		int maxValue = 1;
		if (Main.netMode == 1)
		{
			return;
		}
		if ((Main.tile[x, y].type == 549 && Main.tile[x, y].liquid < 200) || Main.tile[x, y - 1].liquid < 200)
		{
			if (Main.tile[x, y].active() && Main.tile[x, y].type == 549 && genRand.Next(2) == 0)
			{
				KillTile(x, y);
				if (Main.netMode == 2)
				{
					NetMessage.SendData(17, -1, -1, null, 0, x, y);
				}
			}
		}
		else
		{
			if (Main.tile[x, y - 1].active() || Main.tile[x, y - 2].active() || genRand.Next(maxValue) != 0 || Main.tile[x, y - 2].liquid != byte.MaxValue || Main.tile[x, y - 3].liquid != byte.MaxValue)
			{
				return;
			}
			int num = 17;
			int num2 = 4;
			int num3 = 30;
			int num4 = 0;
			for (int i = x - num2; i <= x + num2; i++)
			{
				for (int j = y; j <= y + num2 * 3; j++)
				{
					if (Main.tile[i, j].active() && Main.tile[i, j].type == 549)
					{
						num4++;
						if (num4 > num3)
						{
							return;
						}
					}
				}
			}
			int k;
			for (k = y; !SolidTile(x, k) && k < Main.maxTilesY - 50; k++)
			{
			}
			if (k - y < num - genRand.Next(20))
			{
				PlaceTile(x, y - 1, 549, mute: true);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y - 1);
				}
			}
		}
	}

	public static void GrowCatTail(int x, int j)
	{
		if (Main.netMode == 1)
		{
			return;
		}
		int num = j;
		while (Main.tile[x, num].liquid > 0 && num > 50)
		{
			num--;
		}
		num++;
		int i;
		for (i = num; (!Main.tile[x, i].active() || !Main.tileSolid[Main.tile[x, i].type] || Main.tileSolidTop[Main.tile[x, i].type]) && i < Main.maxTilesY - 50; i++)
		{
		}
		num = i - 1;
		while (Main.tile[x, num].active() && Main.tile[x, num].type == 519)
		{
			num--;
		}
		num++;
		if (!Main.tile[x, num].active() || Main.tile[x, num].type != 519)
		{
			return;
		}
		if (Main.tile[x, num].frameX == 90 && Main.tile[x, num - 1].active() && Main.tileCut[Main.tile[x, num - 1].type])
		{
			KillTile(x, num - 1);
			if (Main.netMode == 2)
			{
				NetMessage.SendData(17, -1, -1, null, 0, x, num - 1);
			}
		}
		if (Main.tile[x, num - 1].active())
		{
			return;
		}
		if (Main.tile[x, num].frameX == 0)
		{
			Main.tile[x, num].frameX = 18;
			SquareTileFrame(x, num);
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, x, num);
			}
		}
		else if (Main.tile[x, num].frameX == 18)
		{
			Main.tile[x, num].frameX = (short)(18 * genRand.Next(2, 5));
			Main.tile[x, num - 1].active(active: true);
			Main.tile[x, num - 1].type = 519;
			Main.tile[x, num - 1].frameX = 90;
			Main.tile[x, num - 1].frameY = Main.tile[x, num].frameY;
			Main.tile[x, num - 1].halfBrick(halfBrick: false);
			Main.tile[x, num - 1].slope(0);
			Main.tile[x, num - 1].CopyPaintAndCoating(Main.tile[x, num]);
			SquareTileFrame(x, num);
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, x, num);
			}
		}
		else if (Main.tile[x, num].frameX == 90)
		{
			if (Main.tile[x, num - 1].liquid == 0)
			{
				if (!Main.tile[x, num - 2].active() && (Main.tile[x, num].liquid > 0 || Main.tile[x, num + 1].liquid > 0 || Main.tile[x, num + 2].liquid > 0) && genRand.Next(3) == 0)
				{
					Main.tile[x, num].frameX = 108;
					Main.tile[x, num - 1].active(active: true);
					Main.tile[x, num - 1].type = 519;
					Main.tile[x, num - 1].frameX = 90;
					Main.tile[x, num - 1].frameY = Main.tile[x, num].frameY;
					Main.tile[x, num - 1].halfBrick(halfBrick: false);
					Main.tile[x, num - 1].slope(0);
					Main.tile[x, num - 1].CopyPaintAndCoating(Main.tile[x, num]);
					SquareTileFrame(x, num);
				}
				else
				{
					int num2 = genRand.Next(3);
					Main.tile[x, num].frameX = (short)(126 + num2 * 18);
					Main.tile[x, num - 1].active(active: true);
					Main.tile[x, num - 1].type = 519;
					Main.tile[x, num - 1].frameX = (short)(180 + num2 * 18);
					Main.tile[x, num - 1].frameY = Main.tile[x, num].frameY;
					Main.tile[x, num - 1].halfBrick(halfBrick: false);
					Main.tile[x, num - 1].slope(0);
					Main.tile[x, num - 1].CopyPaintAndCoating(Main.tile[x, num]);
					SquareTileFrame(x, num);
				}
			}
			else
			{
				Main.tile[x, num].frameX = 108;
				Main.tile[x, num - 1].active(active: true);
				Main.tile[x, num - 1].type = 519;
				Main.tile[x, num - 1].frameX = 90;
				Main.tile[x, num - 1].frameY = Main.tile[x, num].frameY;
				Main.tile[x, num - 1].halfBrick(halfBrick: false);
				Main.tile[x, num - 1].slope(0);
				Main.tile[x, num - 1].CopyPaintAndCoating(Main.tile[x, num]);
				SquareTileFrame(x, num);
			}
		}
		SquareTileFrame(x, num - 1, resetFrame: false);
		if (Main.netMode == 2)
		{
			NetMessage.SendTileSquare(-1, x, num - 1, 1, 2);
		}
	}

	public static bool PlaceLilyPad(int x, int j)
	{
		int num = j;
		if (x < 50 || x > Main.maxTilesX - 50 || num < 50 || num > Main.maxTilesY - 50)
		{
			return false;
		}
		if (Main.tile[x, num].active() || Main.tile[x, num].liquid == 0 || Main.tile[x, num].liquidType() != 0)
		{
			return false;
		}
		while (Main.tile[x, num].liquid > 0 && num > 50)
		{
			num--;
		}
		num++;
		if (Main.tile[x, num].active() || Main.tile[x, num - 1].active() || Main.tile[x, num].liquid == 0 || Main.tile[x, num].liquidType() != 0)
		{
			return false;
		}
		if (Main.tile[x, num].wall != 0 && Main.tile[x, num].wall != 15 && Main.tile[x, num].wall != 70 && (Main.tile[x, num].wall < 63 || Main.tile[x, num].wall > 68))
		{
			return false;
		}
		int num2 = 5;
		int num3 = 0;
		for (int i = x - num2; i <= x + num2; i++)
		{
			for (int k = num - num2; k <= num + num2; k++)
			{
				if (Main.tile[i, k].active() && Main.tile[i, k].type == 518)
				{
					num3++;
				}
			}
		}
		if (num3 > 3)
		{
			return false;
		}
		int l;
		for (l = num; (!Main.tile[x, l].active() || !Main.tileSolid[Main.tile[x, l].type] || Main.tileSolidTop[Main.tile[x, l].type]) && l < Main.maxTilesY - 50; l++)
		{
			if (Main.tile[x, l].active() && Main.tile[x, l].type == 519)
			{
				return false;
			}
		}
		int num4 = 12;
		if (l - num > num4)
		{
			return false;
		}
		if (l - num < 3)
		{
			return false;
		}
		int type = Main.tile[x, l].type;
		int num5 = -1;
		if (type == 2 || type == 477)
		{
			num5 = 0;
		}
		if (type == 109 || type == 492 || type == 116)
		{
			num5 = 18;
		}
		if (type == 60)
		{
			num5 = 36;
		}
		if (num5 < 0)
		{
			return false;
		}
		byte color = Main.tile[x, l].color();
		Main.tile[x, num].active(active: true);
		Main.tile[x, num].type = 518;
		Main.tile[x, num].color(color);
		if (genRand.Next(2) == 0)
		{
			Main.tile[x, num].frameX = (short)(18 * genRand.Next(3));
		}
		else if (genRand.Next(15) == 0)
		{
			Main.tile[x, num].frameX = (short)(18 * genRand.Next(18));
		}
		else
		{
			int num6 = Main.maxTilesX / 5;
			if (x < num6)
			{
				Main.tile[x, num].frameX = (short)(18 * genRand.Next(6, 9));
			}
			else if (x < num6 * 2)
			{
				Main.tile[x, num].frameX = (short)(18 * genRand.Next(9, 12));
			}
			else if (x < num6 * 3)
			{
				Main.tile[x, num].frameX = (short)(18 * genRand.Next(3, 6));
			}
			else if (x < num6 * 4)
			{
				Main.tile[x, num].frameX = (short)(18 * genRand.Next(15, 18));
			}
			else
			{
				Main.tile[x, num].frameX = (short)(18 * genRand.Next(12, 15));
			}
		}
		Main.tile[x, num].frameY = (short)num5;
		Main.tile[x, num].halfBrick(halfBrick: false);
		Main.tile[x, num].slope(0);
		SquareTileFrame(x, num);
		return true;
	}

	public static void CheckLilyPad(int x, int y)
	{
		if (Main.netMode == 1)
		{
			return;
		}
		if (Main.tile[x, y].liquidType() != 0)
		{
			KillTile(x, y);
			if (Main.netMode == 2)
			{
				NetMessage.SendData(17, -1, -1, null, 0, x, y);
			}
			return;
		}
		int num = y;
		while ((!Main.tile[x, num].active() || !Main.tileSolid[Main.tile[x, num].type] || Main.tileSolidTop[Main.tile[x, num].type]) && num < Main.maxTilesY - 50)
		{
			num++;
			if (Main.tile[x, num] == null)
			{
				return;
			}
		}
		int type = Main.tile[x, num].type;
		int num2 = -1;
		if (type == 2 || type == 477)
		{
			num2 = 0;
		}
		if (type == 109 || type == 109 || type == 116)
		{
			num2 = 18;
		}
		if (type == 60)
		{
			num2 = 36;
		}
		if (num2 >= 0)
		{
			if (num2 != Main.tile[x, y].frameY)
			{
				Main.tile[x, y].frameY = (short)num2;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
			}
			if (Main.tile[x, y - 1].liquid > 0 && !Main.tile[x, y - 1].active())
			{
				Main.tile[x, y - 1].active(active: true);
				Main.tile[x, y - 1].type = 518;
				Main.tile[x, y - 1].frameX = Main.tile[x, y].frameX;
				Main.tile[x, y - 1].frameY = Main.tile[x, y].frameY;
				Main.tile[x, y - 1].halfBrick(halfBrick: false);
				Main.tile[x, y - 1].slope(0);
				Main.tile[x, y - 1].color(Main.tile[x, y].color());
				Main.tile[x, y].active(active: false);
				Main.tile[x, y].type = 0;
				SquareTileFrame(x, y - 1, resetFrame: false);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y - 1, 1, 2);
				}
			}
			else
			{
				if (Main.tile[x, y].liquid != 0)
				{
					return;
				}
				Tile tileSafely = Framing.GetTileSafely(x, y + 1);
				if (!tileSafely.active())
				{
					Main.tile[x, y + 1].active(active: true);
					Main.tile[x, y + 1].type = 518;
					Main.tile[x, y + 1].frameX = Main.tile[x, y].frameX;
					Main.tile[x, y + 1].frameY = Main.tile[x, y].frameY;
					Main.tile[x, y + 1].halfBrick(halfBrick: false);
					Main.tile[x, y + 1].slope(0);
					Main.tile[x, y + 1].color(Main.tile[x, y].color());
					Main.tile[x, y].active(active: false);
					Main.tile[x, y].type = 0;
					SquareTileFrame(x, y + 1, resetFrame: false);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y, 1, 2);
					}
				}
				else if (tileSafely.active() && !TileID.Sets.Platforms[tileSafely.type] && (!Main.tileSolid[tileSafely.type] || Main.tileSolidTop[tileSafely.type]))
				{
					KillTile(x, y);
					if (Main.netMode == 2)
					{
						NetMessage.SendData(17, -1, -1, null, 0, x, y);
					}
				}
			}
		}
		else
		{
			KillTile(x, y);
			if (Main.netMode == 2)
			{
				NetMessage.SendData(17, -1, -1, null, 0, x, y);
			}
		}
	}

	public static bool TryKillingReplaceableTile(int x, int y, int tileType)
	{
		if (!InWorld(x, y, 2))
		{
			return false;
		}
		if (Main.tile[x, y].active() && (Main.tileCut[Main.tile[x, y].type] || TileID.Sets.BreakableWhenPlacing[Main.tile[x, y].type] || TileID.Sets.IsADripTile[Main.tile[x, y].type]))
		{
			if (Main.tile[x, y].type != tileType)
			{
				bool num = Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 579;
				bool flag = Main.tile[x, y].type == 3 || Main.tile[x, y].type == 73;
				bool flag2 = Main.tileAlch[Main.tile[x, y].type] && IsHarvestableHerbWithSeed(Main.tile[x, y].type, Main.tile[x, y].frameX / 18, y);
				bool flag3 = Main.tileAlch[tileType];
				if (num || ((flag || flag2) && flag3))
				{
					KillTile(x, y);
					if (!Main.tile[x, y].active() && Main.netMode != 0)
					{
						NetMessage.SendData(17, -1, -1, null, 0, x, y);
					}
					return true;
				}
				return false;
			}
			return false;
		}
		return false;
	}

	public static bool PlaceTile(int i, int j, int Type, bool mute = false, bool forced = false, int plr = -1, int style = 0)
	{
		int num = Type;
		if (isGeneratingOrLoadingWorld && Main.tile[i, j].active() && Main.tile[i, j].type == 488)
		{
			return false;
		}
		if (num >= TileID.Count)
		{
			return false;
		}
		bool result = false;
		if (i >= 0 && j >= 0 && i < Main.maxTilesX && j < Main.maxTilesY)
		{
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				tile = new Tile();
				Main.tile[i, j] = tile;
			}
			if (tile.active())
			{
				if (num == 23 && tile.type == 59)
				{
					num = 661;
				}
				if (num == 199 && tile.type == 59)
				{
					num = 662;
				}
			}
			if (forced || Collision.EmptyTile(i, j) || !Main.tileSolid[num] || (num == 23 && tile.type == 0 && tile.active()) || (num == 199 && tile.type == 0 && tile.active()) || (num == 2 && tile.type == 0 && tile.active()) || (num == 109 && tile.type == 0 && tile.active()) || (num == 60 && tile.type == 59 && tile.active()) || (num == 661 && tile.type == 59 && tile.active()) || (num == 662 && tile.type == 59 && tile.active()) || (num == 70 && tile.type == 59 && tile.active()) || (num == 633 && tile.type == 57 && tile.active()) || (Main.tileMoss[num] && (tile.type == 1 || tile.type == 38) && tile.active()))
			{
				if (num == 23 && (tile.type != 0 || !tile.active()))
				{
					return false;
				}
				if (num == 199 && (tile.type != 0 || !tile.active()))
				{
					return false;
				}
				if (num == 2 && (tile.type != 0 || !tile.active()))
				{
					return false;
				}
				if (num == 109 && (tile.type != 0 || !tile.active()))
				{
					return false;
				}
				if (num == 60 && (tile.type != 59 || !tile.active()))
				{
					return false;
				}
				if (num == 661 && (tile.type != 59 || !tile.active()))
				{
					return false;
				}
				if (num == 662 && (tile.type != 59 || !tile.active()))
				{
					return false;
				}
				if (num == 70 && (tile.type != 59 || !tile.active()))
				{
					return false;
				}
				if (num == 633 && (tile.type != 57 || !tile.active()))
				{
					return false;
				}
				if (Main.tileMoss[num])
				{
					if ((tile.type != 1 && tile.type != 38) || !tile.active())
					{
						return false;
					}
					if (tile.type == 38)
					{
						num = num switch
						{
							381 => 517, 
							534 => 535, 
							536 => 537, 
							539 => 540, 
							625 => 626, 
							627 => 628, 
							_ => 512 + num - 179, 
						};
					}
				}
				if (num == 81)
				{
					if (Main.tile[i, j - 1] == null)
					{
						Main.tile[i, j - 1] = new Tile();
					}
					if (Main.tile[i, j + 1] == null)
					{
						Main.tile[i, j + 1] = new Tile();
					}
					if (Main.tile[i, j - 1].active())
					{
						return false;
					}
					if (!Main.tile[i, j + 1].active() || !Main.tileSolid[Main.tile[i, j + 1].type] || Main.tile[i, j + 1].halfBrick() || Main.tile[i, j + 1].slope() != 0)
					{
						return false;
					}
				}
				if (TileID.Sets.IsADripTile[num] && (Main.tile[i, j - 1] == null || Main.tile[i, j - 1].bottomSlope()))
				{
					return false;
				}
				if (tile.liquid > 0 || tile.checkingLiquid())
				{
					if (TileID.Sets.Torches[num])
					{
						if (num == 4 && style != 8 && style != 11 && style != 17)
						{
							return false;
						}
						TileObjectData tileData = TileObjectData.GetTileData(num, style);
						if (tileData != null && tileData.WaterPlacement != LiquidPlacement.Allowed)
						{
							return false;
						}
					}
					else if (num == 3 || num == 20 || num == 24 || num == 27 || num == 32 || num == 51 || num == 69 || num == 72 || num == 201 || num == 352 || num == 529 || num == 624 || num == 700 || num == 637 || num == 656 || num == 701 || num == 697)
					{
						return false;
					}
				}
				if (!tile.active())
				{
					tile.Clear(TileDataType.Tile | TileDataType.TilePaint | TileDataType.Slope);
				}
				else if (TileID.Sets.ResetsHalfBrickPlacementAttempt[num] && (!tile.active() || !Main.tileFrameImportant[tile.type]))
				{
					tile.halfBrick(halfBrick: false);
					tile.frameY = 0;
					tile.frameX = 0;
				}
				if (num == 624 || num == 700)
				{
					if ((!tile.active() || Main.tileCut[tile.type] || TileID.Sets.BreakableWhenPlacing[tile.type]) && HasValidGroundForAbigailsFlowerBelowSpot(i, j))
					{
						tile.active(active: true);
						tile.type = (ushort)num;
						tile.halfBrick(halfBrick: false);
						tile.slope(0);
						tile.frameX = 0;
						tile.frameY = 0;
					}
				}
				else if (num == 656 || num == 701)
				{
					if ((!tile.active() || Main.tileCut[tile.type] || TileID.Sets.BreakableWhenPlacing[tile.type]) && HasValidGroundForGlowTulipBelowSpot(i, j))
					{
						tile.active(active: true);
						tile.type = (ushort)num;
						tile.halfBrick(halfBrick: false);
						tile.slope(0);
						tile.frameX = 0;
						tile.frameY = 0;
					}
				}
				else if (num == 3 || num == 24 || num == 110 || num == 201 || num == 637)
				{
					if (IsFitToPlaceFlowerIn(i, j, num))
					{
						if (num == 24 && genRand.Next(13) == 0)
						{
							tile.active(active: true);
							tile.type = 32;
							SquareTileFrame(i, j);
						}
						else if (num == 201 && genRand.Next(13) == 0)
						{
							tile.active(active: true);
							tile.type = 352;
							SquareTileFrame(i, j);
						}
						else if (Main.tile[i, j + 1].type == 78 || Main.tile[i, j + 1].type == 380 || Main.tile[i, j + 1].type == 579)
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							int num2 = genRand.NextFromList<int>(6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 24, 27, 30, 33, 36, 39, 42);
							switch (num2)
							{
							case 21:
							case 24:
							case 27:
							case 30:
							case 33:
							case 36:
							case 39:
							case 42:
								num2 += genRand.Next(3);
								break;
							}
							tile.frameX = (short)(num2 * 18);
						}
						else if (tile.wall >= 0 && tile.wall < WallID.Count && WallID.Sets.AllowsPlantsToGrow[tile.wall] && Main.tile[i, j + 1].wall >= 0 && Main.tile[i, j + 1].wall < WallID.Count && WallID.Sets.AllowsPlantsToGrow[Main.tile[i, j + 1].wall])
						{
							if (genRand.Next(50) == 0 || ((num == 24 || num == 201) && genRand.Next(40) == 0))
							{
								tile.active(active: true);
								tile.type = (ushort)num;
								if (num == 201)
								{
									tile.frameX = 270;
								}
								else
								{
									tile.frameX = 144;
								}
							}
							else if (genRand.Next(35) == 0 || (Main.tile[i, j].wall >= 63 && Main.tile[i, j].wall <= 70))
							{
								tile.active(active: true);
								tile.type = (ushort)num;
								int num3 = genRand.NextFromList<int>(6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20);
								if (num == 201)
								{
									num3 = genRand.NextFromList<int>(6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 18, 19, 20, 21, 22);
								}
								if (num == 637)
								{
									num3 = genRand.NextFromList<int>(6, 7, 8, 9, 10);
								}
								tile.frameX = (short)(num3 * 18);
							}
							else
							{
								tile.active(active: true);
								tile.type = (ushort)num;
								tile.frameX = (short)(genRand.Next(6) * 18);
							}
						}
					}
				}
				else if (num == 61)
				{
					if (j + 1 < Main.maxTilesY && Main.tile[i, j + 1].active() && Main.tile[i, j + 1].slope() == 0 && !Main.tile[i, j + 1].halfBrick() && (Main.tile[i, j + 1].type == 60 || Main.tile[i, j + 1].type == 226))
					{
						bool flag = Main.tile[i, j + 1].type == 226;
						bool flag2 = (double)j > Main.rockLayer || Main.remixWorld || remixWorldGen;
						if (flag)
						{
							flag2 = false;
						}
						if (genRand.Next(16) == 0 && (double)j > Main.worldSurface && !flag)
						{
							tile.active(active: true);
							tile.type = 69;
							SquareTileFrame(i, j);
						}
						else if (genRand.Next(60) == 0 && flag2)
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							tile.frameX = 144;
						}
						else if (genRand.Next(230) == 0 && flag2)
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							tile.frameX = 162;
						}
						else if (genRand.Next(15) == 0 && !flag)
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							if (genRand.Next(3) != 0)
							{
								tile.frameX = (short)(genRand.Next(2) * 18 + 108);
							}
							else
							{
								tile.frameX = (short)(genRand.Next(13) * 18 + 180);
							}
						}
						else
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							tile.frameX = (short)(genRand.Next(6) * 18);
						}
					}
				}
				else if (num == 518)
				{
					PlaceLilyPad(i, j);
				}
				else if (num == 519)
				{
					PlaceCatTail(i, j);
				}
				else if (num == 529)
				{
					PlantSeaOat(i, j);
				}
				else if (num == 571)
				{
					PlaceBamboo(i, j);
				}
				else if (num == 549)
				{
					PlaceUnderwaterPlant(549, i, j);
				}
				else if (num == 71)
				{
					if (j + 1 < Main.maxTilesY && Main.tile[i, j + 1].active() && Main.tile[i, j + 1].slope() == 0 && !Main.tile[i, j + 1].halfBrick() && Main.tile[i, j + 1].type == 70)
					{
						Point point = new Point(-1, -1);
						if ((double)j > Main.worldSurface)
						{
							point = PlaceCatTail(i, j);
						}
						if (InWorld(point.X, point.Y))
						{
							if (isGeneratingOrLoadingWorld)
							{
								int num4 = genRand.Next(14);
								for (int k = 0; k < num4; k++)
								{
									GrowCatTail(point.X, point.Y);
								}
								SquareTileFrame(point.X, point.Y);
							}
						}
						else
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							tile.frameX = (short)(genRand.Next(5) * 18);
						}
					}
				}
				else if (num == 129)
				{
					int newFrameDirection = 0;
					if (CheckAndAdjustMultiDirectionalTile(i, j, num, out newFrameDirection))
					{
						tile.active(active: true);
						tile.type = (ushort)num;
						tile.frameX = (short)(style * 18);
						SquareTileFrame(i, j);
					}
				}
				else if (num == 178)
				{
					int newFrameDirection2 = 0;
					if (CheckAndAdjustMultiDirectionalTile(i, j, num, out newFrameDirection2))
					{
						tile.active(active: true);
						tile.type = (ushort)num;
						tile.frameX = (short)(style * 18);
						tile.frameY = (short)(genRand.Next(3) * 18);
						SquareTileFrame(i, j);
					}
				}
				else if (num == 184)
				{
					if ((Main.tileMoss[Main.tile[i - 1, j].type] && SolidTile(i - 1, j)) || (Main.tileMoss[Main.tile[i + 1, j].type] && SolidTile(i + 1, j)) || (Main.tileMoss[Main.tile[i, j - 1].type] && SolidTile(i, j - 1)) || (Main.tileMoss[Main.tile[i, j + 1].type] && SolidTile(i, j + 1)))
					{
						tile.active(active: true);
						tile.type = (ushort)num;
						tile.frameX = (short)(style * 18);
						tile.frameY = (short)(genRand.Next(3) * 18);
						SquareTileFrame(i, j);
					}
					if ((TileID.Sets.tileMossBrick[Main.tile[i - 1, j].type] && SolidTile(i - 1, j)) || (TileID.Sets.tileMossBrick[Main.tile[i + 1, j].type] && SolidTile(i + 1, j)) || (TileID.Sets.tileMossBrick[Main.tile[i, j - 1].type] && SolidTile(i, j - 1)) || (TileID.Sets.tileMossBrick[Main.tile[i, j + 1].type] && SolidTile(i, j + 1)))
					{
						tile.active(active: true);
						tile.type = (ushort)num;
						tile.frameX = (short)(style * 18);
						tile.frameY = (short)(genRand.Next(3) * 18);
						SquareTileFrame(i, j);
					}
				}
				else if (num == 485)
				{
					PlaceObject(i, j, num, mute, style);
				}
				else if (num == 171)
				{
					PlaceXmasTree(i, j, 171);
				}
				else if (num == 254)
				{
					Place2x2Style(i, j, (ushort)num, style);
				}
				else if (num == 335 || num == 564 || num == 594)
				{
					Place2x2(i, j, (ushort)num, 0);
				}
				else if (num == 654 || num == 319 || num == 132 || num == 484 || num == 138 || num == 664 || num == 711 || num == 712 || num == 142 || num == 143 || num == 282 || (num >= 288 && num <= 295) || (num >= 316 && num <= 318) || num == 713 || num == 714 || num == 715 || num == 716)
				{
					Place2x2(i, j, (ushort)num, 0);
				}
				else if (num == 411)
				{
					Place2x2(i, j, (ushort)num, 0);
				}
				else if (num == 457)
				{
					Place2x2Horizontal(i, j, 457, style);
				}
				else if (num == 137)
				{
					tile.active(active: true);
					tile.type = (ushort)num;
					tile.frameY = (short)(18 * style);
				}
				else if (num == 136)
				{
					if (Main.tile[i - 1, j] == null)
					{
						Main.tile[i - 1, j] = new Tile();
					}
					if (Main.tile[i + 1, j] == null)
					{
						Main.tile[i + 1, j] = new Tile();
					}
					if (Main.tile[i, j + 1] == null)
					{
						Main.tile[i, j + 1] = new Tile();
					}
					if ((Main.tile[i - 1, j].nactive() && !Main.tile[i - 1, j].halfBrick() && !TileID.Sets.NotReallySolid[Main.tile[i - 1, j].type] && Main.tile[i - 1, j].slope() == 0 && (SolidTile(i - 1, j) || TileID.Sets.IsBeam[Main.tile[i - 1, j].type] || (Main.tile[i - 1, j].type == 5 && Main.tile[i - 1, j - 1].type == 5 && Main.tile[i - 1, j + 1].type == 5))) || (Main.tile[i + 1, j].nactive() && !Main.tile[i + 1, j].halfBrick() && !TileID.Sets.NotReallySolid[Main.tile[i + 1, j].type] && Main.tile[i + 1, j].slope() == 0 && (SolidTile(i + 1, j) || TileID.Sets.IsBeam[Main.tile[i + 1, j].type] || (Main.tile[i + 1, j].type == 5 && Main.tile[i + 1, j - 1].type == 5 && Main.tile[i + 1, j + 1].type == 5))) || (Main.tile[i, j + 1].nactive() && !Main.tile[i, j + 1].halfBrick() && SolidTile(i, j + 1) && Main.tile[i, j + 1].slope() == 0) || tile.wall > 0)
					{
						tile.active(active: true);
						tile.type = (ushort)num;
						SquareTileFrame(i, j);
					}
				}
				else if (num == 442)
				{
					if (Main.tile[i - 1, j] == null)
					{
						Main.tile[i - 1, j] = new Tile();
					}
					if (Main.tile[i + 1, j] == null)
					{
						Main.tile[i + 1, j] = new Tile();
					}
					if (Main.tile[i, j + 1] == null)
					{
						Main.tile[i, j + 1] = new Tile();
					}
					if ((Main.tile[i - 1, j].nactive() && !Main.tile[i - 1, j].halfBrick() && !TileID.Sets.NotReallySolid[Main.tile[i - 1, j].type] && Main.tile[i - 1, j].slope() == 0 && (SolidTile(i - 1, j) || TileID.Sets.IsBeam[Main.tile[i - 1, j].type] || (Main.tile[i - 1, j].type == 5 && Main.tile[i - 1, j - 1].type == 5 && Main.tile[i - 1, j + 1].type == 5))) || (Main.tile[i + 1, j].nactive() && !Main.tile[i + 1, j].halfBrick() && !TileID.Sets.NotReallySolid[Main.tile[i + 1, j].type] && Main.tile[i + 1, j].slope() == 0 && (SolidTile(i + 1, j) || TileID.Sets.IsBeam[Main.tile[i + 1, j].type] || (Main.tile[i + 1, j].type == 5 && Main.tile[i + 1, j - 1].type == 5 && Main.tile[i + 1, j + 1].type == 5))) || (Main.tile[i, j + 1].nactive() && !Main.tile[i, j + 1].halfBrick() && SolidTile(i, j + 1) && Main.tile[i, j + 1].slope() == 0))
					{
						tile.active(active: true);
						tile.type = (ushort)num;
						SquareTileFrame(i, j);
					}
				}
				else if (num == 4)
				{
					if (Main.tile[i - 1, j] == null)
					{
						Main.tile[i - 1, j] = new Tile();
					}
					if (Main.tile[i + 1, j] == null)
					{
						Main.tile[i + 1, j] = new Tile();
					}
					if (Main.tile[i, j + 1] == null)
					{
						Main.tile[i, j + 1] = new Tile();
					}
					if (Main.tile[i - 1, j - 1] == null)
					{
						Main.tile[i - 1, j - 1] = new Tile();
					}
					if (Main.tile[i + 1, j - 1] == null)
					{
						Main.tile[i + 1, j - 1] = new Tile();
					}
					if (Main.tile[i - 1, j + 1] == null)
					{
						Main.tile[i - 1, j + 1] = new Tile();
					}
					if (Main.tile[i + 1, j + 1] == null)
					{
						Main.tile[i + 1, j + 1] = new Tile();
					}
					Tile tile2 = Main.tile[i - 1, j];
					Tile tile3 = Main.tile[i + 1, j];
					Tile tile4 = Main.tile[i, j + 1];
					Tile tile5 = Main.tile[i - 1, j + 1];
					Tile tile6 = Main.tile[i + 1, j + 1];
					Tile tile7 = Main.tile[i - 1, j - 1];
					Tile tile8 = Main.tile[i + 1, j - 1];
					if (tile.wall > 0 || (tile2.active() && (tile2.slope() == 0 || tile2.slope() % 2 != 1) && ((Main.tileSolid[tile2.type] && !Main.tileSolidTop[tile2.type] && !TileID.Sets.NotReallySolid[tile2.type]) || TileID.Sets.IsBeam[tile2.type] || (IsTreeType(tile2.type) && IsTreeType(tile7.type) && IsTreeType(tile5.type)))) || (tile3.active() && (tile3.slope() == 0 || tile3.slope() % 2 != 0) && ((Main.tileSolid[tile3.type] && !Main.tileSolidTop[tile3.type] && !TileID.Sets.NotReallySolid[tile3.type]) || TileID.Sets.IsBeam[tile3.type] || (IsTreeType(tile3.type) && IsTreeType(tile8.type) && IsTreeType(tile6.type)))) || (tile4.active() && Main.tileSolid[tile4.type] && ((TileID.Sets.Platforms[tile4.type] && TopEdgeCanBeAttachedTo(i, j + 1)) || ((!Main.tileSolidTop[tile4.type] || (tile4.type == 380 && tile4.slope() == 0)) && !TileID.Sets.NotReallySolid[tile4.type] && !tile4.halfBrick() && tile4.slope() == 0))))
					{
						tile.active(active: true);
						tile.type = (ushort)num;
						tile.frameY = (short)(22 * style);
						SquareTileFrame(i, j);
					}
				}
				else if (num == 10)
				{
					if (Main.tile[i, j - 1] == null)
					{
						Main.tile[i, j - 1] = new Tile();
					}
					if (Main.tile[i, j - 2] == null)
					{
						Main.tile[i, j - 2] = new Tile();
					}
					if (Main.tile[i, j - 3] == null)
					{
						Main.tile[i, j - 3] = new Tile();
					}
					if (Main.tile[i, j + 1] == null)
					{
						Main.tile[i, j + 1] = new Tile();
					}
					if (Main.tile[i, j + 2] == null)
					{
						Main.tile[i, j + 2] = new Tile();
					}
					if (Main.tile[i, j + 3] == null)
					{
						Main.tile[i, j + 3] = new Tile();
					}
					if (!Main.tile[i, j - 1].active() && !Main.tile[i, j - 2].active() && Main.tile[i, j - 3].active() && Main.tileSolid[Main.tile[i, j - 3].type])
					{
						PlaceDoor(i, j - 1, num, style);
						SquareTileFrame(i, j);
					}
					else
					{
						if (Main.tile[i, j + 1].active() || Main.tile[i, j + 2].active() || !Main.tile[i, j + 3].active() || !Main.tileSolid[Main.tile[i, j + 3].type])
						{
							return false;
						}
						PlaceDoor(i, j + 1, num, style);
						SquareTileFrame(i, j);
					}
				}
				else if ((num >= 275 && num <= 281) || num == 296 || num == 297 || num == 309 || num == 358 || num == 359 || num == 413 || num == 414 || num == 542)
				{
					Place6x3(i, j, (ushort)num);
				}
				else if (num == 237 || num == 244 || num == 285 || num == 286 || num == 298 || num == 299 || num == 310 || num == 339 || num == 538 || (num >= 361 && num <= 364) || num == 532 || num == 533 || num == 486 || num == 488 || num == 544 || num == 582 || num == 619 || num == 629)
				{
					Place3x2(i, j, (ushort)num);
				}
				else if (num == 128)
				{
					PlaceMan(i, j, style);
					SquareTileFrame(i, j);
				}
				else if (num == 269)
				{
					PlaceWoman(i, j, style);
					SquareTileFrame(i, j);
				}
				else if (num == 334)
				{
					int style2 = 0;
					if (style == -1)
					{
						style2 = 1;
					}
					Place3x3Wall(i, j, 334, style2);
					SquareTileFrame(i, j);
				}
				else if (num == 149)
				{
					int newFrameDirection3 = 0;
					if (CheckAndAdjustMultiDirectionalTile(i, j, num, out newFrameDirection3))
					{
						tile.frameX = (short)(18 * style);
						tile.active(active: true);
						tile.type = (ushort)num;
						SquareTileFrame(i, j);
					}
				}
				else if (num == 139 || num == 35)
				{
					PlaceMB(i, j, (ushort)num, style);
					SquareTileFrame(i, j);
				}
				else if (num == 165)
				{
					PlaceTight(i, j);
					SquareTileFrame(i, j);
				}
				else if (num == 235)
				{
					Place3x1(i, j, (ushort)num);
					SquareTileFrame(i, j);
				}
				else if (num == 240)
				{
					Place3x3Wall(i, j, (ushort)num, style);
				}
				else if (num == 440)
				{
					Place3x3Wall(i, j, (ushort)num, style);
				}
				else if (num == 245)
				{
					Place2x3Wall(i, j, (ushort)num, style);
				}
				else if (num == 246)
				{
					Place3x2Wall(i, j, (ushort)num, style);
				}
				else if (num == 241)
				{
					Place4x3Wall(i, j, (ushort)num, style);
				}
				else if (num == 242)
				{
					Place6x4Wall(i, j, (ushort)num, style);
				}
				else if (num == 34)
				{
					PlaceChand(i, j, (ushort)num, style);
					SquareTileFrame(i, j);
				}
				else if (num == 106 || num == 212 || num == 219 || num == 220 || num == 228 || num == 231 || num == 243 || num == 247 || num == 283 || (num >= 300 && num <= 308) || num == 354 || num == 355 || num == 491 || num == 642 || num == 733)
				{
					Place3x3(i, j, (ushort)num, style);
					SquareTileFrame(i, j);
				}
				else
				{
					switch (num)
					{
					case 13:
					case 33:
					case 49:
					case 50:
					case 78:
					case 174:
					case 372:
					case 646:
						PlaceOnTable1x1(i, j, num, style);
						SquareTileFrame(i, j);
						break;
					case 14:
					case 26:
					case 86:
					case 87:
					case 88:
					case 89:
					case 114:
					case 186:
					case 187:
					case 215:
					case 217:
					case 218:
					case 377:
					case 469:
						Place3x2(i, j, (ushort)num, style);
						SquareTileFrame(i, j);
						break;
					case 236:
					case 702:
						PlaceJunglePlant(i, j, (ushort)num, genRand.Next(3), 0, num != 702);
						SquareTileFrame(i, j);
						break;
					case 238:
						PlaceJunglePlant(i, j, (ushort)num, 0, 0, inheritPaint: true);
						SquareTileFrame(i, j);
						break;
					case 20:
					{
						if (Main.tile[i, j + 1] == null)
						{
							Main.tile[i, j + 1] = new Tile();
						}
						int type = Main.tile[i, j + 1].type;
						if (Main.tile[i, j + 1].active() && (type == 2 || type == 109 || type == 147 || type == 60 || type == 23 || type == 199 || type == 661 || type == 662 || type == 53 || type == 234 || type == 116 || type == 112 || type == 633))
						{
							Place1x2(i, j, (ushort)num, style);
							SquareTileFrame(i, j);
						}
						break;
					}
					case 15:
					case 216:
					case 338:
					case 390:
						if (Main.tile[i, j - 1] == null)
						{
							Main.tile[i, j - 1] = new Tile();
						}
						if (Main.tile[i, j] == null)
						{
							Main.tile[i, j] = new Tile();
						}
						Place1x2(i, j, (ushort)num, style);
						SquareTileFrame(i, j);
						break;
					case 227:
						PlaceDye(i, j, style);
						SquareTileFrame(i, j);
						break;
					case 567:
						PlaceGnome(i, j, style);
						SquareTileFrame(i, j);
						break;
					case 16:
					case 18:
					case 29:
					case 103:
					case 134:
					case 462:
						Place2x1(i, j, (ushort)num, style);
						SquareTileFrame(i, j);
						break;
					case 92:
					case 93:
					case 453:
						Place1xX(i, j, (ushort)num, style);
						SquareTileFrame(i, j);
						break;
					case 104:
					case 105:
					case 320:
					case 337:
					case 349:
					case 356:
					case 378:
					case 456:
					case 506:
					case 545:
					case 663:
						Place2xX(i, j, (ushort)num, style);
						SquareTileFrame(i, j);
						break;
					case 17:
					case 77:
					case 133:
						Place3x2(i, j, (ushort)num, style);
						SquareTileFrame(i, j);
						break;
					case 207:
						Place2xX(i, j, (ushort)num, style);
						SquareTileFrame(i, j);
						break;
					case 410:
					case 480:
					case 509:
					case 657:
					case 658:
					case 720:
					case 721:
					case 725:
						Place2xX(i, j, (ushort)num, style);
						SquareTileFrame(i, j);
						break;
					case 465:
					case 531:
					case 591:
					case 592:
						Place2xX(i, j, (ushort)num, style);
						SquareTileFrame(i, j);
						break;
					default:
						if (TileID.Sets.BasicChest[num])
						{
							PlaceChest(i, j, (ushort)num, notNearOtherChests: false, style);
							SquareTileFrame(i, j);
							break;
						}
						switch (num)
						{
						case 91:
							PlaceBanner(i, j, (ushort)num, style);
							SquareTileFrame(i, j);
							break;
						case 419:
						case 420:
						case 423:
						case 424:
						case 429:
						case 445:
							PlaceLogicTiles(i, j, num, style);
							SquareTileFrame(i, j);
							break;
						case 36:
						case 135:
						case 141:
						case 144:
						case 210:
						case 239:
						case 324:
						case 476:
						case 494:
							Place1x1(i, j, num, style);
							SquareTileFrame(i, j);
							break;
						case 101:
						case 102:
						case 463:
							Place3x4(i, j, (ushort)num, style);
							SquareTileFrame(i, j);
							break;
						case 464:
						case 466:
							Place5x4(i, j, (ushort)num, style);
							SquareTileFrame(i, j);
							break;
						case 27:
							PlaceSunflower(i, j, 27);
							SquareTileFrame(i, j);
							break;
						case 28:
							PlacePot(i, j, 28, genRand.Next(4));
							SquareTileFrame(i, j);
							break;
						case 42:
						case 270:
						case 271:
							Place1x2Top(i, j, (ushort)num, style);
							SquareTileFrame(i, j);
							break;
						case 55:
						case 425:
						case 510:
						case 511:
							PlaceSign(i, j, (ushort)num, style);
							break;
						case 85:
						case 376:
							Place2x2Horizontal(i, j, (ushort)num, style);
							break;
						default:
							if (Main.tileAlch[num])
							{
								PlaceAlch(i, j, style);
								break;
							}
							switch (num)
							{
							case 94:
							case 95:
							case 97:
							case 98:
							case 99:
							case 100:
							case 125:
							case 126:
							case 172:
							case 173:
							case 287:
							case 751:
							case 752:
								Place2x2(i, j, (ushort)num, style);
								break;
							case 96:
								Place2x2Style(i, j, (ushort)num, style);
								break;
							case 79:
							case 90:
							{
								int direction = 1;
								if (plr > -1)
								{
									direction = Main.player[plr].direction;
								}
								Place4x2(i, j, (ushort)num, direction, style);
								break;
							}
							case 209:
								PlaceCannon(i, j, (ushort)num, style);
								break;
							case 81:
								tile.frameX = (short)(26 * genRand.Next(6));
								tile.active(active: true);
								tile.type = (ushort)num;
								break;
							case 19:
								tile.frameY = (short)(18 * style);
								tile.active(active: true);
								tile.type = (ushort)num;
								break;
							case 380:
								tile.frameY = (short)(18 * style);
								tile.active(active: true);
								tile.type = (ushort)num;
								break;
							case 314:
								Minecart.PlaceTrack(tile, style);
								break;
							default:
								tile.active(active: true);
								tile.type = (ushort)num;
								if (num == 53 || num == 396 || num == 397)
								{
									if (SpecialSeedFeatures.RainbowSandAndBlackSandWalls)
									{
										tile.color(GetRainbowPaintIDForPosition(i, j, wiggly: true));
									}
									else if (Main.tenthAnniversaryWorld && !Main.remixWorld && !Main.notTheBeesWorld && !Main.dontStarveWorld)
									{
										tile.color(7);
									}
								}
								break;
							}
							break;
						}
						break;
					}
				}
				if (tile.active())
				{
					if (TileID.Sets.TruncatesWalls[tile.type])
					{
						SquareWallFrame(i, j);
					}
					SquareTileFrame(i, j);
					result = true;
					if (!mute)
					{
						switch (num)
						{
						case 127:
							SoundEngine.PlaySound(SoundID.Item30, i * 16, j * 16);
							break;
						case 314:
							SoundEngine.PlaySound(SoundID.Item52, i * 16, j * 16);
							break;
						case 330:
						case 331:
						case 332:
						case 333:
							SoundEngine.PlaySound(18, i * 16, j * 16);
							break;
						default:
							SoundEngine.PlaySound(0, i * 16, j * 16);
							break;
						}
						if (num == 22 || num == 140)
						{
							for (int l = 0; l < 3; l++)
							{
								Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 14);
							}
						}
					}
				}
			}
		}
		return result;
	}

	private static bool ValidAnchorForMultiDirectionalTile(int x, int y, Tile tileCache, int direction)
	{
		if (tileCache != null && tileCache.type >= 0 && !TileID.Sets.Boulders[tileCache.type] && tileCache.type != 10)
		{
			if ((direction != 0 || !SolidTileAllowTopSlope(x, y)) && (direction != 1 || !SolidTileAllowBottomSlope(x, y)) && (direction != 2 || !SolidTileAllowLeftSlope(x, y)))
			{
				if (direction == 3)
				{
					return SolidTileAllowRightSlope(x, y);
				}
				return false;
			}
			return true;
		}
		return false;
	}

	public static bool CheckAndAdjustMultiDirectionalTile(int i, int j, int type, out int newFrameDirection)
	{
		newFrameDirection = 0;
		if (!InWorld(i, j, 2))
		{
			return false;
		}
		Tile tile = Main.tile[i, j - 1];
		Tile tile2 = Main.tile[i, j + 1];
		Tile tile3 = Main.tile[i - 1, j];
		Tile tile4 = Main.tile[i + 1, j];
		int num = -1;
		int num2 = -1;
		int num3 = -1;
		int num4 = -1;
		if (ValidAnchorForMultiDirectionalTile(i, j - 1, tile, 0))
		{
			num2 = tile.type;
		}
		if (ValidAnchorForMultiDirectionalTile(i, j + 1, tile2, 1))
		{
			num = tile2.type;
		}
		if (ValidAnchorForMultiDirectionalTile(i - 1, j, tile3, 2))
		{
			num3 = tile3.type;
		}
		if (ValidAnchorForMultiDirectionalTile(i + 1, j, tile4, 3))
		{
			num4 = tile4.type;
		}
		if (num >= 0 && Main.tileSolid[num] && !Main.tileSolidTop[num])
		{
			newFrameDirection = 0;
			return true;
		}
		if (num3 >= 0 && Main.tileSolid[num3] && !Main.tileSolidTop[num3])
		{
			newFrameDirection = 2;
			return true;
		}
		if (num4 >= 0 && Main.tileSolid[num4] && !Main.tileSolidTop[num4])
		{
			newFrameDirection = 3;
			return true;
		}
		if (num2 >= 0 && Main.tileSolid[num2] && !Main.tileSolidTop[num2])
		{
			newFrameDirection = 1;
			return true;
		}
		return false;
	}

	public static void KillWall(int i, int j, bool fail = false)
	{
		if (i < 0 || j < 0 || i >= Main.maxTilesX || j >= Main.maxTilesY)
		{
			return;
		}
		Tile tile = Main.tile[i, j];
		if (tile == null)
		{
			tile = new Tile();
			Main.tile[i, j] = tile;
		}
		if (tile.wall <= 0)
		{
			return;
		}
		fail = KillWall_CheckFailure(fail, tile);
		KillWall_PlaySounds(i, j, tile);
		int num = 10;
		if (fail)
		{
			num = 3;
		}
		for (int k = 0; k < num; k++)
		{
			KillWall_MakeWallDust(i, j, tile);
		}
		if (fail)
		{
			SquareWallFrame(i, j);
			return;
		}
		KillWall_DropItems(i, j, tile);
		tile.wall = 0;
		tile.ClearWallPaintAndCoating();
		SquareWallFrame(i, j);
		if (tile.type >= 0 && tile.type < TileID.Count && TileID.Sets.FramesOnKillWall[tile.type])
		{
			TileFrame(i, j);
		}
	}

	private static bool KillWall_CheckFailure(bool fail, Tile tileCache)
	{
		if (Main.wallDungeon[tileCache.wall] && !NPC.downedBoss3)
		{
			fail = true;
		}
		if (tileCache.wall == 87 && !NPC.downedGolemBoss)
		{
			fail = true;
		}
		return fail;
	}

	private static void KillWall_PlaySounds(int i, int j, Tile tileCache)
	{
		if (tileCache.wall == 241 || (tileCache.wall >= 88 && tileCache.wall <= 93) || tileCache.wall == 21 || tileCache.wall == 186 || tileCache.wall == 136 || tileCache.wall == 137 || tileCache.wall == 168 || tileCache.wall == 169 || tileCache.wall == 172 || tileCache.wall == 226 || tileCache.wall == 227 || tileCache.wall == 242 || tileCache.wall == 243 || tileCache.wall == 347 || tileCache.wall == 365)
		{
			SoundEngine.PlaySound(13, i * 16, j * 16);
		}
		else if ((tileCache.wall >= 63 && tileCache.wall <= 70) || tileCache.wall == 264 || tileCache.wall == 268 || tileCache.wall == 265)
		{
			SoundEngine.PlaySound(6, i * 16, j * 16);
		}
		else if (tileCache.wall == 357)
		{
			SoundEngine.PlaySound(SoundID.NPCHit25, i * 16, j * 16);
		}
		else
		{
			SoundEngine.PlaySound(0, i * 16, j * 16);
		}
	}

	private static void KillWall_DropItems(int i, int j, Tile tileCache)
	{
		int num = KillWall_GetItemDrops(tileCache);
		if (num > 0)
		{
			Item.NewItem(GetItemSource_FromWallBreak(i, j), i * 16, j * 16, 16, 16, num);
		}
	}

	private static int KillWall_GetItemDrops(Tile tileCache)
	{
		switch (tileCache.wall)
		{
		case 237:
			return 4233;
		case 238:
			return 4234;
		case 239:
			return 4235;
		case 240:
			return 4236;
		case 246:
			return 4486;
		case 247:
			return 4487;
		case 248:
			return 4488;
		case 249:
			return 4489;
		case 250:
			return 4490;
		case 251:
			return 4491;
		case 252:
			return 4492;
		case 253:
			return 4493;
		case 254:
			return 4494;
		case 255:
			return 4495;
		case 314:
			return 4647;
		case 256:
			return 4496;
		case 257:
			return 4497;
		case 258:
			return 4498;
		case 259:
			return 4499;
		case 260:
			return 4500;
		case 261:
			return 4501;
		case 262:
			return 4502;
		case 263:
			return 4503;
		case 264:
			return 4504;
		case 265:
			return 4505;
		case 266:
			return 4506;
		case 267:
			return 4507;
		case 268:
			return 4508;
		case 269:
			return 4509;
		case 270:
			return 4510;
		case 271:
			return 4511;
		case 274:
			return 4512;
		case 275:
			return 3273;
		case 276:
			return 4513;
		case 277:
			return 4514;
		case 278:
			return 4515;
		case 279:
			return 4516;
		case 280:
			return 4517;
		case 281:
			return 4518;
		case 282:
			return 4519;
		case 283:
			return 4520;
		case 284:
			return 4521;
		case 285:
			return 4522;
		case 286:
			return 4523;
		case 287:
			return 4524;
		case 288:
			return 4525;
		case 289:
			return 4526;
		case 290:
			return 4527;
		case 291:
			return 4528;
		case 292:
			return 4529;
		case 293:
			return 4530;
		case 294:
			return 4531;
		case 295:
			return 4532;
		case 296:
			return 4533;
		case 297:
			return 4534;
		case 298:
			return 4535;
		case 299:
			return 4536;
		case 300:
			return 4537;
		case 301:
			return 4538;
		case 302:
			return 4539;
		case 303:
			return 4540;
		case 304:
			return 3340;
		case 305:
			return 3341;
		case 306:
			return 3342;
		case 307:
			return 3343;
		case 308:
			return 3344;
		case 309:
			return 3345;
		case 310:
			return 3346;
		case 311:
			return 3348;
		default:
		{
			int result = 0;
			if (tileCache.wall == 168)
			{
				result = 2696;
			}
			if (tileCache.wall == 169)
			{
				result = 2698;
			}
			if (tileCache.wall == 226)
			{
				result = 3752;
			}
			if (tileCache.wall == 227)
			{
				result = 3753;
			}
			if (tileCache.wall == 228)
			{
				result = 3760;
			}
			if (tileCache.wall == 229)
			{
				result = 3761;
			}
			if (tileCache.wall == 230)
			{
				result = 3762;
			}
			if (tileCache.wall == 142)
			{
				result = 2263;
			}
			if (tileCache.wall == 143)
			{
				result = 2264;
			}
			if (tileCache.wall == 144)
			{
				result = 2271;
			}
			if (tileCache.wall == 149)
			{
				result = 2505;
			}
			if (tileCache.wall == 150)
			{
				result = 2507;
			}
			if (tileCache.wall == 151)
			{
				result = 2506;
			}
			if (tileCache.wall == 152)
			{
				result = 2508;
			}
			if (tileCache.wall == 316)
			{
				result = 5216;
			}
			if (tileCache.wall == 317)
			{
				result = 5217;
			}
			if (tileCache.wall == 245)
			{
				result = 4424;
			}
			if (tileCache.wall == 315)
			{
				result = 4667;
			}
			if (tileCache.wall == 1)
			{
				result = 26;
			}
			if (tileCache.wall == 4)
			{
				result = 93;
			}
			if (tileCache.wall == 5)
			{
				result = 130;
			}
			if (tileCache.wall == 6)
			{
				result = 132;
			}
			if (tileCache.wall == 7)
			{
				result = 135;
			}
			if (tileCache.wall == 8)
			{
				result = 138;
			}
			if (tileCache.wall == 9)
			{
				result = 140;
			}
			if (tileCache.wall == 10)
			{
				result = 142;
			}
			if (tileCache.wall == 11)
			{
				result = 144;
			}
			if (tileCache.wall == 12)
			{
				result = 146;
			}
			if (tileCache.wall == 14)
			{
				result = 330;
			}
			if (tileCache.wall == 224)
			{
				result = 3472;
			}
			if (tileCache.wall == 323)
			{
				result = 5409;
			}
			if (tileCache.wall == 324)
			{
				result = 5410;
			}
			if (tileCache.wall == 325)
			{
				result = 5411;
			}
			if (tileCache.wall == 326)
			{
				result = 5412;
			}
			if (tileCache.wall == 327)
			{
				result = 5413;
			}
			if (tileCache.wall == 328)
			{
				result = 5414;
			}
			if (tileCache.wall == 329)
			{
				result = 5415;
			}
			if (tileCache.wall == 330)
			{
				result = 5416;
			}
			if (tileCache.wall == 331)
			{
				result = 5418;
			}
			if (tileCache.wall == 332)
			{
				result = 5420;
			}
			if (tileCache.wall == 333)
			{
				result = 5422;
			}
			if (tileCache.wall == 334)
			{
				result = 5424;
			}
			if (tileCache.wall == 335)
			{
				result = 5426;
			}
			if (tileCache.wall == 336)
			{
				result = 5428;
			}
			if (tileCache.wall == 337)
			{
				result = 5434;
			}
			if (tileCache.wall == 338)
			{
				result = 5436;
			}
			if (tileCache.wall == 339)
			{
				result = 5430;
			}
			if (tileCache.wall == 340)
			{
				result = 5432;
			}
			if (tileCache.wall == 341)
			{
				result = 5445;
			}
			if (tileCache.wall == 342)
			{
				result = 5446;
			}
			if (tileCache.wall == 343)
			{
				result = 5447;
			}
			if (tileCache.wall == 344)
			{
				result = 5448;
			}
			if (tileCache.wall == 345)
			{
				result = 5449;
			}
			if (tileCache.wall == 346)
			{
				result = 5450;
			}
			if (tileCache.wall == 177)
			{
				result = 3067;
			}
			if (tileCache.wall == 167)
			{
				result = 2691;
			}
			if (tileCache.wall == 60)
			{
				result = 3584;
			}
			if (tileCache.wall == 231)
			{
				result = 3952;
			}
			if (tileCache.wall == 232)
			{
				result = 3954;
			}
			if (tileCache.wall == 225)
			{
				result = 3751;
			}
			if (tileCache.wall == 233)
			{
				result = 3956;
			}
			if (tileCache.wall == 234)
			{
				result = 4052;
			}
			if (tileCache.wall == 235)
			{
				result = 4053;
			}
			if (tileCache.wall == 236)
			{
				result = 4140;
			}
			if (tileCache.wall == 312)
			{
				result = 4565;
			}
			if (tileCache.wall == 313)
			{
				result = 4548;
			}
			if (tileCache.wall == 319)
			{
				result = 5307;
			}
			if (tileCache.wall == 318)
			{
				result = 5291;
			}
			if (tileCache.wall == 179)
			{
				result = 3083;
			}
			if (tileCache.wall == 183)
			{
				result = 3082;
			}
			if (tileCache.wall == 321)
			{
				result = 5397;
			}
			if (tileCache.wall == 322)
			{
				result = 5399;
			}
			if (tileCache.wall == 181)
			{
				result = 3089;
			}
			if (tileCache.wall == 184)
			{
				result = 3088;
			}
			if (tileCache.wall == 186)
			{
				result = 3238;
			}
			if (tileCache.wall == 320)
			{
				result = 5396;
			}
			if (tileCache.wall >= 153 && tileCache.wall <= 166)
			{
				switch (tileCache.wall)
				{
				case 154:
					result = 2679;
					break;
				case 158:
					result = 2680;
					break;
				case 166:
					result = 2689;
					break;
				case 163:
					result = 2690;
					break;
				case 165:
					result = 2687;
					break;
				case 162:
					result = 2688;
					break;
				case 156:
					result = 2683;
					break;
				case 160:
					result = 2684;
					break;
				case 164:
					result = 2685;
					break;
				case 161:
					result = 2686;
					break;
				case 155:
					result = 2681;
					break;
				case 159:
					result = 2682;
					break;
				case 153:
					result = 2677;
					break;
				case 157:
					result = 2678;
					break;
				}
			}
			if (tileCache.wall == 136)
			{
				result = 2169;
			}
			if (tileCache.wall == 137)
			{
				result = 2170;
			}
			if (tileCache.wall == 172)
			{
				result = 2788;
			}
			if (tileCache.wall == 242)
			{
				result = 4279;
			}
			if (tileCache.wall == 243)
			{
				result = 4280;
			}
			if (tileCache.wall == 347)
			{
				result = 5494;
			}
			if (tileCache.wall == 348)
			{
				result = 5623;
			}
			if (tileCache.wall == 351)
			{
				result = 5711;
			}
			if (tileCache.wall == 352)
			{
				result = 5734;
			}
			if (tileCache.wall == 353)
			{
				result = 5919;
			}
			if (tileCache.wall == 354)
			{
				result = 5921;
			}
			if (tileCache.wall == 355)
			{
				result = 5923;
			}
			if (tileCache.wall == 356)
			{
				result = 5925;
			}
			if (tileCache.wall == 357)
			{
				result = 5927;
			}
			if (tileCache.wall == 358)
			{
				result = 5931;
			}
			switch (tileCache.wall)
			{
			case 359:
				result = 5954;
				break;
			case 360:
				result = 5997;
				break;
			case 361:
				result = 6020;
				break;
			case 362:
				result = 6043;
				break;
			case 363:
				result = 6066;
				break;
			case 364:
				result = 6089;
				break;
			case 365:
				result = 6110;
				break;
			case 366:
				result = 6133;
				break;
			}
			if (tileCache.wall == 145)
			{
				result = 2333;
			}
			if (tileCache.wall == 16)
			{
				result = 30;
			}
			if (tileCache.wall == 17)
			{
				result = 135;
			}
			if (tileCache.wall == 18)
			{
				result = 138;
			}
			if (tileCache.wall == 19)
			{
				result = 140;
			}
			if (tileCache.wall == 20)
			{
				result = 330;
			}
			if (tileCache.wall == 21)
			{
				result = 392;
			}
			if (tileCache.wall == 86 || tileCache.wall == 108)
			{
				result = 1126;
			}
			if (tileCache.wall == 173)
			{
				result = 2789;
			}
			if (tileCache.wall == 174)
			{
				result = 2790;
			}
			if (tileCache.wall == 175)
			{
				result = 2791;
			}
			if (tileCache.wall == 176)
			{
				result = 2861;
			}
			if (tileCache.wall == 182)
			{
				result = 3101;
			}
			if (tileCache.wall == 133)
			{
				result = 2158;
			}
			if (tileCache.wall == 134)
			{
				result = 2159;
			}
			if (tileCache.wall == 135)
			{
				result = 2160;
			}
			else if (tileCache.wall == 113)
			{
				result = 1726;
			}
			else if (tileCache.wall == 114)
			{
				result = 1728;
			}
			else if (tileCache.wall == 115)
			{
				result = 1730;
			}
			else if (tileCache.wall == 146)
			{
				result = 2432;
			}
			else if (tileCache.wall == 147)
			{
				result = 2433;
			}
			else if (tileCache.wall == 148)
			{
				result = 2434;
			}
			if (tileCache.wall >= 116 && tileCache.wall <= 125)
			{
				result = 1948 + tileCache.wall - 116;
			}
			if (tileCache.wall >= 126 && tileCache.wall <= 132)
			{
				result = 2008 + tileCache.wall - 126;
			}
			if (tileCache.wall == 22)
			{
				result = 417;
			}
			if (tileCache.wall == 23)
			{
				result = 418;
			}
			if (tileCache.wall == 24)
			{
				result = 419;
			}
			if (tileCache.wall == 25)
			{
				result = 420;
			}
			if (tileCache.wall == 26)
			{
				result = 421;
			}
			if (tileCache.wall == 29)
			{
				result = 587;
			}
			if (tileCache.wall == 30)
			{
				result = 592;
			}
			if (tileCache.wall == 31)
			{
				result = 595;
			}
			if (tileCache.wall == 32)
			{
				result = 605;
			}
			if (tileCache.wall == 33)
			{
				result = 606;
			}
			if (tileCache.wall == 34)
			{
				result = 608;
			}
			if (tileCache.wall == 35)
			{
				result = 610;
			}
			if (tileCache.wall == 36)
			{
				result = 615;
			}
			if (tileCache.wall == 37)
			{
				result = 616;
			}
			if (tileCache.wall == 38)
			{
				result = 617;
			}
			if (tileCache.wall == 39)
			{
				result = 618;
			}
			if (tileCache.wall == 41)
			{
				result = 622;
			}
			if (tileCache.wall == 42)
			{
				result = 623;
			}
			if (tileCache.wall == 43)
			{
				result = 624;
			}
			if (tileCache.wall == 44)
			{
				result = 663;
			}
			if (tileCache.wall == 45)
			{
				result = 720;
			}
			if (tileCache.wall == 46)
			{
				result = 721;
			}
			if (tileCache.wall == 47)
			{
				result = 722;
			}
			if (tileCache.wall == 66)
			{
				result = 745;
			}
			if (tileCache.wall == 67)
			{
				result = 746;
			}
			if (tileCache.wall == 68)
			{
				result = 747;
			}
			if (tileCache.wall == 84)
			{
				result = 884;
			}
			if (tileCache.wall == 72)
			{
				result = 750;
			}
			if (tileCache.wall == 73)
			{
				result = 752;
			}
			if (tileCache.wall == 74)
			{
				result = 764;
			}
			if (tileCache.wall == 85)
			{
				result = 927;
			}
			if (tileCache.wall == 75)
			{
				result = 768;
			}
			if (tileCache.wall == 76)
			{
				result = 769;
			}
			if (tileCache.wall == 77)
			{
				result = 770;
			}
			if (tileCache.wall == 82)
			{
				result = 825;
			}
			if (tileCache.wall == 27)
			{
				result = 479;
			}
			if (tileCache.wall == 106)
			{
				result = 1447;
			}
			if (tileCache.wall == 107)
			{
				result = 1448;
			}
			if (tileCache.wall == 109)
			{
				result = 1590;
			}
			if (tileCache.wall == 110)
			{
				result = 1592;
			}
			if (tileCache.wall == 111)
			{
				result = 1594;
			}
			if (tileCache.wall == 78)
			{
				result = 1723;
			}
			if (tileCache.wall == 87 || tileCache.wall == 112)
			{
				result = 1102;
			}
			if (tileCache.wall == 94 || tileCache.wall == 100)
			{
				result = 1378;
			}
			if (tileCache.wall == 95 || tileCache.wall == 101)
			{
				result = 1379;
			}
			if (tileCache.wall == 96 || tileCache.wall == 102)
			{
				result = 1380;
			}
			if (tileCache.wall == 97 || tileCache.wall == 103)
			{
				result = 1381;
			}
			if (tileCache.wall == 98 || tileCache.wall == 104)
			{
				result = 1382;
			}
			if (tileCache.wall == 99 || tileCache.wall == 105)
			{
				result = 1383;
			}
			if (tileCache.wall == 241)
			{
				result = 4260;
			}
			if (tileCache.wall >= 88 && tileCache.wall <= 93)
			{
				result = 1267 + tileCache.wall - 88;
			}
			if (tileCache.wall >= 138 && tileCache.wall <= 141)
			{
				result = 2210 + tileCache.wall - 138;
			}
			return result;
		}
		}
	}

	private static void KillWall_MakeWallDust(int i, int j, Tile tileCache)
	{
		int num = 0;
		switch (tileCache.wall)
		{
		case 366:
			num = 1;
			break;
		case 365:
			num = 13;
			break;
		case 364:
			num = 10;
			break;
		case 363:
			num = 148;
			break;
		case 362:
			num = 26;
			break;
		case 361:
			num = 78;
			break;
		case 360:
			num = 236;
			break;
		case 359:
			num = 96;
			break;
		case 358:
			num = 78;
			break;
		case 353:
			num = 196;
			break;
		case 357:
			num = 68;
			break;
		case 352:
			num = 10;
			break;
		case 354:
			num = 277;
			break;
		case 355:
			num = 26;
			break;
		case 356:
			num = 277;
			break;
		case 351:
			num = 0;
			break;
		case 348:
			num = 57;
			break;
		case 316:
		case 317:
			num = 36;
			break;
		case 7:
		case 17:
		case 94:
		case 95:
		case 100:
		case 101:
		case 331:
			num = 275;
			break;
		case 8:
		case 18:
		case 98:
		case 99:
		case 104:
		case 105:
		case 332:
			num = 276;
			break;
		case 9:
		case 19:
		case 96:
		case 97:
		case 102:
		case 103:
		case 333:
			num = 277;
			break;
		case 232:
			num = 82;
			break;
		case 231:
			num = 8;
			break;
		case 233:
			num = 18;
			break;
		case 237:
			num = 6;
			break;
		case 238:
			num = 61;
			break;
		case 239:
			num = 242;
			break;
		case 240:
			num = 135;
			break;
		case 3:
		case 246:
			num = ((genRand.Next(2) != 0) ? 1 : 14);
			break;
		case 15:
		case 247:
			num = 38;
			break;
		case 22:
		case 28:
		case 248:
			num = 51;
			break;
		case 40:
		case 249:
			num = 51;
			break;
		case 48:
		case 49:
		case 50:
		case 51:
		case 52:
		case 53:
		case 54:
		case 55:
		case 56:
		case 57:
		case 58:
		case 185:
		case 250:
		case 251:
		case 252:
		case 253:
		case 254:
		case 255:
		case 256:
		case 257:
		case 258:
		case 259:
		case 260:
		case 274:
		case 314:
			num = 1;
			break;
		case 59:
		case 61:
		case 261:
		case 262:
			num = 0;
			break;
		case 62:
		case 263:
			num = 0;
			break;
		case 69:
		case 264:
			num = ((genRand.Next(2) != 0) ? 17 : 14);
			break;
		case 70:
		case 265:
			num = 47;
			break;
		case 71:
		case 266:
			num = 80;
			break;
		case 79:
		case 267:
			num = 37;
			break;
		case 81:
		case 268:
			num = 123;
			break;
		case 83:
		case 234:
		case 269:
			num = ((genRand.Next(2) == 0) ? 1 : 117);
			break;
		case 170:
		case 171:
		case 270:
		case 271:
			num = 0;
			break;
		case 187:
		case 275:
			num = 0;
			break;
		case 188:
		case 189:
		case 190:
		case 191:
		case 276:
		case 277:
		case 278:
		case 279:
			num = 37;
			break;
		case 192:
		case 193:
		case 194:
		case 195:
		case 280:
		case 281:
		case 282:
		case 283:
			num = 117;
			break;
		case 196:
		case 197:
		case 198:
		case 199:
		case 284:
		case 285:
		case 286:
		case 287:
			num = 0;
			break;
		case 200:
		case 202:
		case 288:
		case 290:
			num = ((genRand.Next(2) != 0) ? 70 : 69);
			break;
		case 201:
		case 289:
			num = 17;
			break;
		case 203:
		case 291:
			num = ((genRand.Next(2) != 0) ? 68 : 69);
			break;
		case 204:
		case 205:
		case 207:
		case 292:
		case 293:
		case 295:
			num = 0;
			break;
		case 206:
		case 294:
			num = 1;
			break;
		case 208:
		case 209:
		case 210:
		case 211:
		case 296:
		case 297:
		case 298:
		case 299:
			num = ((genRand.Next(2) != 0) ? 125 : 155);
			break;
		case 212:
		case 213:
		case 214:
		case 215:
		case 300:
		case 301:
		case 302:
		case 303:
			num = 1;
			break;
		case 216:
		case 304:
			num = 0;
			break;
		case 217:
		case 305:
			num = 37;
			break;
		case 218:
		case 306:
			num = 155;
			break;
		case 219:
		case 307:
			num = 17;
			break;
		case 220:
		case 308:
			num = 37;
			break;
		case 221:
		case 309:
			num = 155;
			break;
		case 222:
		case 310:
			num = 37;
			break;
		case 223:
		case 311:
			num = 0;
			break;
		case 312:
		case 313:
		case 315:
			num = -1;
			break;
		}
		if (tileCache.wall == 148)
		{
			num = -1;
		}
		if (tileCache.wall == 1 || tileCache.wall == 5 || tileCache.wall == 6 || tileCache.wall == 107 || tileCache.wall == 349)
		{
			num = 1;
		}
		if (tileCache.wall == 35)
		{
			num = 37;
		}
		if (tileCache.wall == 4 || tileCache.wall == 106)
		{
			num = 7;
		}
		if (tileCache.wall == 12)
		{
			num = 9;
		}
		if (tileCache.wall == 336)
		{
			num = 9;
		}
		if (tileCache.wall == 10)
		{
			num = 10;
		}
		if (tileCache.wall == 334)
		{
			num = 10;
		}
		if (tileCache.wall == 11)
		{
			num = 11;
		}
		if (tileCache.wall == 335)
		{
			num = 11;
		}
		if (tileCache.wall == 21)
		{
			num = 13;
		}
		if (tileCache.wall == 34)
		{
			num = 32;
		}
		if (tileCache.wall == 225)
		{
			num = 1;
		}
		if (tileCache.wall == 145)
		{
			num = 8;
		}
		if (tileCache.wall == 23)
		{
			num = 38;
		}
		if (tileCache.wall == 24)
		{
			num = 36;
		}
		if (tileCache.wall == 25 || tileCache.wall == 339)
		{
			num = 48;
		}
		if (tileCache.wall == 179 || tileCache.wall == 178 || tileCache.wall == 183)
		{
			num = 236;
		}
		if (tileCache.wall == 181 || tileCache.wall == 180 || tileCache.wall == 184)
		{
			num = 240;
		}
		if (tileCache.wall == 113)
		{
			num = 189;
		}
		if (tileCache.wall == 114)
		{
			num = 190;
		}
		if (tileCache.wall == 115)
		{
			num = 191;
		}
		if (tileCache.wall == 177 || tileCache.wall == 13 || tileCache.wall == 338)
		{
			num = 25;
		}
		if (tileCache.wall == 186)
		{
			num = genRand.Next(68, 71);
		}
		if (tileCache.wall == 319)
		{
			num = 171;
		}
		if (tileCache.wall == 321)
		{
			num = 308;
		}
		if (tileCache.wall == 322)
		{
			num = 308;
		}
		if (tileCache.wall == 318)
		{
			num = 226;
		}
		if (tileCache.wall == 142)
		{
			num = 210;
		}
		if (tileCache.wall == 143)
		{
			num = 210;
		}
		if (tileCache.wall == 224)
		{
			num = 265;
		}
		if (tileCache.wall == 323)
		{
			num = 314;
		}
		if (tileCache.wall == 324)
		{
			num = 315;
		}
		if (tileCache.wall == 325)
		{
			num = 316;
		}
		if (tileCache.wall == 326)
		{
			num = 317;
		}
		if (tileCache.wall == 327)
		{
			num = 318;
		}
		if (tileCache.wall == 328)
		{
			num = 319;
		}
		if (tileCache.wall == 329)
		{
			num = 320;
		}
		if (tileCache.wall == 330)
		{
			num = 321;
		}
		if (tileCache.wall == 320)
		{
			num = 0;
		}
		if (tileCache.wall == 341)
		{
			num = 258;
		}
		if (tileCache.wall == 342)
		{
			num = 301;
		}
		if (tileCache.wall == 343)
		{
			num = 299;
		}
		if (tileCache.wall == 344)
		{
			num = 300;
		}
		if (tileCache.wall == 345)
		{
			num = 305;
		}
		if (tileCache.wall == 173)
		{
			num = 128;
		}
		if (tileCache.wall == 174)
		{
			num = 117;
		}
		if (tileCache.wall == 175)
		{
			num = 42;
		}
		if (tileCache.wall == 176)
		{
			num = 226;
		}
		if (tileCache.wall == 182)
		{
			num = ((genRand.Next(2) != 0) ? 23 : 6);
		}
		if (tileCache.wall >= 153 && tileCache.wall <= 166)
		{
			switch (tileCache.wall)
			{
			case 154:
			case 158:
				num = 86;
				break;
			case 163:
			case 166:
				num = 87;
				break;
			case 162:
			case 165:
				num = 88;
				break;
			case 156:
			case 160:
				num = 89;
				break;
			case 161:
			case 164:
				num = 90;
				break;
			case 155:
			case 159:
				num = 91;
				break;
			case 153:
			case 157:
				num = 138;
				break;
			}
		}
		if (tileCache.wall == 26 || tileCache.wall == 30 || tileCache.wall == 340)
		{
			num = 49;
		}
		if (tileCache.wall == 29 || tileCache.wall == 32)
		{
			num = 50;
		}
		if (tileCache.wall == 31)
		{
			num = 51;
		}
		if (tileCache.wall == 14 || tileCache.wall == 20 || tileCache.wall == 337)
		{
			num = 109;
		}
		if (tileCache.wall == 241)
		{
			num = 286;
		}
		if (tileCache.wall >= 88 && tileCache.wall <= 93)
		{
			num = 86 + tileCache.wall - 88;
			if (tileCache.wall == 93)
			{
				num = genRand.Next(88, 94);
			}
		}
		if (tileCache.wall == 33)
		{
			num = 14;
		}
		if (tileCache.wall == 41)
		{
			num = 77;
		}
		if (tileCache.wall == 42)
		{
			num = 78;
		}
		if (tileCache.wall == 43)
		{
			num = 78;
		}
		if (tileCache.wall == 36)
		{
			num = 26;
		}
		if (tileCache.wall == 37)
		{
			num = 32;
		}
		if (tileCache.wall == 38)
		{
			num = 2;
		}
		if (tileCache.wall == 39)
		{
			num = 1;
		}
		if (tileCache.wall == 45)
		{
			num = 81;
		}
		if (tileCache.wall == 46)
		{
			num = 83;
		}
		if (tileCache.wall == 47)
		{
			num = 84;
		}
		if (tileCache.wall == 85)
		{
			num = 126;
		}
		if (tileCache.wall == 63)
		{
			num = 3;
		}
		if (tileCache.wall == 65)
		{
			num = 3;
		}
		if (tileCache.wall == 66)
		{
			num = 3;
		}
		if (tileCache.wall == 68)
		{
			num = 3;
		}
		if (tileCache.wall == 64)
		{
			num = 40;
		}
		if (tileCache.wall == 67)
		{
			num = 40;
		}
		if (tileCache.wall == 84)
		{
			num = 80;
		}
		if (tileCache.wall == 60)
		{
			num = 3;
		}
		if (tileCache.wall == 167)
		{
			num = 81;
		}
		if (tileCache.wall == 147)
		{
			num = 51;
		}
		if (tileCache.wall == 146)
		{
			num = 9;
		}
		if (tileCache.wall == 109)
		{
			num = 144;
		}
		if (tileCache.wall == 110)
		{
			num = 145;
		}
		if (tileCache.wall == 111)
		{
			num = 146;
		}
		if (tileCache.wall == 86 || tileCache.wall == 108)
		{
			num = 147;
		}
		if (tileCache.wall == 87)
		{
			num = 148;
		}
		if (tileCache.wall == 136)
		{
			num = 13;
		}
		if (tileCache.wall == 137)
		{
			num = 13;
		}
		if (tileCache.wall == 168)
		{
			num = 13;
		}
		if (tileCache.wall == 169)
		{
			num = 13;
		}
		if (tileCache.wall == 172)
		{
			num = 13;
		}
		if (tileCache.wall == 226)
		{
			num = 13;
		}
		if (tileCache.wall == 227)
		{
			num = 13;
		}
		if (tileCache.wall == 347)
		{
			num = 13;
		}
		if (tileCache.wall == 242)
		{
			num = 13;
		}
		if (tileCache.wall == 243)
		{
			num = 13;
		}
		if (tileCache.wall == 72)
		{
			num = 40;
		}
		if (tileCache.wall == 73)
		{
			num = 16;
		}
		if (tileCache.wall == 74 || tileCache.wall == 80)
		{
			num = 26;
		}
		if (tileCache.wall == 144)
		{
			num = ((genRand.Next(2) != 0) ? 118 : 10);
		}
		if (tileCache.wall == 75)
		{
			num = 26;
		}
		if (tileCache.wall == 76)
		{
			num = 4;
		}
		if (tileCache.wall == 77 || tileCache.wall == 81)
		{
			num = 5;
		}
		if (tileCache.wall == 78 || tileCache.wall == 244)
		{
			num = 7;
		}
		if (tileCache.wall == 82)
		{
			num = 36;
		}
		if (tileCache.wall == 27)
		{
			num = ((genRand.Next(2) != 0) ? 1 : 7);
		}
		if (tileCache.wall == 138)
		{
			num = 77;
		}
		if (tileCache.wall == 139)
		{
			num = 78;
		}
		if (tileCache.wall == 140)
		{
			num = 79;
		}
		if (tileCache.wall == 141)
		{
			num = 126;
		}
		if (tileCache.wall == 149 || tileCache.wall == 150)
		{
			num = 214;
		}
		if (tileCache.wall == 151 || tileCache.wall == 152)
		{
			num = 215;
		}
		if (tileCache.wall == 245)
		{
			num = 195;
		}
		if (tileCache.wall == 348)
		{
			Main.dust[Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num)].velocity *= 0.4f;
		}
		else if (tileCache.wall == 44 || tileCache.wall == 346)
		{
			int num2 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 66, 0f, 0f, 100, new Color(Main.DiscoR, Main.DiscoG, Main.DiscoB), 0.75f);
			Main.dust[num2].noGravity = true;
		}
		else if ((tileCache.wall < 133 || tileCache.wall > 135) && (tileCache.wall < 116 || tileCache.wall > 125) && (tileCache.wall < 126 || tileCache.wall > 132))
		{
			if (tileCache.wall == 76)
			{
				Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num, 0f, 0f, 75, new Color(0, 80, 255, 100), 0.75f);
			}
			else if (num >= 0)
			{
				Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num);
			}
		}
	}

	public static void LaunchRocket(int x, int y, bool fromWiring)
	{
		int num = Main.tile[x, y].frameY;
		int num2 = 0;
		while (num >= 40)
		{
			num -= 40;
			num2++;
		}
		if (num == 18)
		{
			y--;
		}
		Vector2 vector = new Vector2(x * 16 + 8, y * 16 + 4);
		int type = 167 + num2;
		int damage = 150;
		int num3 = 7;
		int num4 = Projectile.NewProjectile(GetProjectileSource_PlayerOrWires(x, y, fromWiring, Main.LocalPlayer), vector.X, vector.Y + 2f, 0f, -8f, type, damage, num3, Main.myPlayer);
		Main.projectile[num4].originatedFromActivableTile = true;
		Main.tile[x, y].active(active: false);
		Main.tile[x, y + 1].active(active: false);
		NetMessage.SendTileSquare(-1, x, y, 1, 2);
	}

	public static void LaunchRocketSmall(int x, int y, bool fromWiring)
	{
		if (Main.tile[x, y].frameX == 18)
		{
			x--;
		}
		if (Main.tile[x, y].frameY == 18)
		{
			y--;
		}
		Vector2 vector = new Vector2(x * 16 + 16, y * 16);
		int type = 415 + Main.rand.Next(4);
		int damage = 0;
		int num = 0;
		int num2 = Projectile.NewProjectile(GetProjectileSource_PlayerOrWires(x, y, fromWiring, Main.LocalPlayer), vector.X, vector.Y + 2f, 0f, -8f, type, damage, num, Main.myPlayer);
		Main.projectile[num2].originatedFromActivableTile = true;
	}

	public static bool CanKillTile(int i, int j, SpecialKillTileContext context)
	{
		if (context == SpecialKillTileContext.MowingTheGrass)
		{
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				return false;
			}
			if (tile.type == 2 || tile.type == 109)
			{
				return true;
			}
		}
		return CanKillTile(i, j);
	}

	public static bool CanKillTile(int i, int j)
	{
		bool blockDamaged;
		return CanKillTile(i, j, out blockDamaged);
	}

	public static bool CanKillTile(int i, int j, out bool blockDamaged)
	{
		blockDamaged = false;
		if (i < 0 || j < 0 || i >= Main.maxTilesX || j >= Main.maxTilesY)
		{
			return false;
		}
		Tile tile = Main.tile[i, j];
		Tile tile2 = null;
		if (tile == null)
		{
			return false;
		}
		if (!tile.active())
		{
			return false;
		}
		if (tile.wall == 350)
		{
			return false;
		}
		if (j >= 1)
		{
			tile2 = Main.tile[i, j - 1];
		}
		if (tile2 != null && tile2.active())
		{
			int type = tile2.type;
			if (TileID.Sets.IsATreeTrunk[type] && tile.type != type && (tile2.frameX != 66 || tile2.frameY < 0 || tile2.frameY > 44) && (tile2.frameX != 88 || tile2.frameY < 66 || tile2.frameY > 110) && tile2.frameY < 198)
			{
				return false;
			}
			switch (type)
			{
			case 323:
				if (tile.type != type && (tile2.frameX == 66 || tile2.frameX == 220))
				{
					return false;
				}
				break;
			case 21:
			case 26:
			case 72:
			case 77:
			case 88:
			case 467:
			case 488:
				if (tile.type != type)
				{
					return false;
				}
				break;
			case 80:
				if (tile.type != type)
				{
					int num = tile2.frameX / 18;
					if ((uint)num <= 1u || (uint)(num - 4) <= 1u)
					{
						return false;
					}
				}
				break;
			}
		}
		if (TileID.Sets.Boulders[tile.type] && CheckBoulderChest(i, j))
		{
			blockDamaged = true;
			return false;
		}
		switch (tile.type)
		{
		case 10:
			if (IsLockedDoor(tile))
			{
				blockDamaged = true;
				return false;
			}
			break;
		case 235:
		{
			int num2 = i - tile.frameX % 54 / 18;
			for (int k = 0; k < 3; k++)
			{
				Tile tile3 = Main.tile[num2 + k, j - 1];
				if (tile3.active() && CheckTileBreakability_HasReasonToReturnEarly(tile.type, tile3, scanForContainer: true))
				{
					blockDamaged = true;
					return false;
				}
			}
			break;
		}
		case 21:
		case 467:
			if (!Chest.CanDestroyChest(i - tile.frameX / 18 % 2, j - tile.frameY / 18))
			{
				return false;
			}
			break;
		case 88:
			if (!Chest.CanDestroyChest(i - tile.frameX / 18 % 3, j - tile.frameY / 18))
			{
				return false;
			}
			break;
		}
		return true;
	}

	public static bool IsTileReplacable(int x, int y)
	{
		Tile tile = Main.tile[x, y];
		if (y >= 1)
		{
			Tile tile2 = Main.tile[x, y - 1];
			if (tile == null || tile2 == null)
			{
				return false;
			}
			if (tile2.active())
			{
				if (tile2.type == 80)
				{
					return false;
				}
				if (tile2.type == 488)
				{
					return false;
				}
				if (TileID.Sets.PreventsTileReplaceIfOnTopOfIt[tile2.type] && tile.type != tile2.type)
				{
					if (TileID.Sets.IsATreeTrunk[tile2.type])
					{
						if ((tile2.frameX == 66 && tile2.frameY >= 0 && tile2.frameY <= 44) || (tile2.frameX == 88 && tile2.frameY >= 66 && tile2.frameY <= 110) || tile2.frameY >= 198)
						{
							return true;
						}
						return false;
					}
					if (tile2.type == 323)
					{
						if (tile2.frameX == 66 || tile2.frameX == 220)
						{
							return false;
						}
						return true;
					}
					return false;
				}
			}
		}
		return true;
	}

	public static int CheckTileBreakability(int x, int y)
	{
		if (Main.tile[x, y] == null)
		{
			Main.tile[x, y] = new Tile();
		}
		Tile tile = Main.tile[x, y];
		if (y >= 1 && y <= Main.maxTilesY - 1)
		{
			if (Main.tile[x, y - 1] == null)
			{
				Main.tile[x, y - 1] = new Tile();
			}
			if (Main.tile[x, y + 1] == null)
			{
				Main.tile[x, y + 1] = new Tile();
			}
			Tile tile2 = Main.tile[x, y - 1];
			Tile tile3 = Main.tile[x, y + 1];
			if (tile3 != null && tile3.active() && IsLockedDoor(tile3))
			{
				return 2;
			}
			if (!Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type])
			{
				return 0;
			}
			if (tile2.active())
			{
				bool flag = IsAContainer(tile);
				if (CheckTileBreakability_HasReasonToReturnEarly(tile.type, tile2, !flag))
				{
					if (TileID.Sets.IsATreeTrunk[tile2.type])
					{
						if ((tile2.frameX == 66 && tile2.frameY >= 0 && tile2.frameY <= 44) || (tile2.frameX == 88 && tile2.frameY >= 66 && tile2.frameY <= 110) || tile2.frameY >= 198)
						{
							return 0;
						}
						return 2;
					}
					if (tile2.type == 323)
					{
						if (tile2.frameX == 66 || tile2.frameX == 220)
						{
							return 2;
						}
						return 0;
					}
					return 2;
				}
				if (tile2.type == 80 && tile2.type != tile.type)
				{
					int num = tile2.frameX / 18;
					if ((uint)num <= 1u || (uint)(num - 4) <= 1u)
					{
						return 2;
					}
				}
				if (tile.type == 10 && IsLockedDoor(tile))
				{
					return 1;
				}
				if (TileID.Sets.Boulders[tile.type])
				{
					if (CheckBoulderChest(x, y))
					{
						return 1;
					}
					return 0;
				}
			}
			if (tile.type == 235)
			{
				int frameX = tile.frameX;
				int num2 = x - frameX % 54 / 18;
				for (int i = 0; i < 3; i++)
				{
					Tile tile4 = Main.tile[num2 + i, y - 1];
					if (tile4.active() && CheckTileBreakability_HasReasonToReturnEarly(tile.type, tile4, scanForContainer: true))
					{
						return 2;
					}
				}
			}
		}
		return 0;
	}

	private static bool CheckTileBreakability_HasReasonToReturnEarly(int ignoreType, Tile target, bool scanForContainer)
	{
		if (ignoreType != target.type)
		{
			if (target.type == 77 && !Main.hardMode)
			{
				return true;
			}
			if (TileID.Sets.PreventsTileRemovalIfOnTopOfIt[target.type])
			{
				return true;
			}
		}
		if (IsLockedDoor(target))
		{
			return true;
		}
		if (scanForContainer && IsAContainer(target))
		{
			return true;
		}
		return false;
	}

	public static bool CheckTileBreakability2_ShouldTileSurvive(int x, int y)
	{
		if (Main.netMode == 1)
		{
			return false;
		}
		if (Main.tile[x, y] == null)
		{
			Main.tile[x, y] = new Tile();
		}
		Tile tile = Main.tile[x, y];
		if (TileID.Sets.BasicChest[tile.type])
		{
			int num = tile.frameX / 18;
			int y2 = y - tile.frameY / 18;
			while (num > 1)
			{
				num -= 2;
			}
			num = x - num;
			if (!Chest.DestroyChest(num, y2))
			{
				return true;
			}
		}
		if (tile.type == 88)
		{
			int num2 = tile.frameX / 18;
			int y3 = y - tile.frameY / 18;
			num2 %= 3;
			num2 = x - num2;
			if (!Chest.DestroyChest(num2, y3))
			{
				return true;
			}
		}
		if (tile.type == 470)
		{
			return !TEDisplayDoll.IsBreakable(x, y);
		}
		if (tile.type == 475)
		{
			return !TEHatRack.IsBreakable(x, y);
		}
		return false;
	}

	public static bool ReplaceWall(int x, int y, ushort targetWall)
	{
		if (targetWall >= WallID.Count)
		{
			return false;
		}
		Tile tile = Main.tile[x, y];
		if (tile.wall == 0 || targetWall == 0 || tile.wall == 350)
		{
			return false;
		}
		if (KillWall_CheckFailure(fail: false, tile))
		{
			return false;
		}
		int num = 10;
		for (int i = 0; i < num; i++)
		{
			KillWall_MakeWallDust(x, y, tile);
		}
		KillWall_PlaySounds(x, y, tile);
		KillWall_DropItems(x, y, tile);
		tile.wall = targetWall;
		tile.ClearWallPaintAndCoating();
		SquareWallFrame(x, y);
		return true;
	}

	public static bool ReplaceTile(int x, int y, int targetType, int targetStyle)
	{
		Tile tileSafely = Framing.GetTileSafely(x, y);
		if (!WouldTileReplacementWork(targetType, x, y))
		{
			return false;
		}
		if (!IsTileReplacable(x, y))
		{
			return false;
		}
		MoveReplaceTileAnchor(ref x, ref y, targetType, tileSafely);
		int num = KillTile_GetTileDustAmount(fail: false, tileSafely);
		for (int i = 0; i < num; i++)
		{
			KillTile_MakeTileDust(x, y, tileSafely);
		}
		KillTile_PlaySounds(x, y, fail: false, tileSafely);
		KillTile_DropItems(x, y, tileSafely, includeLargeObjectDrops: true);
		AttemptFossilShattering(x, y, tileSafely, fail: false);
		ReplaceTile_DoActualReplacement(targetType, targetStyle, x, y, tileSafely);
		return true;
	}

	private static void ReplaceTile_DoActualReplacement(int targetType, int targetStyle, int topLeftX, int topLeftY, Tile t)
	{
		if (TileID.Sets.BasicChest[targetType])
		{
			if (IsChestRigged(topLeftX, topLeftY) && Main.netMode != 1)
			{
				Wiring.HitSwitch(topLeftX, topLeftY);
				NetMessage.SendData(59, -1, -1, null, topLeftX, topLeftY);
			}
			ReplaceTile_DoActualReplacement_Area(targetType, targetStyle, topLeftX, topLeftY, 2, 2);
		}
		else if (TileID.Sets.BasicDresser[targetType])
		{
			ReplaceTile_DoActualReplacement_Area(targetType, targetStyle, topLeftX, topLeftY, 3, 2);
		}
		else if (TileID.Sets.Campfires[targetType])
		{
			bool flag = t.frameY >= 36;
			ReplaceTile_DoActualReplacement_Area(targetType, targetStyle, topLeftX, topLeftY, 3, 2, 0, flag ? 36 : 0);
		}
		else
		{
			ReplaceTile_DoActualReplacement_Single(targetType, targetStyle, topLeftX, topLeftY, t);
		}
	}

	private static void ReplaceTile_DoActualReplacement_Single(int targetType, int targetStyle, int topLeftX, int topLeftY, Tile t)
	{
		ReplaceTile_EliminateNaturalExtras(topLeftX, topLeftY);
		int type = t.type;
		t.type = (ushort)targetType;
		if (TileID.Sets.Platforms[t.type] || t.type == 380)
		{
			t.frameY = (short)(targetStyle * 18);
		}
		if (TileID.Sets.Torches[t.type])
		{
			t.frameY = (short)(targetStyle * 22);
		}
		t.ClearBlockPaintAndCoating();
		bool flag = !CanPoundTile(topLeftX, topLeftY);
		if (TileID.Sets.Platforms[type] && TileID.Sets.Platforms[t.type])
		{
			flag = false;
		}
		if (flag)
		{
			t.slope(0);
			t.halfBrick(halfBrick: false);
		}
		if (t.type == 53 || t.type == 396 || t.type == 397)
		{
			if (SpecialSeedFeatures.RainbowSandAndBlackSandWalls)
			{
				t.color(GetRainbowPaintIDForPosition(topLeftX, topLeftY, wiggly: true));
			}
			else if (Main.tenthAnniversaryWorld && !Main.remixWorld && !Main.notTheBeesWorld && !Main.dontStarveWorld)
			{
				t.color(7);
			}
		}
		if (TileID.Sets.TruncatesWalls[targetType] != TileID.Sets.TruncatesWalls[type])
		{
			SquareWallFrame(topLeftX, topLeftY);
		}
		SquareTileFrame(topLeftX, topLeftY);
	}

	private static void ReplaceTile_EliminateNaturalExtras(int x, int y)
	{
		if (InWorld(x, y, 2))
		{
			if (Main.tile[x, y - 1] != null && Main.tile[x, y - 1].active() && (TileID.Sets.ReplaceTileBreakUp[Main.tile[x, y - 1].type] || (Main.tile[x, y - 1].type == 165 && (Main.tile[x, y - 1].frameY == 36 || Main.tile[x, y - 1].frameY == 54 || Main.tile[x, y - 1].frameY == 90))))
			{
				KillTile(x, y - 1);
			}
			if (Main.tile[x, y + 1] != null && Main.tile[x, y + 1].active() && (TileID.Sets.ReplaceTileBreakDown[Main.tile[x, y + 1].type] || (Main.tile[x, y + 1].type == 165 && (Main.tile[x, y + 1].frameY == 0 || Main.tile[x, y + 1].frameY == 18 || Main.tile[x, y + 1].frameY == 72))))
			{
				KillTile(x, y + 1);
			}
		}
	}

	private static void ReplaceTile_DoActualReplacement_Area(int targetType, int targetStyle, int topLeftX, int topLeftY, int areaSizeX, int areaSizeY, int frameOffsetX = 0, int frameOffsetY = 0)
	{
		for (int i = 0; i < areaSizeX; i++)
		{
			for (int j = 0; j < areaSizeY; j++)
			{
				Tile tile = Main.tile[topLeftX + i, topLeftY + j];
				tile.type = (ushort)targetType;
				tile.frameX = (short)(targetStyle * (areaSizeX * 18) + i * 18 + frameOffsetX);
				tile.frameY = (short)(j * 18 + frameOffsetY);
				tile.ClearBlockPaintAndCoating();
			}
		}
		for (int k = 0; k < areaSizeX; k++)
		{
			for (int l = 0; l < areaSizeY; l++)
			{
				SquareTileFrame(topLeftX + k, topLeftY + l);
			}
		}
	}

	private static void MoveReplaceTileAnchor(ref int x, ref int y, int targetType, Tile t)
	{
		if (TileID.Sets.BasicChest[t.type])
		{
			x -= t.frameX % 36 / 18;
			y -= t.frameY % 36 / 18;
		}
		if (TileID.Sets.BasicDresser[t.type])
		{
			x -= t.frameX % 54 / 18;
			y -= t.frameY % 36 / 18;
		}
		if (TileID.Sets.Campfires[t.type])
		{
			x -= t.frameX % 54 / 18;
			y -= t.frameY % 36 / 18;
		}
	}

	public static bool WouldTileReplacementWork(int attemptingToReplaceWith, int x, int y)
	{
		Tile tile = Main.tile[x, y];
		if (attemptingToReplaceWith >= TileID.Count)
		{
			return false;
		}
		if (TileID.Sets.Conversion.Grass[attemptingToReplaceWith] || attemptingToReplaceWith == 633)
		{
			return false;
		}
		if (Main.tileRope[tile.type] && InWorld(x, y, 2))
		{
			Tile tile2 = Main.tile[x - 1, y];
			Tile tile3 = Main.tile[x + 1, y];
			if (attemptingToReplaceWith == 314 && tile2 != null && tile3 != null && ((tile2.active() && tile2.type == 314) || (tile3.active() && tile3.type == 314)))
			{
				return true;
			}
			if (TileID.Sets.Platforms[attemptingToReplaceWith] && tile2 != null && tile3 != null && ((tile2.active() && TileID.Sets.Platforms[tile2.type]) || (tile3.active() && TileID.Sets.Platforms[tile3.type])))
			{
				return true;
			}
			if (attemptingToReplaceWith == 380 && tile2 != null && tile3 != null && ((tile2.active() && tile2.type == 380) || (tile3.active() && tile3.type == 380)))
			{
				return true;
			}
		}
		bool flag = !ReplaceTile_IsValidSolid(attemptingToReplaceWith) || !ReplaceTile_IsValidSolid(tile.type);
		bool flag2 = !ReplaceTile_IsValidTorch(attemptingToReplaceWith) || !ReplaceTile_IsValidTorch(tile.type);
		bool flag3 = !ReplaceTile_IsValidCampfire(attemptingToReplaceWith) || !ReplaceTile_IsValidCampfire(tile.type);
		bool num = !ReplaceTile_IsValidPlatform(attemptingToReplaceWith) || !ReplaceTile_IsValidPlatform(tile.type);
		bool flag4 = (!ReplaceTile_IsValidSolid(attemptingToReplaceWith) && !ReplaceTile_IsValidPlatform(attemptingToReplaceWith)) || (!ReplaceTile_IsValidSolid(tile.type) && !ReplaceTile_IsValidPlatform(tile.type));
		bool flag5 = !ReplaceTile_IsValidChest(attemptingToReplaceWith) || !ReplaceTile_IsValidChest(tile.type) || Chest.IsLocked(tile);
		bool flag6 = !ReplaceTile_IsValidDresser(attemptingToReplaceWith) || !ReplaceTile_IsValidDresser(tile.type);
		return !(num && flag2 && flag3 && flag && flag4 && flag5 && flag6);
	}

	private static bool ReplaceTile_IsValidSolid(int type)
	{
		if (Main.tileSolid[type] && !Main.tileSolidTop[type])
		{
			if (!Main.tileRope[type])
			{
				return !Main.tileFrameImportant[type];
			}
			return true;
		}
		return false;
	}

	private static bool ReplaceTile_IsValidTorch(int type)
	{
		return TileID.Sets.Torches[type];
	}

	private static bool ReplaceTile_IsValidCampfire(int type)
	{
		return TileID.Sets.Campfires[type];
	}

	private static bool ReplaceTile_IsValidChest(int type)
	{
		return TileID.Sets.BasicChest[type];
	}

	private static bool ReplaceTile_IsValidDresser(int type)
	{
		return TileID.Sets.BasicDresser[type];
	}

	private static bool ReplaceTile_IsValidPlatform(int type)
	{
		return TileID.Sets.Platforms[type];
	}

	public static bool GetAshTreeFoliageData(int i, int j, int xoffset, ref int treeFrame, ref int treeStyle, out int floorY, out int topTextureFrameWidth, out int topTextureFrameHeight)
	{
		_ = Main.tile[i, j];
		int num = i + xoffset;
		topTextureFrameWidth = 116;
		topTextureFrameHeight = 96;
		floorY = j;
		for (int k = 0; k < 100; k++)
		{
			floorY = j + k;
			Tile tile = Main.tile[num, floorY];
			if (tile == null)
			{
				return false;
			}
			if (tile.type == 633)
			{
				treeStyle = 31;
				return true;
			}
		}
		return false;
	}

	public static bool GetVanityTreeFoliageData(int i, int j, int xoffset, ref int treeFrame, ref int treeStyle, out int floorY, out int topTextureFrameWidth, out int topTextureFrameHeight)
	{
		Tile tile = Main.tile[i, j];
		int num = i + xoffset;
		topTextureFrameWidth = 118;
		topTextureFrameHeight = 96;
		floorY = j;
		for (int k = 0; k < 100; k++)
		{
			floorY = j + k;
			Tile tile2 = Main.tile[num, floorY];
			if (tile2 == null)
			{
				return false;
			}
			if (TileID.Sets.Conversion.Grass[tile2.type])
			{
				switch (tile.type)
				{
				case 596:
					treeStyle = 29;
					return true;
				case 616:
					treeStyle = 30;
					return true;
				}
			}
		}
		return false;
	}

	public static bool GetGemTreeFoliageData(int i, int j, int xoffset, ref int treeFrame, ref int treeStyle, out int floorY, out int topTextureFrameWidth, out int topTextureFrameHeight)
	{
		Tile tile = Main.tile[i, j];
		int num = i + xoffset;
		topTextureFrameWidth = 116;
		topTextureFrameHeight = 96;
		floorY = j;
		if (!GrowTreeSettings.Profiles.TryGetFromTreeId(tile.type, out var profile))
		{
			return false;
		}
		for (int k = 0; k < 100; k++)
		{
			floorY = j + k;
			Tile tile2 = Main.tile[num, floorY];
			if (tile2 == null)
			{
				return false;
			}
			if (profile.GroundTest(tile2.type))
			{
				switch (tile.type)
				{
				case 583:
					treeStyle = 22;
					return true;
				case 584:
					treeStyle = 23;
					return true;
				case 585:
					treeStyle = 24;
					return true;
				case 586:
					treeStyle = 25;
					return true;
				case 587:
					treeStyle = 26;
					return true;
				case 588:
					treeStyle = 27;
					return true;
				case 589:
					treeStyle = 28;
					return true;
				}
			}
		}
		return false;
	}

	public static bool GetCommonTreeFoliageData(int i, int j, int xoffset, ref int treeFrame, ref int treeStyle, out int floorY, out int topTextureFrameWidth, out int topTextureFrameHeight)
	{
		_ = Main.tile[i, j];
		int num = i + xoffset;
		topTextureFrameWidth = 80;
		topTextureFrameHeight = 80;
		floorY = j;
		int num2 = 0;
		for (int k = 0; k < 100; k++)
		{
			floorY = j + k;
			Tile tile = Main.tile[num, floorY];
			if (tile == null)
			{
				return false;
			}
			switch (tile.type)
			{
			case 2:
			case 477:
			{
				int num4 = 0;
				num4 = ((num <= Main.treeX[0]) ? TreeTops.GetTreeStyle(0) : ((num <= Main.treeX[1]) ? TreeTops.GetTreeStyle(1) : ((num > Main.treeX[2]) ? TreeTops.GetTreeStyle(3) : TreeTops.GetTreeStyle(2))));
				switch (num4)
				{
				case 0:
					treeStyle = 0;
					break;
				case 5:
					treeStyle = 10;
					break;
				default:
					treeStyle = 5 + num4;
					break;
				}
				return true;
			}
			case 23:
			case 661:
				treeStyle = 1;
				return true;
			case 70:
				treeStyle = 14;
				return true;
			case 199:
			case 662:
				treeStyle = 5;
				return true;
			case 60:
				topTextureFrameHeight = 96;
				topTextureFrameWidth = 114;
				treeStyle = 2;
				num2 = TreeTops.GetTreeStyle(5);
				if (num2 == 1)
				{
					treeStyle = 11;
					topTextureFrameWidth = 116;
				}
				if ((double)floorY > Main.worldSurface)
				{
					treeStyle = 13;
					topTextureFrameWidth = 116;
				}
				return true;
			case 147:
				treeStyle = 4;
				num2 = TreeTops.GetTreeStyle(6);
				if (num2 == 0)
				{
					treeStyle = 12;
					if (i % 10 == 0)
					{
						treeStyle = 18;
					}
				}
				if (num2 == 2 || num2 == 3 || num2 == 32 || num2 == 4 || num2 == 42 || num2 == 5 || num2 == 7)
				{
					if (num2 % 2 == 0)
					{
						if (i < Main.maxTilesX / 2)
						{
							treeStyle = 16;
						}
						else
						{
							treeStyle = 17;
						}
					}
					else if (i > Main.maxTilesX / 2)
					{
						treeStyle = 16;
					}
					else
					{
						treeStyle = 17;
					}
				}
				return true;
			case 109:
			case 492:
			{
				topTextureFrameHeight = 140;
				int num3 = (treeStyle = GetHollowTreeFoliageStyle());
				if (num3 == 19)
				{
					topTextureFrameWidth = 120;
				}
				if (num3 == 20)
				{
					treeStyle = 20;
					if (i % 6 == 1)
					{
						treeFrame += 3;
					}
					else if (i % 6 == 2)
					{
						treeFrame += 6;
					}
					else if (i % 6 == 3)
					{
						treeFrame += 9;
					}
					else if (i % 6 == 4)
					{
						treeFrame += 12;
					}
					else if (i % 6 == 5)
					{
						treeFrame += 15;
					}
				}
				else if (i % 3 == 1)
				{
					treeFrame += 3;
				}
				else if (i % 3 == 2)
				{
					treeFrame += 6;
				}
				return true;
			}
			}
		}
		return false;
	}

	public static int GetHollowTreeFoliageStyle()
	{
		TreeTops.GetTreeStyle(7);
		switch (hallowBG)
		{
		default:
			return 3;
		case 4:
			return 19;
		case 2:
		case 3:
			return 20;
		}
	}

	public static int GetTreeFrame(Tile t)
	{
		if (t.frameY == 220)
		{
			return 1;
		}
		if (t.frameY == 242)
		{
			return 2;
		}
		return 0;
	}

	public static TreeTypes GetTreeTypeAndTreeBottom(int x, int y, out int bottomX, out int bottomY)
	{
		bottomX = x;
		bottomY = y;
		GetTreeBottom(x, y, out bottomX, out bottomY);
		Tile tile = Main.tile[bottomX, bottomY];
		if (tile == null || !tile.active())
		{
			return TreeTypes.None;
		}
		return GetTreeType(tile.type);
	}

	public static TreeTypes GetTreeType(int x, int y)
	{
		int bottomX = 0;
		int bottomY = 0;
		return GetTreeTypeAndTreeBottom(x, y, out bottomX, out bottomY);
	}

	public static TreeTypes GetTreeType(int tileType)
	{
		switch (tileType)
		{
		case 2:
		case 477:
			return TreeTypes.Forest;
		case 23:
			return TreeTypes.Corrupt;
		case 70:
			return TreeTypes.Mushroom;
		case 199:
			return TreeTypes.Crimson;
		case 60:
			return TreeTypes.Jungle;
		case 147:
			return TreeTypes.Snow;
		case 109:
		case 492:
			return TreeTypes.Hallowed;
		case 53:
			return TreeTypes.Palm;
		case 112:
			return TreeTypes.PalmCorrupt;
		case 234:
			return TreeTypes.PalmCrimson;
		case 116:
			return TreeTypes.PalmHallowed;
		case 633:
			return TreeTypes.Ash;
		default:
			return TreeTypes.None;
		}
	}

	public static bool TreeTypeDropsAcorns(TreeTypes treeType)
	{
		if (treeType == TreeTypes.None || treeType == TreeTypes.Mushroom || treeType == TreeTypes.Jungle)
		{
			return false;
		}
		return true;
	}

	public static bool IsThisAMushroomTree(int i, int j)
	{
		return GetTreeType(i, j) == TreeTypes.Mushroom;
	}

	public static void ResetTreeShakes()
	{
		numTreeShakes = 0;
	}

	private static void ShakeTree(int i, int j)
	{
		if (numTreeShakes == maxTreeShakes)
		{
			return;
		}
		int bottomX;
		int bottomY;
		TreeTypes treeTypeAndTreeBottom = GetTreeTypeAndTreeBottom(i, j, out bottomX, out bottomY);
		int num = bottomY;
		if (treeTypeAndTreeBottom == TreeTypes.None)
		{
			return;
		}
		for (int k = 0; k < numTreeShakes; k++)
		{
			if (treeShakeX[k] == bottomX && treeShakeY[k] == bottomY)
			{
				return;
			}
		}
		treeShakeX[numTreeShakes] = bottomX;
		treeShakeY[numTreeShakes] = bottomY;
		numTreeShakes++;
		bottomY--;
		while (bottomY > 10 && Main.tile[bottomX, bottomY].active() && TileID.Sets.IsShakeable[Main.tile[bottomX, bottomY].type])
		{
			bottomY--;
		}
		bottomY++;
		if (!IsTileALeafyTreeTop(bottomX, bottomY) || Collision.SolidTiles(bottomX - 2, bottomX + 2, bottomY - 2, bottomY + 2))
		{
			return;
		}
		int num2 = 17;
		int type = 28;
		if (Main.tenthAnniversaryWorld && !Main.remixWorld)
		{
			num2 *= 2;
			type = 75;
		}
		if (Main.tenthAnniversaryWorld && Main.notTheBeesWorld && !Main.drunkWorld && genRand.Next(50) == 0)
		{
			int stack = Main.rand.Next(12, 21);
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 1130, stack);
		}
		else if (Main.getGoodWorld && genRand.Next(num2) == 0)
		{
			Projectile.NewProjectile(GetProjectileSource_ShakeTree(bottomX, bottomY), bottomX * 16, bottomY * 16, (float)Main.rand.Next(-100, 101) * 0.002f, 0f, type, 0, 0f, Main.myPlayer, 16f, 16f);
		}
		else if (genRand.Next(300) == 0 && treeTypeAndTreeBottom == TreeTypes.Forest)
		{
			Item.NewItem(GetItemSource_ShakeTree(bottomX, bottomY), bottomX * 16, bottomY * 16, 16, 16, 832);
		}
		else if (genRand.Next(300) == 0 && treeTypeAndTreeBottom == TreeTypes.Forest)
		{
			Item.NewItem(GetItemSource_ShakeTree(bottomX, bottomY), bottomX * 16, bottomY * 16, 16, 16, 933);
		}
		else if (genRand.Next(200) == 0 && treeTypeAndTreeBottom == TreeTypes.Jungle)
		{
			Item.NewItem(GetItemSource_ShakeTree(bottomX, bottomY), bottomX * 16, bottomY * 16, 16, 16, 3360);
		}
		else if (genRand.Next(200) == 0 && treeTypeAndTreeBottom == TreeTypes.Jungle)
		{
			Item.NewItem(GetItemSource_ShakeTree(bottomX, bottomY), bottomX * 16, bottomY * 16, 16, 16, 3361);
		}
		else if (genRand.Next(1000) == 0 && treeTypeAndTreeBottom == TreeTypes.Forest)
		{
			Item.NewItem(GetItemSource_ShakeTree(bottomX, bottomY), bottomX * 16, bottomY * 16, 16, 16, 5517);
		}
		else if (genRand.Next(1000) == 0 && treeTypeAndTreeBottom == TreeTypes.Forest)
		{
			Item.NewItem(GetItemSource_ShakeTree(bottomX, bottomY), bottomX * 16, bottomY * 16, 16, 16, 4366);
		}
		else if (genRand.Next(100) == 0 && (treeTypeAndTreeBottom == TreeTypes.Forest || treeTypeAndTreeBottom == TreeTypes.Snow || treeTypeAndTreeBottom == TreeTypes.Hallowed || treeTypeAndTreeBottom == TreeTypes.Ash))
		{
			Item.NewItem(GetItemSource_ShakeTree(bottomX, bottomY), bottomX * 16, bottomY * 16, 16, 16, 5629);
		}
		else if (genRand.Next(7) == 0 && (treeTypeAndTreeBottom == TreeTypes.Forest || treeTypeAndTreeBottom == TreeTypes.Snow || treeTypeAndTreeBottom == TreeTypes.Hallowed || treeTypeAndTreeBottom == TreeTypes.Ash))
		{
			Item.NewItem(GetItemSource_ShakeTree(bottomX, bottomY), bottomX * 16, bottomY * 16, 16, 16, 27, genRand.Next(1, 3));
		}
		else if (genRand.Next(8) == 0 && treeTypeAndTreeBottom == TreeTypes.Mushroom)
		{
			Item.NewItem(GetItemSource_ShakeTree(bottomX, bottomY), bottomX * 16, bottomY * 16, 16, 16, 194, genRand.Next(1, 2));
		}
		else if (genRand.Next(35) == 0 && Main.halloween)
		{
			Item.NewItem(GetItemSource_ShakeTree(bottomX, bottomY), bottomX * 16, bottomY * 16, 16, 16, 1809, genRand.Next(1, 3));
		}
		else if (genRand.Next(12) == 0)
		{
			int dropItem = 0;
			KillTile_GetItemDrops(i, j, Main.tile[i, j], out dropItem, out var _, out var _, out var _, out var noPrefix);
			if (dropItem > 0)
			{
				Item.NewItem(GetItemSource_FromTreeShake(bottomX, bottomY), bottomX * 16, bottomY * 16, 16, 16, dropItem, genRand.Next(1, 4), noBroadcast: false, noPrefix ? (-4) : 0);
			}
		}
		else if (genRand.Next(20) == 0)
		{
			int type2 = 71;
			int num3 = genRand.Next(50, 100);
			if (genRand.Next(30) == 0)
			{
				type2 = 73;
				num3 = 1;
				if (genRand.Next(5) == 0)
				{
					num3++;
				}
				if (genRand.Next(10) == 0)
				{
					num3++;
				}
			}
			else if (genRand.Next(10) == 0)
			{
				type2 = 72;
				num3 = genRand.Next(1, 21);
				if (genRand.Next(3) == 0)
				{
					num3 += genRand.Next(1, 21);
				}
				if (genRand.Next(4) == 0)
				{
					num3 += genRand.Next(1, 21);
				}
			}
			Item.NewItem(GetItemSource_FromTreeShake(bottomX, bottomY), bottomX * 16, bottomY * 16, 16, 16, type2, num3);
		}
		else if (genRand.Next(15) == 0 && (treeTypeAndTreeBottom == TreeTypes.Forest || treeTypeAndTreeBottom == TreeTypes.Hallowed))
		{
			int type3 = genRand.Next(5) switch
			{
				0 => 74, 
				1 => 297, 
				2 => 298, 
				3 => 299, 
				_ => 538, 
			};
			if (Player.GetClosestRollLuck(bottomX, bottomY, NPC.goldCritterChance) == 0f)
			{
				type3 = ((genRand.Next(2) != 0) ? 539 : 442);
			}
			NPC.NewNPC(new EntitySource_ShakeTree(bottomX, bottomY), bottomX * 16, bottomY * 16, type3);
		}
		else if (genRand.Next(50) == 0 && treeTypeAndTreeBottom == TreeTypes.Hallowed && !Main.dayTime)
		{
			int type4 = Main.rand.NextFromList(new short[3] { 583, 584, 585 });
			if (Main.tenthAnniversaryWorld && Main.rand.Next(4) != 0)
			{
				type4 = 583;
			}
			NPC.NewNPC(new EntitySource_ShakeTree(bottomX, bottomY), bottomX * 16, bottomY * 16, type4);
		}
		else if (genRand.Next(50) == 0 && treeTypeAndTreeBottom == TreeTypes.Forest && !Main.dayTime)
		{
			NPC obj = Main.npc[NPC.NewNPC(new EntitySource_ShakeTree(bottomX, bottomY), bottomX * 16, bottomY * 16, 611)];
			obj.velocity.Y = 1f;
			obj.netUpdate = true;
		}
		else if (genRand.Next(50) == 0 && treeTypeAndTreeBottom == TreeTypes.Jungle && Main.dayTime)
		{
			NPC obj2 = Main.npc[NPC.NewNPC(new EntitySource_ShakeTree(bottomX, bottomY), bottomX * 16, bottomY * 16, Main.rand.NextFromList(new short[5] { 671, 672, 673, 674, 675 }))];
			obj2.velocity.Y = 1f;
			obj2.netUpdate = true;
		}
		else if (genRand.Next(40) == 0 && treeTypeAndTreeBottom == TreeTypes.Forest && !Main.dayTime && Main.halloween)
		{
			NPC.NewNPC(new EntitySource_ShakeTree(bottomX, bottomY), bottomX * 16, bottomY * 16, 301);
		}
		else if (genRand.Next(50) == 0 && (treeTypeAndTreeBottom == TreeTypes.Forest || treeTypeAndTreeBottom == TreeTypes.Hallowed))
		{
			for (int l = 0; l < 5; l++)
			{
				Point point = new Point(bottomX + Main.rand.Next(-2, 2), bottomY - 1 + Main.rand.Next(-2, 2));
				int type5 = ((Player.GetClosestRollLuck(bottomX, bottomY, NPC.goldCritterChance) != 0f) ? Main.rand.NextFromList(new short[3] { 74, 297, 298 }) : 442);
				NPC obj3 = Main.npc[NPC.NewNPC(new EntitySource_ShakeTree(bottomX, bottomY), point.X * 16, point.Y * 16, type5)];
				obj3.velocity = Main.rand.NextVector2CircularEdge(3f, 3f);
				obj3.netUpdate = true;
			}
		}
		else if (genRand.Next(40) == 0 && treeTypeAndTreeBottom == TreeTypes.Jungle)
		{
			for (int m = 0; m < 5; m++)
			{
				Point point2 = new Point(bottomX + Main.rand.Next(-2, 2), bottomY - 1 + Main.rand.Next(-2, 2));
				NPC obj4 = Main.npc[NPC.NewNPC(new EntitySource_ShakeTree(bottomX, bottomY), point2.X * 16, point2.Y * 16, Main.rand.NextFromList(new short[2] { 210, 211 }))];
				obj4.ai[1] = 65f;
				obj4.CanBeReplacedByOtherNPCs = true;
				obj4.netUpdate = true;
			}
		}
		else if (genRand.Next(20) == 0 && (treeTypeAndTreeBottom == TreeTypes.Palm || treeTypeAndTreeBottom == TreeTypes.PalmCorrupt || treeTypeAndTreeBottom == TreeTypes.PalmCrimson || treeTypeAndTreeBottom == TreeTypes.PalmHallowed) && !IsPalmOasisTree(bottomX))
		{
			NPC.NewNPC(new EntitySource_ShakeTree(bottomX, bottomY), bottomX * 16, bottomY * 16, 603);
		}
		else if (genRand.Next(30) == 0 && (treeTypeAndTreeBottom == TreeTypes.Crimson || treeTypeAndTreeBottom == TreeTypes.PalmCrimson))
		{
			NPC.NewNPC(new EntitySource_ShakeTree(bottomX, bottomY), bottomX * 16 + 8, (bottomY - 1) * 16, -22);
		}
		else if (genRand.Next(30) == 0 && (treeTypeAndTreeBottom == TreeTypes.Corrupt || treeTypeAndTreeBottom == TreeTypes.PalmCorrupt))
		{
			NPC.NewNPC(new EntitySource_ShakeTree(bottomX, bottomY), bottomX * 16 + 8, (bottomY - 1) * 16, -11);
		}
		else if (genRand.Next(30) == 0 && treeTypeAndTreeBottom == TreeTypes.Jungle && !Main.dayTime)
		{
			NPC.NewNPC(new EntitySource_ShakeTree(bottomX, bottomY), bottomX * 16, bottomY * 16, 51);
		}
		else if (genRand.Next(40) == 0 && treeTypeAndTreeBottom == TreeTypes.Jungle)
		{
			Projectile.NewProjectile(GetProjectileSource_ShakeTree(bottomX, bottomY), bottomX * 16 + 8, (bottomY - 1) * 16, 0f, 0f, 655, 0, 0f, Main.myPlayer);
		}
		else if (genRand.Next(20) == 0 && (treeTypeAndTreeBottom == TreeTypes.Forest || treeTypeAndTreeBottom == TreeTypes.Hallowed) && !Main.raining && !NPC.TooWindyForButterflies && Main.dayTime)
		{
			int type6 = 356;
			if (Player.GetClosestRollLuck(bottomX, bottomY, NPC.goldCritterChance) == 0f)
			{
				type6 = 444;
			}
			NPC.NewNPC(new EntitySource_ShakeTree(bottomX, bottomY), bottomX * 16, bottomY * 16, type6);
		}
		else if (genRand.Next(20) == 0 && treeTypeAndTreeBottom == TreeTypes.Ash && bottomY > Main.maxTilesY - 250)
		{
			int num4 = genRand.Next(3);
			NPC.NewNPC(new EntitySource_ShakeTree(bottomX, bottomY), bottomX * 16, bottomY * 16, num4 switch
			{
				0 => 654, 
				1 => 653, 
				_ => 655, 
			});
		}
		else if (Main.remixWorld && genRand.Next(20) == 0 && treeTypeAndTreeBottom == TreeTypes.Ash && bottomY > Main.maxTilesY - 250)
		{
			Item.NewItem(GetItemSource_FromTreeShake(bottomX, bottomY), bottomX * 16, bottomY * 16, 16, 16, 965, genRand.Next(20, 41));
		}
		else if (genRand.Next(12) == 0 && treeTypeAndTreeBottom == TreeTypes.Forest)
		{
			int num5 = genRand.Next(5);
			Item.NewItem(GetItemSource_FromTreeShake(bottomX, bottomY), bottomX * 16, bottomY * 16, 16, 16, num5 switch
			{
				0 => 4009, 
				1 => 4293, 
				2 => 4282, 
				3 => 4290, 
				_ => 4291, 
			});
		}
		else if (genRand.Next(12) == 0 && treeTypeAndTreeBottom == TreeTypes.Snow)
		{
			Item.NewItem(Type: (genRand.Next(2) != 0) ? 4295 : 4286, source: GetItemSource_FromTreeShake(bottomX, bottomY), X: bottomX * 16, Y: bottomY * 16, Width: 16, Height: 16);
		}
		else if (genRand.Next(12) == 0 && treeTypeAndTreeBottom == TreeTypes.Jungle)
		{
			Item.NewItem(Type: (genRand.Next(2) != 0) ? 4292 : 4294, source: GetItemSource_FromTreeShake(bottomX, bottomY), X: bottomX * 16, Y: bottomY * 16, Width: 16, Height: 16);
		}
		else if (genRand.Next(12) == 0 && (treeTypeAndTreeBottom == TreeTypes.Palm || treeTypeAndTreeBottom == TreeTypes.PalmCorrupt || treeTypeAndTreeBottom == TreeTypes.PalmCrimson || treeTypeAndTreeBottom == TreeTypes.PalmHallowed) && !IsPalmOasisTree(bottomX))
		{
			Item.NewItem(Type: (genRand.Next(2) != 0) ? 4287 : 4283, source: GetItemSource_FromTreeShake(bottomX, bottomY), X: bottomX * 16, Y: bottomY * 16, Width: 16, Height: 16);
		}
		else if (genRand.Next(12) == 0 && (treeTypeAndTreeBottom == TreeTypes.Corrupt || treeTypeAndTreeBottom == TreeTypes.PalmCorrupt))
		{
			Item.NewItem(Type: (genRand.Next(2) != 0) ? 4289 : 4284, source: GetItemSource_FromTreeShake(bottomX, bottomY), X: bottomX * 16, Y: bottomY * 16, Width: 16, Height: 16);
		}
		else if (genRand.Next(12) == 0 && (treeTypeAndTreeBottom == TreeTypes.Hallowed || treeTypeAndTreeBottom == TreeTypes.PalmHallowed))
		{
			Item.NewItem(Type: (genRand.Next(2) != 0) ? 4288 : 4297, source: GetItemSource_FromTreeShake(bottomX, bottomY), X: bottomX * 16, Y: bottomY * 16, Width: 16, Height: 16);
		}
		else if (genRand.Next(12) == 0 && (treeTypeAndTreeBottom == TreeTypes.Crimson || treeTypeAndTreeBottom == TreeTypes.PalmCrimson))
		{
			Item.NewItem(Type: (genRand.Next(2) != 0) ? 4285 : 4296, source: GetItemSource_FromTreeShake(bottomX, bottomY), X: bottomX * 16, Y: bottomY * 16, Width: 16, Height: 16);
		}
		else if (genRand.Next(12) == 0 && treeTypeAndTreeBottom == TreeTypes.Ash)
		{
			Item.NewItem(Type: (genRand.Next(2) != 0) ? 5278 : 5277, source: GetItemSource_FromTreeShake(bottomX, bottomY), X: bottomX * 16, Y: bottomY * 16, Width: 16, Height: 16);
		}
		int treeHeight = 0;
		int treeFrame = 0;
		int passStyle = 0;
		GetTreeLeaf(bottomX, Main.tile[bottomX, bottomY], Main.tile[bottomX, num], ref treeHeight, out treeFrame, out passStyle);
		if (passStyle != -1)
		{
			if (Main.netMode == 2)
			{
				NetMessage.SendData(112, -1, -1, null, 1, bottomX, bottomY, 1f, passStyle, 1);
			}
			if (Main.netMode == 0)
			{
				TreeGrowFX(bottomX, bottomY, 1, passStyle, hitTree: true);
			}
		}
	}

	private static void GetVineTop(int i, int j, out int x, out int y)
	{
		x = i;
		y = j;
		Tile tileSafely = Framing.GetTileSafely(x, y);
		if (TileID.Sets.IsVine[tileSafely.type])
		{
			while (y > 20 && tileSafely.active() && TileID.Sets.IsVine[tileSafely.type])
			{
				y--;
				tileSafely = Framing.GetTileSafely(x, y);
			}
		}
	}

	public static void GetTreeBottom(int i, int j, out int x, out int y)
	{
		x = i;
		y = j;
		Tile tileSafely = Framing.GetTileSafely(x, y);
		if (tileSafely.type == 323)
		{
			while (y < Main.maxTilesY - 1 && (!tileSafely.active() || tileSafely.type == 323))
			{
				y++;
				tileSafely = Framing.GetTileSafely(x, y);
			}
			return;
		}
		int num = tileSafely.frameX / 22;
		int num2 = tileSafely.frameY / 22;
		if (num == 3 && num2 <= 2)
		{
			x++;
		}
		else if (num == 4 && num2 >= 3 && num2 <= 5)
		{
			x--;
		}
		else if (num == 1 && num2 >= 6 && num2 <= 8)
		{
			x--;
		}
		else if (num == 2 && num2 >= 6 && num2 <= 8)
		{
			x++;
		}
		else if (num == 2 && num2 >= 9)
		{
			x++;
		}
		else if (num == 3 && num2 >= 9)
		{
			x--;
		}
		tileSafely = Framing.GetTileSafely(x, y);
		while (y < Main.maxTilesY - 1 && (!tileSafely.active() || TileID.Sets.IsATreeTrunk[tileSafely.type] || tileSafely.type == 72))
		{
			y++;
			tileSafely = Framing.GetTileSafely(x, y);
		}
	}

	private static void AttemptFossilShattering(int i, int j, Tile tileCache, bool fail)
	{
		if (tileCache.type != 404 || Main.netMode == 1 || fossilBreak)
		{
			return;
		}
		fossilBreak = true;
		for (int k = i - 1; k <= i + 1; k++)
		{
			for (int l = j - 1; l <= j + 1; l++)
			{
				int maxValue = 15;
				if (!SolidTile(k, l + 1))
				{
					maxValue = 4;
				}
				else if (k == i && l == j - 1 && !fail)
				{
					maxValue = 4;
				}
				if ((k != i || l != j) && Main.tile[k, l].active() && Main.tile[k, l].type == 404 && genRand.Next(maxValue) == 0)
				{
					KillTile(k, l, fail: false, effectOnly: false, noItem: true);
					if (Main.netMode == 2)
					{
						NetMessage.SendData(17, -1, -1, null, 0, k, l);
					}
				}
			}
		}
		fossilBreak = false;
	}

	public static void KillTile(int i, int j, bool fail = false, bool effectOnly = false, bool noItem = false)
	{
		if (i < 0 || j < 0 || i >= Main.maxTilesX || j >= Main.maxTilesY)
		{
			return;
		}
		Tile tile = Main.tile[i, j];
		if (tile == null)
		{
			tile = new Tile();
			Main.tile[i, j] = tile;
		}
		if (!tile.active())
		{
			return;
		}
		if (j >= 1 && Main.tile[i, j - 1] == null)
		{
			Main.tile[i, j - 1] = new Tile();
		}
		int num = CheckTileBreakability(i, j);
		if (num == 1)
		{
			fail = true;
		}
		if (num == 2)
		{
			return;
		}
		if (isGeneratingOrLoadingWorld)
		{
			noItem = true;
		}
		if (!effectOnly && !stopDrops)
		{
			if (!noItem && FixExploitManEaters.SpotProtected(i, j))
			{
				return;
			}
			if (!Main.dedServ && !isGeneratingOrLoadingWorld && !Main.gameMenu)
			{
				KillTile_PlaySounds(i, j, fail, tile);
			}
		}
		if (tile.type == 128 || tile.type == 269)
		{
			int num2 = i;
			int num3 = tile.frameX;
			int num4;
			for (num4 = tile.frameX; num4 >= 100; num4 -= 100)
			{
			}
			while (num4 >= 36)
			{
				num4 -= 36;
			}
			if (num4 == 18)
			{
				num3 = Main.tile[i - 1, j].frameX;
				num2--;
			}
			if (num3 >= 100)
			{
				int num5 = 0;
				while (num3 >= 100)
				{
					num3 -= 100;
					num5++;
				}
				int num6 = Main.tile[num2, j].frameY / 18;
				if (num6 == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, Item.headType[num5]);
				}
				if (num6 == 1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, Item.bodyType[num5]);
				}
				if (num6 == 2)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, Item.legType[num5]);
				}
				for (num3 = Main.tile[num2, j].frameX; num3 >= 100; num3 -= 100)
				{
				}
				Main.tile[num2, j].frameX = (short)num3;
			}
		}
		if (tile.type == 334)
		{
			int num7 = i;
			int frameX = tile.frameX;
			int num8 = tile.frameX;
			int num9 = 0;
			while (num8 >= 5000)
			{
				num8 -= 5000;
				num9++;
			}
			if (num9 != 0)
			{
				num8 = (num9 - 1) * 18;
			}
			num8 %= 54;
			if (num8 == 18)
			{
				frameX = Main.tile[i - 1, j].frameX;
				num7--;
			}
			if (num8 == 36)
			{
				frameX = Main.tile[i - 2, j].frameX;
				num7 -= 2;
			}
			if (frameX >= 5000)
			{
				int num10 = frameX % 5000;
				num10 -= 100;
				int frameX2 = Main.tile[num7 + 1, j].frameX;
				frameX2 = ((frameX2 < 25000) ? (frameX2 - 10000) : (frameX2 - 25000));
				if (Main.netMode != 1)
				{
					Item item = new Item();
					item.netDefaults(num10);
					item.Prefix(frameX2);
					int num11 = Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, num10, 1, noBroadcast: true);
					Main.item[num11].OverrideWith(item);
					NetMessage.SendData(21, -1, -1, null, num11);
				}
				frameX = Main.tile[num7, j].frameX;
				int num12 = 0;
				while (frameX >= 5000)
				{
					frameX -= 5000;
					num12++;
				}
				if (num12 != 0)
				{
					frameX = (num12 - 1) * 18;
				}
				Main.tile[num7, j].frameX = (short)frameX;
				Main.tile[num7 + 1, j].frameX = (short)(frameX + 18);
			}
		}
		if (tile.type == 395 && TileEntity.TryGetAt<TEItemFrame>(i - tile.frameX % 36 / 18, j - tile.frameY % 36 / 18, out var result) && result.item.stack > 0)
		{
			result.DropItem();
			if (Main.netMode != 2)
			{
				Main.LocalPlayer.InterruptItemUsageIfOverTile(395);
			}
			return;
		}
		if (tile.type == 698 && TileEntity.TryGetAt<TEDeadCellsDisplayJar>(i - tile.frameX % 18 / 18, j - tile.frameY % 32 / 18, out var result2) && result2.item.stack > 0)
		{
			result2.DropItem();
			if (Main.netMode != 2)
			{
				Main.LocalPlayer.InterruptItemUsageIfOverTile(698);
			}
			return;
		}
		if (tile.type == 471 && TileEntity.TryGetAt<TEWeaponsRack>(i - tile.frameX % 54 / 18, j - tile.frameY % 54 / 18, out var result3) && result3.item.stack > 0)
		{
			result3.DropItem();
			if (Main.netMode != 2)
			{
				Main.LocalPlayer.InterruptItemUsageIfOverTile(471);
			}
			return;
		}
		if (tile.type == 520 && TileEntity.TryGetAt<TEFoodPlatter>(i, j, out var result4) && result4.item.stack > 0)
		{
			result4.DropItem();
			if (Main.netMode != 2)
			{
				Main.LocalPlayer.InterruptItemUsageIfOverTile(520);
			}
			return;
		}
		if (!fail && (tile.type == 723 || tile.type == 724) && TileEntity.TryGetAt<TELeashedEntityAnchorWithItem>(i, j, out var result5))
		{
			result5.DropItemForTileBreak();
		}
		if ((tile.type == 470 && (CheckTileBreakability2_ShouldTileSurvive(i, j) || fail)) || (tile.type == 475 && (CheckTileBreakability2_ShouldTileSurvive(i, j) || fail)))
		{
			return;
		}
		int num13 = KillTile_GetTileDustAmount(fail, tile);
		for (int k = 0; k < num13; k++)
		{
			KillTile_MakeTileDust(i, j, tile);
		}
		if (effectOnly)
		{
			return;
		}
		AttemptFossilShattering(i, j, tile, fail);
		if (fail)
		{
			if (Main.netMode != 1 && TileID.Sets.IsShakeable[tile.type])
			{
				ShakeTree(i, j);
			}
			if (tile.type == 2 || tile.type == 23 || tile.type == 109 || tile.type == 199 || tile.type == 477 || tile.type == 492)
			{
				tile.type = 0;
			}
			if (tile.type == 633)
			{
				tile.type = 57;
			}
			if (tile.type == 60 || tile.type == 661 || tile.type == 662 || tile.type == 70)
			{
				tile.type = 59;
			}
			if (Main.tileMoss[tile.type])
			{
				tile.type = 1;
			}
			if (TileID.Sets.tileMossBrick[tile.type])
			{
				tile.type = 38;
			}
			SquareTileFrame(i, j);
			return;
		}
		if (Main.getGoodWorld && Main.netMode != 1 && tile.type == 57)
		{
			for (int l = 0; l < 8; l++)
			{
				int maxValue = 2;
				int num14 = i;
				int num15 = j;
				switch (l)
				{
				case 0:
					num14--;
					break;
				case 1:
					num14++;
					break;
				case 2:
					num15--;
					break;
				case 3:
					num15++;
					break;
				case 4:
					num14--;
					num15--;
					break;
				case 5:
					num14++;
					num15--;
					break;
				case 6:
					num14--;
					num15++;
					break;
				case 7:
					num14++;
					num15++;
					break;
				}
				Tile tile2 = Main.tile[num14, num15];
				if (tile2.active() && genRand.Next(maxValue) == 0 && tile2.type == 57 && !SolidTile(num14, num15 + 1))
				{
					KillTile(num14, num15, fail: false, effectOnly: false, noItem: true);
					if (Main.netMode == 2)
					{
						NetMessage.TrySendData(17, -1, -1, null, 20, num14, num15);
					}
					int num16 = Projectile.NewProjectile(GetProjectileSource_TileBreak(num14, num15), num14 * 16 + 8, num15 * 16 + 8, 0f, 0.41f, 40, 15, 0f, Main.myPlayer);
					Main.projectile[num16].netUpdate = true;
				}
			}
		}
		if (Main.netMode != 1 && tile.type >= 481 && tile.type <= 483)
		{
			for (int m = 0; m < 8; m++)
			{
				int num17 = 6;
				int num18 = i;
				int num19 = j;
				switch (m)
				{
				case 0:
					num18--;
					break;
				case 1:
					num18++;
					break;
				case 2:
					num19--;
					num17 /= 2;
					break;
				case 3:
					num19++;
					break;
				case 4:
					num18--;
					num19--;
					break;
				case 5:
					num18++;
					num19--;
					break;
				case 6:
					num18--;
					num19++;
					break;
				case 7:
					num18++;
					num19++;
					break;
				}
				Tile tile3 = Main.tile[num18, num19];
				if (tile3.active() && genRand.Next(num17) == 0 && tile3.type >= 481 && tile3.type <= 483)
				{
					tile.active(active: false);
					KillTile(num18, num19, fail: false, effectOnly: false, noItem: true);
					if (Main.netMode == 2)
					{
						NetMessage.TrySendData(17, -1, -1, null, 20, num18, num19);
					}
				}
			}
			int type = tile.type - 481 + 736;
			int damage = 20;
			EntitySource_TileBreak projectileSource_TileBreak = GetProjectileSource_TileBreak(i, j);
			if (Main.netMode == 0)
			{
				Projectile.NewProjectile(projectileSource_TileBreak, i * 16 + 8, j * 16 + 8, 0f, 0.41f, type, damage, 0f, Main.myPlayer);
			}
			else if (Main.netMode == 2)
			{
				int num20 = Projectile.NewProjectile(projectileSource_TileBreak, i * 16 + 8, j * 16 + 8, 0f, 0.41f, type, damage, 0f, Main.myPlayer);
				Main.projectile[num20].netUpdate = true;
			}
		}
		if (CheckTileBreakability2_ShouldTileSurvive(i, j))
		{
			return;
		}
		if (tile.type == 51 && tile.wall == 62 && genRand.Next(4) != 0)
		{
			noItem = true;
		}
		if (!noItem && !stopDrops && Main.netMode != 1)
		{
			KillTile_DropBait(i, j, tile);
			KillTile_DropItems(i, j, tile);
		}
		if (tile.type == 520)
		{
			TileEntityType<TEFoodPlatter>.Kill(i, j);
		}
		if (tile.type == 423)
		{
			TELogicSensor.Kill(i, j);
		}
		if (tile.type == 723)
		{
			TEKiteAnchor.Kill(i, j);
		}
		if (tile.type == 724)
		{
			TECritterAnchor.Kill(i, j);
		}
		if (Main.netMode != 2)
		{
			AchievementsHelper.NotifyTileDestroyed(Main.player[Main.myPlayer], tile.type);
		}
		tile.active(active: false);
		tile.halfBrick(halfBrick: false);
		tile.frameX = -1;
		tile.frameY = -1;
		tile.ClearBlockPaintAndCoating();
		tile.frameNumber(0);
		if (Main.netMode != 1)
		{
			if (tile.type == 58 && j > Main.UnderworldLayer)
			{
				tile.lava(lava: true);
				tile.liquid = 128;
			}
			else if (tile.type == 230 && Main.getGoodWorld && genRand.Next(2) == 0)
			{
				tile.lava(lava: true);
				tile.liquid = 128;
			}
			else if (tile.type > 0 && tile.type < TileID.Count && (tile.type == 147 || tile.type == 224 || TileID.Sets.Ices[tile.type]) && Main.getGoodWorld && Main.remixWorld && !Main.drunkWorld && genRand.Next(2) == 0)
			{
				tile.liquidType(0);
				tile.liquid = 64;
			}
		}
		if (tile.type == 419)
		{
			Wiring.PokeLogicGate(i, j + 1);
		}
		else if (TileID.Sets.TruncatesWalls[tile.type])
		{
			SquareWallFrame(i, j);
		}
		tile.type = 0;
		tile.inActive(inActive: false);
		SquareTileFrame(i, j);
		CheckExploitDestroyQueue();
	}

	public static void CheckExploitDestroyQueue()
	{
		if (destroyObject)
		{
			return;
		}
		while (ExploitDestroyQueue.Count > 0)
		{
			Point point = ExploitDestroyQueue.Dequeue();
			if (Framing.GetTileSafely(point.X, point.Y).active())
			{
				SquareTileFrame(point.X, point.Y);
				if (Main.netMode != 0)
				{
					NetMessage.SendTileSquare(-1, point.X, point.Y);
				}
			}
		}
	}

	private static Player GetPlayerForTile(int x, int y)
	{
		return Main.player[Player.FindClosest(new Vector2(x, y) * 16f, 16, 16)];
	}

	public static void KillTile_DropItems(int x, int y, Tile tileCache, bool includeLargeObjectDrops = false)
	{
		KillTile_GetItemDrops(x, y, tileCache, out var dropItem, out var dropItemStack, out var secondaryItem, out var secondaryItemStack, out var noPrefix, includeLargeObjectDrops);
		if (!Main.getGoodWorld || tileCache.active())
		{
			if (dropItem > 0)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, dropItem, dropItemStack, noBroadcast: false, noPrefix ? (-4) : (-1));
			}
			if (secondaryItem > 0)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, secondaryItem, secondaryItemStack, noBroadcast: false, noPrefix ? (-4) : (-1));
			}
		}
	}

	public static void KillTile_GetItemDrops(int x, int y, Tile tileCache, out int dropItem, out int dropItemStack, out int secondaryItem, out int secondaryItemStack, out bool noPrefix, bool includeLargeObjectDrops = false)
	{
		dropItem = 0;
		dropItemStack = 1;
		secondaryItem = 0;
		secondaryItemStack = 1;
		noPrefix = false;
		int num = 0;
		if (includeLargeObjectDrops)
		{
			switch (tileCache.type)
			{
			case 21:
			case 467:
				dropItem = GetItemDrop_Chests(x, y, tileCache.type);
				break;
			case 88:
				num = tileCache.frameX / 54;
				dropItem = GetItemDrop_Dressers(num);
				break;
			case 215:
				num = tileCache.frameX / 54;
				dropItem = GetCampfireItemDrop(num);
				break;
			}
		}
		switch (tileCache.type)
		{
		case 668:
			dropItem = 5400;
			break;
		case 659:
			dropItem = 5349;
			break;
		case 667:
			dropItem = 5398;
			break;
		case 179:
		case 180:
		case 181:
		case 182:
		case 183:
		case 381:
		case 534:
		case 536:
		case 539:
		case 625:
		case 627:
			dropItem = 3;
			break;
		case 512:
		case 513:
		case 514:
		case 515:
		case 516:
		case 517:
		case 535:
		case 537:
		case 540:
		case 626:
		case 628:
			dropItem = 129;
			break;
		case 0:
		case 2:
		case 109:
		case 199:
		case 477:
		case 492:
			dropItem = 2;
			break;
		case 633:
			dropItem = 172;
			break;
		case 426:
			dropItem = 3621;
			break;
		case 430:
			dropItem = 3633;
			break;
		case 431:
			dropItem = 3634;
			break;
		case 432:
			dropItem = 3635;
			break;
		case 433:
			dropItem = 3636;
			break;
		case 434:
			dropItem = 3637;
			break;
		case 727:
			dropItem = 5674;
			break;
		case 728:
			dropItem = 5675;
			break;
		case 729:
			dropItem = 5676;
			break;
		case 730:
			dropItem = 5677;
			break;
		case 731:
			dropItem = 5678;
			break;
		case 732:
			dropItem = 5679;
			break;
		case 427:
			dropItem = 3622;
			break;
		case 435:
			dropItem = 3638;
			break;
		case 436:
			dropItem = 3639;
			break;
		case 437:
			dropItem = 3640;
			break;
		case 438:
			dropItem = 3641;
			break;
		case 439:
			dropItem = 3642;
			break;
		case 446:
			dropItem = 3736;
			break;
		case 447:
			dropItem = 3737;
			break;
		case 448:
			dropItem = 3738;
			break;
		case 449:
			dropItem = 3739;
			break;
		case 450:
			dropItem = 3740;
			break;
		case 451:
			dropItem = 3741;
			break;
		case 368:
			dropItem = 3086;
			break;
		case 369:
			dropItem = 3087;
			break;
		case 367:
			dropItem = 3081;
			break;
		case 379:
			dropItem = 3214;
			break;
		case 353:
			dropItem = 2996;
			break;
		case 365:
			dropItem = 3077;
			break;
		case 366:
			dropItem = 3078;
			break;
		case 357:
			dropItem = 3066;
			break;
		case 1:
			dropItem = 3;
			break;
		case 442:
			dropItem = 3707;
			break;
		case 383:
			dropItem = 620;
			break;
		case 315:
			dropItem = 2435;
			break;
		case 641:
			dropItem = 5306;
			break;
		case 330:
			dropItem = 71;
			break;
		case 331:
			dropItem = 72;
			break;
		case 332:
			dropItem = 73;
			break;
		case 333:
			dropItem = 74;
			break;
		case 408:
			dropItem = 3460;
			break;
		case 409:
			dropItem = 3461;
			break;
		case 669:
			dropItem = 5401;
			break;
		case 670:
			dropItem = 5402;
			break;
		case 671:
			dropItem = 5403;
			break;
		case 672:
			dropItem = 5404;
			break;
		case 673:
			dropItem = 5405;
			break;
		case 674:
			dropItem = 5406;
			break;
		case 675:
			dropItem = 5407;
			break;
		case 676:
			dropItem = 5408;
			break;
		case 677:
			dropItem = 5417;
			break;
		case 678:
			dropItem = 5419;
			break;
		case 679:
			dropItem = 5421;
			break;
		case 680:
			dropItem = 5423;
			break;
		case 681:
			dropItem = 5425;
			break;
		case 682:
			dropItem = 5427;
			break;
		case 683:
			dropItem = 5433;
			break;
		case 684:
			dropItem = 5435;
			break;
		case 685:
			dropItem = 5429;
			break;
		case 686:
			dropItem = 5431;
			break;
		case 687:
			dropItem = 5439;
			break;
		case 688:
			dropItem = 5440;
			break;
		case 689:
			dropItem = 5441;
			break;
		case 690:
			dropItem = 5442;
			break;
		case 691:
			dropItem = 5443;
			break;
		case 692:
			dropItem = 5444;
			break;
		case 666:
			dropItem = 5395;
			break;
		case 415:
			dropItem = 3573;
			break;
		case 416:
			dropItem = 3574;
			break;
		case 417:
			dropItem = 3575;
			break;
		case 418:
			dropItem = 3576;
			break;
		case 421:
			dropItem = 3609;
			break;
		case 422:
			dropItem = 3610;
			break;
		case 498:
			dropItem = 4139;
			break;
		case 424:
			dropItem = 3616;
			break;
		case 445:
			dropItem = 3725;
			break;
		case 429:
			dropItem = 3629;
			break;
		case 272:
			dropItem = 1344;
			break;
		case 273:
			dropItem = 2119;
			break;
		case 274:
			dropItem = 2120;
			break;
		case 618:
			dropItem = 4962;
			break;
		case 460:
			dropItem = 3756;
			break;
		case 541:
			dropItem = 4392;
			break;
		case 630:
			dropItem = 5137;
			break;
		case 631:
			dropItem = 5138;
			break;
		case 472:
			dropItem = 3951;
			break;
		case 473:
			dropItem = 3953;
			break;
		case 726:
			dropItem = 929;
			break;
		case 474:
			dropItem = 3955;
			break;
		case 478:
			dropItem = 4050;
			break;
		case 479:
			dropItem = 4051;
			break;
		case 496:
			dropItem = 4091;
			break;
		case 495:
			dropItem = 4090;
			break;
		case 346:
			dropItem = 2792;
			break;
		case 347:
			dropItem = 2793;
			break;
		case 348:
			dropItem = 2794;
			break;
		case 350:
			dropItem = 2860;
			break;
		case 336:
			dropItem = 2701;
			break;
		case 340:
			dropItem = 2751;
			break;
		case 341:
			dropItem = 2752;
			break;
		case 342:
			dropItem = 2753;
			break;
		case 343:
			dropItem = 2754;
			break;
		case 344:
			dropItem = 2755;
			break;
		case 351:
			dropItem = 2868;
			break;
		case 500:
			dropItem = 4229;
			break;
		case 501:
			dropItem = 4230;
			break;
		case 502:
			dropItem = 4231;
			break;
		case 503:
			dropItem = 4232;
			break;
		case 546:
		case 557:
			dropItem = 4422;
			break;
		case 561:
			dropItem = 4554;
			break;
		case 574:
			dropItem = 4717;
			break;
		case 575:
			dropItem = 4718;
			break;
		case 576:
			dropItem = 4719;
			break;
		case 577:
			dropItem = 4720;
			break;
		case 578:
			dropItem = 4721;
			break;
		case 562:
			dropItem = 4564;
			break;
		case 571:
			dropItem = 4564;
			dropItemStack = genRand.Next(1, 3);
			break;
		case 563:
			dropItem = 4547;
			break;
		case 251:
			dropItem = 1725;
			break;
		case 252:
			dropItem = 1727;
			break;
		case 253:
			dropItem = 1729;
			break;
		case 325:
			dropItem = 2692;
			break;
		case 370:
			dropItem = 3100;
			break;
		case 396:
			dropItem = 3271;
			break;
		case 400:
			dropItem = 3276;
			break;
		case 401:
			dropItem = 3277;
			break;
		case 403:
			dropItem = 3339;
			break;
		case 397:
			dropItem = 3272;
			break;
		case 398:
			dropItem = 3274;
			break;
		case 399:
			dropItem = 3275;
			break;
		case 402:
			dropItem = 3338;
			break;
		case 404:
			dropItem = 3347;
			break;
		case 407:
			dropItem = 3380;
			break;
		case 579:
			dropItem = 4761;
			break;
		case 593:
			dropItem = 4868;
			break;
		case 624:
			dropItem = 5114;
			break;
		case 700:
			dropItem = 5114;
			noPrefix = true;
			break;
		case 656:
			dropItem = 5333;
			break;
		case 701:
			dropItem = 5333;
			break;
		case 170:
			dropItem = 1872;
			break;
		case 284:
			dropItem = 2173;
			break;
		case 214:
			dropItem = 85;
			break;
		case 213:
			dropItem = 965;
			break;
		case 211:
			dropItem = 947;
			break;
		case 6:
			dropItem = 11;
			break;
		case 7:
			dropItem = 12;
			break;
		case 8:
			dropItem = 13;
			break;
		case 9:
			dropItem = 14;
			break;
		case 202:
			dropItem = 824;
			break;
		case 234:
			dropItem = 1246;
			break;
		case 226:
			dropItem = 1101;
			break;
		case 224:
			dropItem = 1103;
			break;
		case 36:
			dropItem = 1869;
			break;
		case 311:
			dropItem = 2260;
			break;
		case 312:
			dropItem = 2261;
			break;
		case 313:
			dropItem = 2262;
			break;
		case 229:
			dropItem = 1125;
			break;
		case 230:
			dropItem = 1127;
			break;
		case 221:
			dropItem = 1104;
			break;
		case 222:
			dropItem = 1105;
			break;
		case 223:
			dropItem = 1106;
			break;
		case 248:
			dropItem = 1589;
			break;
		case 249:
			dropItem = 1591;
			break;
		case 250:
			dropItem = 1593;
			break;
		case 191:
			dropItem = 9;
			break;
		case 203:
			dropItem = 836;
			break;
		case 204:
			dropItem = 880;
			break;
		case 166:
			dropItem = 699;
			break;
		case 167:
			dropItem = 700;
			break;
		case 168:
			dropItem = 701;
			break;
		case 169:
			dropItem = 702;
			break;
		case 123:
			dropItem = 424;
			break;
		case 124:
			dropItem = 480;
			break;
		case 157:
			dropItem = 619;
			break;
		case 158:
			dropItem = 620;
			break;
		case 159:
			dropItem = 621;
			break;
		case 161:
			dropItem = 664;
			break;
		case 206:
			dropItem = 883;
			break;
		case 232:
			dropItem = 1150;
			break;
		case 198:
			dropItem = 775;
			break;
		case 314:
			dropItem = Minecart.GetTrackItem(tileCache);
			break;
		case 189:
			dropItem = 751;
			break;
		case 717:
			dropItem = 5569;
			break;
		case 718:
			dropItem = 5570;
			break;
		case 719:
			dropItem = 5571;
			break;
		case 195:
			dropItem = 763;
			break;
		case 194:
			dropItem = 154;
			break;
		case 193:
			dropItem = 762;
			break;
		case 196:
			dropItem = 765;
			break;
		case 197:
			dropItem = 767;
			break;
		case 22:
			dropItem = 56;
			break;
		case 140:
			dropItem = 577;
			break;
		case 23:
			dropItem = 2;
			break;
		case 25:
			dropItem = 61;
			break;
		case 30:
			dropItem = 9;
			break;
		case 208:
			dropItem = 911;
			break;
		case 372:
			dropItem = 3117;
			break;
		case 646:
			dropItem = 5322;
			break;
		case 371:
			dropItem = 3113;
			break;
		case 174:
			dropItem = 713;
			break;
		case 37:
			dropItem = 116;
			break;
		case 38:
			dropItem = 129;
			break;
		case 39:
			dropItem = 131;
			break;
		case 40:
			dropItem = 133;
			break;
		case 41:
			dropItem = 134;
			break;
		case 43:
			dropItem = 137;
			break;
		case 44:
			dropItem = 139;
			break;
		case 45:
			dropItem = 141;
			break;
		case 46:
			dropItem = 143;
			break;
		case 47:
			dropItem = 145;
			break;
		case 48:
			dropItem = 147;
			break;
		case 49:
			dropItem = 148;
			break;
		case 51:
			dropItem = 150;
			break;
		case 697:
			dropItem = 5471;
			break;
		case 53:
			dropItem = 169;
			break;
		case 151:
			dropItem = 607;
			break;
		case 152:
			dropItem = 609;
			break;
		case 56:
			dropItem = 173;
			break;
		case 57:
			dropItem = 172;
			break;
		case 58:
			dropItem = 174;
			break;
		case 70:
			dropItem = 176;
			break;
		case 75:
			dropItem = 192;
			break;
		case 76:
			dropItem = 214;
			break;
		case 78:
			dropItem = 222;
			break;
		case 81:
			dropItem = 275;
			break;
		case 80:
			dropItem = 276;
			break;
		case 188:
			dropItem = 276;
			break;
		case 107:
			dropItem = 364;
			break;
		case 108:
			dropItem = 365;
			break;
		case 111:
			dropItem = 366;
			break;
		case 150:
			dropItem = 604;
			break;
		case 112:
			dropItem = 370;
			break;
		case 116:
			dropItem = 408;
			break;
		case 117:
			dropItem = 409;
			break;
		case 118:
			dropItem = 412;
			break;
		case 119:
			dropItem = 413;
			break;
		case 120:
			dropItem = 414;
			break;
		case 121:
			dropItem = 415;
			break;
		case 122:
			dropItem = 416;
			break;
		case 136:
			dropItem = 538;
			break;
		case 385:
			dropItem = 3234;
			break;
		case 141:
			dropItem = 580;
			break;
		case 145:
			dropItem = 586;
			break;
		case 146:
			dropItem = 591;
			break;
		case 147:
			dropItem = 593;
			break;
		case 148:
			dropItem = 594;
			break;
		case 153:
			dropItem = 611;
			break;
		case 154:
			dropItem = 612;
			break;
		case 155:
			dropItem = 613;
			break;
		case 156:
			dropItem = 614;
			break;
		case 160:
			dropItem = 662;
			break;
		case 175:
			dropItem = 717;
			break;
		case 176:
			dropItem = 718;
			break;
		case 177:
			dropItem = 719;
			break;
		case 163:
			dropItem = 833;
			break;
		case 164:
			dropItem = 834;
			break;
		case 200:
			dropItem = 835;
			break;
		case 210:
			dropItem = 937;
			break;
		case 130:
			dropItem = 511;
			break;
		case 131:
			dropItem = 512;
			break;
		case 321:
			dropItem = 2503;
			break;
		case 322:
			dropItem = 2504;
			break;
		case 635:
			dropItem = 5215;
			break;
		case 54:
			dropItem = 170;
			break;
		case 326:
			dropItem = 2693;
			break;
		case 327:
			dropItem = 2694;
			break;
		case 458:
			dropItem = 3754;
			break;
		case 459:
			dropItem = 3755;
			break;
		case 345:
			dropItem = 2787;
			break;
		case 708:
			dropItem = 5493;
			break;
		case 328:
			dropItem = 2695;
			break;
		case 329:
			dropItem = 2697;
			break;
		case 507:
			dropItem = 4277;
			break;
		case 508:
			dropItem = 4278;
			break;
		case 722:
			dropItem = 5622;
			break;
		case 734:
			dropItem = 5710;
			break;
		case 735:
			dropItem = 5733;
			break;
		case 736:
			dropItem = 5920;
			break;
		case 737:
			dropItem = 5922;
			break;
		case 738:
			dropItem = 5924;
			break;
		case 739:
			dropItem = 5926;
			break;
		case 740:
			dropItem = 5928;
			break;
		case 741:
			dropItem = 5930;
			break;
		case 742:
			dropItem = 5953;
			break;
		case 743:
			dropItem = 5996;
			break;
		case 744:
			dropItem = 6019;
			break;
		case 745:
			dropItem = 6042;
			break;
		case 746:
			dropItem = 6065;
			break;
		case 747:
			dropItem = 6088;
			break;
		case 748:
			dropItem = 6109;
			break;
		case 749:
			dropItem = 6132;
			break;
		case 750:
			dropItem = 6134;
			break;
		case 255:
		case 256:
		case 257:
		case 258:
		case 259:
		case 260:
		case 261:
			dropItem = 1970 + tileCache.type - 255;
			break;
		case 262:
		case 263:
		case 264:
		case 265:
		case 266:
		case 267:
		case 268:
			dropItem = 1970 + tileCache.type - 262;
			break;
		case 59:
		case 60:
		case 661:
		case 662:
			dropItem = 176;
			break;
		case 190:
			dropItem = 183;
			break;
		case 63:
		case 64:
		case 65:
		case 66:
		case 67:
		case 68:
			dropItem = tileCache.type - 63 + 177;
			break;
		case 566:
			dropItem = 999;
			break;
		case 703:
			switch (tileCache.frameX / 18)
			{
			default:
				dropItem = 195;
				break;
			case 6:
			case 7:
				dropItem = 208;
				break;
			case 8:
				dropItem = 331;
				break;
			case 9:
				dropItem = 223;
				noPrefix = true;
				break;
			}
			break;
		case 637:
			if (Main.rand.Next(100) == 0)
			{
				dropItem = 5214;
			}
			break;
		case 129:
			if (tileCache.frameX >= 324)
			{
				dropItem = 4988;
			}
			else
			{
				dropItem = 502;
			}
			break;
		case 3:
			if (tileCache.frameX == 144)
			{
				dropItem = 5;
			}
			else if (KillTile_ShouldDropSeeds(x, y))
			{
				dropItem = 283;
			}
			break;
		case 519:
			if (tileCache.frameY == 90 && genRand.Next(2) == 0)
			{
				dropItem = 183;
			}
			break;
		case 528:
			if (genRand.Next(2) == 0)
			{
				dropItem = 183;
			}
			break;
		case 110:
			if (tileCache.frameX == 144)
			{
				dropItem = 5;
			}
			break;
		case 24:
			if (tileCache.frameX == 144)
			{
				dropItem = 60;
			}
			break;
		case 201:
			if (tileCache.frameX == 270)
			{
				dropItem = 2887;
			}
			break;
		case 73:
			if (KillTile_ShouldDropSeeds(x, y))
			{
				dropItem = 283;
			}
			break;
		case 52:
		case 62:
		case 382:
			if (Main.rand.Next(2) == 0 && GetPlayerForTile(x, y).cordage)
			{
				dropItem = 2996;
			}
			break;
		case 693:
			dropItem = GetStalactiteEchoDrop(x, y, tileCache.frameX / 18);
			break;
		case 227:
			num = tileCache.frameX / 34;
			dropItem = 1107 + num;
			if (num >= 8 && num <= 11)
			{
				dropItem = 3385 + num - 8;
			}
			break;
		case 4:
			num = tileCache.frameY / 22;
			switch (num)
			{
			case 0:
				dropItem = 8;
				break;
			case 8:
				dropItem = 523;
				break;
			case 9:
				dropItem = 974;
				break;
			case 10:
				dropItem = 1245;
				break;
			case 11:
				dropItem = 1333;
				break;
			case 12:
				dropItem = 2274;
				break;
			case 13:
				dropItem = 3004;
				break;
			case 14:
				dropItem = 3045;
				break;
			case 15:
				dropItem = 3114;
				break;
			case 16:
				dropItem = 4383;
				break;
			case 17:
				dropItem = 4384;
				break;
			case 18:
				dropItem = 4385;
				break;
			case 19:
				dropItem = 4386;
				break;
			case 20:
				dropItem = 4387;
				break;
			case 21:
				dropItem = 4388;
				break;
			case 22:
				dropItem = 5293;
				break;
			case 23:
				dropItem = 5353;
				break;
			default:
				dropItem = 426 + num;
				break;
			}
			break;
		case 239:
			num = tileCache.frameX / 18;
			if (num == 0)
			{
				dropItem = 20;
			}
			if (num == 1)
			{
				dropItem = 703;
			}
			if (num == 2)
			{
				dropItem = 22;
			}
			if (num == 3)
			{
				dropItem = 704;
			}
			if (num == 4)
			{
				dropItem = 21;
			}
			if (num == 5)
			{
				dropItem = 705;
			}
			if (num == 6)
			{
				dropItem = 19;
			}
			if (num == 7)
			{
				dropItem = 706;
			}
			if (num == 8)
			{
				dropItem = 57;
			}
			if (num == 9)
			{
				dropItem = 117;
			}
			if (num == 10)
			{
				dropItem = 175;
			}
			if (num == 11)
			{
				dropItem = 381;
			}
			if (num == 12)
			{
				dropItem = 1184;
			}
			if (num == 13)
			{
				dropItem = 382;
			}
			if (num == 14)
			{
				dropItem = 1191;
			}
			if (num == 15)
			{
				dropItem = 391;
			}
			if (num == 16)
			{
				dropItem = 1198;
			}
			if (num == 17)
			{
				dropItem = 1006;
			}
			if (num == 18)
			{
				dropItem = 1225;
			}
			if (num == 19)
			{
				dropItem = 1257;
			}
			if (num == 20)
			{
				dropItem = 1552;
			}
			if (num == 21)
			{
				dropItem = 3261;
			}
			if (num == 22)
			{
				dropItem = 3467;
			}
			break;
		case 380:
			num = tileCache.frameY / 18;
			dropItem = 3215 + num;
			break;
		case 5:
		case 596:
		case 616:
		case 634:
		{
			bool bonusWood = false;
			bool dropIsWood = false;
			KillTile_GetTreeDrops(x, y, tileCache, ref dropIsWood, ref bonusWood, ref dropItem, ref secondaryItem);
			if (bonusWood)
			{
				dropItemStack++;
			}
			if (SpecialSeedFeatures.ShouldDropExtraWood && dropIsWood)
			{
				dropItemStack *= 2;
			}
			break;
		}
		case 323:
		{
			dropItem = 2504;
			if (Main.tenthAnniversaryWorld)
			{
				dropItemStack += genRand.Next(2, 5);
			}
			if (tileCache.frameX <= 132 && tileCache.frameX >= 88)
			{
				secondaryItem = 27;
			}
			int j;
			for (j = y; !Main.tile[x, j].active() || !Main.tileSolid[Main.tile[x, j].type]; j++)
			{
			}
			if (Main.tile[x, j].active())
			{
				switch (Main.tile[x, j].type)
				{
				case 234:
					dropItem = 911;
					break;
				case 116:
					dropItem = 621;
					break;
				case 112:
					dropItem = 619;
					break;
				}
			}
			if (SpecialSeedFeatures.ShouldDropExtraWood)
			{
				dropItemStack *= 3;
			}
			break;
		}
		case 171:
			if (tileCache.frameX >= 10)
			{
				dropXmasTree(x, y, 0);
				dropXmasTree(x, y, 1);
				dropXmasTree(x, y, 2);
				dropXmasTree(x, y, 3);
			}
			break;
		case 324:
			switch (tileCache.frameY / 22)
			{
			case 0:
				dropItem = 2625;
				break;
			case 1:
				dropItem = 2626;
				break;
			case 2:
				dropItem = 4072;
				break;
			case 3:
				dropItem = 4073;
				break;
			case 4:
				dropItem = 4071;
				break;
			}
			break;
		case 419:
			switch (tileCache.frameX / 18)
			{
			case 0:
				dropItem = 3602;
				break;
			case 1:
				dropItem = 3618;
				break;
			case 2:
				dropItem = 3663;
				break;
			}
			break;
		case 428:
			switch (tileCache.frameY / 18)
			{
			case 0:
				dropItem = 3630;
				break;
			case 1:
				dropItem = 3632;
				break;
			case 2:
				dropItem = 3631;
				break;
			case 3:
				dropItem = 3626;
				break;
			}
			PressurePlateHelper.DestroyPlate(new Point(x, y));
			break;
		case 420:
			switch (tileCache.frameY / 18)
			{
			case 0:
				dropItem = 3603;
				break;
			case 1:
				dropItem = 3604;
				break;
			case 2:
				dropItem = 3605;
				break;
			case 3:
				dropItem = 3606;
				break;
			case 4:
				dropItem = 3607;
				break;
			case 5:
				dropItem = 3608;
				break;
			}
			break;
		case 650:
			num = tileCache.frameX / 18;
			if (num < 6)
			{
				dropItem = 3;
				break;
			}
			if (num < 12)
			{
				dropItem = 2;
				break;
			}
			if (num < 20)
			{
				dropItem = 154;
				break;
			}
			if (num < 28)
			{
				dropItem = 154;
				break;
			}
			if (num < 36)
			{
				dropItem = 9;
				break;
			}
			if (num < 42)
			{
				dropItem = 593;
				break;
			}
			if (num < 48)
			{
				dropItem = 664;
				break;
			}
			if (num < 54)
			{
				dropItem = 150;
				break;
			}
			if (num < 60)
			{
				dropItem = 3271;
				break;
			}
			if (num < 66)
			{
				dropItem = 3086;
				break;
			}
			if (num < 72)
			{
				dropItem = 3081;
				break;
			}
			if (num < 73)
			{
				dropItem = 62;
				break;
			}
			switch (num)
			{
			case 74:
			case 76:
				dropItem = 169;
				break;
			case 75:
			case 77:
				dropItem = 276;
				break;
			}
			break;
		case 476:
			dropItem = 4040;
			break;
		case 494:
			dropItem = 4089;
			break;
		case 423:
			TELogicSensor.Kill(x, y);
			switch (tileCache.frameY / 18)
			{
			case 0:
				dropItem = 3613;
				break;
			case 1:
				dropItem = 3614;
				break;
			case 2:
				dropItem = 3615;
				break;
			case 3:
				dropItem = 3726;
				break;
			case 4:
				dropItem = 3727;
				break;
			case 5:
				dropItem = 3728;
				break;
			case 6:
				dropItem = 3729;
				break;
			}
			break;
		case 520:
			dropItem = 4326;
			break;
		case 225:
			if (Main.rand.Next(3) == 0)
			{
				tileCache.honey(honey: true);
				tileCache.liquid = byte.MaxValue;
				break;
			}
			dropItem = 1124;
			if (Main.netMode != 1 && Main.rand.Next(2) == 0)
			{
				int num3 = 1;
				if (Main.rand.Next(3) == 0)
				{
					num3 = 2;
				}
				for (int i = 0; i < num3; i++)
				{
					int type = Main.rand.Next(210, 212);
					int num4 = NPC.NewNPC(GetNPCSource_TileBreak(x, y), x * 16 + 8, y * 16 + 15, type, 1);
					Main.npc[num4].velocity.X = (float)Main.rand.Next(-200, 201) * 0.002f;
					Main.npc[num4].velocity.Y = (float)Main.rand.Next(-200, 201) * 0.002f;
					Main.npc[num4].netUpdate = true;
				}
			}
			break;
		case 178:
			switch (tileCache.frameX / 18)
			{
			case 0:
				dropItem = 181;
				break;
			case 1:
				dropItem = 180;
				break;
			case 2:
				dropItem = 177;
				break;
			case 3:
				dropItem = 179;
				break;
			case 4:
				dropItem = 178;
				break;
			case 5:
				dropItem = 182;
				break;
			case 6:
				dropItem = 999;
				break;
			}
			break;
		case 149:
			if (tileCache.frameX == 0 || tileCache.frameX == 54)
			{
				dropItem = 596;
			}
			else if (tileCache.frameX == 18 || tileCache.frameX == 72)
			{
				dropItem = 597;
			}
			else if (tileCache.frameX == 36 || tileCache.frameX == 90)
			{
				dropItem = 598;
			}
			break;
		case 13:
			num = tileCache.frameX / 18;
			dropItem = GetItemDrop_Bottles(num);
			break;
		case 19:
			num = tileCache.frameY / 18;
			dropItem = GetItemDrop_Platforms(num);
			break;
		case 33:
			num = tileCache.frameY / 22;
			dropItem = GetItemDrop_Candles(num);
			break;
		case 137:
			num = tileCache.frameY / 18;
			if (num == 0)
			{
				dropItem = 539;
			}
			if (num == 1)
			{
				dropItem = 1146;
			}
			if (num == 2)
			{
				dropItem = 1147;
			}
			if (num == 3)
			{
				dropItem = 1148;
			}
			if (num == 4)
			{
				dropItem = 1149;
			}
			if (num == 5)
			{
				dropItem = 5135;
			}
			break;
		case 135:
			num = tileCache.frameY / 18;
			if (num == 0)
			{
				dropItem = 529;
			}
			if (num == 1)
			{
				dropItem = 541;
			}
			if (num == 2)
			{
				dropItem = 542;
			}
			if (num == 3)
			{
				dropItem = 543;
			}
			if (num == 4)
			{
				dropItem = 852;
			}
			if (num == 5)
			{
				dropItem = 853;
			}
			if (num == 6)
			{
				dropItem = 1151;
			}
			break;
		case 144:
			if (tileCache.frameX == 0)
			{
				dropItem = 583;
			}
			if (tileCache.frameX == 18)
			{
				dropItem = 584;
			}
			if (tileCache.frameX == 36)
			{
				dropItem = 585;
			}
			if (tileCache.frameX == 54)
			{
				dropItem = 4484;
			}
			if (tileCache.frameX == 72)
			{
				dropItem = 4485;
			}
			break;
		case 61:
		case 74:
			if (tileCache.frameX == 144 && tileCache.type == 61)
			{
				dropItem = 331;
				dropItemStack = Main.rand.Next(2, 4);
			}
			else if (tileCache.frameX == 162 && tileCache.type == 61)
			{
				dropItem = 223;
			}
			else if (tileCache.frameX >= 108 && tileCache.frameX <= 126 && tileCache.type == 61 && Main.rand.Next(20) == 0)
			{
				dropItem = 208;
			}
			else if (Main.rand.Next(100) == 0)
			{
				dropItem = 195;
			}
			break;
		case 71:
		case 72:
			if (Main.rand.Next(40) == 0)
			{
				dropItem = 194;
			}
			else if (Main.rand.Next(2) == 0)
			{
				dropItem = 183;
			}
			break;
		case 50:
			if (tileCache.frameX == 90)
			{
				dropItem = 165;
			}
			else
			{
				dropItem = 149;
			}
			break;
		case 707:
			if (tileCache.frameX == 90)
			{
				dropItem = 165;
				noPrefix = true;
			}
			else
			{
				dropItem = 149;
			}
			break;
		case 83:
		case 84:
		{
			num = tileCache.frameX / 18;
			dropItem = 313 + num;
			int num2 = 307 + num;
			if (num == 6)
			{
				dropItem = 2358;
				num2 = 2357;
			}
			bool flag = IsHarvestableHerbWithSeed(tileCache.type, num, y);
			if (GetPlayerForTile(x, y).staffOfRegrowthBonus)
			{
				dropItemStack = Main.rand.Next(1, 3);
				secondaryItem = num2;
				secondaryItemStack = Main.rand.Next(1, 6);
			}
			else if (flag)
			{
				secondaryItem = num2;
				secondaryItemStack = Main.rand.Next(1, 4);
			}
			break;
		}
		case 589:
			SetGemTreeDrops(999, 4857, tileCache, ref dropItem, ref secondaryItem);
			if (dropItem == 3)
			{
				dropItemStack = Main.rand.Next(1, 3);
			}
			break;
		case 584:
			SetGemTreeDrops(181, 4852, tileCache, ref dropItem, ref secondaryItem);
			if (dropItem == 3)
			{
				dropItemStack = Main.rand.Next(1, 3);
			}
			break;
		case 583:
			SetGemTreeDrops(180, 4851, tileCache, ref dropItem, ref secondaryItem);
			if (dropItem == 3)
			{
				dropItemStack = Main.rand.Next(1, 3);
			}
			break;
		case 586:
			SetGemTreeDrops(179, 4854, tileCache, ref dropItem, ref secondaryItem);
			if (dropItem == 3)
			{
				dropItemStack = Main.rand.Next(1, 3);
			}
			break;
		case 585:
			SetGemTreeDrops(177, 4853, tileCache, ref dropItem, ref secondaryItem);
			if (dropItem == 3)
			{
				dropItemStack = Main.rand.Next(1, 3);
			}
			break;
		case 587:
			SetGemTreeDrops(178, 4855, tileCache, ref dropItem, ref secondaryItem);
			if (dropItem == 3)
			{
				dropItemStack = Main.rand.Next(1, 3);
			}
			break;
		case 588:
			SetGemTreeDrops(182, 4856, tileCache, ref dropItem, ref secondaryItem);
			if (dropItem == 3)
			{
				dropItemStack = Main.rand.Next(1, 3);
			}
			break;
		case 10:
		case 11:
		case 12:
		case 14:
		case 15:
		case 16:
		case 17:
		case 18:
		case 20:
		case 21:
		case 26:
		case 27:
		case 28:
		case 29:
		case 31:
		case 32:
		case 34:
		case 35:
		case 42:
		case 55:
		case 69:
		case 77:
		case 79:
		case 82:
		case 85:
		case 86:
		case 87:
		case 88:
		case 89:
		case 90:
		case 91:
		case 92:
		case 93:
		case 94:
		case 95:
		case 96:
		case 97:
		case 98:
		case 99:
		case 100:
		case 101:
		case 102:
		case 103:
		case 104:
		case 105:
		case 106:
		case 113:
		case 114:
		case 115:
		case 125:
		case 126:
		case 127:
		case 128:
		case 132:
		case 133:
		case 134:
		case 138:
		case 139:
		case 142:
		case 143:
		case 162:
		case 165:
		case 172:
		case 173:
		case 184:
		case 185:
		case 186:
		case 187:
		case 192:
		case 205:
		case 207:
		case 209:
		case 212:
		case 215:
		case 216:
		case 217:
		case 218:
		case 219:
		case 220:
		case 228:
		case 231:
		case 233:
		case 235:
		case 236:
		case 237:
		case 238:
		case 240:
		case 241:
		case 242:
		case 243:
		case 244:
		case 245:
		case 246:
		case 247:
		case 254:
		case 269:
		case 270:
		case 271:
		case 275:
		case 276:
		case 277:
		case 278:
		case 279:
		case 280:
		case 281:
		case 282:
		case 283:
		case 285:
		case 286:
		case 287:
		case 288:
		case 289:
		case 290:
		case 291:
		case 292:
		case 293:
		case 294:
		case 295:
		case 296:
		case 297:
		case 298:
		case 299:
		case 300:
		case 301:
		case 302:
		case 303:
		case 304:
		case 305:
		case 306:
		case 307:
		case 308:
		case 309:
		case 310:
		case 316:
		case 317:
		case 318:
		case 319:
		case 320:
		case 334:
		case 335:
		case 337:
		case 338:
		case 339:
		case 349:
		case 352:
		case 354:
		case 355:
		case 356:
		case 358:
		case 359:
		case 360:
		case 361:
		case 362:
		case 363:
		case 364:
		case 373:
		case 374:
		case 375:
		case 376:
		case 377:
		case 378:
		case 384:
		case 386:
		case 387:
		case 388:
		case 389:
		case 390:
		case 391:
		case 392:
		case 393:
		case 394:
		case 395:
		case 405:
		case 406:
		case 410:
		case 411:
		case 412:
		case 413:
		case 414:
		case 425:
		case 440:
		case 441:
		case 443:
		case 444:
		case 452:
		case 453:
		case 454:
		case 455:
		case 456:
		case 457:
		case 461:
		case 462:
		case 463:
		case 464:
		case 465:
		case 466:
		case 467:
		case 468:
		case 469:
		case 470:
		case 471:
		case 475:
		case 480:
		case 481:
		case 482:
		case 483:
		case 484:
		case 485:
		case 486:
		case 487:
		case 488:
		case 489:
		case 490:
		case 491:
		case 493:
		case 497:
		case 499:
		case 504:
		case 505:
		case 506:
		case 509:
		case 510:
		case 511:
		case 518:
		case 521:
		case 522:
		case 523:
		case 524:
		case 525:
		case 526:
		case 527:
		case 529:
		case 530:
		case 531:
		case 532:
		case 533:
		case 538:
		case 542:
		case 543:
		case 544:
		case 545:
		case 547:
		case 548:
		case 549:
		case 550:
		case 551:
		case 552:
		case 553:
		case 554:
		case 555:
		case 556:
		case 558:
		case 559:
		case 560:
		case 564:
		case 565:
		case 567:
		case 568:
		case 569:
		case 570:
		case 572:
		case 573:
		case 580:
		case 581:
		case 582:
		case 590:
		case 591:
		case 592:
		case 594:
		case 595:
		case 597:
		case 598:
		case 599:
		case 600:
		case 601:
		case 602:
		case 603:
		case 604:
		case 605:
		case 606:
		case 607:
		case 608:
		case 609:
		case 610:
		case 611:
		case 612:
		case 613:
		case 614:
		case 615:
		case 617:
		case 619:
		case 620:
		case 621:
		case 622:
		case 623:
		case 629:
		case 632:
		case 636:
		case 638:
		case 639:
		case 640:
		case 642:
		case 643:
		case 644:
		case 645:
		case 647:
		case 648:
		case 649:
		case 651:
		case 652:
		case 653:
		case 654:
		case 655:
		case 657:
		case 658:
		case 660:
		case 663:
		case 664:
		case 665:
		case 694:
		case 695:
		case 696:
		case 698:
		case 699:
		case 702:
		case 704:
		case 705:
		case 706:
		case 709:
		case 710:
		case 711:
		case 712:
		case 713:
		case 714:
		case 715:
		case 716:
		case 720:
		case 721:
		case 723:
		case 724:
		case 725:
		case 733:
			break;
		}
	}

	private static void SetGemTreeDrops(int gemType, int seedType, Tile tileCache, ref int dropItem, ref int secondaryItem)
	{
		if (Main.rand.Next(10) == 0)
		{
			dropItem = gemType;
		}
		else
		{
			dropItem = 3;
		}
		if (tileCache.frameX >= 22 && tileCache.frameY >= 198 && Main.rand.Next(2) == 0)
		{
			secondaryItem = seedType;
		}
	}

	private static void SetVanityTreeDrops(int dropType, Tile tileCache, ref int dropItem)
	{
		if (Main.rand.Next(2) == 0)
		{
			dropItem = dropType;
		}
	}

	public static bool IsHarvestableHerbWithSeed(int type, int style, int y)
	{
		switch (type)
		{
		case 82:
			return false;
		default:
			return false;
		case 83:
		case 84:
		{
			bool result = false;
			if (type == 84)
			{
				result = true;
			}
			if (IsAlchemyPlantHarvestable(style, y))
			{
				result = true;
			}
			return result;
		}
		}
	}

	public static bool IsAlchemyPlantHarvestable(int style, int y)
	{
		if (style == 0 && Main.dayTime)
		{
			return true;
		}
		if (style == 1 && !Main.dayTime)
		{
			return true;
		}
		if (style == 3 && !Main.dayTime && (Main.bloodMoon || Main.moonPhase == 0))
		{
			return true;
		}
		if (style == 4 && (Main.raining || Main.cloudAlpha > 0f))
		{
			return true;
		}
		if (style == 5 && (!Main.raining || (Main.remixWorld ? (y < GenVars.remixSurfaceLayerHigh) : ((double)y > Main.worldSurface))) && Main.time > 40500.0)
		{
			return true;
		}
		return false;
	}

	private static bool KillTile_ShouldDropSeeds(int x, int y)
	{
		if (Main.rand.Next(2) == 0)
		{
			if (!GetPlayerForTile(x, y).HasItem(281))
			{
				return GetPlayerForTile(x, y).HasItem(986);
			}
			return true;
		}
		return false;
	}

	private static void KillTile_GetTreeDrops(int i, int j, Tile tileCache, ref bool dropIsWood, ref bool bonusWood, ref int dropItem, ref int secondaryItem)
	{
		if (tileCache.frameX >= 22 && tileCache.frameY >= 198)
		{
			if (Main.netMode != 1)
			{
				if (genRand.Next(2) == 0)
				{
					if (TreeTypeDropsAcorns(GetTreeType(i, j)))
					{
						dropItem = 9;
						secondaryItem = 27;
					}
					else
					{
						dropItem = 9;
					}
				}
				else
				{
					dropItem = 9;
				}
			}
		}
		else
		{
			dropItem = 9;
		}
		if (dropItem != 9)
		{
			return;
		}
		dropIsWood = true;
		int bottomX;
		int bottomY;
		switch (GetTreeTypeAndTreeBottom(i, j, out bottomX, out bottomY))
		{
		case TreeTypes.Ash:
			dropItem = 5215;
			break;
		case TreeTypes.Corrupt:
			dropItem = 619;
			break;
		case TreeTypes.Crimson:
			dropItem = 911;
			break;
		case TreeTypes.Jungle:
			dropItem = 620;
			break;
		case TreeTypes.Hallowed:
			dropItem = 621;
			break;
		case TreeTypes.Mushroom:
			if (genRand.Next(2) == 0)
			{
				dropItem = 183;
			}
			else
			{
				dropItem = 0;
			}
			break;
		case TreeTypes.Snow:
			dropItem = 2503;
			break;
		}
		int num = Player.FindClosest(new Vector2(bottomX * 16, bottomY * 16), 16, 16);
		int axe = Main.player[num].inventory[Main.player[num].selectedItem].axe;
		if (genRand.Next(35) <= axe || Main.rand.Next(3) == 0)
		{
			bonusWood = true;
		}
	}

	private static void KillTile_DropBait(int i, int j, Tile tileCache)
	{
		int num = -1;
		int num2 = -1;
		int num3 = -1;
		int num4 = -1;
		int num5 = -1;
		int num6 = Player.FindClosest(new Vector2(i * 16, j * 16), 16, 16);
		if (tileCache.type == 3)
		{
			num = 400;
			num2 = 100;
			if (Main.player[num6].flowerBoots && tileCache.frameX >= 108)
			{
				num *= 10000;
				num2 *= 10000;
			}
		}
		if (tileCache.type == 73)
		{
			if (tileCache.frameX < 108)
			{
				num3 = 1000;
			}
			num = 200;
			num2 = 50;
			if (Main.player[num6].flowerBoots && tileCache.frameX >= 108)
			{
				num *= 10000;
				num2 *= 10000;
			}
		}
		if (tileCache.type == 637)
		{
			num5 = 100;
			if (Main.player[num6].flowerBoots && tileCache.frameX >= 108)
			{
				num5 *= 10000;
			}
		}
		if (tileCache.type == 61)
		{
			num4 = 80;
			if (Main.player[num6].flowerBoots && tileCache.frameX >= 108)
			{
				num4 *= 10000;
			}
		}
		if (tileCache.type == 74)
		{
			num4 = 40;
			if (Main.player[num6].flowerBoots && tileCache.frameX >= 108)
			{
				num4 *= 10000;
			}
		}
		if (tileCache.type == 62)
		{
			num4 = 250;
		}
		if (tileCache.type == 185)
		{
			if (tileCache.frameY == 0 && tileCache.frameX < 214)
			{
				num = 6;
			}
			if (tileCache.frameY == 18 && (tileCache.frameX < 214 || tileCache.frameX >= 1368))
			{
				num = 6;
			}
		}
		else if (tileCache.type == 186)
		{
			if (tileCache.frameX >= 378 && tileCache.frameX <= 700)
			{
				num = 6;
			}
		}
		else if (tileCache.type == 187)
		{
			if (tileCache.frameX >= 756 && tileCache.frameX <= 916)
			{
				num = 6;
			}
			if (tileCache.frameX <= 322)
			{
				num = 6;
			}
		}
		else if (tileCache.type == 233)
		{
			num4 = 10;
		}
		int num7 = 357;
		if (Main.player[num6].ZoneGraveyard)
		{
			num7 = 606;
		}
		if (num > 0 && NPC.CountNPCS(num7) < 5 && genRand.Next(num) == 0)
		{
			int type = num7;
			if (num7 == 357 && Player.GetClosestRollLuck(i, j, NPC.goldCritterChance) == 0f)
			{
				type = 448;
			}
			int num8 = NPC.NewNPC(GetNPCSource_TileBreak(i, j), i * 16 + 10, j * 16, type);
			Main.npc[num8].TargetClosest();
			Main.npc[num8].velocity.Y = (float)genRand.Next(-50, -21) * 0.1f;
			Main.npc[num8].velocity.X = (float)genRand.Next(0, 26) * 0.1f * (float)(-Main.npc[num8].direction);
			Main.npc[num8].direction *= -1;
			Main.npc[num8].netUpdate = true;
		}
		if (num3 > 0 && genRand.Next(num3) == 0)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 5574);
		}
		if (num2 > 0 && NPC.CountNPCS(377) < 5 && genRand.Next(num2) == 0)
		{
			int type2 = 377;
			if (Player.GetClosestRollLuck(i, j, NPC.goldCritterChance) == 0f)
			{
				type2 = 446;
			}
			int num9 = NPC.NewNPC(GetNPCSource_TileBreak(i, j), i * 16 + 10, j * 16, type2);
			Main.npc[num9].TargetClosest();
			Main.npc[num9].velocity.Y = (float)genRand.Next(-50, -21) * 0.1f;
			Main.npc[num9].velocity.X = (float)genRand.Next(0, 26) * 0.1f * (float)(-Main.npc[num9].direction);
			Main.npc[num9].direction *= -1;
			Main.npc[num9].netUpdate = true;
		}
		if (num4 > 0 && NPC.CountNPCS(485) + NPC.CountNPCS(486) + NPC.CountNPCS(487) < 8 && genRand.Next((int)((double)num4 * 1.25)) == 0)
		{
			int type3 = 485;
			if (genRand.Next(4) == 0)
			{
				type3 = 486;
			}
			if (genRand.Next(12) == 0)
			{
				type3 = 487;
			}
			int num10 = NPC.NewNPC(GetNPCSource_TileBreak(i, j), i * 16 + 10, j * 16, type3);
			Main.npc[num10].TargetClosest();
			Main.npc[num10].velocity.Y = (float)genRand.Next(-50, -21) * 0.1f;
			Main.npc[num10].velocity.X = (float)genRand.Next(0, 26) * 0.1f * (float)(-Main.npc[num10].direction);
			Main.npc[num10].direction *= -1;
			Main.npc[num10].netUpdate = true;
		}
		if (num5 > 0 && NPC.CountNPCS(654) + NPC.CountNPCS(653) < 8 && genRand.Next(num5) == 0)
		{
			int type4 = 653;
			if (genRand.Next(2) == 0)
			{
				type4 = 654;
			}
			int num11 = NPC.NewNPC(GetNPCSource_TileBreak(i, j), i * 16 + 10, j * 16, type4);
			Main.npc[num11].TargetClosest();
			Main.npc[num11].velocity.Y = (float)genRand.Next(-50, -21) * 0.1f;
			Main.npc[num11].velocity.X = (float)genRand.Next(0, 26) * 0.1f * (float)(-Main.npc[num11].direction);
			Main.npc[num11].direction *= -1;
			Main.npc[num11].netUpdate = true;
		}
	}

	public static void KillTile_PlaySounds(int i, int j, bool fail, Tile tileCache)
	{
		if (isGeneratingOrLoadingWorld)
		{
			return;
		}
		int type = tileCache.type;
		if (type == 127 || type == 623)
		{
			SoundEngine.PlaySound(SoundID.Item27, i * 16, j * 16);
		}
		else if (type == 147 || type == 224)
		{
			if (genRand.Next(2) == 0)
			{
				SoundEngine.PlaySound(SoundID.Item48, i * 16, j * 16);
			}
			else
			{
				SoundEngine.PlaySound(SoundID.Item49, i * 16, j * 16);
			}
		}
		else if (type == 161 || type == 163 || type == 164 || type == 200 || type == 541 || type == 736)
		{
			SoundEngine.PlaySound(SoundID.Item50, i * 16, j * 16);
		}
		else if (type == 518 || type == 519 || type == 528 || type == 529 || type == 549 || type == 637 || type == 638 || type == 636)
		{
			SoundEngine.PlaySound(6, i * 16, j * 16);
		}
		else if (type == 530 && tileCache.frameX < 270)
		{
			SoundEngine.PlaySound(6, i * 16, j * 16);
		}
		else if (type == 705 && tileCache.frameX % 6 < 270)
		{
			SoundEngine.PlaySound(6, i * 16, j * 16);
		}
		else
		{
			switch (type)
			{
			case 3:
			case 110:
				SoundEngine.PlaySound(6, i * 16, j * 16);
				break;
			case 254:
				SoundEngine.PlaySound(6, i * 16, j * 16);
				break;
			case 24:
				SoundEngine.PlaySound(6, i * 16, j * 16);
				break;
			default:
				if (Main.tileAlch[type] || type == 384 || type == 227 || type == 32 || type == 51 || type == 697 || type == 52 || type == 61 || type == 703 || type == 62 || type == 69 || type == 655 || type == 71 || type == 73 || type == 74 || type == 113 || type == 115 || type == 184 || type == 192 || type == 205 || type == 233 || type == 352 || type == 382 || type == 624 || type == 656 || type == 700 || type == 701)
				{
					SoundEngine.PlaySound(6, i * 16, j * 16);
					break;
				}
				if (type == 485)
				{
					SoundEngine.PlaySound(4, i * 16, j * 16, 11);
					break;
				}
				if (type == 201)
				{
					SoundEngine.PlaySound(6, i * 16, j * 16);
					break;
				}
				if (type == 481 || type == 482 || type == 483)
				{
					SoundEngine.PlaySound(SoundID.Item127, i * 16, j * 16);
					break;
				}
				if (type == 1 || type == 6 || type == 7 || type == 8 || type == 9 || type == 22 || type == 140 || type == 25 || type == 37 || type == 38 || type == 39 || type == 41 || type == 43 || type == 44 || type == 45 || type == 46 || type == 47 || type == 48 || type == 56 || type == 58 || type == 63 || type == 64 || type == 65 || type == 66 || type == 67 || type == 68 || type == 75 || type == 76 || type == 107 || type == 108 || type == 111 || type == 117 || type == 118 || type == 119 || type == 120 || type == 121 || type == 122 || type == 150 || type == 151 || type == 152 || type == 153 || type == 154 || type == 155 || type == 156 || type == 160 || type == 161 || type == 166 || type == 167 || type == 168 || type == 169 || type == 175 || type == 176 || type == 177 || type == 203 || type == 202 || type == 204 || type == 206 || type == 211 || type == 221 || type == 222 || type == 223 || type == 226 || type == 248 || type == 249 || type == 250 || type == 272 || type == 273 || type == 274 || type == 478 || type == 284 || type == 325 || type == 346 || type == 347 || type == 348 || type == 350 || type == 367 || type == 357 || type == 368 || type == 369 || type == 370 || type == 407 || type == 472 || type == 473 || type == 500 || type == 501 || type == 502 || type == 503 || type == 546 || type == 557 || type == 566 || type == 618 || type == 408 || type == 409 || type == 669 || type == 670 || type == 671 || type == 672 || type == 673 || type == 674 || type == 675 || type == 676 || type == 677 || type == 678 || type == 679 || type == 680 || type == 681 || type == 682 || type == 683 || type == 684 || type == 685 || type == 686 || type == 687 || type == 689 || type == 688 || type == 690 || type == 691 || type == 692 || type == 726 || type == 749 || type == 747 || type == 743 || type == 735 || type == 737 || type == 745 || type == 750)
				{
					SoundEngine.PlaySound(21, i * 16, j * 16);
					break;
				}
				if (type == 666)
				{
					SoundEngine.PlaySound(SoundID.Item177, i * 16, j * 16);
					break;
				}
				if (type == 739)
				{
					SoundEngine.PlaySound(SoundID.NPCHit25, i * 16, j * 16);
					break;
				}
				if (type == 231 || type == 195 || type == 474)
				{
					SoundEngine.PlaySound(4, i * 16, j * 16);
					if (type == 231)
					{
						SoundEngine.PlaySound(SoundID.Item173, i * 16, j * 16);
					}
					break;
				}
				if ((type == 26 || type == 695) && tileCache.frameX >= 54)
				{
					SoundEngine.PlaySound(4, i * 16, j * 16);
					break;
				}
				switch (type)
				{
				case 314:
					SoundEngine.PlaySound(SoundID.Item52, i * 16, j * 16);
					break;
				case 330:
				case 331:
				case 332:
				case 333:
					SoundEngine.PlaySound(18, i * 16, j * 16);
					break;
				default:
					if ((type == 162 || type == 385 || type == 129 || (type == 165 && tileCache.frameX < 54)) && !fail)
					{
						SoundEngine.PlaySound(SoundID.Item27, i * 16, j * 16);
					}
					else if (type != 138)
					{
						SoundEngine.PlaySound(0, i * 16, j * 16);
					}
					break;
				}
				break;
			}
		}
		if (!fail)
		{
			switch (tileCache.type)
			{
			case 13:
			case 54:
			case 326:
			case 327:
			case 328:
			case 329:
			case 345:
			case 458:
			case 459:
			case 507:
			case 508:
			case 708:
			case 748:
				SoundEngine.PlaySound(13, i * 16, j * 16);
				break;
			}
		}
	}

	public static Rectangle? GetTileVisualHitbox(int x, int y)
	{
		Tile tile = Main.tile[x, y];
		if (tile == null || !tile.nactive())
		{
			return null;
		}
		Rectangle value = new Rectangle(x * 16, y * 16, 16, 16);
		ushort type = tile.type;
		if (type == 323)
		{
			value.X += tile.frameY;
		}
		if (tile.halfBrick())
		{
			value.Y += 8;
			value.Height = 8;
		}
		return value;
	}

	public static int KillTile_GetTileDustAmount(bool fail, Tile tileCache)
	{
		switch (tileCache.type)
		{
		default:
			if (!fail)
			{
				return 10;
			}
			return 3;
		case 654:
			return 0;
		case 630:
		case 631:
			return 0;
		case 231:
			if (!fail)
			{
				return 6;
			}
			return 3;
		case 481:
		case 482:
		case 483:
			return 3;
		case 541:
			return 1;
		case 549:
			return 2;
		case 125:
		case 138:
		case 172:
		case 287:
		case 300:
		case 301:
		case 302:
		case 303:
		case 304:
		case 305:
		case 306:
		case 307:
		case 308:
		case 354:
		case 355:
		case 373:
		case 374:
		case 375:
		case 376:
		case 461:
		case 484:
		case 499:
		case 564:
		case 565:
		case 593:
		case 594:
		case 617:
		case 664:
		case 665:
		case 699:
		case 709:
		case 711:
		case 712:
		case 713:
		case 714:
		case 715:
		case 716:
			return 0;
		case 534:
		case 536:
		case 539:
		case 625:
		case 627:
			if (!fail)
			{
				return 5;
			}
			return 3;
		case 184:
			if (tileCache.frameX / 22 >= 5)
			{
				return 5;
			}
			if (!fail)
			{
				return 10;
			}
			return 3;
		}
	}

	public static int KillTile_MakeTileDust(int i, int j, Tile tileCache)
	{
		int num = 0;
		if (tileCache.type == 216)
		{
			num = -1;
		}
		if (tileCache.type == 324)
		{
			num = ((tileCache.frameY != 0) ? (281 + tileCache.frameX / 18) : 280);
		}
		if (tileCache.type == 216)
		{
			num = -1;
		}
		if (tileCache.type == 335)
		{
			num = -1;
		}
		if (tileCache.type == 338)
		{
			num = -1;
		}
		if (tileCache.type == 0)
		{
			num = 0;
		}
		if (tileCache.type == 192)
		{
			num = 3;
		}
		if (tileCache.type == 208)
		{
			num = 126;
		}
		else if (tileCache.type == 408 || tileCache.type == 409)
		{
			num = 265;
		}
		else if (tileCache.type == 669)
		{
			num = 314;
		}
		else if (tileCache.type == 670)
		{
			num = 315;
		}
		else if (tileCache.type == 671)
		{
			num = 316;
		}
		else if (tileCache.type == 672)
		{
			num = 317;
		}
		else if (tileCache.type == 673)
		{
			num = 318;
		}
		else if (tileCache.type == 674)
		{
			num = 319;
		}
		else if (tileCache.type == 675)
		{
			num = 320;
		}
		else if (tileCache.type == 676)
		{
			num = 321;
		}
		if (tileCache.type == 16)
		{
			num = 1;
			if (tileCache.frameX >= 36)
			{
				num = 82;
			}
		}
		else if (tileCache.type == 415 || tileCache.type == 500)
		{
			num = 6;
		}
		else if (tileCache.type == 416 || tileCache.type == 501)
		{
			num = 61;
		}
		else if (tileCache.type == 417 || tileCache.type == 502)
		{
			num = 242;
		}
		else if (tileCache.type == 418 || tileCache.type == 503)
		{
			num = 135;
		}
		else if (tileCache.type == 474)
		{
			num = 18;
		}
		if (tileCache.type == 1 || tileCache.type == 17 || tileCache.type == 38 || tileCache.type == 39 || tileCache.type == 41 || tileCache.type == 43 || tileCache.type == 44 || tileCache.type == 481 || tileCache.type == 482 || tileCache.type == 483 || tileCache.type == 48 || Main.tileStone[tileCache.type] || tileCache.type == 85 || tileCache.type == 90 || tileCache.type == 92 || tileCache.type == 96 || tileCache.type == 97 || tileCache.type == 99 || tileCache.type == 117 || tileCache.type == 130 || tileCache.type == 131 || tileCache.type == 132 || tileCache.type == 135 || tileCache.type == 142 || tileCache.type == 143 || tileCache.type == 144 || tileCache.type == 210 || tileCache.type == 207 || tileCache.type == 235 || tileCache.type == 247 || tileCache.type == 272 || tileCache.type == 273 || tileCache.type == 283 || tileCache.type == 410 || tileCache.type == 480 || tileCache.type == 509 || tileCache.type == 618 || tileCache.type == 657 || tileCache.type == 658 || tileCache.type == 677 || tileCache.type == 678 || tileCache.type == 679 || tileCache.type == 720 || tileCache.type == 721 || tileCache.type == 725 || tileCache.type == 733)
		{
			num = 1;
		}
		if (tileCache.type == 379)
		{
			num = 257;
		}
		if (tileCache.type == 751 || tileCache.type == 752)
		{
			num = -1;
		}
		if (tileCache.type == 311)
		{
			num = 207;
		}
		if (tileCache.type == 312)
		{
			num = 208;
		}
		if (tileCache.type == 313)
		{
			num = 209;
		}
		if (tileCache.type == 104)
		{
			num = -1;
		}
		if (tileCache.type == 95 || tileCache.type == 98 || tileCache.type == 100 || tileCache.type == 174 || tileCache.type == 173)
		{
			num = 6;
		}
		if (tileCache.type == 30 || tileCache.type == 86 || tileCache.type == 94 || tileCache.type == 106 || tileCache.type == 114 || tileCache.type == 124 || tileCache.type == 128 || tileCache.type == 269)
		{
			num = 7;
		}
		if (tileCache.type == 372)
		{
			num = 242;
		}
		if (tileCache.type == 646)
		{
			num = 29;
		}
		if (tileCache.type == 49)
		{
			num = 29;
		}
		if (tileCache.type == 371)
		{
			num = 243;
		}
		if (tileCache.type == 334)
		{
			num = 7;
		}
		switch (tileCache.type)
		{
		case 10:
		case 11:
		case 87:
		case 89:
		case 93:
		case 139:
		case 209:
		case 319:
		case 320:
		case 386:
		case 387:
		case 390:
		case 405:
		case 406:
		case 411:
		case 412:
		case 419:
		case 420:
		case 421:
		case 422:
		case 423:
		case 424:
		case 425:
		case 428:
		case 429:
		case 441:
		case 442:
		case 445:
		case 446:
		case 447:
		case 448:
		case 449:
		case 450:
		case 451:
		case 452:
		case 453:
		case 455:
		case 456:
		case 457:
		case 462:
		case 463:
		case 464:
		case 465:
		case 466:
		case 468:
		case 476:
		case 486:
		case 487:
		case 489:
		case 490:
		case 491:
		case 493:
		case 494:
		case 497:
		case 510:
		case 511:
		case 520:
		case 521:
		case 522:
		case 523:
		case 524:
		case 525:
		case 526:
		case 527:
		case 531:
		case 545:
		case 547:
		case 548:
		case 560:
		case 564:
		case 565:
		case 567:
		case 572:
		case 579:
		case 591:
		case 592:
		case 593:
		case 594:
		case 613:
		case 614:
		case 621:
		case 622:
		case 623:
		case 624:
		case 630:
		case 631:
		case 656:
		case 700:
		case 701:
		case 726:
			num = -1;
			break;
		case 668:
			num = 0;
			break;
		case 407:
			num = 10;
			break;
		case 454:
			num = 139;
			break;
		case 41:
		case 481:
		case 677:
			num = 275;
			break;
		case 43:
		case 482:
		case 678:
			num = 276;
			break;
		case 44:
		case 483:
		case 679:
			num = 277;
			break;
		case 473:
			num = 82;
			break;
		case 472:
		case 546:
		case 557:
			num = 8;
			break;
		case 498:
			num = 30;
			break;
		case 517:
		case 687:
			num = 258;
			break;
		case 535:
		case 689:
			num = 299;
			break;
		case 537:
		case 690:
			num = 300;
			break;
		case 540:
		case 688:
			num = 301;
			break;
		case 626:
		case 691:
			num = 305;
			break;
		case 184:
		{
			int num2 = tileCache.frameX / 22;
			num = num2 switch
			{
				5 => 258, 
				6 => 299, 
				7 => 300, 
				8 => 301, 
				9 => 305, 
				10 => 267, 
				_ => 93 + num2, 
			};
			break;
		}
		case 515:
			num = 96;
			break;
		case 516:
			num = 97;
			break;
		case 514:
			num = 95;
			break;
		case 513:
			num = 94;
			break;
		case 512:
			num = 93;
			break;
		case 541:
			num = 226;
			break;
		case 590:
			num = 1;
			break;
		case 583:
			num = ((genRand.Next(10) != 0) ? 1 : 87);
			break;
		case 584:
			num = ((genRand.Next(10) != 0) ? 1 : 86);
			break;
		case 585:
			num = ((genRand.Next(10) != 0) ? 1 : 88);
			break;
		case 586:
			num = ((genRand.Next(10) != 0) ? 1 : 89);
			break;
		case 587:
			num = ((genRand.Next(10) != 0) ? 1 : 90);
			break;
		case 588:
			num = ((genRand.Next(10) != 0) ? 1 : 91);
			break;
		case 589:
			num = ((genRand.Next(10) != 0) ? 1 : 138);
			break;
		case 595:
			num = 78;
			break;
		case 596:
			num = 78;
			break;
		case 615:
			num = 78;
			break;
		case 616:
			num = 78;
			break;
		case 633:
			num = ((genRand.Next(6) != 0) ? 237 : 36);
			break;
		case 637:
		case 638:
			num = 237;
			break;
		case 634:
			num = ((genRand.Next(10) != 0) ? 36 : 31);
			if (genRand.Next(12) == 0)
			{
				num = 6;
			}
			break;
		}
		if (Main.tileMoss[tileCache.type])
		{
			num = ((tileCache.type == 381) ? 258 : ((tileCache.type == 534) ? 299 : ((tileCache.type == 536) ? 300 : ((tileCache.type == 539) ? 301 : ((tileCache.type == 625) ? 305 : ((tileCache.type != 627) ? (tileCache.type - 179 + 93) : 267))))));
		}
		if (tileCache.type == 240)
		{
			int num3 = tileCache.frameX / 54;
			if (tileCache.frameY >= 54)
			{
				num3 += 36 * (tileCache.frameY / 54);
			}
			num = 7;
			if (num3 == 16 || num3 == 17)
			{
				num = 26;
			}
			if (num3 >= 46 && num3 <= 49)
			{
				num = -1;
			}
			if (num3 == 100)
			{
				num = -1;
			}
		}
		if (tileCache.type == 241)
		{
			num = 1;
		}
		if (tileCache.type == 242)
		{
			num = -1;
		}
		if (tileCache.type == 529)
		{
			num = (int)Main.tile[i, j + 1].type switch
			{
				116 => num = 47, 
				234 => num = 125, 
				112 => num = 17, 
				_ => (i >= beachDistance && i <= Main.maxTilesX - beachDistance) ? 289 : 290, 
			};
		}
		if (tileCache.type == 356)
		{
			num = -1;
		}
		if (tileCache.type == 663)
		{
			num = -1;
		}
		if (tileCache.type == 351)
		{
			num = -1;
		}
		if (tileCache.type == 246)
		{
			num = -1;
		}
		if (tileCache.type == 36)
		{
			num = -1;
		}
		if (tileCache.type == 365)
		{
			num = 239;
		}
		if (tileCache.type == 366)
		{
			num = 30;
		}
		if (tileCache.type == 504)
		{
			num = -1;
		}
		if (tileCache.type == 357 || tileCache.type == 367 || tileCache.type == 561)
		{
			num = 236;
		}
		if (tileCache.type == 368 || tileCache.type == 369 || tileCache.type == 576)
		{
			num = 240;
		}
		if (tileCache.type == 170)
		{
			num = 196;
		}
		if (tileCache.type == 315)
		{
			num = 225;
		}
		if (tileCache.type == 641)
		{
			num = ((genRand.Next(2) != 0) ? 161 : 243);
		}
		if (tileCache.type == 659)
		{
			num = 308;
		}
		if (tileCache.type == 667)
		{
			num = 308;
		}
		if (tileCache.type == 346)
		{
			num = 128;
		}
		if (tileCache.type == 347)
		{
			num = 117;
		}
		if (tileCache.type == 348)
		{
			num = 42;
		}
		if (tileCache.type == 350)
		{
			num = 226;
		}
		if (tileCache.type == 370)
		{
			num = ((genRand.Next(2) != 0) ? 23 : 6);
		}
		if (tileCache.type == 171)
		{
			num = ((genRand.Next(2) != 0) ? (-1) : 196);
		}
		if (tileCache.type == 326)
		{
			num = 13;
		}
		if (tileCache.type == 327)
		{
			num = 13;
		}
		if (tileCache.type == 345)
		{
			num = 13;
		}
		if (tileCache.type == 708)
		{
			num = 13;
		}
		if (tileCache.type == 458)
		{
			num = 13;
		}
		if (tileCache.type == 459)
		{
			num = 13;
		}
		if (tileCache.type == 336)
		{
			num = 6;
		}
		if (tileCache.type == 340)
		{
			num = 75;
		}
		if (tileCache.type == 341)
		{
			num = 65;
		}
		if (tileCache.type == 342)
		{
			num = 135;
		}
		if (tileCache.type == 343)
		{
			num = 169;
		}
		if (tileCache.type == 344)
		{
			num = 156;
		}
		if (tileCache.type == 328)
		{
			num = 13;
		}
		if (tileCache.type == 329)
		{
			num = 13;
		}
		if (tileCache.type == 507)
		{
			num = 13;
		}
		if (tileCache.type == 508)
		{
			num = 13;
		}
		if (tileCache.type == 562)
		{
			num = 273;
		}
		if (tileCache.type == 571)
		{
			num = 40;
		}
		if (tileCache.type == 563)
		{
			num = 273;
		}
		if (tileCache.type == 330)
		{
			num = 9;
		}
		if (tileCache.type == 331)
		{
			num = 11;
		}
		if (tileCache.type == 332)
		{
			num = 19;
		}
		if (tileCache.type == 333)
		{
			num = 11;
		}
		if (tileCache.type == 722)
		{
			num = 57;
		}
		if (tileCache.type == 734)
		{
			num = 0;
		}
		if (tileCache.type == 735)
		{
			num = 10;
		}
		if (tileCache.type == 736)
		{
			num = 277;
		}
		if (tileCache.type == 737)
		{
			num = 26;
		}
		if (tileCache.type == 738)
		{
			num = 277;
		}
		if (tileCache.type == 739)
		{
			num = 68;
		}
		if (tileCache.type == 740)
		{
			num = 1;
		}
		if (tileCache.type == 741)
		{
			num = 78;
		}
		switch (tileCache.type)
		{
		case 750:
			num = 26;
			break;
		case 749:
			num = 1;
			break;
		case 748:
			num = 13;
			break;
		case 747:
			num = 10;
			break;
		case 746:
			num = 148;
			break;
		case 745:
			num = 26;
			break;
		case 744:
			num = 78;
			break;
		case 742:
			num = 96;
			break;
		case 743:
			num = 236;
			break;
		}
		if (tileCache.type == 101)
		{
			num = -1;
		}
		if (tileCache.type == 19)
		{
			num = (tileCache.frameY / 18) switch
			{
				0 => 7, 
				1 => 77, 
				2 => 78, 
				3 => 79, 
				4 => 26, 
				5 => 126, 
				6 => 275, 
				7 => 277, 
				8 => 276, 
				9 => 1, 
				10 => 214, 
				11 => 214, 
				12 => 214, 
				13 => 109, 
				14 => 13, 
				15 => 189, 
				16 => 191, 
				17 => 215, 
				18 => 26, 
				19 => 214, 
				20 => 4, 
				21 => 10, 
				22 => 32, 
				23 => 78, 
				24 => 147, 
				25 => 40, 
				26 => 226, 
				27 => 23, 
				28 => 240, 
				29 => 236, 
				30 => 68 + Main.rand.Next(3), 
				31 => 10, 
				32 => 78, 
				33 => 148, 
				34 => 5, 
				35 => 80, 
				37 => 18, 
				38 => 6, 
				39 => 61, 
				40 => 242, 
				41 => 135, 
				42 => 287, 
				44 => 273, 
				45 => 243, 
				46 => 243, 
				47 => 36, 
				48 => 226, 
				49 => 16, 
				50 => 309, 
				_ => 1, 
			};
		}
		if (tileCache.type == 79)
		{
			int num4 = tileCache.frameY / 36;
			num = ((num4 == 0) ? 7 : ((num4 == 1) ? 77 : ((num4 == 2) ? 78 : ((num4 == 3) ? 79 : ((num4 == 4) ? 126 : ((num4 == 8) ? 109 : ((num4 < 9) ? 1 : (-1))))))));
		}
		if (tileCache.type == 18)
		{
			switch (tileCache.frameX / 36)
			{
			case 0:
				num = 7;
				break;
			case 1:
				num = 77;
				break;
			case 2:
				num = 78;
				break;
			case 3:
				num = 79;
				break;
			case 4:
				num = 26;
				break;
			case 5:
				num = 40;
				break;
			case 6:
				num = 5;
				break;
			case 7:
				num = 26;
				break;
			case 8:
				num = 4;
				break;
			case 9:
				num = 126;
				break;
			case 10:
				num = 148;
				break;
			case 11:
			case 12:
			case 13:
				num = 1;
				break;
			case 14:
				num = 109;
				break;
			case 15:
				num = 126;
				break;
			default:
				num = -1;
				break;
			}
		}
		if (tileCache.type == 14 || tileCache.type == 87 || tileCache.type == 88 || tileCache.type == 469)
		{
			num = -1;
		}
		if (tileCache.type >= 255 && tileCache.type <= 261)
		{
			int num5 = tileCache.type - 255;
			num = 86 + num5;
			if (num5 == 6)
			{
				num = 138;
			}
		}
		if (tileCache.type >= 262 && tileCache.type <= 268)
		{
			int num6 = tileCache.type - 262;
			num = 86 + num6;
			if (num6 == 6)
			{
				num = 138;
			}
		}
		if (tileCache.type == 178)
		{
			int num7 = tileCache.frameX / 18;
			num = 86 + num7;
			if (num7 == 6)
			{
				num = 138;
			}
		}
		if (tileCache.type == 440)
		{
			num = (tileCache.frameX / 54) switch
			{
				0 => 90, 
				1 => 88, 
				2 => 89, 
				3 => 87, 
				4 => 86, 
				5 => 91, 
				6 => 138, 
				_ => -1, 
			};
			if (tileCache.frameY < 54)
			{
				num = -1;
			}
		}
		switch (tileCache.type)
		{
		case 426:
		case 427:
		case 727:
			num = 90;
			break;
		case 430:
		case 435:
		case 728:
			num = 89;
			break;
		case 431:
		case 436:
		case 729:
			num = 88;
			break;
		case 432:
		case 437:
		case 730:
			num = 87;
			break;
		case 433:
		case 438:
		case 731:
			num = 86;
			break;
		case 434:
		case 439:
		case 732:
			num = 91;
			break;
		case 496:
			num = 109;
			break;
		case 549:
			num = 3;
			break;
		case 552:
			num = 32;
			break;
		}
		if (tileCache.type == 186)
		{
			num = ((tileCache.frameX <= 360) ? 26 : ((tileCache.frameX <= 846) ? 1 : ((tileCache.frameX <= 954) ? 9 : ((tileCache.frameX <= 1062) ? 11 : ((tileCache.frameX <= 1170) ? 10 : ((tileCache.frameX > 1332) ? ((tileCache.frameX > 1386) ? 80 : 10) : 0))))));
		}
		if (tileCache.type == 187)
		{
			if (tileCache.frameX <= 144)
			{
				num = 1;
			}
			else if (tileCache.frameX <= 306)
			{
				num = 38;
			}
			else if (tileCache.frameX <= 468)
			{
				num = 36;
			}
			else if (tileCache.frameX <= 738)
			{
				num = 30;
			}
			else if (tileCache.frameX <= 970)
			{
				num = 1;
			}
			else if (tileCache.frameX <= 1132)
			{
				num = 148;
			}
			else if (tileCache.frameX <= 1132)
			{
				num = 155;
			}
			else if (tileCache.frameX <= 1348)
			{
				num = 1;
			}
			else if (tileCache.frameX <= 1564)
			{
				num = 0;
			}
			else if (tileCache.frameX <= 1890)
			{
				num = 250;
			}
			else if (tileCache.frameX <= 2196)
			{
				num = 240;
			}
			else if (tileCache.frameX <= 2520)
			{
				num = 236;
			}
		}
		if (tileCache.type == 647)
		{
			int num8 = tileCache.frameX / 54;
			if (num8 < 7)
			{
				num = 26;
			}
			else if (num8 < 16)
			{
				num = 1;
			}
			else if (num8 < 18)
			{
				num = 9;
			}
			else if (num8 < 20)
			{
				num = 11;
			}
			else if (num8 < 22)
			{
				num = 10;
			}
			else if (num8 < 26)
			{
				num = 7;
			}
			else if (num8 < 32)
			{
				num = 80;
			}
			else if (num8 < 35)
			{
				num = 80;
			}
		}
		if (tileCache.type == 648)
		{
			int num9 = tileCache.frameX / 54;
			num9 += tileCache.frameY / 36 * 35;
			if (num9 < 3)
			{
				num = 1;
			}
			else if (num9 < 6)
			{
				num = 38;
			}
			else if (num9 < 9)
			{
				num = 36;
			}
			else if (num9 < 14)
			{
				num = 30;
			}
			else if (num9 < 17)
			{
				num = 1;
			}
			else if (num9 < 18)
			{
				num = 1;
			}
			else if (num9 < 21)
			{
				num = 148;
			}
			else if (num9 < 29)
			{
				num = 155;
			}
			else if (num9 < 35)
			{
				num = 287;
			}
			else if (num9 < 41)
			{
				num = 240;
			}
			else if (num9 < 47)
			{
				num = 236;
			}
			else if (num9 < 50)
			{
				num = 0;
			}
			else if (num9 < 52)
			{
				num = 2;
			}
			else if (num9 < 55)
			{
				num = 26;
			}
		}
		if (tileCache.type == 706)
		{
			num = 1;
		}
		if (tileCache.type == 105)
		{
			num = 1;
			if (tileCache.frameX >= 1548 && tileCache.frameX <= 1654 && tileCache.frameY < 54)
			{
				num = 148;
			}
		}
		if (tileCache.type == 349)
		{
			num = 1;
		}
		if (tileCache.type == 337 || tileCache.type == 506)
		{
			num = 1;
		}
		if (tileCache.type == 239)
		{
			int num10 = tileCache.frameX / 18;
			if (num10 == 0)
			{
				num = 9;
			}
			if (num10 == 1)
			{
				num = 81;
			}
			if (num10 == 2)
			{
				num = 8;
			}
			if (num10 == 3)
			{
				num = 82;
			}
			if (num10 == 4)
			{
				num = 11;
			}
			if (num10 == 5)
			{
				num = 83;
			}
			if (num10 == 6)
			{
				num = 10;
			}
			if (num10 == 7)
			{
				num = 84;
			}
			if (num10 == 8)
			{
				num = 14;
			}
			if (num10 == 9)
			{
				num = 23;
			}
			if (num10 == 10)
			{
				num = 25;
			}
			if (num10 == 11)
			{
				num = 48;
			}
			if (num10 == 12)
			{
				num = 144;
			}
			if (num10 == 13)
			{
				num = 49;
			}
			if (num10 == 14)
			{
				num = 145;
			}
			if (num10 == 15)
			{
				num = 50;
			}
			if (num10 == 16)
			{
				num = 146;
			}
			if (num10 == 17)
			{
				num = 128;
			}
			if (num10 == 18)
			{
				num = 84;
			}
			if (num10 == 19)
			{
				num = 117;
			}
			if (num10 == 20)
			{
				num = 42;
			}
			if (num10 == 21)
			{
				num = -1;
			}
			if (num10 == 22)
			{
				num = 265;
			}
		}
		if (tileCache.type == 185)
		{
			if (tileCache.frameY == 18)
			{
				int num11 = tileCache.frameX / 36;
				if (num11 < 6)
				{
					num = 1;
				}
				else if (num11 < 16)
				{
					num = 26;
				}
				else if (num11 == 16)
				{
					num = 9;
				}
				else if (num11 == 17)
				{
					num = 11;
				}
				else if (num11 == 18)
				{
					num = 10;
				}
				else if (num11 == 19)
				{
					num = 86;
				}
				else if (num11 == 20)
				{
					num = 87;
				}
				else if (num11 == 21)
				{
					num = 88;
				}
				else if (num11 == 22)
				{
					num = 89;
				}
				else if (num11 == 23)
				{
					num = 90;
				}
				else if (num11 == 24)
				{
					num = 91;
				}
				else if (num11 < 31)
				{
					num = 80;
				}
				else if (num11 < 33)
				{
					num = 7;
				}
				else if (num11 < 34)
				{
					num = 8;
				}
				else if (num11 < 38)
				{
					num = 30;
				}
				else if (num11 < 41)
				{
					num = 1;
				}
				else if (num11 < 47)
				{
					num = 287;
				}
				else if (num11 < 53)
				{
					num = 240;
				}
				else if (num11 < 59)
				{
					num = 236;
				}
			}
			else
			{
				int num12 = tileCache.frameX / 18;
				if (num12 < 6)
				{
					num = 1;
				}
				else if (num12 < 12)
				{
					num = 0;
				}
				else if (num12 < 28)
				{
					num = 26;
				}
				else if (num12 < 33)
				{
					num = 1;
				}
				else if (num12 < 36)
				{
					num = 0;
				}
				else if (num12 < 48)
				{
					num = 80;
				}
				else if (num12 < 54)
				{
					num = 30;
				}
				else if (num12 < 60)
				{
					num = 287;
				}
				else if (num12 < 66)
				{
					num = 240;
				}
				else if (num12 < 72)
				{
					num = 236;
				}
				else if (num12 < 73)
				{
					num = 0;
				}
				else if (num12 < 77)
				{
					num = 32;
				}
			}
		}
		if (tileCache.type == 649)
		{
			int num13 = tileCache.frameX / 36 + tileCache.frameY / 18 * 53;
			if (num13 < 6)
			{
				num = 1;
			}
			else if (num13 < 16)
			{
				num = 26;
			}
			else if (num13 == 16)
			{
				num = 9;
			}
			else if (num13 == 17)
			{
				num = 11;
			}
			else if (num13 == 18)
			{
				num = 10;
			}
			else if (num13 == 19)
			{
				num = 86;
			}
			else if (num13 == 20)
			{
				num = 87;
			}
			else if (num13 == 21)
			{
				num = 88;
			}
			else if (num13 == 22)
			{
				num = 89;
			}
			else if (num13 == 23)
			{
				num = 90;
			}
			else if (num13 == 24)
			{
				num = 91;
			}
			else if (num13 < 31)
			{
				num = 80;
			}
			else if (num13 < 33)
			{
				num = 7;
			}
			else if (num13 < 34)
			{
				num = 8;
			}
			else if (num13 < 38)
			{
				num = 30;
			}
			else if (num13 < 41)
			{
				num = 1;
			}
			else if (num13 < 47)
			{
				num = 287;
			}
			else if (num13 < 53)
			{
				num = 240;
			}
			else if (num13 < 59)
			{
				num = 236;
			}
			else if (num13 < 62)
			{
				num = 0;
			}
			else if (num13 < 64)
			{
				num = 32;
			}
			else if (num13 == 64)
			{
				num = 40;
			}
		}
		if (tileCache.type == 650)
		{
			int num14 = tileCache.frameX / 18;
			if (num14 < 6)
			{
				num = 1;
			}
			else if (num14 < 12)
			{
				num = 0;
			}
			else if (num14 < 28)
			{
				num = 26;
			}
			else if (num14 < 33)
			{
				num = 1;
			}
			else if (num14 < 36)
			{
				num = 0;
			}
			else if (num14 < 48)
			{
				num = 80;
			}
			else if (num14 < 54)
			{
				num = 30;
			}
			else if (num14 < 60)
			{
				num = 287;
			}
			else if (num14 < 66)
			{
				num = 240;
			}
			else if (num14 < 72)
			{
				num = 236;
			}
			else if (num14 < 73)
			{
				num = 0;
			}
			else
			{
				switch (num14)
				{
				case 74:
				case 76:
					num = 32;
					break;
				case 75:
				case 77:
					num = 40;
					break;
				}
			}
		}
		if (tileCache.type == 237)
		{
			num = 148;
		}
		if (tileCache.type == 157)
		{
			num = 77;
		}
		if (tileCache.type == 158 || tileCache.type == 232 || tileCache.type == 383 || tileCache.type == 575)
		{
			num = 78;
		}
		if (tileCache.type == 159)
		{
			num = 78;
		}
		if (tileCache.type == 15)
		{
			num = -1;
		}
		if (tileCache.type == 191)
		{
			num = 7;
		}
		if (tileCache.type == 5)
		{
			num = 7;
			if (i > 5 && i < Main.maxTilesX - 5)
			{
				int num15 = i;
				int k = j;
				if (tileCache.frameX == 66 && tileCache.frameY <= 45)
				{
					num15++;
				}
				if (tileCache.frameX == 88 && tileCache.frameY >= 66 && tileCache.frameY <= 110)
				{
					num15--;
				}
				if (tileCache.frameX == 22 && tileCache.frameY >= 132 && tileCache.frameY <= 176)
				{
					num15--;
				}
				if (tileCache.frameX == 44 && tileCache.frameY >= 132 && tileCache.frameY <= 176)
				{
					num15++;
				}
				if (tileCache.frameX == 44 && tileCache.frameY >= 132 && tileCache.frameY <= 176)
				{
					num15++;
				}
				if (tileCache.frameX == 44 && tileCache.frameY >= 198)
				{
					num15++;
				}
				if (tileCache.frameX == 66 && tileCache.frameY >= 198)
				{
					num15--;
				}
				for (; Main.tile[num15, k] != null && (!Main.tile[num15, k].active() || !Main.tileSolid[Main.tile[num15, k].type]); k++)
				{
				}
				if (Main.tile[num15, k] != null)
				{
					if (Main.tile[num15, k].active() && Main.tile[num15, k].type == 23)
					{
						num = 77;
					}
					if (Main.tile[num15, k].active() && Main.tile[num15, k].type == 661)
					{
						num = 77;
					}
					if (Main.tile[num15, k].active() && Main.tile[num15, k].type == 60)
					{
						num = 78;
					}
					if (Main.tile[num15, k].active() && Main.tile[num15, k].type == 70)
					{
						num = 26;
					}
					if (Main.tile[num15, k].active() && Main.tile[num15, k].type == 109)
					{
						num = 79;
					}
					if (Main.tile[num15, k].active() && Main.tile[num15, k].type == 199)
					{
						num = 121;
					}
					if (Main.tile[num15, k].active() && Main.tile[num15, k].type == 662)
					{
						num = 121;
					}
					if (Main.tile[num15, k].active() && Main.tile[num15, k].type == 147)
					{
						num = 122;
					}
				}
			}
		}
		if (tileCache.type == 323)
		{
			num = 215;
			if (i > 5 && i < Main.maxTilesX - 5)
			{
				int l;
				for (l = j; Main.tile[i, l] != null && (!Main.tile[i, l].active() || !Main.tileSolid[Main.tile[i, l].type]); l++)
				{
				}
				if (Main.tile[i, l] != null)
				{
					if (Main.tile[i, l].active() && Main.tile[i, l].type == 234)
					{
						num = 121;
					}
					if (Main.tile[i, l].active() && Main.tile[i, l].type == 116)
					{
						num = 79;
					}
					if (Main.tile[i, l].active() && Main.tile[i, l].type == 112)
					{
						num = 77;
					}
				}
			}
		}
		if (tileCache.type == 137)
		{
			switch (tileCache.frameY / 18)
			{
			default:
				num = 1;
				break;
			case 1:
			case 2:
			case 3:
			case 4:
				num = 148;
				break;
			case 5:
				num = 1;
				break;
			}
		}
		if (tileCache.type == 443)
		{
			num = 1;
		}
		if (tileCache.type == 444)
		{
			num = -1;
		}
		if (tileCache.type == 212)
		{
			num = -1;
		}
		if (tileCache.type == 213)
		{
			num = 129;
		}
		if (tileCache.type == 214)
		{
			num = 1;
		}
		if (tileCache.type == 215)
		{
			num = -6;
		}
		if (tileCache.type == 325)
		{
			num = 81;
		}
		if (tileCache.type == 251)
		{
			num = 189;
		}
		if (tileCache.type == 252)
		{
			num = 190;
		}
		if (tileCache.type == 253)
		{
			num = 191;
		}
		if (tileCache.type == 254)
		{
			if (tileCache.frameX < 72)
			{
				num = 3;
			}
			else if (tileCache.frameX < 108)
			{
				num = 3;
				if (genRand.Next(3) == 0)
				{
					num = 189;
				}
			}
			else if (tileCache.frameX < 144)
			{
				num = 3;
				if (genRand.Next(2) == 0)
				{
					num = 189;
				}
			}
			else
			{
				num = 3;
				if (genRand.Next(4) != 0)
				{
					num = 189;
				}
			}
		}
		if (tileCache.type == 467)
		{
			num = -1;
		}
		if (tileCache.type == 21)
		{
			num = ((tileCache.frameX >= 1008) ? (-1) : ((tileCache.frameX >= 612) ? 11 : ((tileCache.frameX >= 576) ? 148 : ((tileCache.frameX >= 540) ? 26 : ((tileCache.frameX >= 504) ? 126 : ((tileCache.frameX >= 468) ? 116 : ((tileCache.frameX >= 432) ? 7 : ((tileCache.frameX >= 396) ? 11 : ((tileCache.frameX >= 360) ? 10 : ((tileCache.frameX >= 324) ? 79 : ((tileCache.frameX >= 288) ? 78 : ((tileCache.frameX >= 252) ? 77 : ((tileCache.frameX >= 216) ? 1 : ((tileCache.frameX >= 180) ? 7 : ((tileCache.frameX >= 108) ? 37 : ((tileCache.frameX < 36) ? 7 : 10))))))))))))))));
		}
		if (tileCache.type == 382)
		{
			num = 3;
		}
		if (tileCache.type == 2 || tileCache.type == 477)
		{
			num = ((genRand.Next(2) != 0) ? 2 : 0);
		}
		if (tileCache.type == 127)
		{
			num = 67;
		}
		if (tileCache.type == 91)
		{
			num = -1;
		}
		if (tileCache.type == 198)
		{
			num = 109;
		}
		if (tileCache.type == 34)
		{
			num = -1;
		}
		if (tileCache.type == 6)
		{
			num = 8;
		}
		if (tileCache.type == 7 || tileCache.type == 47 || tileCache.type == 284 || tileCache.type == 682)
		{
			num = 9;
		}
		if (tileCache.type == 8 || tileCache.type == 45 || tileCache.type == 102 || tileCache.type == 680)
		{
			num = 10;
		}
		if (tileCache.type == 9 || tileCache.type == 42 || tileCache.type == 46 || tileCache.type == 126 || tileCache.type == 136 || tileCache.type == 681)
		{
			num = 11;
		}
		if (tileCache.type == 166 || tileCache.type == 175)
		{
			num = 81;
		}
		if (tileCache.type == 167)
		{
			num = 82;
		}
		if (tileCache.type == 168 || tileCache.type == 176)
		{
			num = 83;
		}
		if (tileCache.type == 169 || tileCache.type == 177)
		{
			num = 84;
		}
		if (tileCache.type == 199 || tileCache.type == 662)
		{
			num = 117;
		}
		if (tileCache.type == 205)
		{
			num = 125;
		}
		if (tileCache.type == 201)
		{
			num = 125;
		}
		if (tileCache.type == 211)
		{
			num = 128;
		}
		if (tileCache.type == 227)
		{
			switch (tileCache.frameX / 34)
			{
			case 0:
			case 1:
				num = 26;
				break;
			case 3:
				num = 3;
				break;
			case 2:
			case 4:
			case 5:
			case 6:
				num = 40;
				break;
			case 7:
				num = 117;
				break;
			case 8:
				num = 17;
				break;
			case 9:
				num = 6;
				break;
			case 10:
				num = 3;
				break;
			case 11:
				num = 26;
				break;
			}
		}
		if (tileCache.type == 204 || tileCache.type == 478)
		{
			num = 117;
			if (genRand.Next(2) == 0)
			{
				num = 1;
			}
		}
		if (tileCache.type == 203)
		{
			num = 117;
		}
		if (tileCache.type == 243)
		{
			num = ((genRand.Next(2) != 0) ? 13 : 7);
		}
		if (tileCache.type == 219)
		{
			num = -1;
		}
		if (tileCache.type == 642)
		{
			num = -128;
		}
		if (tileCache.type == 244)
		{
			num = ((genRand.Next(2) == 0) ? 1 : 13);
		}
		if (tileCache.type == 597)
		{
			num = -1;
		}
		else if ((tileCache.type >= 358 && tileCache.type <= 364) || (tileCache.type >= 275 && tileCache.type <= 282) || tileCache.type == 285 || tileCache.type == 286 || (tileCache.type >= 288 && tileCache.type <= 297) || (tileCache.type >= 316 && tileCache.type <= 318) || tileCache.type == 298 || tileCache.type == 299 || tileCache.type == 309 || tileCache.type == 310 || tileCache.type == 339 || tileCache.type == 538 || tileCache.type == 413 || tileCache.type == 414 || tileCache.type == 505 || tileCache.type == 521 || tileCache.type == 522 || tileCache.type == 523 || tileCache.type == 524 || tileCache.type == 525 || tileCache.type == 526 || tileCache.type == 527 || tileCache.type == 532 || tileCache.type == 543 || tileCache.type == 544 || tileCache.type == 550 || tileCache.type == 551 || tileCache.type == 533 || tileCache.type == 553 || tileCache.type == 554 || tileCache.type == 555 || tileCache.type == 556 || tileCache.type == 558 || tileCache.type == 559 || tileCache.type == 542 || tileCache.type == 391 || tileCache.type == 394 || tileCache.type == 392 || tileCache.type == 393 || tileCache.type == 568 || tileCache.type == 569 || tileCache.type == 570 || tileCache.type == 582 || tileCache.type == 580 || tileCache.type == 598 || tileCache.type == 599 || tileCache.type == 600 || tileCache.type == 601 || tileCache.type == 602 || tileCache.type == 603 || tileCache.type == 604 || tileCache.type == 605 || tileCache.type == 606 || tileCache.type == 607 || tileCache.type == 608 || tileCache.type == 609 || tileCache.type == 610 || tileCache.type == 611 || tileCache.type == 612 || tileCache.type == 619 || tileCache.type == 620 || tileCache.type == 629 || tileCache.type == 632 || tileCache.type == 640 || tileCache.type == 643 || tileCache.type == 644 || tileCache.type == 645 || tileCache.type == 710)
		{
			num = 13;
			if (genRand.Next(3) != 0)
			{
				num = -1;
			}
		}
		if (tileCache.type == 13)
		{
			num = ((tileCache.frameX < 90) ? 13 : (-1));
		}
		if (tileCache.type == 189)
		{
			num = 16;
		}
		if (tileCache.type == 717)
		{
			num = 326;
		}
		if (tileCache.type == 718)
		{
			num = 327;
		}
		if (tileCache.type == 719)
		{
			num = 328;
		}
		if (tileCache.type == 460)
		{
			num = 16;
		}
		if (tileCache.type == 530)
		{
			num = (int)Main.tile[i, j + 2 - tileCache.frameY / 18].type switch
			{
				116 => 47, 
				234 => 125, 
				112 => 17, 
				_ => (tileCache.frameX >= 270) ? 291 : 40, 
			};
		}
		if (tileCache.type == 705)
		{
			int num16 = tileCache.frameX / 54 + tileCache.frameY / 36 * 10;
			bool flag = tileCache.frameX % 486 < 270;
			num = ((num16 >= 0 && num16 <= 8) ? (flag ? 291 : 40) : ((num16 >= 9 && num16 <= 17) ? 47 : ((num16 < 18 || num16 > 26) ? 17 : 125)));
		}
		if (tileCache.type == 518)
		{
			if (tileCache.frameY == 0)
			{
				num = 3;
			}
			else if (tileCache.frameY == 18)
			{
				num = 47;
			}
			else if (tileCache.frameY == 36)
			{
				num = 40;
			}
		}
		else if (tileCache.type == 519)
		{
			if (tileCache.frameY == 0)
			{
				num = 3;
			}
			else if (tileCache.frameY == 18)
			{
				num = 40;
			}
			else if (tileCache.frameY == 36)
			{
				num = 47;
			}
			else if (tileCache.frameY == 54)
			{
				num = 125;
			}
			else if (tileCache.frameY == 72)
			{
				num = 17;
			}
			else if (tileCache.frameY == 90)
			{
				num = 26;
			}
		}
		else if (tileCache.type == 636)
		{
			num = 17;
		}
		else if (tileCache.type == 528)
		{
			num = 26;
		}
		if (tileCache.type == 12)
		{
			num = 12;
		}
		if (tileCache.type == 639)
		{
			num = 48;
		}
		if (tileCache.type == 3 || tileCache.type == 73)
		{
			num = 3;
		}
		if (tileCache.type == 54)
		{
			num = 13;
		}
		if (tileCache.type == 22 || tileCache.type == 140)
		{
			num = 14;
		}
		if (tileCache.type == 78)
		{
			num = 22;
		}
		if (tileCache.type == 28 || tileCache.type == 653)
		{
			num = 22;
			if (tileCache.frameY >= 72 && tileCache.frameY <= 90)
			{
				num = 1;
			}
			if (tileCache.frameY >= 144 && tileCache.frameY <= 234)
			{
				num = 48;
			}
			if (tileCache.frameY >= 252 && tileCache.frameY <= 358)
			{
				num = 85;
			}
			if (tileCache.frameY >= 360 && tileCache.frameY <= 466)
			{
				num = 26;
			}
			if (tileCache.frameY >= 468 && tileCache.frameY <= 574)
			{
				num = 36;
			}
			if (tileCache.frameY >= 576 && tileCache.frameY <= 790)
			{
				num = 18;
			}
			if (tileCache.frameY >= 792 && tileCache.frameY <= 898)
			{
				num = 5;
			}
			if (tileCache.frameY >= 900 && tileCache.frameY <= 1006)
			{
				num = 0;
			}
			if (tileCache.frameY >= 1008 && tileCache.frameY <= 1114)
			{
				num = 148;
			}
			if (tileCache.frameY >= 1116 && tileCache.frameY <= 1222)
			{
				num = 241;
			}
			if (tileCache.frameY >= 1224 && tileCache.frameY <= 1330)
			{
				num = 287;
			}
		}
		if (tileCache.type == 163)
		{
			num = 118;
		}
		if (tileCache.type == 164)
		{
			num = 119;
		}
		if (tileCache.type == 200)
		{
			num = 120;
		}
		if (tileCache.type == 221 || tileCache.type == 248)
		{
			num = 144;
		}
		if (tileCache.type == 222 || tileCache.type == 249)
		{
			num = 145;
		}
		if (tileCache.type == 223 || tileCache.type == 250)
		{
			num = 146;
		}
		if (tileCache.type == 224)
		{
			num = 149;
		}
		if (tileCache.type == 225)
		{
			num = 147;
		}
		if (tileCache.type == 229)
		{
			num = 153;
		}
		if (tileCache.type == 231)
		{
			num = 153;
			if (genRand.Next(3) == 0)
			{
				num = 26;
			}
		}
		if (tileCache.type == 226)
		{
			num = 148;
		}
		if (tileCache.type == 103)
		{
			num = -1;
		}
		if (tileCache.type == 29)
		{
			num = 23;
		}
		if (tileCache.type == 40)
		{
			num = 28;
		}
		if (tileCache.type == 50 || tileCache.type == 707)
		{
			num = 22;
		}
		if (tileCache.type == 51 || tileCache.type == 697)
		{
			num = 30;
		}
		if (tileCache.type == 52 || tileCache.type == 353)
		{
			num = 3;
		}
		if (tileCache.type == 53 || tileCache.type == 81 || tileCache.type == 151 || tileCache.type == 202 || tileCache.type == 274 || tileCache.type == 495)
		{
			num = 32;
		}
		if (tileCache.type == 56 || tileCache.type == 152)
		{
			num = 37;
		}
		if (tileCache.type == 75 || tileCache.type == 683)
		{
			num = 109;
		}
		if (tileCache.type == 57 || tileCache.type == 119 || tileCache.type == 141 || tileCache.type == 234 || tileCache.type == 635 || tileCache.type == 654)
		{
			num = 36;
		}
		if (tileCache.type == 59 || tileCache.type == 120)
		{
			num = 38;
		}
		if (tileCache.type == 61 || tileCache.type == 703 || tileCache.type == 62 || tileCache.type == 74 || tileCache.type == 80 || tileCache.type == 188 || tileCache.type == 233 || tileCache.type == 236 || tileCache.type == 702 || tileCache.type == 384 || tileCache.type == 652 || tileCache.type == 651)
		{
			num = 40;
		}
		if (tileCache.type == 485)
		{
			num = 32;
		}
		if (tileCache.type == 238)
		{
			num = ((genRand.Next(3) != 0) ? 166 : 167);
		}
		if (tileCache.type == 69)
		{
			num = 7;
		}
		if (tileCache.type == 655)
		{
			num = 166;
		}
		if (tileCache.type == 71 || tileCache.type == 72 || tileCache.type == 190 || tileCache.type == 578)
		{
			num = 26;
		}
		if (tileCache.type == 70)
		{
			num = 17;
		}
		if (tileCache.type == 112)
		{
			num = 14;
		}
		if (tileCache.type == 123)
		{
			num = 53;
		}
		if (tileCache.type == 161)
		{
			num = 80;
		}
		if (tileCache.type == 206)
		{
			num = 80;
		}
		if (tileCache.type == 162)
		{
			num = 80;
		}
		if (tileCache.type == 165 || tileCache.type == 693 || tileCache.type == 694)
		{
			num = (tileCache.frameX / 54) switch
			{
				0 => 80, 
				1 => 1, 
				2 => 30, 
				3 => 147, 
				4 => 51, 
				5 => 14, 
				6 => 117, 
				7 => 250, 
				8 => 240, 
				9 => 236, 
				10 => 119, 
				11 => 118, 
				12 => 120, 
				_ => 1, 
			};
		}
		if (tileCache.type == 666)
		{
			num = 322;
		}
		if (tileCache.type == 193)
		{
			num = 4;
		}
		if (tileCache.type == 194)
		{
			num = 26;
		}
		if (tileCache.type == 195)
		{
			num = 5;
		}
		if (tileCache.type == 196)
		{
			num = 108;
		}
		if (tileCache.type == 460)
		{
			num = 108;
		}
		if (tileCache.type == 197)
		{
			num = 4;
		}
		if (tileCache.type == 153)
		{
			num = 26;
		}
		if (tileCache.type == 154)
		{
			num = 32;
		}
		if (tileCache.type == 155)
		{
			num = 2;
		}
		if (tileCache.type == 156)
		{
			num = 1;
		}
		if (tileCache.type == 116 || tileCache.type == 117 || tileCache.type == 118 || tileCache.type == 147 || tileCache.type == 148)
		{
			num = 51;
		}
		if (tileCache.type == 109 || tileCache.type == 492)
		{
			num = ((genRand.Next(2) != 0) ? 47 : 0);
		}
		if (tileCache.type == 110 || tileCache.type == 113 || tileCache.type == 115)
		{
			num = 47;
		}
		if (tileCache.type == 107 || tileCache.type == 121 || tileCache.type == 685)
		{
			num = 48;
		}
		if (tileCache.type == 108 || tileCache.type == 122 || tileCache.type == 146 || tileCache.type == 686)
		{
			num = 49;
		}
		if (tileCache.type == 111 || tileCache.type == 145 || tileCache.type == 150)
		{
			num = 50;
		}
		if (tileCache.type == 133)
		{
			num = 50;
			if (tileCache.frameX >= 54)
			{
				num = 146;
			}
		}
		if (tileCache.type == 134)
		{
			num = 49;
			if (tileCache.frameX >= 36)
			{
				num = 145;
			}
		}
		if (tileCache.type == 149)
		{
			num = 49;
		}
		if (Main.tileAlch[tileCache.type])
		{
			int num17 = tileCache.frameX / 18;
			if (num17 == 0)
			{
				num = 3;
			}
			if (num17 == 1)
			{
				num = 3;
			}
			if (num17 == 2)
			{
				num = 7;
			}
			if (num17 == 3)
			{
				num = 17;
			}
			if (num17 == 4)
			{
				num = 289;
			}
			if (num17 == 5)
			{
				num = 6;
			}
			if (num17 == 6)
			{
				num = 224;
			}
		}
		if (tileCache.type == 58 || tileCache.type == 76 || tileCache.type == 77 || tileCache.type == 684)
		{
			num = ((genRand.Next(2) != 0) ? 25 : 6);
		}
		if (tileCache.type == 37)
		{
			num = ((genRand.Next(2) != 0) ? 23 : 6);
		}
		if (tileCache.type == 32)
		{
			num = ((genRand.Next(2) != 0) ? 24 : 14);
		}
		if (tileCache.type == 352)
		{
			num = ((genRand.Next(3) != 0) ? 125 : 5);
		}
		if (tileCache.type == 23 || tileCache.type == 24 || tileCache.type == 661)
		{
			num = ((genRand.Next(2) != 0) ? 17 : 14);
		}
		if (tileCache.type == 25 || tileCache.type == 31 || tileCache.type == 696)
		{
			num = (((tileCache.type == 31 || tileCache.type == 696) && tileCache.frameX >= 36) ? 5 : ((genRand.Next(2) != 0) ? 1 : 14));
		}
		if (tileCache.type == 26 || tileCache.type == 695)
		{
			num = ((tileCache.frameX >= 54) ? 5 : ((genRand.Next(2) != 0) ? 1 : 14));
		}
		if (tileCache.type == 20)
		{
			num = (tileCache.frameX / 54) switch
			{
				1 => 122, 
				2 => 78, 
				3 => 77, 
				4 => 121, 
				5 => 79, 
				_ => 7, 
			};
		}
		if (tileCache.type == 27)
		{
			num = ((genRand.Next(2) != 0) ? 19 : 3);
		}
		if (tileCache.type == 129)
		{
			if (tileCache.frameX >= 324)
			{
				num = 69;
			}
			num = ((tileCache.frameX != 0 && tileCache.frameX != 54 && tileCache.frameX != 108) ? ((tileCache.frameX != 18 && tileCache.frameX != 72 && tileCache.frameX != 126) ? 70 : 69) : 68);
		}
		if (tileCache.type == 385)
		{
			num = genRand.Next(68, 71);
		}
		if (tileCache.type == 4)
		{
			int num18 = (int)MathHelper.Clamp(tileCache.frameY / 22, 0f, TorchID.Count - 1);
			num = TorchID.Dust[num18];
		}
		if (tileCache.type == 35)
		{
			num = 189;
			if (tileCache.frameX < 36 && genRand.Next(2) == 0)
			{
				num = 6;
			}
		}
		if ((tileCache.type == 34 || tileCache.type == 42) && genRand.Next(2) == 0)
		{
			num = 6;
		}
		if (tileCache.type == 270)
		{
			num = -1;
		}
		if (tileCache.type == 271)
		{
			num = -1;
		}
		if (tileCache.type == 581)
		{
			num = -1;
		}
		if (tileCache.type == 660)
		{
			num = -1;
		}
		if (tileCache.type == 698)
		{
			num = -1;
		}
		if (tileCache.type == 79 || tileCache.type == 90 || tileCache.type == 101)
		{
			num = -1;
		}
		if (tileCache.type == 33 || tileCache.type == 34 || tileCache.type == 42 || tileCache.type == 93 || tileCache.type == 100)
		{
			num = -1;
		}
		if (tileCache.type == 321 || tileCache.type == 574)
		{
			num = 214;
		}
		if (tileCache.type == 322)
		{
			num = 215;
		}
		if (tileCache.type == 635)
		{
			num = 36;
		}
		bool flag2 = tileCache.type == 178 || tileCache.type == 440;
		switch (tileCache.type)
		{
		case 178:
		case 426:
		case 427:
		case 430:
		case 431:
		case 432:
		case 433:
		case 434:
		case 435:
		case 436:
		case 437:
		case 438:
		case 439:
		case 440:
		case 727:
		case 728:
		case 729:
		case 730:
		case 731:
		case 732:
			flag2 = true;
			break;
		}
		if (num >= 0)
		{
			if (tileCache.type == 627 || tileCache.type == 628 || (tileCache.type == 184 && tileCache.frameX / 22 == 10))
			{
				int num19 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num, 0f, 0f, 0, new Color(Main.DiscoR, Main.DiscoG, Main.DiscoB));
				Main.dust[num19].noGravity = true;
				Main.dust[num19].noLightEmittence = true;
				return num19;
			}
			if (tileCache.type == 518)
			{
				int num20 = tileCache.liquid / 16;
				num20 -= 3;
				if (SolidTile(i, j - 1) && num20 > 8)
				{
					num20 = 8;
				}
				return Dust.NewDust(new Vector2(i * 16, j * 16 - num20), 16, 16, num);
			}
			if (tileCache.type == 352 && num == 5)
			{
				int num21 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 5, 0f, 0f, 100);
				Main.dust[num21].scale = 1.5f;
				Main.dust[num21].noGravity = true;
				Main.dust[num21].velocity *= 1.65f;
				Main.dust[num21].fadeIn = 1.6f;
				return num21;
			}
			if (tileCache.type == 160 || tileCache.type == 692)
			{
				int num22 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 66, 0f, 0f, 100, new Color(Main.DiscoR, Main.DiscoG, Main.DiscoB), 0.75f);
				Main.dust[num22].noGravity = true;
				return num22;
			}
			if (tileCache.type == 323)
			{
				int frameY = tileCache.frameY;
				return Dust.NewDust(new Vector2(i * 16 + frameY, j * 16), 16, 16, num);
			}
			if (tileCache.type == 314)
			{
				int num23 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 213, genRand.Next(-2, 3), genRand.Next(-2, 3));
				Main.dust[num23].noGravity = true;
				Main.dust[num23].fadeIn = Main.dust[num23].scale + 1f + 0.01f * (float)genRand.Next(0, 51);
				Main.dust[num23].noGravity = true;
				return num23;
			}
			if (flag2)
			{
				int num24 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num, 0f, 0f, 75, default(Color), 0.75f);
				Main.dust[num24].noLight = true;
				return num24;
			}
			if (tileCache.type == 193 || (tileCache.type == 18 && num == 4) || (tileCache.type == 19 && num == 4))
			{
				return Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num, 0f, 0f, 75, new Color(0, 80, 255, 100), 0.75f);
			}
			if (tileCache.type == 197)
			{
				return Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num, 0f, 0f, 75, new Color(97, 200, 255, 100), 0.75f);
			}
			if (tileCache.type == 185 && num >= 86 && num <= 91)
			{
				int num25 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num, 0f, 0f, 75, default(Color), 0.75f);
				Main.dust[num25].noLight = true;
				return num25;
			}
			if (tileCache.type == 4 && num == 66)
			{
				int num26 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num, 0f, 0f, 0, new Color((float)Main.DiscoR / 255f, (float)Main.DiscoG / 255f, (float)Main.DiscoB / 255f));
				Main.dust[num26].noGravity = true;
				return num26;
			}
			if (num == 139)
			{
				int type = num + Main.rand.Next(4);
				return Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, type);
			}
			if (tileCache.type == 722)
			{
				int num27 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num);
				Main.dust[num27].velocity *= 0.4f;
				return num27;
			}
			return Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num);
		}
		return 6000;
	}

	public static bool IsOpenDoorAnchorFrame(int x, int y)
	{
		Tile tile = Main.tile[x, y];
		if (!tile.active() || tile.type != 11)
		{
			return false;
		}
		int num = tile.frameX % 72;
		if (num >= 18)
		{
			return num >= 54;
		}
		return true;
	}

	public static bool IsLockedDoor(int x, int y)
	{
		return IsLockedDoor(Main.tile[x, y]);
	}

	public static bool IsLockedDoor(Tile t)
	{
		if (t.type == 10 && t.frameY >= 594 && t.frameY <= 646)
		{
			return t.frameX < 54;
		}
		return false;
	}

	public static int GetDoorItem(int doorStyle)
	{
		int result = 0;
		switch (doorStyle)
		{
		case 0:
			result = 25;
			break;
		case 1:
			result = 650;
			break;
		case 2:
			result = 651;
			break;
		case 3:
			result = 652;
			break;
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
			result = 812 + doorStyle;
			break;
		default:
			switch (doorStyle)
			{
			case 9:
				result = 837;
				break;
			case 10:
				result = 912;
				break;
			case 12:
				result = 1137;
				break;
			case 13:
				result = 1138;
				break;
			case 14:
				result = 1139;
				break;
			case 15:
				result = 1140;
				break;
			case 16:
				result = 1411;
				break;
			case 17:
				result = 1412;
				break;
			case 18:
				result = 1413;
				break;
			case 19:
				result = 1458;
				break;
			case 20:
			case 21:
			case 22:
			case 23:
				result = 1709 + doorStyle - 20;
				break;
			default:
				switch (doorStyle)
				{
				case 24:
					result = 1793;
					break;
				case 25:
					result = 1815;
					break;
				case 26:
					result = 1924;
					break;
				case 27:
					result = 2044;
					break;
				case 28:
					result = 2265;
					break;
				case 29:
					result = 2528;
					break;
				case 30:
					result = 2561;
					break;
				case 31:
					result = 2576;
					break;
				case 32:
					result = 2815;
					break;
				case 33:
					result = 3129;
					break;
				case 34:
					result = 3131;
					break;
				case 35:
					result = 3130;
					break;
				case 36:
					result = 3888;
					break;
				case 37:
					result = 3941;
					break;
				case 38:
					result = 3967;
					break;
				case 39:
					result = 4155;
					break;
				case 40:
					result = 4176;
					break;
				case 41:
					result = 4197;
					break;
				case 42:
					result = 4218;
					break;
				case 43:
					result = 4307;
					break;
				case 44:
					result = 4415;
					break;
				case 45:
					result = 4576;
					break;
				case 46:
					result = 5158;
					break;
				case 47:
					result = 5179;
					break;
				case 48:
					result = 5200;
					break;
				case 49:
					result = 5558;
					break;
				case 50:
					result = 5611;
					break;
				case 51:
					result = 5699;
					break;
				case 52:
					result = 5722;
					break;
				case 53:
					result = 5747;
					break;
				case 54:
					result = 5765;
					break;
				case 55:
					result = 5786;
					break;
				case 56:
					result = 5807;
					break;
				case 57:
					result = 5828;
					break;
				case 58:
					result = 5867;
					break;
				case 59:
					result = 5907;
					break;
				case 60:
					result = 5941;
					break;
				case 61:
					result = 5964;
					break;
				case 62:
					result = 5984;
					break;
				case 63:
					result = 6007;
					break;
				case 64:
					result = 6030;
					break;
				case 65:
					result = 6053;
					break;
				case 66:
					result = 6076;
					break;
				case 67:
					result = 6098;
					break;
				case 68:
					result = 6120;
					break;
				}
				break;
			}
			break;
		}
		return result;
	}

	public static void DropDoorItem(int x, int y, int doorStyle)
	{
		int doorItem = GetDoorItem(doorStyle);
		if (doorItem != 0)
		{
			Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, doorItem);
		}
	}

	public static IEntitySource GetItemSource_FromTileBreak(int x, int y)
	{
		return new EntitySource_TileBreak(x, y);
	}

	public static IEntitySource GetItemSource_FromCoinRain(int x, int y)
	{
		return new EntitySource_CoinRain(x, y);
	}

	public static IEntitySource GetNPCSource_FromTileBreak(int x, int y)
	{
		return new EntitySource_TileBreak(x, y);
	}

	public static IEntitySource GetItemSource_FromWallBreak(int x, int y)
	{
		return new EntitySource_TileBreak(x, y);
	}

	public static IEntitySource GetItemSource_FromTreeShake(int x, int y)
	{
		return new EntitySource_ShakeTree(x, y);
	}

	public static bool PlayerLOS(int x, int y)
	{
		Rectangle rectangle = new Rectangle(x * 16, y * 16, 16, 16);
		for (int i = 0; i < 255; i++)
		{
			if (Main.player[i].active)
			{
				Rectangle value = new Rectangle((int)((double)Main.player[i].position.X + (double)Main.player[i].width * 0.5 - (double)NPC.sWidth * 0.6), (int)((double)Main.player[i].position.Y + (double)Main.player[i].height * 0.5 - (double)NPC.sHeight * 0.6), (int)((double)NPC.sWidth * 1.2), (int)((double)NPC.sHeight * 1.2));
				if (rectangle.Intersects(value))
				{
					return true;
				}
			}
		}
		return false;
	}

	public static void ChlorophyteDefense(int x, int y)
	{
		if (Main.remixWorld)
		{
			Convert(x, y, 10);
		}
	}

	public static bool CanChlorophyteGrow(int i, int j)
	{
		int num = 40;
		int num2 = 130;
		int num3 = 35;
		int num4 = 85;
		if (Main.remixWorld)
		{
			num += 5;
			num2 *= 15;
			num3 -= 4;
			num4 -= 8;
		}
		else if ((double)j < Main.rockLayer)
		{
			num /= 2;
			num2 /= 2;
			num3 = (int)((double)num3 * 1.5);
			num4 = (int)((double)num4 * 1.5);
		}
		int num5 = 0;
		for (int k = i - num3; k < i + num3; k++)
		{
			for (int l = j - num3; l < j + num3; l++)
			{
				if (InWorld(k, l) && Main.tile[k, l].active() && Main.tile[k, l].type == 211)
				{
					num5++;
				}
			}
		}
		if (num5 > num)
		{
			return false;
		}
		num5 = 0;
		for (int m = i - num4; m < i + num4; m++)
		{
			for (int n = j - num4; n < j + num4; n++)
			{
				if (InWorld(m, n) && Main.tile[m, n].active() && Main.tile[m, n].type == 211)
				{
					num5++;
				}
			}
		}
		if (num5 > num2)
		{
			return false;
		}
		return true;
	}

	private static bool nearbyChlorophyte(int i, int j)
	{
		double num = 0.0;
		int num2 = 5;
		if (i <= num2 + 5 || i >= Main.maxTilesX - num2 - 5)
		{
			return false;
		}
		if (j <= num2 + 5 || j >= Main.maxTilesY - num2 - 5)
		{
			return false;
		}
		for (int k = i - num2; k <= i + num2; k++)
		{
			for (int l = j - num2; l <= j + num2; l++)
			{
				if (Main.tile[k, l].active() && (Main.tile[k, l].type == 211 || Main.tile[k, l].type == 346))
				{
					num += 1.0;
					if (num >= 3.0)
					{
						return true;
					}
				}
			}
		}
		if (num > 0.0)
		{
			if (Main.remixWorld)
			{
				if ((double)genRand.Next(-1, 3) < num)
				{
					return true;
				}
			}
			else if ((double)genRand.Next(-1, 4) < num)
			{
				return true;
			}
		}
		return false;
	}

	public static int CountNearBlocksTypes(int i, int j, int radius, int cap = 0, params int[] tiletypes)
	{
		if (tiletypes.Length == 0)
		{
			return 0;
		}
		int value = i - radius;
		int value2 = i + radius;
		int value3 = j - radius;
		int value4 = j + radius;
		int num = Utils.Clamp(value, 0, Main.maxTilesX - 1);
		value2 = Utils.Clamp(value2, 0, Main.maxTilesX - 1);
		value3 = Utils.Clamp(value3, 0, Main.maxTilesY - 1);
		value4 = Utils.Clamp(value4, 0, Main.maxTilesY - 1);
		int num2 = 0;
		for (int k = num; k <= value2; k++)
		{
			for (int l = value3; l <= value4; l++)
			{
				if (!Main.tile[k, l].active())
				{
					continue;
				}
				for (int m = 0; m < tiletypes.Length; m++)
				{
					if (tiletypes[m] == Main.tile[k, l].type)
					{
						num2++;
						if (cap <= 0 || num2 < cap)
						{
							break;
						}
						return num2;
					}
				}
			}
		}
		return num2;
	}

	public static void hardUpdateWorld(int i, int j)
	{
		if (!hardModeWorldUpdates || Main.tile[i, j].inActive())
		{
			return;
		}
		int type = Main.tile[i, j].type;
		if (type > 0 && type < TileID.Count && TileID.Sets.CanGrowCrystalShards[type] && ((double)j > Main.rockLayer || Main.remixWorld) && genRand.Next(5) == 0)
		{
			int num = genRand.Next(4);
			int num2 = 0;
			int num3 = 0;
			switch (num)
			{
			case 0:
				num2 = -1;
				break;
			case 1:
				num2 = 1;
				break;
			default:
				num3 = ((num != 0) ? 1 : (-1));
				break;
			}
			if (!Main.tile[i + num2, j + num3].active())
			{
				int num4 = 0;
				int num5 = 6;
				for (int k = i - num5; k <= i + num5; k++)
				{
					for (int l = j - num5; l <= j + num5; l++)
					{
						if (Main.tile[k, l].active() && Main.tile[k, l].type == 129)
						{
							num4++;
						}
					}
				}
				if (num4 < 2)
				{
					int style = (short)genRand.Next(18);
					if (genRand.Next(50) == 0)
					{
						style = (short)(18 + genRand.Next(6));
					}
					PlaceTile(i + num2, j + num3, 129, mute: true, forced: false, -1, style);
					NetMessage.SendTileSquare(-1, i + num2, j + num3);
				}
			}
		}
		if ((double)j > (Main.worldSurface + Main.rockLayer) / 2.0 || Main.remixWorld)
		{
			if (type == 60 && genRand.Next(300) == 0)
			{
				int num6 = i + genRand.Next(-10, 11);
				int num7 = j + genRand.Next(-10, 11);
				if (InWorld(num6, num7, 2) && Main.tile[num6, num7].active() && Main.tile[num6, num7].type == 59 && (!Main.tile[num6, num7 - 1].active() || (Main.tile[num6, num7 - 1].type != 5 && Main.tile[num6, num7 - 1].type != 236 && Main.tile[num6, num7 - 1].type != 702 && Main.tile[num6, num7 - 1].type != 238)) && CanChlorophyteGrow(num6, num7))
				{
					Convert(num6, num7, 8);
				}
			}
			if (type == 211 || type == 346)
			{
				int num8 = i;
				int num9 = j;
				if (genRand.Next(3) != 0)
				{
					int num10 = genRand.Next(4);
					if (num10 == 0)
					{
						num8++;
					}
					if (num10 == 1)
					{
						num8--;
					}
					if (num10 == 2)
					{
						num9++;
					}
					if (num10 == 3)
					{
						num9--;
					}
					if (InWorld(num8, num9, 2) && Main.tile[num8, num9].active() && (Main.tile[num8, num9].type == 59 || Main.tile[num8, num9].type == 60) && CanChlorophyteGrow(num8, num9))
					{
						Convert(num8, num9, 8);
					}
				}
				bool flag = true;
				while (flag)
				{
					flag = false;
					num8 = i + Main.rand.Next(-6, 7);
					num9 = j + Main.rand.Next(-6, 7);
					if (InWorld(num8, num9, 2) && Main.tile[num8, num9].active())
					{
						Convert(num8, num9, 9);
					}
				}
			}
		}
		if ((NPC.downedPlantBoss && genRand.Next(2) != 0) || !AllowedToSpreadInfections)
		{
			return;
		}
		if (type >= 0 && TileID.Sets.SpreadsCorruption[type])
		{
			bool flag2 = true;
			while (flag2)
			{
				flag2 = false;
				int num11 = i + genRand.Next(-3, 4);
				int num12 = j + genRand.Next(-3, 4);
				if (!InWorld(num11, num12, 10))
				{
					continue;
				}
				if (nearbyChlorophyte(num11, num12))
				{
					ChlorophyteDefense(num11, num12);
				}
				else
				{
					if (CountNearBlocksTypes(num11, num12, 2, 1, 27) > 0)
					{
						continue;
					}
					if (Main.tile[num11, num12].type == 2 || Main.tile[num11, num12].type == 477)
					{
						if (genRand.Next(2) == 0)
						{
							flag2 = true;
						}
						Convert(num11, num12, 1, tiles: true, walls: false);
					}
					else if (Main.tile[num11, num12].type == 1 || Main.tileMoss[Main.tile[num11, num12].type])
					{
						if (genRand.Next(2) == 0)
						{
							flag2 = true;
						}
						Convert(num11, num12, 1, tiles: true, walls: false);
					}
					else if (Main.tile[num11, num12].type == 53)
					{
						if (genRand.Next(2) == 0)
						{
							flag2 = true;
						}
						Convert(num11, num12, 1, tiles: true, walls: false);
					}
					else if (Main.tile[num11, num12].type == 396)
					{
						if (genRand.Next(2) == 0)
						{
							flag2 = true;
						}
						Convert(num11, num12, 1, tiles: true, walls: false);
					}
					else if (Main.tile[num11, num12].type == 397)
					{
						if (genRand.Next(2) == 0)
						{
							flag2 = true;
						}
						Convert(num11, num12, 1, tiles: true, walls: false);
					}
					else if (Main.tile[num11, num12].type == 60)
					{
						if (genRand.Next(2) == 0)
						{
							flag2 = true;
						}
						Convert(num11, num12, 1, tiles: true, walls: false);
					}
					else if (Main.tile[num11, num12].type == 69)
					{
						if (genRand.Next(2) == 0)
						{
							flag2 = true;
						}
						Convert(num11, num12, 1, tiles: true, walls: false);
					}
					else if (Main.tile[num11, num12].type == 161)
					{
						if (genRand.Next(2) == 0)
						{
							flag2 = true;
						}
						Convert(num11, num12, 1, tiles: true, walls: false);
					}
				}
			}
		}
		if (type >= 0 && TileID.Sets.SpreadsCrimson[type])
		{
			bool flag3 = true;
			while (flag3)
			{
				flag3 = false;
				int num13 = i + genRand.Next(-3, 4);
				int num14 = j + genRand.Next(-3, 4);
				if (!InWorld(num13, num14, 10))
				{
					continue;
				}
				if (nearbyChlorophyte(num13, num14))
				{
					ChlorophyteDefense(num13, num14);
				}
				else
				{
					if (CountNearBlocksTypes(num13, num14, 2, 1, 27) > 0)
					{
						continue;
					}
					if (Main.tile[num13, num14].type == 2 || Main.tile[num13, num14].type == 477)
					{
						if (genRand.Next(2) == 0)
						{
							flag3 = true;
						}
						Convert(num13, num14, 4, tiles: true, walls: false);
					}
					else if (Main.tile[num13, num14].type == 1 || Main.tileMoss[Main.tile[num13, num14].type])
					{
						if (genRand.Next(2) == 0)
						{
							flag3 = true;
						}
						Convert(num13, num14, 4, tiles: true, walls: false);
					}
					else if (Main.tile[num13, num14].type == 53)
					{
						if (genRand.Next(2) == 0)
						{
							flag3 = true;
						}
						Convert(num13, num14, 4, tiles: true, walls: false);
					}
					else if (Main.tile[num13, num14].type == 396)
					{
						if (genRand.Next(2) == 0)
						{
							flag3 = true;
						}
						Convert(num13, num14, 4, tiles: true, walls: false);
					}
					else if (Main.tile[num13, num14].type == 397)
					{
						if (genRand.Next(2) == 0)
						{
							flag3 = true;
						}
						Convert(num13, num14, 4, tiles: true, walls: false);
					}
					else if (Main.tile[num13, num14].type == 60)
					{
						if (genRand.Next(2) == 0)
						{
							flag3 = true;
						}
						Convert(num13, num14, 4, tiles: true, walls: false);
					}
					else if (Main.tile[num13, num14].type == 69)
					{
						if (genRand.Next(2) == 0)
						{
							flag3 = true;
						}
						Convert(num13, num14, 4, tiles: true, walls: false);
					}
					else if (Main.tile[num13, num14].type == 161)
					{
						if (genRand.Next(2) == 0)
						{
							flag3 = true;
						}
						Convert(num13, num14, 4, tiles: true, walls: false);
					}
				}
			}
		}
		if (type < 0 || !TileID.Sets.SpreadsHallow[type])
		{
			return;
		}
		bool flag4 = true;
		while (flag4)
		{
			flag4 = false;
			int num15 = i + genRand.Next(-3, 4);
			int num16 = j + genRand.Next(-3, 4);
			if (!InWorld(num15, num16, 10) || CountNearBlocksTypes(num15, num16, 2, 1, 27) > 0)
			{
				continue;
			}
			if (Main.tile[num15, num16].type == 2)
			{
				if (genRand.Next(2) == 0)
				{
					flag4 = true;
				}
				Convert(num15, num16, 2, tiles: true, walls: false);
			}
			else if (Main.tile[num15, num16].type == 477)
			{
				if (genRand.Next(2) == 0)
				{
					flag4 = true;
				}
				Convert(num15, num16, 2, tiles: true, walls: false);
			}
			else if (Main.tile[num15, num16].type == 1 || Main.tileMoss[Main.tile[num15, num16].type])
			{
				if (genRand.Next(2) == 0)
				{
					flag4 = true;
				}
				Convert(num15, num16, 2, tiles: true, walls: false);
			}
			else if (Main.tile[num15, num16].type == 53)
			{
				if (genRand.Next(2) == 0)
				{
					flag4 = true;
				}
				Convert(num15, num16, 2, tiles: true, walls: false);
			}
			else if (Main.tile[num15, num16].type == 396)
			{
				if (genRand.Next(2) == 0)
				{
					flag4 = true;
				}
				Convert(num15, num16, 2, tiles: true, walls: false);
			}
			else if (Main.tile[num15, num16].type == 397)
			{
				if (genRand.Next(2) == 0)
				{
					flag4 = true;
				}
				Convert(num15, num16, 2, tiles: true, walls: false);
			}
			else if (Main.tile[num15, num16].type == 161)
			{
				if (genRand.Next(2) == 0)
				{
					flag4 = true;
				}
				Convert(num15, num16, 2, tiles: true, walls: false);
			}
		}
	}

	public static bool SolidTile(Tile testTile)
	{
		try
		{
			if (testTile == null)
			{
				return true;
			}
			if (testTile.nactive() && Main.tileSolid[testTile.type] && !Main.tileSolidTop[testTile.type] && !testTile.halfBrick() && testTile.slope() == 0)
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool TileEmpty(int i, int j)
	{
		if (Main.tile[i, j] != null && Main.tile[i, j].active())
		{
			return Main.tile[i, j].inActive();
		}
		return true;
	}

	public static bool SolidOrSlopedTile(Tile tile)
	{
		if (tile != null && tile.active() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type])
		{
			return !tile.inActive();
		}
		return false;
	}

	public static int TileType(int x, int y)
	{
		if (!Main.tile[x, y].active())
		{
			return -1;
		}
		return Main.tile[x, y].type;
	}

	public static bool SolidOrSlopedTile(int x, int y)
	{
		return SolidOrSlopedTile(Main.tile[x, y]);
	}

	public static void GetRopeEnds(int x, int y, out int topRopeY, out int bottomRopeY, bool treatEmptyAsTheRopeEnd = false, int rangeToCheck = 5)
	{
		topRopeY = -1;
		bottomRopeY = -1;
		for (int i = 1; i <= rangeToCheck && InWorld(x, y - i); i++)
		{
			Tile tile = Main.tile[x, y - i];
			if (tile == null)
			{
				break;
			}
			if (!tile.active())
			{
				if (treatEmptyAsTheRopeEnd)
				{
					topRopeY = y - i;
				}
				break;
			}
			if (Main.tileRope[tile.type])
			{
				topRopeY = y - i;
				break;
			}
		}
		int num = y - topRopeY;
		for (int j = 1 + num; j <= rangeToCheck + 1 && InWorld(x, topRopeY + j); j++)
		{
			Tile tile2 = Main.tile[x, topRopeY + j];
			if (tile2 == null)
			{
				break;
			}
			if (!tile2.active())
			{
				if (treatEmptyAsTheRopeEnd)
				{
					bottomRopeY = topRopeY + j;
				}
				break;
			}
			if (Main.tileRope[tile2.type])
			{
				bottomRopeY = topRopeY + j;
				break;
			}
		}
	}

	public static bool IsRope(int x, int y, int rangeToCheck = 5)
	{
		int topRopeY = 0;
		int bottomRopeY = 0;
		return IsRope(x, y, out topRopeY, out bottomRopeY, rangeToCheck);
	}

	public static bool IsRope(int x, int y, out int topRopeY, out int bottomRopeY, int rangeToCheck = 5)
	{
		topRopeY = -1;
		bottomRopeY = -1;
		Tile tile = Main.tile[x, y];
		if (tile == null || !tile.active())
		{
			return false;
		}
		if (Main.tileRope[tile.type])
		{
			return true;
		}
		if (tile.type != 314 && tile.type != 380 && !TileID.Sets.Platforms[tile.type])
		{
			return false;
		}
		GetRopeEnds(x, y, out topRopeY, out bottomRopeY, treatEmptyAsTheRopeEnd: false, rangeToCheck);
		if (topRopeY != -1)
		{
			return bottomRopeY != -1;
		}
		return false;
	}

	public static bool SolidTile(Point p)
	{
		return SolidTile(p.X, p.Y);
	}

	public static bool SolidTile(int i, int j, bool noDoors = false)
	{
		try
		{
			if (Main.tile[i, j] == null)
			{
				return true;
			}
			if (Main.tile[i, j].active() && Main.tileSolid[Main.tile[i, j].type] && !Main.tileSolidTop[Main.tile[i, j].type] && !Main.tile[i, j].halfBrick() && Main.tile[i, j].slope() == 0 && !Main.tile[i, j].inActive())
			{
				if (noDoors && Main.tile[i, j].type == 10)
				{
					return false;
				}
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool SolidTile2(Tile testTile)
	{
		try
		{
			if (testTile == null)
			{
				return true;
			}
			if (testTile.active() && Main.tileSolid[testTile.type] && testTile.slope() == 0 && !testTile.halfBrick() && !testTile.inActive())
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool PlatformProperTopFrame(short frameX)
	{
		int num = frameX / TileObjectData.PlatformFrameWidth();
		if ((num < 0 || num > 7) && (num < 12 || num > 16))
		{
			if (num >= 25)
			{
				return num <= 26;
			}
			return false;
		}
		return true;
	}

	public static bool SolidTileAllowBottomSlope(int i, int j)
	{
		try
		{
			if (!InWorld(i, j))
			{
				return true;
			}
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				return true;
			}
			if (tile.active() && (Main.tileSolid[tile.type] || Main.tileSolidTop[tile.type]) && (!tile.topSlope() || (TileID.Sets.Platforms[tile.type] && PlatformProperTopFrame(tile.frameX))) && !tile.halfBrick() && !tile.inActive())
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool SolidTileNoPlatforms(int i, int j)
	{
		try
		{
			if (!InWorld(i, j))
			{
				return true;
			}
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				return true;
			}
			if (tile.active() && !TileID.Sets.Platforms[tile.type] && (Main.tileSolid[tile.type] || Main.tileSolidTop[tile.type]) && !tile.inActive())
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool AnyLiquidAt(int x, int y, int liquidType = -1)
	{
		if (!InWorld(x, y, 5))
		{
			return false;
		}
		Tile tile = Main.tile[x, y];
		if (tile == null)
		{
			return false;
		}
		if (tile.liquid > 0)
		{
			if (liquidType > -1)
			{
				return tile.liquidType() == liquidType;
			}
			return true;
		}
		return false;
	}

	public static bool AnyLiquidAt(int x, int y, int range, int liquidType = -1)
	{
		if (range <= 0)
		{
			return AnyLiquidAt(x, y, liquidType);
		}
		int num = 5;
		int num2 = Math.Max(num, x - range);
		int num3 = Math.Max(num, y - range);
		int num4 = Math.Min(Main.maxTilesX - num, x + range);
		int num5 = Math.Min(Main.maxTilesY - num, y + range);
		for (int i = num2; i < num4; i++)
		{
			for (int j = num3; j < num5; j++)
			{
				if (AnyLiquidAt(i, j, liquidType))
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool ActiveAndWalkableTile(int i, int j)
	{
		try
		{
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				return true;
			}
			if (tile.active() && Main.tileSolid[tile.type] && !tile.inActive())
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool SolidTileAllowTopSlope(int i, int j)
	{
		try
		{
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				return true;
			}
			if (tile.active() && (Main.tileSolid[tile.type] || tile.type == 380) && ((!TileID.Sets.Platforms[tile.type] && !tile.bottomSlope()) || (TileID.Sets.Platforms[tile.type] && tile.halfBrick())) && !tile.inActive())
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool SolidTileAllowLeftSlope(int i, int j)
	{
		try
		{
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				return true;
			}
			if (tile.active() && Main.tileSolid[tile.type] && !tile.halfBrick() && !tile.rightSlope() && !TileID.Sets.Platforms[tile.type] && !tile.inActive())
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool SolidTileAllowRightSlope(int i, int j)
	{
		try
		{
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				return true;
			}
			if (tile.active() && Main.tileSolid[tile.type] && !tile.halfBrick() && !tile.leftSlope() && !TileID.Sets.Platforms[tile.type] && !tile.inActive())
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool TopEdgeCanBeAttachedTo(int i, int j)
	{
		try
		{
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				return true;
			}
			if (tile.active() && (Main.tileSolid[tile.type] || Main.tileSolidTop[tile.type]) && (!tile.topSlope() || (TileID.Sets.Platforms[tile.type] && PlatformProperTopFrame(tile.frameX))) && !tile.halfBrick() && !tile.inActive())
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool RightEdgeCanBeAttachedTo(int i, int j)
	{
		try
		{
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				return true;
			}
			if (tile.active() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type] && !tile.rightSlope() && !tile.halfBrick() && !tile.inActive() && !Main.tileNoAttach[tile.type])
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool LeftEdgeCanBeAttachedTo(int i, int j)
	{
		try
		{
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				return true;
			}
			if (tile.active() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type] && !tile.leftSlope() && !tile.halfBrick() && !tile.inActive() && !Main.tileNoAttach[tile.type])
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool BottomEdgeCanBeAttachedTo(int i, int j)
	{
		try
		{
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				return true;
			}
			if (tile.active() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type] && !tile.bottomSlope() && !tile.inActive() && !Main.tileNoAttach[tile.type])
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool SolidTile3(Point p)
	{
		return SolidTile3(p.X, p.Y);
	}

	public static bool SolidTile3(int i, int j)
	{
		if (!InWorld(i, j, 1))
		{
			return false;
		}
		return SolidTile3(Main.tile[i, j]);
	}

	public static bool SolidTile3(Tile t)
	{
		if (t == null)
		{
			return false;
		}
		if (t.active() && !t.inActive() && Main.tileSolid[t.type])
		{
			return !Main.tileSolidTop[t.type];
		}
		return false;
	}

	public static bool SolidTile2(Point p)
	{
		return SolidTile2(p.X, p.Y);
	}

	public static bool SolidTile2(int i, int j)
	{
		try
		{
			if (Main.tile[i, j] == null)
			{
				return true;
			}
			if (Main.tile[i, j].active() && Main.tileSolid[Main.tile[i, j].type] && ((TileID.Sets.Platforms[Main.tile[i, j].type] && (Main.tile[i, j].halfBrick() || Main.tile[i, j].topSlope())) || Main.tile[i, j].slope() == 0) && !Main.tile[i, j].halfBrick() && !Main.tile[i, j].inActive())
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool SolidTileNoAttach(int i, int j)
	{
		try
		{
			if (Main.tile[i, j] == null)
			{
				return true;
			}
			if (Main.tile[i, j].active() && Main.tileSolid[Main.tile[i, j].type] && !Main.tileNoAttach[Main.tile[i, j].type] && Main.tile[i, j].slope() == 0 && !Main.tile[i, j].halfBrick() && !Main.tile[i, j].inActive())
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static void MineHouse(int i, int j)
	{
		if (i < 50 || i > Main.maxTilesX - 50 || j < 50 || j > Main.maxTilesY - 50)
		{
			return;
		}
		int num = genRand.Next(6, 12);
		int num2 = genRand.Next(3, 6);
		int num3 = genRand.Next(15, 30);
		int num4 = genRand.Next(15, 30);
		if (SolidTile(i, j) || Main.tile[i, j].wall > 0)
		{
			return;
		}
		int num5 = j - num;
		int num6 = j + num2;
		for (int k = 0; k < 2; k++)
		{
			bool flag = true;
			int num7 = i;
			int num8 = j;
			int num9 = -1;
			int num10 = num3;
			if (k == 1)
			{
				num9 = 1;
				num10 = num4;
				num7++;
			}
			while (flag)
			{
				if (num8 - num < num5)
				{
					num5 = num8 - num;
				}
				if (num8 + num2 > num6)
				{
					num6 = num8 + num2;
				}
				for (int l = 0; l < 2; l++)
				{
					int num11 = num8;
					bool flag2 = true;
					int num12 = num;
					int num13 = -1;
					if (l == 1)
					{
						num11++;
						num12 = num2;
						num13 = 1;
					}
					while (flag2)
					{
						if (num7 != i && Main.tile[num7 - num9, num11].wall != 27 && (SolidTile(num7 - num9, num11) || !Main.tile[num7 - num9, num11].active() || Main.tile[num7 - num9, num11].halfBrick() || Main.tile[num7 - num9, num11].slope() != 0))
						{
							Main.tile[num7 - num9, num11].active(active: true);
							Main.tile[num7 - num9, num11].type = 30;
						}
						if (SolidTile(num7 - 1, num11) || Main.tile[num7 - 1, num11].halfBrick() || Main.tile[num7 - 1, num11].slope() != 0)
						{
							Main.tile[num7 - 1, num11].type = 30;
						}
						if (SolidTile(num7 + 1, num11) || Main.tile[num7 + 1, num11].halfBrick() || Main.tile[num7 + 1, num11].slope() != 0)
						{
							Main.tile[num7 + 1, num11].type = 30;
						}
						if (SolidTile(num7, num11) || Main.tile[num7, num11].halfBrick() || Main.tile[num7, num11].slope() != 0)
						{
							int num14 = 0;
							if (SolidTile(num7 - 1, num11))
							{
								num14++;
							}
							if (SolidTile(num7 + 1, num11))
							{
								num14++;
							}
							if (SolidTile(num7, num11 - 1))
							{
								num14++;
							}
							if (SolidTile(num7, num11 + 1))
							{
								num14++;
							}
							if (num14 < 2)
							{
								Main.tile[num7, num11].active(active: false);
							}
							else
							{
								flag2 = false;
								Main.tile[num7, num11].type = 30;
							}
						}
						else
						{
							Main.tile[num7, num11].wall = 27;
							Main.tile[num7, num11].liquid = 0;
							Main.tile[num7, num11].lava(lava: false);
						}
						num11 += num13;
						num12--;
						if (num12 <= 0)
						{
							if (!Main.tile[num7, num11].active())
							{
								Main.tile[num7, num11].active(active: true);
								Main.tile[num7, num11].type = 30;
							}
							flag2 = false;
						}
					}
				}
				num10--;
				num7 += num9;
				if (SolidTile(num7, num8))
				{
					int num15 = 0;
					int num16 = 0;
					int num17 = num8;
					bool flag3 = true;
					while (flag3)
					{
						num17--;
						num15++;
						if (SolidTile(num7 - num9, num17))
						{
							num15 = 999;
							flag3 = false;
						}
						else if (!SolidTile(num7, num17))
						{
							flag3 = false;
						}
					}
					num17 = num8;
					flag3 = true;
					while (flag3)
					{
						num17++;
						num16++;
						if (SolidTile(num7 - num9, num17))
						{
							num16 = 999;
							flag3 = false;
						}
						else if (!SolidTile(num7, num17))
						{
							flag3 = false;
						}
					}
					if (num16 <= num15)
					{
						if (num16 > num2)
						{
							num10 = 0;
						}
						else
						{
							num8 += num16 + 1;
						}
					}
					else if (num15 > num)
					{
						num10 = 0;
					}
					else
					{
						num8 -= num15 + 1;
					}
				}
				if (num10 <= 0)
				{
					flag = false;
				}
			}
		}
		int num18 = i - num3 - 1;
		int num19 = i + num4 + 2;
		int num20 = num5 - 1;
		int num21 = num6 + 2;
		for (int m = num18; m < num19; m++)
		{
			for (int n = num20; n < num21; n++)
			{
				if (Main.tile[m, n].wall == 27 && !Main.tile[m, n].active())
				{
					if (Main.tile[m - 1, n].wall != 27 && m < i && !SolidTile(m - 1, n))
					{
						PlaceTile(m, n, 30, mute: true);
						Main.tile[m, n].wall = 0;
					}
					if (Main.tile[m + 1, n].wall != 27 && m > i && !SolidTile(m + 1, n))
					{
						PlaceTile(m, n, 30, mute: true);
						Main.tile[m, n].wall = 0;
					}
					for (int num22 = m - 1; num22 <= m + 1; num22++)
					{
						for (int num23 = n - 1; num23 <= n + 1; num23++)
						{
							if (SolidTile(num22, num23))
							{
								Main.tile[num22, num23].type = 30;
							}
						}
					}
				}
				if (Main.tile[m, n].type == 30 && Main.tile[m - 1, n].wall == 27 && Main.tile[m + 1, n].wall == 27 && (Main.tile[m, n - 1].wall == 27 || Main.tile[m, n - 1].active()) && (Main.tile[m, n + 1].wall == 27 || Main.tile[m, n + 1].active()))
				{
					Main.tile[m, n].active(active: false);
					Main.tile[m, n].wall = 27;
				}
			}
		}
		for (int num24 = num18; num24 < num19; num24++)
		{
			for (int num25 = num20; num25 < num21; num25++)
			{
				if (Main.tile[num24, num25].type == 30)
				{
					if (Main.tile[num24 - 1, num25].wall == 27 && Main.tile[num24 + 1, num25].wall == 27 && !Main.tile[num24 - 1, num25].active() && !Main.tile[num24 + 1, num25].active())
					{
						Main.tile[num24, num25].active(active: false);
						Main.tile[num24, num25].wall = 27;
					}
					if (!TileID.Sets.BasicChest[Main.tile[num24, num25 - 1].type] && Main.tile[num24 - 1, num25].wall == 27 && Main.tile[num24 + 1, num25].type == 30 && Main.tile[num24 + 2, num25].wall == 27 && !Main.tile[num24 - 1, num25].active() && !Main.tile[num24 + 2, num25].active())
					{
						Main.tile[num24, num25].active(active: false);
						Main.tile[num24, num25].wall = 27;
						Main.tile[num24 + 1, num25].active(active: false);
						Main.tile[num24 + 1, num25].wall = 27;
					}
					if (Main.tile[num24, num25 - 1].wall == 27 && Main.tile[num24, num25 + 1].wall == 27 && !Main.tile[num24, num25 - 1].active() && !Main.tile[num24, num25 + 1].active())
					{
						Main.tile[num24, num25].active(active: false);
						Main.tile[num24, num25].wall = 27;
					}
				}
			}
		}
		for (int num26 = num18; num26 < num19; num26++)
		{
			for (int num27 = num21; num27 > num20; num27--)
			{
				bool flag4 = false;
				if (Main.tile[num26, num27].active() && Main.tile[num26, num27].type == 30)
				{
					int num28 = -1;
					for (int num29 = 0; num29 < 2; num29++)
					{
						if (!SolidTile(num26 + num28, num27) && Main.tile[num26 + num28, num27].wall == 0)
						{
							int num30 = 0;
							int num31 = num27;
							int num32 = num27;
							while (Main.tile[num26, num31].active() && Main.tile[num26, num31].type == 30 && !SolidTile(num26 + num28, num31) && Main.tile[num26 + num28, num31].wall == 0)
							{
								num31--;
								num30++;
							}
							num31++;
							int num33 = num31 + 1;
							if (num30 > 4)
							{
								if (genRand.Next(2) == 0)
								{
									num31 = num32 - 1;
									bool flag5 = true;
									for (int num34 = num26 - 2; num34 <= num26 + 2; num34++)
									{
										for (int num35 = num31 - 2; num35 <= num31; num35++)
										{
											if (num34 != num26 && Main.tile[num34, num35].active())
											{
												flag5 = false;
											}
										}
									}
									if (flag5)
									{
										Main.tile[num26, num31].active(active: false);
										Main.tile[num26, num31 - 1].active(active: false);
										Main.tile[num26, num31 - 2].active(active: false);
										PlaceTile(num26, num31, 10, mute: true);
										flag4 = true;
									}
								}
								if (!flag4)
								{
									for (int num36 = num33; num36 < num32; num36++)
									{
										Main.tile[num26, num36].type = 124;
									}
								}
							}
						}
						num28 = 1;
					}
				}
				if (flag4)
				{
					break;
				}
			}
		}
		int num37 = genRand.Next(1, 2);
		if (genRand.Next(4) == 0)
		{
			num37 = 0;
		}
		if (genRand.Next(6) == 0)
		{
			num37++;
		}
		if (genRand.Next(10) == 0)
		{
			num37++;
		}
		for (int num38 = 0; num38 < num37; num38++)
		{
			int num39 = 0;
			int num40 = genRand.Next(num18, num19);
			int num41 = genRand.Next(num20, num21);
			while (!Main.wallHouse[Main.tile[num40, num41].wall] || Main.tile[num40, num41].active())
			{
				num39++;
				if (num39 > 1000)
				{
					break;
				}
				num40 = genRand.Next(num18, num19);
				num41 = genRand.Next(num20, num21);
			}
			if (num39 > 1000)
			{
				break;
			}
			int num42 = num40;
			int num43 = num40;
			int num44 = num41;
			int num45 = num41;
			int num46 = 0;
			for (int num47 = 0; num47 < 2; num47++)
			{
				num42 = num40;
				num43 = num40;
				while (!Main.tile[num42, num41].active() && Main.wallHouse[Main.tile[num42, num41].wall])
				{
					num42--;
				}
				num42++;
				for (; !Main.tile[num43, num41].active() && Main.wallHouse[Main.tile[num43, num41].wall]; num43++)
				{
				}
				num43--;
				i = (num42 + num43) / 2;
				num44 = num41;
				num45 = num41;
				while (!Main.tile[num40, num44].active() && Main.wallHouse[Main.tile[num40, num44].wall])
				{
					num44--;
				}
				num44++;
				for (; !Main.tile[num40, num45].active() && Main.wallHouse[Main.tile[num40, num45].wall]; num45++)
				{
				}
				num45--;
				num41 = (num44 + num45) / 2;
			}
			num42 = num40;
			num43 = num40;
			while (!Main.tile[num42, num41].active() && !Main.tile[num42, num41 - 1].active() && !Main.tile[num42, num41 + 1].active())
			{
				num42--;
			}
			num42++;
			for (; !Main.tile[num43, num41].active() && !Main.tile[num43, num41 - 1].active() && !Main.tile[num43, num41 + 1].active(); num43++)
			{
			}
			num43--;
			num44 = num41;
			num45 = num41;
			while (!Main.tile[num40, num44].active() && !Main.tile[num40 - 1, num44].active() && !Main.tile[num40 + 1, num44].active())
			{
				num44--;
			}
			num44++;
			for (; !Main.tile[num40, num45].active() && !Main.tile[num40 - 1, num45].active() && !Main.tile[num40 + 1, num45].active(); num45++)
			{
			}
			num45--;
			num40 = (num42 + num43) / 2;
			num41 = (num44 + num45) / 2;
			int num48 = num43 - num42;
			num46 = num45 - num44;
			if (num48 <= 7 || num46 <= 5)
			{
				continue;
			}
			int num49 = 0;
			if (nearPicture2(i, num41))
			{
				num49 = -1;
			}
			if (num49 == 0)
			{
				PaintingEntry paintingEntry = RandHousePicture();
				if (!nearPicture(num40, num41))
				{
					PlaceTile(num40, num41, paintingEntry.tileType, mute: true, forced: false, -1, paintingEntry.style);
				}
			}
		}
		int num50;
		for (num50 = num18; num50 < num19; num50++)
		{
			bool flag6 = true;
			for (int num51 = num20; num51 < num21; num51++)
			{
				for (int num52 = num50 - 3; num52 <= num50 + 3; num52++)
				{
					if (Main.tile[num52, num51].active() && (!SolidTile(num52, num51) || Main.tile[num52, num51].type == 10))
					{
						flag6 = false;
					}
				}
			}
			if (flag6)
			{
				for (int num53 = num20; num53 < num21; num53++)
				{
					if (Main.tile[num50, num53].wall == 27 && !Main.tile[num50, num53].active())
					{
						PlaceTile(num50, num53, 124, mute: true);
					}
				}
			}
			num50 += genRand.Next(4);
		}
		for (int num54 = 0; num54 < 4; num54++)
		{
			int num55 = genRand.Next(num18 + 2, num19 - 1);
			int num56 = genRand.Next(num20 + 2, num21 - 1);
			while (Main.tile[num55, num56].wall != 27)
			{
				num55 = genRand.Next(num18 + 2, num19 - 1);
				num56 = genRand.Next(num20 + 2, num21 - 1);
			}
			while (Main.tile[num55, num56].active())
			{
				num56--;
			}
			for (; !Main.tile[num55, num56].active(); num56++)
			{
			}
			num56--;
			if (Main.tile[num55, num56].wall != 27)
			{
				continue;
			}
			if (genRand.Next(3) == 0)
			{
				int num57 = genRand.Next(9);
				if (num57 == 0)
				{
					num57 = 14;
				}
				if (num57 == 1)
				{
					num57 = 16;
				}
				if (num57 == 2)
				{
					num57 = 18;
				}
				if (num57 == 3)
				{
					num57 = 86;
				}
				if (num57 == 4)
				{
					num57 = 87;
				}
				if (num57 == 5)
				{
					num57 = 94;
				}
				if (num57 == 6)
				{
					num57 = 101;
				}
				if (num57 == 7)
				{
					num57 = 104;
				}
				if (num57 == 8)
				{
					num57 = 106;
				}
				PlaceTile(num55, num56, num57, mute: true);
			}
			else if (GenVars.statueList != null)
			{
				int num58 = genRand.Next(2, GenVars.statueList.Length);
				PlaceTile(num55, num56, GenVars.statueList[num58].X, mute: true, forced: true, -1, GenVars.statueList[num58].Y);
			}
		}
		for (int num59 = 0; num59 < 40; num59++)
		{
			int num60 = genRand.Next(num18 + 2, num19 - 1);
			int num61 = genRand.Next(num20 + 2, num21 - 1);
			while (Main.tile[num60, num61].wall != 27)
			{
				num60 = genRand.Next(num18 + 2, num19 - 1);
				num61 = genRand.Next(num20 + 2, num21 - 1);
			}
			while (Main.tile[num60, num61].active())
			{
				num61--;
			}
			for (; !Main.tile[num60, num61].active(); num61++)
			{
			}
			num61--;
			if (Main.tile[num60, num61].wall == 27 && genRand.Next(2) == 0)
			{
				int style = genRand.Next(22, 26);
				PlaceTile(num60, num61, 186, mute: true, forced: false, -1, style);
			}
		}
		for (int num62 = 0; num62 < 20; num62++)
		{
			int num63 = genRand.Next(num18 + 2, num19 - 1);
			int num64 = genRand.Next(num20 + 2, num21 - 1);
			while (Main.tile[num63, num64].wall != 27)
			{
				num63 = genRand.Next(num18 + 2, num19 - 1);
				num64 = genRand.Next(num20 + 2, num21 - 1);
			}
			while (Main.tile[num63, num64].active())
			{
				num64--;
			}
			for (; !Main.tile[num63, num64].active(); num64++)
			{
			}
			num64--;
			if (Main.tile[num63, num64].wall == 27 && genRand.Next(2) == 0)
			{
				int pileStyle = genRand.Next(31, 34);
				PlaceSmallPile(num63, num64, pileStyle, 1, 185);
			}
		}
		for (int num65 = 0; num65 < 15; num65++)
		{
			int num66 = genRand.Next(num18 + 2, num19 - 1);
			int num67 = genRand.Next(num20 + 2, num21 - 1);
			while (Main.tile[num66, num67].wall != 27)
			{
				num66 = genRand.Next(num18 + 2, num19 - 1);
				num67 = genRand.Next(num20 + 2, num21 - 1);
			}
			while (Main.tile[num66, num67].active())
			{
				num67--;
			}
			while (num67 > 0 && !Main.tile[num66, num67 - 1].active())
			{
				num67--;
			}
			if (Main.tile[num66, num67].wall != 27)
			{
				continue;
			}
			int num68 = 4;
			int style2 = 0;
			if (genRand.Next(10) < 9)
			{
				num68 = -1;
			}
			else
			{
				num68 = 34;
				style2 = genRand.Next(6);
			}
			if (num68 <= 0)
			{
				continue;
			}
			PlaceTile(num66, num67, num68, mute: true, forced: false, -1, style2);
			if (Main.tile[num66, num67].type != num68)
			{
				continue;
			}
			if (num68 == 4)
			{
				Main.tile[num66, num67].frameX += 54;
				continue;
			}
			int num69 = num66;
			int num70 = num67;
			num67 = num70 - Main.tile[num69, num70].frameY % 54 / 18;
			num66 = Main.tile[num69, num70].frameX / 18;
			if (num66 > 2)
			{
				num66 -= 3;
			}
			num66 = num69 - num66;
			short num71 = 54;
			if (Main.tile[num66, num67].frameX > 0)
			{
				num71 = -54;
			}
			for (int num72 = num66; num72 < num66 + 3; num72++)
			{
				for (int num73 = num67; num73 < num67 + 3; num73++)
				{
					Main.tile[num72, num73].frameX += num71;
				}
			}
		}
	}

	public static void CountTiles(int X)
	{
		if (X == 0)
		{
			totalEvil = totalEvil2;
			totalBlood = totalBlood2;
			totalSolid = totalSolid2;
			totalGood = totalGood2;
			tGood = (byte)Math.Round((double)totalGood / (double)totalSolid * 100.0);
			tEvil = (byte)Math.Round((double)totalEvil / (double)totalSolid * 100.0);
			tBlood = (byte)Math.Round((double)totalBlood / (double)totalSolid * 100.0);
			if (tGood == 0 && totalGood > 0)
			{
				tGood = 1;
			}
			if (tEvil == 0 && totalEvil > 0)
			{
				tEvil = 1;
			}
			if (tBlood == 0 && totalBlood > 0)
			{
				tBlood = 1;
			}
			if (Main.netMode == 2)
			{
				NetMessage.SendData(57);
			}
			totalEvil2 = 0;
			totalSolid2 = 0;
			totalGood2 = 0;
			totalBlood2 = 0;
		}
		ushort num = 0;
		ushort num2 = 0;
		int num3 = 0;
		int num4 = 0;
		int num5 = 0;
		do
		{
			int num6;
			int num7;
			if (num4 == 0)
			{
				num6 = 40;
				num5 = (int)(Main.worldSurface + 1.0);
				num7 = 5;
			}
			else
			{
				num6 = num5;
				num5 = Main.maxTilesY - 40;
				num7 = 1;
			}
			for (int i = num6; i < num5; i++)
			{
				Tile tile = Main.tile[X, i];
				if (tile == null)
				{
					tile = (Main.tile[X, i] = new Tile());
				}
				Skyblock.hasWall[tile.wall] = true;
				if (!tile.active())
				{
					continue;
				}
				Skyblock.currentActiveTiles++;
				Skyblock.hasTile[tile.type] = true;
				num = tile.type;
				if (num != 0)
				{
					if (num == num2)
					{
						num3 += num7;
						continue;
					}
					tileCounts[num2] += num3;
					num2 = num;
					num3 = num7;
				}
			}
			tileCounts[num2] += num3;
			num3 = 0;
			num4++;
		}
		while (num4 < 2);
		AddUpAlignmentCounts();
		if (X == Main.maxTilesX - 1)
		{
			Skyblock.Calculate();
		}
	}

	public static void AddUpAlignmentCounts(bool clearCounts = false)
	{
		if (clearCounts)
		{
			totalEvil2 = 0;
			totalSolid2 = 0;
			totalGood2 = 0;
			totalBlood2 = 0;
		}
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		for (int i = 0; i < TileID.Sets.HallowCountCollection.Count; i++)
		{
			int num4 = tileCounts[TileID.Sets.HallowCountCollection[i]];
			totalGood2 += num4;
			num += num4;
		}
		for (int j = 0; j < TileID.Sets.CorruptCountCollection.Count; j++)
		{
			int num5 = tileCounts[TileID.Sets.CorruptCountCollection[j]];
			totalEvil2 += num5;
			num2 += num5;
		}
		for (int k = 0; k < TileID.Sets.CrimsonCountCollection.Count; k++)
		{
			int num6 = tileCounts[TileID.Sets.CrimsonCountCollection[k]];
			totalBlood2 += num6;
			num3 += num6;
		}
		if (Main.remixWorld)
		{
			int num7 = tileCounts[474];
			totalEvil2 += num7;
			num2 += num7;
			num7 = tileCounts[195];
			totalBlood2 += num7;
			num3 += num7;
		}
		totalSolid2 += tileCounts[2] + tileCounts[477] + tileCounts[1] + tileCounts[60] + tileCounts[53] + tileCounts[161];
		totalSolid2 += num;
		totalSolid2 += num2;
		totalSolid2 += num3;
		Array.Clear(tileCounts, 0, tileCounts.Length);
	}

	public static void plantDye(int i, int j, bool exoticPlant = false)
	{
		UnifiedRandom unifiedRandom = (isGeneratingOrLoadingWorld ? genRand : Main.rand);
		if (!Main.tile[i, j].active() || i < 95 || i > Main.maxTilesX - 95 || j < 95 || j > Main.maxTilesY - 95)
		{
			return;
		}
		int num = 90;
		if (exoticPlant)
		{
			num = 240;
		}
		if (((double)j < Main.worldSurface || remixWorldGen) && (!Main.tile[i, j - 1].active() || Main.tile[i, j - 1].type == 3 || Main.tile[i, j - 1].type == 51 || Main.tile[i, j - 1].type == 61 || Main.tile[i, j - 1].type == 73 || Main.tile[i, j - 1].type == 74 || Main.tile[i, j - 1].type == 184))
		{
			int num2 = Utils.Clamp(i - num, 1, Main.maxTilesX - 1 - 1);
			int num3 = Utils.Clamp(i + num, 1, Main.maxTilesX - 1 - 1);
			int num4 = Utils.Clamp(j - num, 1, Main.maxTilesY - 1 - 1);
			int num5 = Utils.Clamp(j + num, 1, Main.maxTilesY - 1 - 1);
			for (int k = num2; k < num3; k++)
			{
				for (int l = num4; l < num5; l++)
				{
					if (Main.tile[k, l].active() && Main.tile[k, l].type == 227 && (!exoticPlant || Main.tile[k, l].frameX >= 272) && (exoticPlant || Main.tile[k, l].frameX < 272))
					{
						return;
					}
				}
			}
			if (exoticPlant)
			{
				int type = Main.tile[i, j].type;
				bool flag = TileID.Sets.Conversion.Grass[type] || TileID.Sets.Conversion.Moss[type] || type == 0;
				if (Main.tile[i, j - 1].liquid > 0 && (Main.tile[i, j - 1].lava() || Main.tile[i, j - 1].honey()))
				{
					flag = false;
				}
				if (flag)
				{
					PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, genRand.Next(8, 12));
				}
			}
			else if (Main.tile[i, j].type == 2 || Main.tile[i, j].type == 109)
			{
				if (unifiedRandom.Next(4) == 0)
				{
					PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 4);
				}
				else
				{
					PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 3);
				}
			}
			else if (Main.tile[i, j].type == 60)
			{
				if (unifiedRandom.Next(2) == 0)
				{
					PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 2);
				}
				else
				{
					PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 4);
				}
			}
			else if (Main.tile[i, j].type == 53 && Main.tile[i, j - 1].liquid == byte.MaxValue && Main.tile[i, j - 2].liquid == byte.MaxValue)
			{
				PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 2);
			}
			else if (Main.tile[i, j].type == 80 && !Main.tile[i - 1, j - 1].active() && !Main.tile[i + 1, j - 1].active())
			{
				try
				{
					bool flag2 = true;
					for (int m = i - 5; m <= i + 5; m++)
					{
						for (int n = j - 5; n <= j + 15; n++)
						{
							if (Main.tile[m, n].active() && (Main.tile[m, n].type == 112 || Main.tile[m, n].type == 234))
							{
								flag2 = false;
							}
						}
					}
					if (flag2)
					{
						PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 6);
					}
				}
				catch
				{
				}
			}
		}
		if ((!((double)j >= Main.worldSurface) && !remixWorldGen) || j >= Main.UnderworldLayer)
		{
			return;
		}
		if (!Main.tile[i, j - 1].active() || Main.tile[i, j - 1].type == 3 || Main.tile[i, j - 1].type == 51 || Main.tile[i, j - 1].type == 61 || Main.tile[i, j - 1].type == 73 || Main.tile[i, j - 1].type == 74 || Main.tile[i, j - 1].type == 184)
		{
			int num6 = Utils.Clamp(i - num, 1, Main.maxTilesX - 1 - 1);
			int num7 = Utils.Clamp(i + num, 1, Main.maxTilesX - 1 - 1);
			int num8 = Utils.Clamp(j - num, 1, Main.maxTilesY - 1 - 1);
			int num9 = Utils.Clamp(j + num, 1, Main.maxTilesY - 1 - 1);
			for (int num10 = num6; num10 < num7; num10++)
			{
				for (int num11 = num8; num11 < num9; num11++)
				{
					if (Main.tile[num10, num11].active() && Main.tile[num10, num11].type == 227 && (!exoticPlant || Main.tile[num10, num11].frameX >= 272) && (exoticPlant || Main.tile[num10, num11].frameX < 272))
					{
						return;
					}
				}
			}
			if (exoticPlant)
			{
				int type2 = Main.tile[i, j].type;
				if (TileID.Sets.Conversion.Grass[type2] || TileID.Sets.Conversion.Moss[type2] || type2 == 0)
				{
					PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, genRand.Next(8, 12));
				}
			}
			else if (Main.tile[i, j].type == 60)
			{
				if (unifiedRandom.Next(2) == 0)
				{
					PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 2);
				}
				else if (unifiedRandom.Next(2) == 0)
				{
					PlaceTile(i, j - 1, 227, mute: true);
				}
				else
				{
					PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 1);
				}
			}
			else if (Main.tile[i, j].type == 0 || Main.tile[i, j].type == 1 || Main.tile[i, j].type == 59)
			{
				if (unifiedRandom.Next(2) == 0)
				{
					PlaceTile(i, j - 1, 227, mute: true);
				}
				else
				{
					PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 1);
				}
			}
			else if (Main.tile[i, j - 1].liquid == byte.MaxValue && Main.tile[i, j - 2].liquid == byte.MaxValue)
			{
				PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 5);
			}
		}
		if (Main.tile[i, j + 1].active() || exoticPlant)
		{
			return;
		}
		for (int num12 = i - num; num12 < i + num; num12++)
		{
			for (int num13 = j - num; num13 < j + num; num13++)
			{
				if (Main.tile[num12, num13].active() && Main.tile[num12, num13].type == 227)
				{
					return;
				}
			}
		}
		if (Main.tile[i, j].type == 0)
		{
			PlaceTile(i, j + 1, 227, mute: true, forced: false, -1, 7);
		}
	}

	private static int MossConversion(int thisType, int otherType)
	{
		if (TileID.Sets.tileMossBrick[thisType] && otherType == 38)
		{
			return thisType;
		}
		if (Main.tileMoss[thisType] && otherType == 1)
		{
			return thisType;
		}
		return thisType switch
		{
			182 => 515, 
			515 => 182, 
			180 => 513, 
			513 => 180, 
			179 => 512, 
			512 => 179, 
			381 => 517, 
			517 => 381, 
			534 => 535, 
			535 => 534, 
			536 => 537, 
			537 => 536, 
			539 => 540, 
			540 => 539, 
			625 => 626, 
			626 => 625, 
			627 => 628, 
			628 => 627, 
			183 => 516, 
			516 => 183, 
			181 => 514, 
			514 => 181, 
			_ => 0, 
		};
	}

	public static void UpdateWorld()
	{
		if (isGeneratingOrLoadingWorld)
		{
			return;
		}
		hardModeWorldUpdates = Main.hardMode || (Main.remixWorld && Main.getGoodWorld && !Main.tenthAnniversaryWorld);
		AllowedToSpreadInfections = true;
		CreativePowers.StopBiomeSpreadPower power = CreativePowerManager.Instance.GetPower<CreativePowers.StopBiomeSpreadPower>();
		if (power != null && power.GetIsUnlocked())
		{
			AllowedToSpreadInfections = !power.Enabled;
		}
		int wallDist = 3;
		Wiring.UpdateMech();
		TileEntity.PerformUpdates();
		UpdateLunarApocalypse();
		if (Main.netMode != 1)
		{
			totalD++;
			if (totalD >= 30)
			{
				totalD = 0;
				CountTiles(totalX);
				totalX++;
				if (totalX >= Main.maxTilesX)
				{
					totalX = 0;
				}
			}
		}
		Liquid.skipCount++;
		if (Liquid.skipCount > 1)
		{
			Liquid.UpdateLiquid();
			Liquid.skipCount = 0;
		}
		SpawnStormLightning();
		int worldUpdateRate = GetWorldUpdateRate();
		if (worldUpdateRate == 0)
		{
			return;
		}
		double num = 3E-05f * (float)worldUpdateRate;
		double num2 = 6E-05f * (float)worldUpdateRate;
		double num3 = 1.5E-05f * (float)worldUpdateRate;
		double num4 = 2.5E-05f * (float)worldUpdateRate;
		npcSpawnPeriod = 20 * worldUpdateRate;
		if (prioritizedTownNPCType != 37)
		{
			for (int i = 0; i < Main.maxNPCs; i++)
			{
				if (Main.npc[i].active && Main.npc[i].homeless && Main.npc[i].townNPC && Main.npc[i].lookForHomeTimeout == 0 && Main.npc[i].type != 368)
				{
					prioritizedTownNPCType = Main.npc[i].type;
					break;
				}
			}
		}
		CheckForHousesNearAPlayer();
		if (Main.isThereAWorldSurface)
		{
			double num5 = (double)(Main.maxTilesX * Main.maxTilesY) * num;
			int maxValue = (int)Main.worldSurface - 1;
			if (!Main.remixWorld && Main.notTheBeesWorld)
			{
				num5 = (double)(Main.maxTilesX * Main.maxTilesY) * num2;
				maxValue = (int)Main.rockLayer - 1;
				growGrassUnderground = true;
			}
			if (Main.IsItRaining)
			{
				num5 *= 1.5;
			}
			int num6 = 151;
			int num7 = (int)Utils.Lerp(num6, (double)num6 * 2.8, Utils.Clamp((double)Main.maxTilesX / 4200.0 - 1.0, 0.0, 1.0));
			for (int j = 0; (double)j < num5; j++)
			{
				if (Main.rand.Next(num7 * 100) == 0)
				{
					PlantAlch();
				}
				int num8 = genRand.Next(10, Main.maxTilesX - 10);
				int num9 = genRand.Next(10, maxValue);
				if (Main.dontStarveWorld && Main.getGoodWorld && !Main.remixWorld && num8 > beachDistance && num8 < Main.maxTilesX - beachDistance && Main.tile[num8, num9].wall == 0 && Main.raining && (float)Main.rand.Next(300000) < 100f * Main.maxRaining)
				{
					int k;
					for (k = genRand.Next(50, (int)Main.worldSurface - 50); !SolidTile3(num8, k) && Main.tile[num8, k].liquid == 0 && (double)k < Main.worldSurface; k++)
					{
					}
					if ((double)k < Main.worldSurface)
					{
						if (SolidTile3(num8, k) || Main.tile[num8, k].liquid == byte.MaxValue)
						{
							k--;
						}
						if (!TileID.Sets.isDesertBiomeSand[Main.tile[num8, k + 1].type] && Main.tile[num8, k + 1].type != 112 && Main.tile[num8, k + 1].type != 234 && Main.tile[num8, k + 1].type != 147 && Main.tile[num8, k + 1].type != 161 && (Main.tile[num8, k + 1].liquid == 0 || Main.tile[num8, k + 1].water()) && !SolidTile3(num8, k) && Main.tile[num8, k].liquid < byte.MaxValue)
						{
							int liquid = Main.tile[num8, k].liquid;
							liquid += Main.rand.Next(127, 255);
							if (liquid > 255)
							{
								liquid = 255;
							}
							Main.tile[num8, k].liquid = (byte)liquid;
							Main.tile[num8, k].liquidType(0);
							TileFrame(num8, k);
						}
					}
				}
				UpdateWorld_OvergroundTile(num8, num9, wallDist);
			}
		}
		growGrassUnderground = false;
		if (Main.remixWorld)
		{
			for (int l = 0; (double)l < (double)(Main.maxTilesX * Main.maxTilesY) * num4; l++)
			{
				int i2 = genRand.Next(10, Main.maxTilesX - 10);
				int j2 = genRand.Next((int)Main.worldSurface - 1, Main.maxTilesY - 20);
				growGrassUnderground = true;
				UpdateWorld_UndergroundTile(i2, j2, wallDist);
				UpdateWorld_OvergroundTile(i2, j2, wallDist);
				growGrassUnderground = false;
			}
		}
		else
		{
			for (int m = 0; (double)m < (double)(Main.maxTilesX * Main.maxTilesY) * num3; m++)
			{
				int i3 = genRand.Next(10, Main.maxTilesX - 10);
				int j3 = genRand.Next((int)Main.worldSurface - 1, Main.maxTilesY - 20);
				UpdateWorld_UndergroundTile(i3, j3, wallDist);
			}
		}
		SpawnFallingObjects();
	}

	private static void CheckForHousesNearAPlayer()
	{
		int num = Main.CurrentFrameFlags.ActivePlayersCount;
		if (num <= 0)
		{
			num = 1;
		}
		int num2 = (int)(Main.GameUpdateCount % num);
		for (int i = 0; i < 255; i++)
		{
			Player player = Main.player[i];
			if (!player.active || num2-- != 0)
			{
				continue;
			}
			Rectangle tileRectangle = Utils.CenteredRectangle(player.Center.ToTileCoordinates(), Point.Zero);
			tileRectangle.Inflate(Main.MaxWorldViewSize.X / 32, Main.MaxWorldViewSize.Y / 32);
			tileRectangle = WorldUtils.ClampToWorld(tileRectangle, 10);
			for (int j = 0; j < 300; j++)
			{
				Point point = Main.rand.NextFromRectangle(tileRectangle);
				if (Main.wallHouse[Main.tile[point.X, point.Y].wall])
				{
					bool flag = Main.tileSolid[379];
					Main.tileSolid[379] = true;
					SpawnTownNPC(point.X, point.Y, canSpawnNewTownNPC: false);
					Main.tileSolid[379] = flag;
					break;
				}
			}
		}
	}

	private static void SpawnFallingObjects()
	{
		if (!Main.isThereAWorldSurface)
		{
			return;
		}
		int num;
		if (Main.drunkWorld && Main.getGoodWorld && !Main.remixWorld)
		{
			num = (Main.IsItStorming ? 1 : 0);
			if (num != 0)
			{
				goto IL_0036;
			}
		}
		else
		{
			num = 0;
		}
		if (_isRainingBoulders)
		{
			AchievementsHelper.NotifyProgressionEvent(34);
		}
		goto IL_0036;
		IL_0036:
		_isRainingBoulders = (byte)num != 0;
		if (num != 0)
		{
			int maxValue = 3;
			if (Main.dontStarveWorld)
			{
				maxValue = 5;
			}
			if (Main.rand.Next(maxValue) == 0)
			{
				int num2 = Main.rand.Next(Main.maxTilesX - 50) + 100;
				num2 *= 16;
				int num3 = Main.rand.Next((int)((double)Main.maxTilesY * 0.05));
				num3 *= 16;
				Vector2 position = new Vector2(num2, num3);
				int num4 = -1;
				if (!Collision.SolidCollision(position, 32, 32))
				{
					float value = Main.windSpeedCurrent * 16f;
					value = Utils.Clamp(value, -16f, 16f);
					float speedY = 8f;
					EntitySource_ByProjectileSourceId spawnSource = new EntitySource_ByProjectileSourceId(19);
					if (Main.rand.Next(50) == 0)
					{
						Projectile.NewProjectile(spawnSource, position.X, position.Y, value, speedY, 1013, 70, 10f, Main.myPlayer, 0f, num4, 0f, NewProjectileModifiers.RainHazard);
					}
					else
					{
						Projectile.NewProjectile(spawnSource, position.X, position.Y, value, speedY, 99, 70, 10f, Main.myPlayer, 0f, num4, 0f, NewProjectileModifiers.RainHazard);
					}
				}
			}
		}
		if (Main.dontStarveWorld && Main.getGoodWorld && !Main.remixWorld && Main.IsItStorming)
		{
			int maxValue2 = 3;
			if (Main.drunkWorld)
			{
				maxValue2 = 2;
			}
			if (Main.rand.Next(maxValue2) != 0)
			{
				int num5 = Main.rand.Next(Main.maxTilesX - 50) + 100;
				num5 *= 16;
				int num6 = Main.rand.Next((int)((float)Main.maxTilesY * 0.05f));
				num6 *= 16;
				Vector2 position2 = new Vector2(num5, num6);
				int num7 = -1;
				if (!Collision.SolidCollision(position2, 32, 32))
				{
					Vector2 spinninpoint = new Vector2(Utils.Clamp(Main.windSpeedCurrent * 16f, -16f, 16f), 8f);
					EntitySource_ByProjectileSourceId spawnSource2 = new EntitySource_ByProjectileSourceId(20);
					spinninpoint = spinninpoint.RotatedByRandom(0.13089969754219055);
					Projectile.NewProjectile(spawnSource2, position2.X, position2.Y, spinninpoint.X, spinninpoint.Y, 1049, 70, 10f, Main.myPlayer, 0f, num7, 0f, NewProjectileModifiers.RainHazard);
				}
			}
		}
		if (meteorShowerCount > 0)
		{
			if (Main.fastForwardTimeToDawn || Main.fastForwardTimeToDusk)
			{
				meteorShowerCount = 0;
			}
			int maxValue3 = 4;
			if (Main.rand.Next(maxValue3) == 0)
			{
				int num8 = 12;
				int num9 = Main.rand.Next(Main.maxTilesX - 50) + 100;
				num9 *= 16;
				int num10 = Main.rand.Next((int)((double)Main.maxTilesY * 0.05));
				num10 *= 16;
				Vector2 position3 = new Vector2(num9, num10);
				int num11 = Player.FindClosest(position3, 12, 12);
				if (Main.player[num11].active && !Main.player[num11].dead && Main.rand.Next(2) == 0)
				{
					num9 = (int)Main.player[num11].Center.X + Main.rand.Next(-2400, 2400);
					num9 = Utils.Clamp(num9, 800, (Main.maxTilesX - 50) * 16);
					position3.X = num9;
				}
				if (!Collision.SolidCollision(position3, 16, 16))
				{
					meteorShowerCount--;
					float num12 = Main.rand.Next(-100, 101);
					float num13 = Main.rand.Next(200) + 100;
					float num14 = (float)Math.Sqrt(num12 * num12 + num13 * num13);
					num14 = (float)num8 / num14;
					num12 *= num14;
					num13 *= num14;
					EntitySource_ByProjectileSourceId spawnSource3 = new EntitySource_ByProjectileSourceId(21);
					int damage = 50;
					if (Main.masterMode)
					{
						damage = 35;
					}
					else if (Main.expertMode)
					{
						damage = 40;
					}
					Projectile.NewProjectile(spawnSource3, position3.X, position3.Y, num12, num13, 1078, damage, 5f);
				}
			}
		}
		if (Main.coinRain > 0)
		{
			if (!Main.raining || Main.IsItStorming)
			{
				Main.coinRain = 0;
			}
			else if (Main.rand.Next(30) == 0)
			{
				int num15 = Main.rand.Next(50, Main.maxTilesX - 50);
				num15 *= 16;
				int num16 = Main.rand.Next((int)((double)Main.maxTilesY * 0.05));
				num16 *= 16;
				Vector2 position4 = new Vector2(num15, num16);
				int num17 = Player.FindClosest(position4, 12, 12);
				if (Main.player[num17].active && !Main.player[num17].dead && Main.rand.Next(2) == 0)
				{
					num15 = (int)Main.player[num17].Center.X + Main.rand.Next(-2400, 2400);
					num15 = Utils.Clamp(num15, 800, (Main.maxTilesX - 50) * 16);
					position4.X = num15;
				}
				if (!Collision.SolidCollision(position4, 32, 32))
				{
					int type = 71;
					int num18 = Main.rand.Next(50, 100);
					int num19 = num18;
					if (Main.rand.Next(3) == 0)
					{
						type = 72;
						num18 = Main.rand.Next(25, 100);
						num19 = num18 * 100;
					}
					if (Main.rand.Next(9) == 0)
					{
						type = 73;
						num18 = 1;
						num19 = num18 * 100 * 100;
					}
					int num20 = Item.NewItem(GetItemSource_FromCoinRain(num15, num16), num15, num16, 16, 16, type, num18);
					Main.coinRain -= num19;
					if (num20 > 390)
					{
						Main.coinRain = 0;
					}
					if (Main.coinRain < 0)
					{
						Main.coinRain = 0;
					}
				}
			}
		}
		if (Main.dayTime && !Main.remixWorld)
		{
			return;
		}
		for (int i = 0; i < Main.dayRate; i++)
		{
			double num21 = (double)Main.maxTilesX / 4200.0;
			num21 *= (double)Star.starfallBoost;
			if ((double)Main.rand.Next(8000) < 10.0 * num21)
			{
				int num22 = 12;
				int num23 = Main.rand.Next(Main.maxTilesX - 50) + 100;
				num23 *= 16;
				int num24 = Main.rand.Next((int)((double)Main.maxTilesY * 0.05));
				num24 *= 16;
				Vector2 position5 = new Vector2(num23, num24);
				int num25 = -1;
				int range = 15;
				int num26 = Player.FindClosest(position5, 1, 1);
				range = ((!Main.remixWorld) ? Main.player[num26].RollLuck(range) : Main.player[num26].RollBadLuck(range));
				if (range == 0 && (double)Main.player[num26].position.Y < Main.worldSurface * 16.0 && Main.player[num26].afkCounter < Player.AFKTimeNeededForNoLuckyStars)
				{
					int num27 = Main.rand.Next(1, 640);
					position5.X = Main.player[num26].position.X + (float)Main.rand.Next(-num27, num27 + 1);
					num25 = num26;
				}
				if (!Collision.SolidCollision(position5, 16, 16))
				{
					float num28 = Main.rand.Next(-100, 101);
					float num29 = Main.rand.Next(200) + 100;
					float num30 = (float)Math.Sqrt(num28 * num28 + num29 * num29);
					num30 = (float)num22 / num30;
					num28 *= num30;
					num29 *= num30;
					Projectile.NewProjectile(new EntitySource_ByProjectileSourceId(11), position5.X, position5.Y, num28, num29, 720, 0, 0f, Main.myPlayer, 0f, num25);
				}
			}
		}
	}

	private static void DebugLogLightning(string msg)
	{
	}

	private static void SpawnStormLightning()
	{
		if (!Main.IsItStorming)
		{
			return;
		}
		int num = 150;
		if (NPC.AnyDanger())
		{
			num = (int)(1.5 * (double)num);
		}
		List<Rectangle> spawnThunderStorm_SafeSpots = _SpawnThunderStorm_SafeSpots;
		spawnThunderStorm_SafeSpots.Clear();
		for (int i = 0; i < 255; i++)
		{
			Player player = Main.player[i];
			if (player.active && !player.dead)
			{
				Rectangle rectangle = Utils.CenteredRectangle(size: new Point(24, 24), center: player.Center.ToTileCoordinates());
				Rectangle value = rectangle;
				double num2 = Utils.Clamp(player.velocity.X, -5.75, 5.75);
				value.Offset(new Point((int)(num2 * 60.0 / 16.0), 0));
				rectangle = Rectangle.Union(rectangle, value);
				spawnThunderStorm_SafeSpots.Add(rectangle);
			}
		}
		for (int j = 0; j < 255; j++)
		{
			Player player2 = Main.player[j];
			if (player2.active && !player2.dead && player2.ZoneRain && !player2.ZoneSnow && player2.afkCounter < Player.AFKTimeNeededForNoLuckyStars)
			{
				int num3 = num;
				if (player2.sleeping.isSleeping)
				{
					num3 *= 2;
				}
				if (player2.HeldItem.fishingPole > 0)
				{
					num3 *= 2;
				}
				if (Main.rand.Next(num3) == 0)
				{
					SpawnStormLightningNearPlayer(spawnThunderStorm_SafeSpots, player2);
				}
			}
		}
	}

	private static void SpawnStormLightningNearPlayer(List<Rectangle> safespots, Player player)
	{
		Rectangle tileRectangle = Utils.CenteredRectangle(player.Center.ToTileCoordinates(), Point.Zero);
		tileRectangle.Inflate(Main.MaxWorldViewSize.X / 32, Main.MaxWorldViewSize.Y / 32);
		tileRectangle = WorldUtils.ClampToWorld(tileRectangle, 10);
		if (tileRectangle.Width == 0 || tileRectangle.Height == 0)
		{
			return;
		}
		for (int i = 0; i < 400; i++)
		{
			int num = Main.rand.Next(tileRectangle.Left, tileRectangle.Right + 1);
			int num2 = Main.rand.Next(tileRectangle.Top, tileRectangle.Bottom + 1);
			Tile tile = Main.tile[num, num2];
			while (num2 > 0 && IsLightningAttractor(Main.tile[num, num2 - 1]))
			{
				tile = Main.tile[num, --num2];
			}
			if (i < 350)
			{
				if (!IsLightningAttractor(tile))
				{
					continue;
				}
			}
			else if (tile.liquid == 0 && !SolidTile(tile))
			{
				continue;
			}
			if (num2 <= 0 || Main.tile[num, num2 - 1].liquid == 0)
			{
				bool shouldSkipForThisPlayer = false;
				if (TrySpawnLightningBolt(safespots, num, num2, ref shouldSkipForThisPlayer))
				{
					DebugLogLightning((i < 350) ? "attracted" : "spawned");
					return;
				}
				if (shouldSkipForThisPlayer)
				{
					DebugLogLightning("too close to existing strike");
					return;
				}
			}
		}
		DebugLogLightning("no target");
	}

	private static bool IsLightningAttractor(Tile tile)
	{
		if (tile.nactive())
		{
			if (!TileID.Sets.GetsCheckedForLeaves[tile.type])
			{
				return TileID.Sets.AttractsStormLightning[tile.type];
			}
			return true;
		}
		return false;
	}

	private static bool TrySpawnLightningBolt(List<Rectangle> safespots, int x, int y, ref bool shouldSkipForThisPlayer)
	{
		if (IsSafeFromRain(x, y - 1))
		{
			return false;
		}
		foreach (Rectangle safespot in safespots)
		{
			if (safespot.Contains(x, y))
			{
				return false;
			}
		}
		Vector2 other = new Vector2(x * 16 + 8, y * 16 + 2);
		for (int i = 0; i < 1000; i++)
		{
			Projectile projectile = Main.projectile[i];
			if (projectile.active && projectile.type == 1091 && projectile.Distance(other) < 800f)
			{
				shouldSkipForThisPlayer = true;
				return false;
			}
		}
		return TrySpawnLightningBolt(x, y);
	}

	public static bool TrySpawnLightningBolt(int x, int y)
	{
		int num = Main.rand.Next(Utils.MaxFloatInt + 1);
		int num2 = 2;
		if (Main.tile[x, y].liquid > 0)
		{
			num2 += 16 * (255 - Main.tile[x, y].liquid) / 255;
		}
		Vector2 vector = new Vector2(x * 16 + 8, y * 16 + num2);
		if (!LightningGenerator.StormLightning.CanHitTarget((uint)num, vector))
		{
			return false;
		}
		Projectile.NewProjectile(new EntitySource_ByProjectileSourceId(22), vector, Vector2.Zero, 1091, 500, 0f, Main.myPlayer, -1f, 0f, num);
		return true;
	}

	public static int GetWorldUpdateRate()
	{
		int result = Math.Min(Main.desiredWorldTilesUpdateRate, 24);
		if (CreativePowerManager.Instance.GetPower<CreativePowers.FreezeTime>().Enabled)
		{
			result = 0;
		}
		return result;
	}

	private static void UpdateWorld_OvergroundTile(int i, int j, int wallDist)
	{
		int num = i - 1;
		int num2 = i + 2;
		int num3 = j - 1;
		int num4 = j + 2;
		if (num < 10)
		{
			num = 10;
		}
		if (num2 > Main.maxTilesX - 10)
		{
			num2 = Main.maxTilesX - 10;
		}
		if (num3 < 10)
		{
			num3 = 10;
		}
		if (num4 > Main.maxTilesY - 10)
		{
			num4 = Main.maxTilesY - 10;
		}
		if (Main.tile[i, j] == null)
		{
			return;
		}
		if (Main.tile[i, j].type == 655 && !NPC.AnyNPCs(262))
		{
			KillTile(i, j);
			if (Main.netMode == 2)
			{
				NetMessage.SendData(17, -1, -1, null, 0, i, j);
			}
		}
		if (Main.tile[i, j].type == 85)
		{
			TryGrowingAbigailsFlower(i, j);
		}
		else if (Main.tileAlch[Main.tile[i, j].type])
		{
			GrowAlch(i, j);
		}
		else if ((double)j < Main.worldSurface + 10.0 && (i < beachDistance || i > Main.maxTilesX - beachDistance) && !Main.tile[i, j].active())
		{
			int num5 = 3000;
			num5 -= (int)(Math.Abs(Main.windSpeedCurrent) * 1250f);
			if (Main.raining)
			{
				num5 -= (int)(1250f * Main.maxRaining);
			}
			if (num5 < 300)
			{
				num5 = 300;
			}
			if (genRand.Next(num5) == 0)
			{
				int k;
				for (k = j; (double)k < Main.worldSurface + 10.0 && !Main.tile[i, k].active() && k - j < 15; k++)
				{
				}
				if (Main.tile[i, k].active() && Main.tile[i, k].type == 53 && SolidTileAllowBottomSlope(i, k))
				{
					Tile other = Main.tile[i, k];
					k--;
					if (Main.tile[i, k].active() && Main.tile[i, k].type == 324)
					{
						return;
					}
					int num6 = genRand.Next(2, 5);
					int num7 = genRand.Next(8, 11);
					int num8 = 0;
					for (int l = i - num7; l <= i + num7; l++)
					{
						for (int m = k - num7; m <= k + num7; m++)
						{
							if (Main.tile[l, m].active() && (Main.tile[l, m].type == 324 || Main.tile[l, m].type == 81))
							{
								num8++;
							}
						}
					}
					if (num8 < num6)
					{
						if (genRand.Next(2) == 0 && Main.tile[i, k].liquid >= 230)
						{
							PlaceTile(i, k, 81, mute: true);
							if (Main.tile[i, k].active())
							{
								if (Main.tile[i, k].type == 81)
								{
									Main.tile[i, k].CopyPaintAndCoating(other);
								}
								if (Main.netMode == 2)
								{
									NetMessage.SendTileSquare(-1, i, k);
								}
							}
						}
						else
						{
							PlaceTile(i, k, 324, mute: true, forced: false, -1, RollRandomSeaShellStyle());
							if (Main.tile[i, k].active())
							{
								if (Main.tile[i, k].type == 324)
								{
									Main.tile[i, k].CopyPaintAndCoating(other);
								}
								if (Main.netMode == 2)
								{
									NetMessage.SendTileSquare(-1, i, k);
								}
							}
						}
					}
				}
			}
		}
		if ((Main.tile[i, j].type == 596 || Main.tile[i, j].type == 616 || Main.tile[i, j].type == 595 || Main.tile[i, j].type == 615) && (Main.tile[i, j + 1].type == 199 || Main.tile[i, j + 1].type == 23))
		{
			KillTile(i, j);
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, i, j);
			}
		}
		if ((Main.tile[i, j].type == 571 || (Main.tile[i, j].type == 60 && Main.tile[i, j - 1].liquid > 0)) && genRand.Next(5) == 0 && (!Main.tile[i, j - 1].active() || Main.tile[i, j - 1].type == 61 || Main.tile[i, j - 1].type == 74 || Main.tile[i, j - 1].type == 518) && (Main.tile[i, j].type != 60 || genRand.Next(30) == 0) && PlaceBamboo(i, j - 1))
		{
			NetMessage.SendTileSquare(-1, i, j - 1, 1, 2);
		}
		if (Main.tile[i, j].type == 518)
		{
			if (Main.tile[i, j].liquid == 0 || (Main.tile[i, j].liquid / 16 >= 9 && SolidTile(i, j - 1)) || (Main.tile[i, j - 1].liquid > 0 && Main.tile[i, j - 1].active()))
			{
				KillTile(i, j);
				if (Main.netMode == 2)
				{
					NetMessage.SendData(17, -1, -1, null, 0, i, j);
				}
			}
			else
			{
				CheckLilyPad(i, j);
			}
		}
		else if (Main.tile[i, j].type == 519)
		{
			CheckCatTail(i, j);
			if (Main.tile[i, j].active() && genRand.Next(8) == 0)
			{
				GrowCatTail(i, j);
				CheckCatTail(i, j);
			}
		}
		else if (Main.tile[i, j].liquid > 32)
		{
			if (Main.tile[i, j].active())
			{
				if (TileID.Sets.SlowlyDiesInWater[Main.tile[i, j].type])
				{
					KillTile(i, j);
					if (Main.netMode == 2)
					{
						NetMessage.SendData(17, -1, -1, null, 0, i, j);
					}
				}
				else if (Main.tile[i, j].type == 60 || Main.tile[i, j].type == 226)
				{
					UpdateWorld_GrassGrowth(i, j, num, num2, num3, num4, underground: false);
				}
			}
			else if (genRand.Next(600) == 0)
			{
				PlaceTile(i, j, 518, mute: true);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, j);
				}
			}
			else if (genRand.Next(600) == 0)
			{
				PlaceTile(i, j, 519, mute: true);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, j);
				}
			}
		}
		else if (Main.tile[i, j].nactive())
		{
			hardUpdateWorld(i, j);
			if (Main.rand.Next(3000) == 0)
			{
				plantDye(i, j);
			}
			else if (Main.hardMode && ((double)i < (double)Main.maxTilesX * 0.4 || (double)i > (double)Main.maxTilesX * 0.6) && Main.rand.Next(15000) == 0)
			{
				plantDye(i, j, exoticPlant: true);
			}
			if (Main.tile[i, j].type == 80)
			{
				if (genRand.Next(15) == 0)
				{
					GrowCactus(i, j);
				}
			}
			else if (Main.tile[i, j].type == 529)
			{
				if (CheckSeaOat(i, j) && genRand.Next(20) == 0)
				{
					GrowSeaOat(i, j);
				}
			}
			else if (TileID.Sets.Conversion.Sand[Main.tile[i, j].type])
			{
				if (!Main.tile[i, num3].active())
				{
					if (genRand.Next(25) == 0)
					{
						PlaceOasisPlant(i, num3, 530);
						if (Main.tile[i, num3].type == 530 && Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i - 1, num3 - 1, 3, 2);
						}
					}
					if (genRand.Next(20) != 0 || !PlantSeaOat(i, num3))
					{
						if (i < oceanDistance || i > Main.maxTilesX - oceanDistance)
						{
							if (genRand.Next(500) == 0)
							{
								int num9 = 7;
								int num10 = 6;
								int num11 = 0;
								for (int n = i - num9; n <= i + num9; n++)
								{
									for (int num12 = num3 - num9; num12 <= num3 + num9; num12++)
									{
										if (Main.tile[n, num12].active() && Main.tile[n, num12].type == 81)
										{
											num11++;
										}
									}
								}
								if (num11 < num10 && Main.tile[i, num3].liquid == byte.MaxValue && Main.tile[i, num3 - 1].liquid == byte.MaxValue && Main.tile[i, num3 - 2].liquid == byte.MaxValue && Main.tile[i, num3 - 3].liquid == byte.MaxValue && Main.tile[i, num3 - 4].liquid == byte.MaxValue)
								{
									PlaceTile(i, num3, 81, mute: true);
									if (Main.netMode == 2 && Main.tile[i, num3].active())
									{
										NetMessage.SendTileSquare(-1, i, num3);
									}
								}
							}
						}
						else if (i > beachDistance + 20 && i < Main.maxTilesX - beachDistance - 20 && genRand.Next(300) == 0)
						{
							GrowCactus(i, j);
						}
					}
				}
			}
			else if (Main.tile[i, j].type == 530)
			{
				if (!OasisPlantWaterCheck(i, j, boost: true))
				{
					KillTile(i, j);
					if (Main.netMode == 2)
					{
						NetMessage.SendData(17, -1, -1, null, 0, i, j);
					}
				}
			}
			else if (Main.tile[i, j].type == 147 || Main.tile[i, j].type == 161 || Main.tile[i, j].type == 163 || Main.tile[i, j].type == 164 || Main.tile[i, j].type == 200)
			{
				if (Main.rand.Next(10) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 2].active())
				{
					int num13 = i - 3;
					int num14 = i + 4;
					int num15 = 0;
					for (int num16 = num13; num16 < num14; num16++)
					{
						if (Main.tile[num16, j].type == 165 && Main.tile[num16, j].active())
						{
							num15++;
						}
						if (Main.tile[num16, j + 1].type == 165 && Main.tile[num16, j + 1].active())
						{
							num15++;
						}
						if (Main.tile[num16, j + 2].type == 165 && Main.tile[num16, j + 2].active())
						{
							num15++;
						}
						if (Main.tile[num16, j + 3].type == 165 && Main.tile[num16, j + 3].active())
						{
							num15++;
						}
					}
					if (num15 < 2)
					{
						PlaceTight(i, j + 1);
						SquareTileFrame(i, j + 1);
						if (Main.netMode == 2 && Main.tile[i, j + 1].active())
						{
							NetMessage.SendTileSquare(-1, i, j + 1, 1, 2);
						}
					}
				}
			}
			else if (Main.tile[i, j].type == 254)
			{
				if (Main.rand.Next((Main.tile[i, j].frameX + 10) / 10) == 0)
				{
					GrowPumpkin(i, j, 254);
				}
			}
			else if (Main.tile[i, j].type == 78 || Main.tile[i, j].type == 380 || Main.tile[i, j].type == 579)
			{
				if (!Main.tile[i, num3].active() && genRand.Next(2) == 0)
				{
					PlaceTile(i, num3, 3, mute: true);
					if (Main.netMode == 2 && Main.tile[i, num3].active())
					{
						NetMessage.SendTileSquare(-1, i, num3);
					}
				}
			}
			else if (TileID.Sets.SpreadOverground[Main.tile[i, j].type])
			{
				UpdateWorld_GrassGrowth(i, j, num, num2, num3, num4, underground: false);
				int type = Main.tile[i, j].type;
				if ((type == 32 || type == 352) && genRand.Next(3) == 0)
				{
					if (type == 32)
					{
						GrowSpike(i, j, 32, 23);
					}
					else
					{
						GrowSpike(i, j, 352, 199);
					}
				}
			}
			else if (Main.tileMoss[Main.tile[i, j].type] || TileID.Sets.tileMossBrick[Main.tile[i, j].type])
			{
				if (genRand.NextDouble() < 0.5)
				{
					int type2 = Main.tile[i, j].type;
					bool flag = false;
					TileColorCache color = Main.tile[i, j].BlockColorAndCoating();
					for (int num17 = num; num17 < num2; num17++)
					{
						for (int num18 = num3; num18 < num4; num18++)
						{
							if ((i != num17 || j != num18) && Main.tile[num17, num18].active() && (Main.tile[num17, num18].type == 1 || Main.tile[num17, num18].type == 38))
							{
								int type3 = Main.tile[num17, num18].type;
								int num19 = MossConversion(type2, type3);
								SpreadGrass(num17, num18, Main.tile[num17, num18].type, num19, repeat: false, color);
								if (Main.tile[num17, num18].type == num19)
								{
									SquareTileFrame(num17, num18);
									flag = true;
								}
							}
						}
					}
					if (Main.netMode == 2 && flag)
					{
						NetMessage.SendTileSquare(-1, i, j, 3);
					}
					if (genRand.Next(6) == 0)
					{
						int num20 = i;
						int num21 = j;
						switch (genRand.Next(4))
						{
						case 0:
							num20--;
							break;
						case 1:
							num20++;
							break;
						case 2:
							num21--;
							break;
						default:
							num21++;
							break;
						}
						if (!Main.tile[num20, num21].active())
						{
							if (PlaceTile(num20, num21, 184, mute: true))
							{
								Main.tile[num20, num21].CopyPaintAndCoating(Main.tile[i, j]);
							}
							if (Main.netMode == 2 && Main.tile[num20, num21].active())
							{
								NetMessage.SendTileSquare(-1, num20, num21);
							}
						}
					}
				}
			}
			else if (Main.tile[i, j].type == 20)
			{
				if (genRand.Next(20) == 0)
				{
					AttemptToGrowTreeFromSapling(i, j, underground: false);
				}
			}
			else if (Main.tile[i, j].type == 595)
			{
				if (genRand.Next(5) == 0)
				{
					AttemptToGrowTreeFromSapling(i, j, underground: false);
				}
			}
			else if (Main.tile[i, j].type == 615)
			{
				if (genRand.Next(5) == 0)
				{
					AttemptToGrowTreeFromSapling(i, j, underground: false);
				}
			}
			else if (Main.tile[i, j].type == 3 && genRand.Next(20) == 0)
			{
				if (Main.tile[i, j].frameX != 144)
				{
					Main.tile[i, j].type = 73;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, j);
					}
				}
			}
			else if (Main.tile[i, j].type == 110 && genRand.Next(20) == 0 && Main.tile[i, j].frameX < 144)
			{
				Main.tile[i, j].type = 113;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, j);
				}
			}
			if ((Main.dungeonX < 0 || Main.dungeonY < 0) && (double)j < Main.worldSurface && Main.tileDungeon[Main.tile[i, j].type])
			{
				bool flag2 = true;
				for (int num22 = i - 1; num22 <= i + 1; num22++)
				{
					for (int num23 = j - 3; num23 <= j - 1; num23++)
					{
						if (SolidTile3(num22, num23))
						{
							flag2 = false;
						}
					}
				}
				if (flag2)
				{
					Main.dungeonX = i;
					Main.dungeonY = j;
				}
			}
		}
		else
		{
			if (Main.tile[i, j].wall == 62 && Main.tile[i, j].liquid == 0)
			{
				GrowWeb(i, j);
			}
			TrySpawningTownNPC(i, j);
		}
		if (AllowedToSpreadInfections)
		{
			SpreadGrassWalls(wallDist, i, j);
			SpreadDesertWalls(wallDist, i, j);
		}
		if (Main.tile[i, j].nactive())
		{
			if (Main.tile[i, j].type == 2 || Main.tile[i, j].type == 52 || Main.tile[i, j].type == 382 || (Main.tile[i, j].type == 192 && genRand.Next(10) == 0))
			{
				int num24 = 60;
				if (Main.tile[i, j].type == 52 || Main.tile[i, j].type == 382)
				{
					num24 = 20;
				}
				num24 = 1;
				if (genRand.Next(num24) == 0 && GrowMoreVines(i, j) && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].anyLava())
				{
					bool flag3 = false;
					ushort type4 = 52;
					if (Main.tile[i, j].type == 382)
					{
						type4 = 382;
					}
					else if (Main.tile[i, j].type != 52)
					{
						if (Main.tile[i, j].wall == 68 || Main.tile[i, j].wall == 65 || Main.tile[i, j].wall == 66 || Main.tile[i, j].wall == 63)
						{
							type4 = 382;
						}
						else if (Main.tile[i, j + 1].wall == 68 || Main.tile[i, j + 1].wall == 65 || Main.tile[i, j + 1].wall == 66 || Main.tile[i, j + 1].wall == 63)
						{
							type4 = 382;
						}
						if (Main.remixWorld && genRand.Next(5) == 0)
						{
							type4 = 382;
						}
					}
					for (int num25 = j; num25 > j - 10; num25--)
					{
						if (Main.tile[i, num25].bottomSlope())
						{
							flag3 = false;
							break;
						}
						if (Main.tile[i, num25].active() && Main.tile[i, num25].type == 2 && !Main.tile[i, num25].bottomSlope())
						{
							flag3 = true;
							break;
						}
					}
					if (flag3)
					{
						int num26 = j + 1;
						Main.tile[i, num26].type = type4;
						Main.tile[i, num26].active(active: true);
						Main.tile[i, num26].CopyPaintAndCoating(Main.tile[i, j]);
						SquareTileFrame(i, num26);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, num26);
						}
					}
				}
			}
			else if (Main.tile[i, j].type == 61 && genRand.Next(3) == 0 && Main.tile[i, j + 1].type != 226 && Main.tile[i, j].frameX < 144)
			{
				if (Main.rand.Next(4) == 0)
				{
					Main.tile[i, j].frameX = (short)(162 + genRand.Next(8) * 18);
				}
				Main.tile[i, j].type = 74;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, j);
				}
			}
			if ((Main.tile[i, j].type == 60 || Main.tile[i, j].type == 62 || Main.tile[i, j].type == 384 || Main.tile[i, j].type == 226) && GrowMoreVines(i, j))
			{
				bool flag4 = true;
				int maxValue = 30;
				if (Main.tile[i, j].type == 62)
				{
					maxValue = 10;
				}
				if (Main.tile[i, j].type == 226)
				{
					flag4 = !TooManyJungleVinesNearby(i, j);
					maxValue = 20;
				}
				if (flag4 && genRand.Next(maxValue) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].anyLava())
				{
					bool flag5 = false;
					for (int num27 = j; num27 > j - 10; num27--)
					{
						if (Main.tile[i, num27].bottomSlope())
						{
							flag5 = false;
							break;
						}
						if (Main.tile[i, num27].active() && (Main.tile[i, num27].type == 60 || Main.tile[i, num27].type == 384 || Main.tile[i, num27].type == 226))
						{
							flag5 = true;
							break;
						}
					}
					if (flag5)
					{
						int num28 = j + 1;
						Main.tile[i, num28].type = 62;
						Main.tile[i, num28].active(active: true);
						Main.tile[i, num28].CopyPaintAndCoating(Main.tile[i, j]);
						SquareTileFrame(i, num28);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, num28);
						}
					}
				}
			}
			else if ((Main.tile[i, j].type == 70 || Main.tile[i, j].type == 528) && GrowMoreVines(i, j))
			{
				int maxValue2 = 70;
				if (Main.tile[i, j].type == 528)
				{
					maxValue2 = 7;
				}
				if (genRand.Next(maxValue2) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].anyLava())
				{
					bool flag6 = false;
					for (int num29 = j; num29 > j - 10; num29--)
					{
						if (Main.tile[i, num29].bottomSlope())
						{
							flag6 = false;
							break;
						}
						if (Main.tile[i, num29].active() && Main.tile[i, num29].type == 70 && !Main.tile[i, num29].bottomSlope())
						{
							flag6 = true;
							break;
						}
					}
					if (flag6)
					{
						int num30 = j + 1;
						Main.tile[i, num30].type = 528;
						Main.tile[i, num30].active(active: true);
						Main.tile[i, num30].CopyPaintAndCoating(Main.tile[i, j]);
						SquareTileFrame(i, num30);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, num30);
						}
					}
				}
			}
			else if ((Main.tile[i, j].type == 109 || Main.tile[i, j].type == 115) && GrowMoreVines(i, j))
			{
				int maxValue3 = 60;
				if (Main.tile[i, j].type == 115)
				{
					maxValue3 = 20;
				}
				if (genRand.Next(maxValue3) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].anyLava())
				{
					bool flag7 = false;
					for (int num31 = j; num31 > j - 10; num31--)
					{
						if (Main.tile[i, num31].bottomSlope())
						{
							flag7 = false;
							break;
						}
						if (Main.tile[i, num31].active() && Main.tile[i, num31].type == 109 && !Main.tile[i, num31].bottomSlope())
						{
							flag7 = true;
							break;
						}
					}
					if (flag7)
					{
						int num32 = j + 1;
						Main.tile[i, num32].type = 115;
						Main.tile[i, num32].active(active: true);
						Main.tile[i, num32].CopyPaintAndCoating(Main.tile[i, j]);
						SquareTileFrame(i, num32);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, num32);
						}
					}
				}
			}
			else if ((Main.tile[i, j].type == 23 || Main.tile[i, j].type == 661 || Main.tile[i, j].type == 636) && GrowMoreVines(i, j))
			{
				int maxValue4 = 60;
				if (Main.tile[i, j].type == 636)
				{
					maxValue4 = 20;
				}
				if (genRand.Next(maxValue4) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].anyLava())
				{
					bool flag8 = false;
					for (int num33 = j; num33 > j - 10; num33--)
					{
						if (Main.tile[i, num33].bottomSlope())
						{
							flag8 = false;
							break;
						}
						if (Main.tile[i, num33].active() && (Main.tile[i, num33].type == 23 || Main.tile[i, num33].type == 661) && !Main.tile[i, num33].bottomSlope())
						{
							flag8 = true;
							break;
						}
					}
					if (flag8)
					{
						int num34 = j + 1;
						Main.tile[i, num34].type = 636;
						Main.tile[i, num34].active(active: true);
						Main.tile[i, num34].CopyPaintAndCoating(Main.tile[i, j]);
						SquareTileFrame(i, num34);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, num34);
						}
					}
				}
			}
			else if ((Main.tile[i, j].type == 199 || Main.tile[i, j].type == 662 || Main.tile[i, j].type == 205) && GrowMoreVines(i, j))
			{
				int maxValue5 = 60;
				if (Main.tile[i, j].type == 205)
				{
					maxValue5 = 20;
				}
				if (genRand.Next(maxValue5) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].anyLava())
				{
					bool flag9 = false;
					for (int num35 = j; num35 > j - 10; num35--)
					{
						if (Main.tile[i, num35].bottomSlope())
						{
							flag9 = false;
							break;
						}
						if (Main.tile[i, num35].active() && (Main.tile[i, num35].type == 199 || Main.tile[i, num35].type == 662) && !Main.tile[i, num35].bottomSlope())
						{
							flag9 = true;
							break;
						}
					}
					if (flag9)
					{
						int num36 = j + 1;
						Main.tile[i, num36].type = 205;
						Main.tile[i, num36].active(active: true);
						Main.tile[i, num36].CopyPaintAndCoating(Main.tile[i, j]);
						SquareTileFrame(i, num36);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, num36);
						}
					}
				}
			}
			else if ((Main.tile[i, j].type == 633 || Main.tile[i, j].type == 638) && GrowMoreVines(i, j))
			{
				int maxValue6 = 70;
				if (Main.tile[i, j].type == 638)
				{
					maxValue6 = 7;
				}
				if (genRand.Next(maxValue6) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].anyLava())
				{
					bool flag10 = false;
					for (int num37 = j; num37 > j - 10; num37--)
					{
						if (Main.tile[i, num37].bottomSlope())
						{
							flag10 = false;
							break;
						}
						if (Main.tile[i, num37].active() && Main.tile[i, num37].type == 633 && !Main.tile[i, num37].bottomSlope())
						{
							flag10 = true;
							break;
						}
					}
					if (flag10)
					{
						int num38 = j + 1;
						Main.tile[i, num38].type = 638;
						Main.tile[i, num38].active(active: true);
						Main.tile[i, num38].CopyPaintAndCoating(Main.tile[i, j]);
						SquareTileFrame(i, num38);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, num38);
						}
					}
				}
			}
		}
		if (!Main.remixWorld && Main.dontStarveWorld && (float)Main.rand.Next(200) < 100f * Main.maxRaining && Main.maxRaining >= 0.2f)
		{
			DontStarveTryWateringTile(i, j);
		}
	}

	public static bool AttemptToGrowTreeFromSapling(int x, int y, bool underground, int treeHeightAddon = 0, bool ignoreWalls = false)
	{
		if (Main.netMode == 1)
		{
			return false;
		}
		if (!InWorld(x, y, 2))
		{
			return false;
		}
		Tile tile = Main.tile[x, y];
		if (tile == null || !tile.active())
		{
			return false;
		}
		bool flag = false;
		int num = 0;
		int num2 = -1;
		switch (tile.type)
		{
		case 20:
			switch (tile.frameX / 54)
			{
			case 10:
				flag = TryGrowingTreeByType(634, x, y, treeHeightAddon, ignoreWalls);
				break;
			case 6:
			case 7:
			case 8:
			case 9:
				if (underground && !Main.notTheBeesWorld && !Main.remixWorld)
				{
					return false;
				}
				flag = TryGrowingTreeByType(323, x, y, treeHeightAddon, ignoreWalls);
				break;
			default:
				if (underground && !Main.notTheBeesWorld && !Main.remixWorld)
				{
					return false;
				}
				flag = TryGrowingTreeByType(5, x, y, treeHeightAddon, ignoreWalls);
				break;
			}
			if (flag && PlayerLOS(x, y))
			{
				TreeGrowFXCheck(x, y);
			}
			return flag;
		case 595:
			num = tile.frameX / 54;
			num2 = 596;
			if (num == 0)
			{
				num2 = 596;
			}
			flag = TryGrowingTreeByType(num2, x, y, treeHeightAddon, ignoreWalls);
			if (flag && PlayerLOS(x, y))
			{
				TreeGrowFXCheck(x, y);
			}
			return flag;
		case 615:
			num = tile.frameX / 54;
			num2 = 616;
			if (num == 0)
			{
				num2 = 616;
			}
			flag = TryGrowingTreeByType(num2, x, y, treeHeightAddon, ignoreWalls);
			if (flag && PlayerLOS(x, y))
			{
				TreeGrowFXCheck(x, y);
			}
			return flag;
		case 590:
			if (!underground)
			{
				return false;
			}
			num = tile.frameX / 54;
			num2 = 587;
			switch (num)
			{
			case 0:
				num2 = 583;
				break;
			case 1:
				num2 = 584;
				break;
			case 2:
				num2 = 585;
				break;
			case 3:
				num2 = 586;
				break;
			case 4:
				num2 = 587;
				break;
			case 5:
				num2 = 588;
				break;
			case 6:
				num2 = 589;
				break;
			}
			flag = TryGrowingTreeByType(num2, x, y, treeHeightAddon, ignoreWalls);
			if (flag && PlayerLOS(x, y))
			{
				TreeGrowFXCheck(x, y);
			}
			return flag;
		default:
			return false;
		}
	}

	public static void DontStarveTryWateringTile(int x, int y)
	{
		Tile tile = Main.tile[x, y];
		if (tile.active() && TileObjectData.CheckWaterDeath(tile) && !IsSafeFromRain(x, y) && !HasAnyWireNearby(x, y, 0) && !TryToggleLight(x, y, false, skipWires: false))
		{
			KillTile(x, y);
			if (Main.netMode == 2)
			{
				NetMessage.SendData(17, -1, -1, null, 0, x, y);
			}
		}
	}

	public static bool HasAnyWireNearby(int sourceX, int sourceY, int boxSpread)
	{
		int num = Utils.Clamp(sourceX - boxSpread, 0, Main.maxTilesX - 1);
		int num2 = Utils.Clamp(sourceX + boxSpread, 0, Main.maxTilesX - 1);
		int num3 = Utils.Clamp(sourceY - boxSpread, 0, Main.maxTilesY - 1);
		int num4 = Utils.Clamp(sourceY + boxSpread, 0, Main.maxTilesY - 1);
		for (int i = num; i <= num2; i++)
		{
			for (int j = num3; j <= num4; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile != null && (tile.wire() || tile.wire2() || tile.wire3() || tile.wire4()))
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool IsSafeFromRain(int startX, int startY)
	{
		Vector2D vector2D = -Rain.GetRainFallVelocity().SafeNormalize(new Vector2(0f, 1f)).ToVector2D();
		Vector2D vector2D2 = new Vector2D(startX, startY) * 16.0 + Vector2D.One * 8.0;
		double num = 85.0;
		DelegateMethods.CheckResultOut = false;
		Utils.PlotTileLine(vector2D2, vector2D2 + vector2D * 16.0 * num, 4.0, DelegateMethods.CheckStopForSolids);
		return DelegateMethods.CheckResultOut;
	}

	public static bool TryToggleLight(int x, int y, bool? forcedState, bool skipWires)
	{
		Tile tile = Main.tile[x, y];
		if (!tile.active())
		{
			return false;
		}
		if (TileID.Sets.Torches[tile.type])
		{
			Wiring.ToggleTorch(x, y, tile, forcedState);
			return true;
		}
		if (TileID.Sets.Campfires[tile.type])
		{
			Wiring.ToggleCampFire(x, y, tile, forcedState, skipWires);
			return true;
		}
		switch (tile.type)
		{
		default:
			return false;
		case 33:
		case 49:
		case 174:
		case 372:
		case 646:
			Wiring.ToggleCandle(x, y, tile, forcedState);
			return true;
		case 405:
			Wiring.ToggleFirePlace(x, y, tile, forcedState, skipWires);
			return true;
		case 95:
		case 100:
		case 126:
		case 173:
		case 564:
			Wiring.Toggle2x2Light(x, y, tile, forcedState, skipWires);
			return true;
		case 92:
			Wiring.ToggleLampPost(x, y, tile, forcedState, skipWires);
			return true;
		case 34:
			Wiring.ToggleChandelier(x, y, tile, forcedState, skipWires);
			return true;
		case 93:
			Wiring.ToggleLamp(x, y, tile, forcedState, skipWires);
			return true;
		case 42:
			Wiring.ToggleHangingLantern(x, y, tile, forcedState, skipWires);
			return true;
		case 149:
			Wiring.ToggleHolidayLight(x, y, tile, forcedState);
			return true;
		}
	}

	private static bool HasValidGroundForAbigailsFlowerBelowSpot(int x, int y)
	{
		if (!InWorld(x, y, 2))
		{
			return false;
		}
		Tile tile = Main.tile[x, y + 1];
		if (tile == null || !tile.active())
		{
			return false;
		}
		ushort type = tile.type;
		if (type < 0 || type >= TileID.Count)
		{
			return false;
		}
		if (type != 70 && type != 633 && !TileID.Sets.Conversion.Grass[type])
		{
			return false;
		}
		return SolidTileAllowBottomSlope(x, y + 1);
	}

	private static bool TryGrowingAbigailsFlower(int i, int j)
	{
		if (Main.rand.Next(30) != 0)
		{
			return false;
		}
		int num = 1;
		if (Main.dontStarveWorld)
		{
			num = 2;
		}
		for (int k = 0; k < num; k++)
		{
			int num2 = genRand.Next(Math.Max(10, i - 10), Math.Min(Main.maxTilesX - 10, i + 10));
			int num3 = genRand.Next(Math.Max(10, j - 10), Math.Min(Main.maxTilesY - 10, j + 10));
			if (HasValidGroundForAbigailsFlowerBelowSpot(num2, num3) && NoNearbyAbigailsFlower(num2, num3) && PlaceTile(num2, num3, 624, mute: true))
			{
				if (Main.netMode == 2 && Main.tile[num2, num3] != null && Main.tile[num2, num3].active())
				{
					NetMessage.SendTileSquare(-1, num2, num3);
				}
				return true;
			}
		}
		return false;
	}

	private static bool NoNearbyAbigailsFlower(int i, int j)
	{
		int num = Utils.Clamp(i - 120, 10, Main.maxTilesX - 1 - 10);
		int num2 = Utils.Clamp(i + 120, 10, Main.maxTilesX - 1 - 10);
		int num3 = Utils.Clamp(j - 120, 10, Main.maxTilesY - 1 - 10);
		int num4 = Utils.Clamp(j + 120, 10, Main.maxTilesY - 1 - 10);
		for (int k = num; k <= num2; k++)
		{
			for (int l = num3; l <= num4; l++)
			{
				Tile tile = Main.tile[k, l];
				if (tile.active() && tile.type == 624)
				{
					return false;
				}
			}
		}
		return true;
	}

	private static bool HasValidGroundForGlowTulipBelowSpot(int x, int y)
	{
		if (!InWorld(x, y, 2))
		{
			return false;
		}
		Tile tile = Main.tile[x, y + 1];
		if (tile == null || !tile.active())
		{
			return false;
		}
		ushort type = tile.type;
		if (type < 0 || type >= TileID.Count)
		{
			return false;
		}
		if (type != 0 && type != 70 && type != 633 && type != 59 && type != 225 && !TileID.Sets.Conversion.Grass[type] && !TileID.Sets.Conversion.Stone[type] && !Main.tileMoss[type])
		{
			return false;
		}
		return SolidTileAllowBottomSlope(x, y + 1);
	}

	private static bool TryGrowingGlowTulip(int i, int j)
	{
		int num = 5;
		for (int k = 0; k < num; k++)
		{
			int num2 = genRand.Next(Math.Max(10, i - 10), Math.Min(Main.maxTilesX - 10, i + 10));
			int num3 = genRand.Next(Math.Max(10, j - 10), Math.Min(Main.maxTilesY - 10, j + 10));
			if (!HasValidGroundForGlowTulipBelowSpot(num2, num3) || !NoNearbyGlowTulips(num2, num3))
			{
				continue;
			}
			PlaceTile(num2, num3, 656, mute: true);
			Tile tile = Main.tile[num2, num3];
			if (tile.active() && tile.type == 656)
			{
				if (!generatingWorld && Main.netMode == 2 && Main.tile[num2, num3] != null && Main.tile[num2, num3].active())
				{
					NetMessage.SendTileSquare(-1, num2, num3);
				}
				return true;
			}
		}
		return false;
	}

	private static bool NoNearbyGlowTulips(int i, int j)
	{
		int num = Utils.Clamp(i - 120, 10, Main.maxTilesX - 1 - 10);
		int num2 = Utils.Clamp(i + 120, 10, Main.maxTilesX - 1 - 10);
		int num3 = Utils.Clamp(j - 120, 10, Main.maxTilesY - 1 - 10);
		int num4 = Utils.Clamp(j + 120, 10, Main.maxTilesY - 1 - 10);
		for (int k = num; k <= num2; k++)
		{
			for (int l = num3; l <= num4; l++)
			{
				Tile tile = Main.tile[k, l];
				if (tile.active() && tile.type == 656)
				{
					return false;
				}
			}
		}
		return true;
	}

	private static bool TooManyJunglePlantsNearby(int i, int j, int maxCount = 2)
	{
		int num = Utils.Clamp(i - 9, 10, Main.maxTilesX - 1 - 10);
		int num2 = Utils.Clamp(i + 9, 10, Main.maxTilesX - 1 - 10);
		int num3 = Utils.Clamp(j - 5, 10, Main.maxTilesY - 1 - 10);
		int num4 = Utils.Clamp(j + 5, 10, Main.maxTilesY - 1 - 10);
		int num5 = 0;
		for (int k = num; k <= num2; k++)
		{
			for (int l = num3; l <= num4; l++)
			{
				Tile tile = Main.tile[k, l];
				if (tile.active() && (tile.type == 61 || tile.type == 74))
				{
					num5++;
					if (num5 > maxCount)
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	private static bool TooManyJungleVinesNearby(int i, int j, int maxCount = 6)
	{
		int num = Utils.Clamp(i - 9, 10, Main.maxTilesX - 1 - 10);
		int num2 = Utils.Clamp(i + 9, 10, Main.maxTilesX - 1 - 10);
		int num3 = Utils.Clamp(j - 5, 10, Main.maxTilesY - 1 - 10);
		int num4 = Utils.Clamp(j + 5, 10, Main.maxTilesY - 1 - 10);
		int num5 = 0;
		for (int k = num; k <= num2; k++)
		{
			for (int l = num3; l <= num4; l++)
			{
				Tile tile = Main.tile[k, l];
				if (tile.active() && tile.type == 62)
				{
					num5++;
					if (num5 > maxCount)
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	private static void UpdateWorld_UndergroundTile(int i, int j, int wallDist)
	{
		int num = i - 1;
		int num2 = i + 2;
		int num3 = j - 1;
		int num4 = j + 2;
		if (num < 10)
		{
			num = 10;
		}
		if (num2 > Main.maxTilesX - 10)
		{
			num2 = Main.maxTilesX - 10;
		}
		if (num3 < 10)
		{
			num3 = 10;
		}
		if (num4 > Main.maxTilesY - 10)
		{
			num4 = Main.maxTilesY - 10;
		}
		if (Main.tile[i, j] == null)
		{
			return;
		}
		if (Main.tile[i, j].type == 655 && !NPC.AnyNPCs(262))
		{
			KillTile(i, j);
			if (Main.netMode == 2)
			{
				NetMessage.SendData(17, -1, -1, null, 0, i, j);
			}
		}
		if (Main.tileAlch[Main.tile[i, j].type])
		{
			GrowAlch(i, j);
		}
		else if (Main.tile[i, j].nactive())
		{
			hardUpdateWorld(i, j);
			if (Main.rand.Next(2500) == 0)
			{
				plantDye(i, j);
			}
			else if (Main.hardMode && Main.rand.Next(10000) == 0)
			{
				plantDye(i, j, exoticPlant: true);
			}
			if (Main.tile[i, j].type == 519)
			{
				CheckCatTail(i, j);
				if (Main.tile[i, j].active() && genRand.Next(2) == 0)
				{
					GrowCatTail(i, j);
					CheckCatTail(i, j);
				}
			}
			if (Main.tile[i, j].type == 549)
			{
				GrowCheckSeaweed(i, j);
			}
			else if (Main.tile[i, j].type == 53 && !Main.tile[i, j].topSlope() && !Main.tile[i, j].halfBrick() && !Main.tile[i, j - 1].active() && genRand.Next(20) == 0)
			{
				GrowCheckSeaweed(i, j);
			}
			else if (TileID.Sets.SpreadUnderground[Main.tile[i, j].type])
			{
				UpdateWorld_GrassGrowth(i, j, num, num2, num3, num4, underground: true);
				int type = Main.tile[i, j].type;
				if ((type == 32 || type == 352) && genRand.Next(3) == 0)
				{
					if (type == 32)
					{
						GrowSpike(i, j, 32, 23);
					}
					else
					{
						GrowSpike(i, j, 352, 199);
					}
				}
			}
			else if (Main.tile[i, j].type == 61 && genRand.Next(3) == 0)
			{
				if (Main.tile[i, j + 1].type != 226 && Main.tile[i, j].frameX < 144)
				{
					if (Main.rand.Next(4) == 0)
					{
						Main.tile[i, j].frameX = (short)(162 + genRand.Next(8) * 18);
					}
					Main.tile[i, j].type = 74;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, j);
					}
				}
			}
			else if ((Main.tile[i, j].type == 60 || Main.tile[i, j].type == 62) && genRand.Next(5) == 0 && GrowMoreVines(i, j))
			{
				if (!Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].anyLava())
				{
					bool flag = false;
					for (int num5 = j; num5 > j - 10; num5--)
					{
						if (Main.tile[i, num5].bottomSlope())
						{
							flag = false;
							break;
						}
						if (Main.tile[i, num5].active() && Main.tile[i, num5].type == 60 && !Main.tile[i, num5].bottomSlope())
						{
							flag = true;
							break;
						}
					}
					if (flag)
					{
						int num6 = j + 1;
						Main.tile[i, num6].type = 62;
						Main.tile[i, num6].active(active: true);
						SquareTileFrame(i, num6);
						Main.tile[i, num6].CopyPaintAndCoating(Main.tile[i, num6 - 1]);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, num6);
						}
					}
				}
			}
			else if ((Main.tile[i, j].type == 633 || Main.tile[i, j].type == 638) && GrowMoreVines(i, j))
			{
				if (!Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].anyLava())
				{
					int maxValue = 70;
					if (Main.tile[i, j].type == 638)
					{
						maxValue = 7;
					}
					if (genRand.Next(maxValue) == 0)
					{
						bool flag2 = false;
						for (int num7 = j; num7 > j - 10; num7--)
						{
							if (Main.tile[i, num7].bottomSlope())
							{
								flag2 = false;
								break;
							}
							if (Main.tile[i, num7].active() && Main.tile[i, num7].type == 633 && !Main.tile[i, num7].bottomSlope())
							{
								flag2 = true;
								break;
							}
						}
						if (flag2)
						{
							int num8 = j + 1;
							Main.tile[i, num8].type = 638;
							Main.tile[i, num8].active(active: true);
							Main.tile[i, num8].CopyPaintAndCoating(Main.tile[i, num8 - 1]);
							SquareTileFrame(i, num8);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, i, num8);
							}
						}
					}
				}
			}
			else if ((Main.tile[i, j].type == 70 || Main.tile[i, j].type == 528) && GrowMoreVines(i, j))
			{
				if (!Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].anyLava())
				{
					int maxValue2 = 70;
					if (Main.tile[i, j].type == 528)
					{
						maxValue2 = 7;
					}
					if (genRand.Next(maxValue2) == 0)
					{
						bool flag3 = false;
						for (int num9 = j; num9 > j - 10; num9--)
						{
							if (Main.tile[i, num9].bottomSlope())
							{
								flag3 = false;
								break;
							}
							if (Main.tile[i, num9].active() && Main.tile[i, num9].type == 70 && !Main.tile[i, num9].bottomSlope())
							{
								flag3 = true;
								break;
							}
						}
						if (flag3)
						{
							int num10 = j + 1;
							Main.tile[i, num10].type = 528;
							Main.tile[i, num10].active(active: true);
							Main.tile[i, num10].CopyPaintAndCoating(Main.tile[i, num10 - 1]);
							SquareTileFrame(i, num10);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, i, num10);
							}
						}
					}
				}
			}
			else if ((Main.tile[i, j].type == 661 || Main.tile[i, j].type == 636) && GrowMoreVines(i, j))
			{
				if (!Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].anyLava())
				{
					int maxValue3 = 70;
					if (Main.tile[i, j].type == 636)
					{
						maxValue3 = 7;
					}
					if (genRand.Next(maxValue3) == 0)
					{
						bool flag4 = false;
						for (int num11 = j; num11 > j - 10; num11--)
						{
							if (Main.tile[i, num11].bottomSlope())
							{
								flag4 = false;
								break;
							}
							if (Main.tile[i, num11].active() && Main.tile[i, num11].type == 661 && !Main.tile[i, num11].bottomSlope())
							{
								flag4 = true;
								break;
							}
						}
						if (flag4)
						{
							int num12 = j + 1;
							Main.tile[i, num12].type = 636;
							Main.tile[i, num12].active(active: true);
							Main.tile[i, num12].CopyPaintAndCoating(Main.tile[i, num12 - 1]);
							SquareTileFrame(i, num12);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, i, num12);
							}
						}
					}
				}
			}
			else if ((Main.tile[i, j].type == 662 || Main.tile[i, j].type == 205) && GrowMoreVines(i, j))
			{
				if (!Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].anyLava())
				{
					int maxValue4 = 70;
					if (Main.tile[i, j].type == 205)
					{
						maxValue4 = 7;
					}
					if (genRand.Next(maxValue4) == 0)
					{
						bool flag5 = false;
						for (int num13 = j; num13 > j - 10; num13--)
						{
							if (Main.tile[i, num13].bottomSlope())
							{
								flag5 = false;
								break;
							}
							if (Main.tile[i, num13].active() && Main.tile[i, num13].type == 662 && !Main.tile[i, num13].bottomSlope())
							{
								flag5 = true;
								break;
							}
						}
						if (flag5)
						{
							int num14 = j + 1;
							Main.tile[i, num14].type = 205;
							Main.tile[i, num14].active(active: true);
							Main.tile[i, num14].CopyPaintAndCoating(Main.tile[i, num14 - 1]);
							SquareTileFrame(i, num14);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, i, num14);
							}
						}
					}
				}
			}
			else if ((Main.tile[i, j].type == 60 || Main.tile[i, j].type == 62) && genRand.Next(80) == 0 && !PlayerLOS(i, j))
			{
				bool flag6 = true;
				int num15 = j;
				if (Main.tile[i, j].type == 60)
				{
					num15++;
				}
				for (int k = i; k < i + 2; k++)
				{
					int num16 = num15 - 1;
					if (!AnchorValid(Framing.GetTileSafely(k, num16), AnchorType.SolidTile) || Main.tile[k, num16].bottomSlope())
					{
						flag6 = false;
					}
					if (Main.tile[k, num16].liquid > 0 || Main.wallHouse[Main.tile[k, num16].wall])
					{
						flag6 = false;
					}
					if (!flag6)
					{
						break;
					}
					for (int l = num15; l < num15 + 2; l++)
					{
						if ((Main.tile[k, l].active() && (!Main.tileCut[Main.tile[k, l].type] || Main.tile[k, l].type == 444)) || Main.tile[k, l].anyLava())
						{
							flag6 = false;
						}
						if (!flag6)
						{
							break;
						}
					}
					if (!flag6)
					{
						break;
					}
				}
				if (flag6 && CountNearBlocksTypes(i, j, 20, 1, 444) > 0)
				{
					flag6 = false;
				}
				if (flag6)
				{
					for (int m = i; m < i + 2; m++)
					{
						Main.tile[m, num15 - 1].slope(0);
						Main.tile[m, num15 - 1].halfBrick(halfBrick: false);
						for (int n = num15; n < num15 + 2; n++)
						{
							if (Main.tile[m, n].active())
							{
								KillTile(m, n);
							}
						}
					}
					for (int num17 = i; num17 < i + 2; num17++)
					{
						for (int num18 = num15; num18 < num15 + 2; num18++)
						{
							Main.tile[num17, num18].active(active: true);
							Main.tile[num17, num18].type = 444;
							Main.tile[num17, num18].frameX = (short)((num17 - i) * 18);
							Main.tile[num17, num18].frameY = (short)((num18 - num15) * 18);
						}
					}
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, num15 - 1, 2, 3);
					}
				}
			}
			else if (Main.tile[i, j].type == 396 && genRand.Next(80) == 0 && !PlayerLOS(i, j))
			{
				bool flag7 = true;
				int num19 = j - 1;
				for (int num20 = i; num20 < i + 2; num20++)
				{
					int num21 = num19 + 1;
					if (!AnchorValid(Framing.GetTileSafely(num20, num21), AnchorType.SolidTile) || Main.tile[num20, num21].topSlope())
					{
						flag7 = false;
					}
					if (Main.tile[num20, num21].liquid > 0 || Main.wallHouse[Main.tile[num20, num21].wall])
					{
						flag7 = false;
					}
					if (!flag7)
					{
						break;
					}
					for (int num22 = num19 - 2; num22 < num19; num22++)
					{
						if ((Main.tile[num20, num22].active() && (!Main.tileCut[Main.tile[num20, num22].type] || Main.tile[num20, num22].type == 485)) || Main.tile[num20, num22].anyLava())
						{
							flag7 = false;
						}
						if (!flag7)
						{
							break;
						}
					}
					if (!flag7)
					{
						break;
					}
				}
				if (flag7 && CountNearBlocksTypes(i, j, 20, 1, 485) > 0)
				{
					flag7 = false;
				}
				if (flag7)
				{
					bool flag8 = true;
					for (int num23 = -1; num23 >= -3; num23--)
					{
						if (Main.tile[i, j + num23].active())
						{
							flag8 = false;
							break;
						}
					}
					if (flag8)
					{
						ushort num24 = 485;
						int style = genRand.Next(4);
						if (genRand.Next(100) == 0)
						{
							num24 = 751;
							style = 0;
						}
						PlaceTile(i, j - 1, num24, mute: true, forced: false, -1, style);
						if (Main.tile[i, j - 1].active() && Main.tile[i, j - 1].type == num24)
						{
							Tile other = Main.tile[i, j];
							for (int num25 = 0; num25 < 3; num25++)
							{
								for (int num26 = 0; num26 > -2; num26--)
								{
									Tile tile = Main.tile[i + num25, j - 1 + num26];
									if (tile.active() && tile.type == num24)
									{
										tile.CopyPaintAndCoating(other);
									}
								}
							}
						}
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, j - 2, 2, 2);
						}
					}
				}
			}
			else if (Main.tile[i, j].type == 69)
			{
				GrowSpike(i, j, 69, 60);
			}
			else if (Main.tile[i, j].type == 147 || Main.tile[i, j].type == 161 || Main.tile[i, j].type == 163 || Main.tile[i, j].type == 164 || Main.tile[i, j].type == 200)
			{
				if (Main.rand.Next(10) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 2].active())
				{
					int num27 = i - 3;
					int num28 = i + 4;
					int num29 = 0;
					for (int num30 = num27; num30 < num28; num30++)
					{
						if (Main.tile[num30, j].type == 165 && Main.tile[num30, j].active())
						{
							num29++;
						}
						if (Main.tile[num30, j + 1].type == 165 && Main.tile[num30, j + 1].active())
						{
							num29++;
						}
						if (Main.tile[num30, j + 2].type == 165 && Main.tile[num30, j + 2].active())
						{
							num29++;
						}
						if (Main.tile[num30, j + 3].type == 165 && Main.tile[num30, j + 3].active())
						{
							num29++;
						}
					}
					if (num29 < 2)
					{
						PlaceTight(i, j + 1);
						SquareTileFrame(i, j + 1);
						if (Main.netMode == 2 && Main.tile[i, j + 1].active())
						{
							NetMessage.SendTileSquare(-1, i, j + 1, 1, 2);
						}
					}
				}
			}
			else if (Main.tileMoss[Main.tile[i, j].type] || TileID.Sets.tileMossBrick[Main.tile[i, j].type])
			{
				int type2 = Main.tile[i, j].type;
				bool flag9 = false;
				TileColorCache color = Main.tile[i, j].BlockColorAndCoating();
				for (int num31 = num; num31 < num2; num31++)
				{
					for (int num32 = num3; num32 < num4; num32++)
					{
						if ((i != num31 || j != num32) && Main.tile[num31, num32].active() && (Main.tile[num31, num32].type == 1 || Main.tile[num31, num32].type == 38))
						{
							int type3 = Main.tile[num31, num32].type;
							int num33 = MossConversion(type2, type3);
							SpreadGrass(num31, num32, Main.tile[num31, num32].type, num33, repeat: false, color);
							if (Main.tile[num31, num32].type == num33)
							{
								SquareTileFrame(num31, num32);
								flag9 = true;
							}
						}
					}
				}
				if (Main.netMode == 2 && flag9)
				{
					NetMessage.SendTileSquare(-1, i, j, 3);
				}
				if (genRand.Next(6) == 0)
				{
					int num34 = i;
					int num35 = j;
					switch (genRand.Next(4))
					{
					case 0:
						num34--;
						break;
					case 1:
						num34++;
						break;
					case 2:
						num35--;
						break;
					default:
						num35++;
						break;
					}
					if (!Main.tile[num34, num35].active())
					{
						if (PlaceTile(num34, num35, 184, mute: true))
						{
							Main.tile[num34, num35].CopyPaintAndCoating(Main.tile[i, j]);
						}
						if (Main.netMode == 2 && Main.tile[num34, num35].active())
						{
							NetMessage.SendTileSquare(-1, num34, num35);
						}
					}
				}
			}
			else if (Main.tile[i, j].type == 20)
			{
				if (genRand.Next(5) == 0)
				{
					AttemptToGrowTreeFromSapling(i, j, underground: true);
				}
			}
			else if (Main.tile[i, j].type == 590)
			{
				if (genRand.Next(5) == 0)
				{
					AttemptToGrowTreeFromSapling(i, j, underground: true);
				}
			}
			else if (Main.tile[i, j].type == 595)
			{
				if (genRand.Next(5) == 0)
				{
					AttemptToGrowTreeFromSapling(i, j, underground: true);
				}
			}
			else if (Main.tile[i, j].type == 615 && genRand.Next(5) == 0)
			{
				AttemptToGrowTreeFromSapling(i, j, underground: true);
			}
			if (!Main.isThereAWorldSurface && (Main.dungeonX < 0 || Main.dungeonY < 0) && (double)j < Main.rockLayer && Main.tileDungeon[Main.tile[i, j].type])
			{
				bool flag10 = true;
				for (int num36 = i - 1; num36 <= i + 1; num36++)
				{
					for (int num37 = j - 3; num37 <= j - 1; num37++)
					{
						if (SolidTile3(num36, num37))
						{
							flag10 = false;
						}
					}
				}
				if (flag10)
				{
					Main.dungeonX = i;
					Main.dungeonY = j;
				}
			}
		}
		else
		{
			if (Main.tile[i, j].wall == 62 && Main.tile[i, j].liquid == 0)
			{
				GrowWeb(i, j);
			}
			TrySpawningTownNPC(i, j);
		}
		if (AllowedToSpreadInfections)
		{
			SpreadGrassWalls(wallDist, i, j);
			SpreadDesertWalls(wallDist, i, j);
		}
		if (!Main.tile[i, j].nactive())
		{
			return;
		}
		if (Main.tile[i, j].type == 61 && genRand.Next(3) == 0 && Main.tile[i, j + 1].type != 226 && Main.tile[i, j].frameX < 144)
		{
			if (Main.rand.Next(4) == 0)
			{
				Main.tile[i, j].frameX = (short)(162 + genRand.Next(8) * 18);
			}
			Main.tile[i, j].type = 74;
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, i, j);
			}
		}
		if ((Main.tile[i, j].type == 60 || Main.tile[i, j].type == 226 || Main.tile[i, j].type == 62) && GrowMoreVines(i, j))
		{
			int maxValue5 = 30;
			if (Main.tile[i, j].type == 62)
			{
				maxValue5 = 10;
			}
			if (genRand.Next(maxValue5) != 0 || Main.tile[i, j + 1].active() || Main.tile[i, j + 1].anyLava())
			{
				return;
			}
			bool flag11 = false;
			for (int num38 = j; num38 > j - 10; num38--)
			{
				if (Main.tile[i, num38].bottomSlope())
				{
					flag11 = false;
					break;
				}
				if (Main.tile[i, num38].active() && (Main.tile[i, num38].type == 60 || Main.tile[i, num38].type == 226) && !Main.tile[i, num38].bottomSlope())
				{
					flag11 = true;
					break;
				}
			}
			if (flag11)
			{
				int num39 = j + 1;
				Main.tile[i, num39].type = 62;
				Main.tile[i, num39].active(active: true);
				Main.tile[i, num39].CopyPaintAndCoating(Main.tile[i, num39 - 1]);
				SquareTileFrame(i, num39);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, num39);
				}
			}
		}
		else if ((Main.tile[i, j].type == 633 || Main.tile[i, j].type == 638) && GrowMoreVines(i, j))
		{
			int maxValue6 = 70;
			if (Main.tile[i, j].type == 638)
			{
				maxValue6 = 7;
			}
			if (genRand.Next(maxValue6) != 0 || Main.tile[i, j + 1].active() || Main.tile[i, j + 1].anyLava())
			{
				return;
			}
			bool flag12 = false;
			for (int num40 = j; num40 > j - 10; num40--)
			{
				if (Main.tile[i, num40].bottomSlope())
				{
					flag12 = false;
					break;
				}
				if (Main.tile[i, num40].active() && Main.tile[i, num40].type == 633 && !Main.tile[i, num40].bottomSlope())
				{
					flag12 = true;
					break;
				}
			}
			if (flag12)
			{
				int num41 = j + 1;
				Main.tile[i, num41].type = 638;
				Main.tile[i, num41].active(active: true);
				Main.tile[i, num41].CopyPaintAndCoating(Main.tile[i, num41 - 1]);
				SquareTileFrame(i, num41);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, num41);
				}
			}
		}
		else
		{
			if ((Main.tile[i, j].type != 70 && Main.tile[i, j].type != 528) || !GrowMoreVines(i, j))
			{
				return;
			}
			int maxValue7 = 70;
			if (Main.tile[i, j].type == 528)
			{
				maxValue7 = 7;
			}
			if (genRand.Next(maxValue7) != 0 || Main.tile[i, j + 1].active() || Main.tile[i, j + 1].anyLava())
			{
				return;
			}
			bool flag13 = false;
			for (int num42 = j; num42 > j - 10; num42--)
			{
				if (Main.tile[i, num42].bottomSlope())
				{
					flag13 = false;
					break;
				}
				if (Main.tile[i, num42].active() && Main.tile[i, num42].type == 70 && !Main.tile[i, num42].bottomSlope())
				{
					flag13 = true;
					break;
				}
			}
			if (flag13)
			{
				int num43 = j + 1;
				Main.tile[i, num43].type = 528;
				Main.tile[i, num43].active(active: true);
				Main.tile[i, num43].CopyPaintAndCoating(Main.tile[i, num43 - 1]);
				SquareTileFrame(i, num43);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, num43);
				}
			}
		}
	}

	public static void LavaLayerCaverer()
	{
		int num = 2;
		int num2 = 8;
		int num3 = 30;
		int num4 = -1;
		int num5 = GenVars.waterLine - 1;
		int num6 = GenVars.waterLine + 1;
		int num7 = GenVars.waterLine - num3;
		int num8 = num7;
		int num9 = 10;
		while (num9 < Main.maxTilesX - 10)
		{
			num9++;
			if (genRand.Next(4) == 0)
			{
				num8 += genRand.Next(-4, 5);
				if (num8 < num7 - num3)
				{
					num8 = num7 - num3;
				}
				if (num8 > num7 + num3)
				{
					num8 = num7 + num3;
				}
			}
			if (genRand.Next(3) == 0)
			{
				num5 += genRand.Next(-4, 5);
				if (num5 < num8 - num2)
				{
					num5 = num8 - num2;
				}
				if (num5 > num8 - num)
				{
					num5 = num8 - num;
				}
			}
			if (genRand.Next(3) == 0)
			{
				num6 += genRand.Next(-4, 5);
				if (num6 > num8 + num2)
				{
					num6 = num8 + num2;
				}
				if (num6 < num8 + num)
				{
					num6 = num8 + num;
				}
			}
			for (int i = num5; i <= num6; i++)
			{
				KillTile(num9, i);
				if (!Main.tile[num9, i].active() && !Main.wallDungeon[Main.tile[num9, i].wall] && genRand.Next(15) == 0)
				{
					Main.tile[num9, i].liquid = byte.MaxValue;
					Main.tile[num9, i].lava(lava: true);
				}
			}
			bool flag = true;
			for (int j = num5 - 1; j <= num6 + 1; j++)
			{
				if (Main.wallDungeon[Main.tile[num9, j].wall])
				{
					if (j > num5 && j < num6)
					{
						flag = false;
					}
					if (Main.wallDungeon[Main.tile[num9, num5].wall] && Main.tile[num9, num5].wall == Main.tile[num9, num6].wall)
					{
						num4 = Main.tile[num9, num5].wall;
					}
					if (num4 < 0)
					{
						num4 = Main.tile[num9, j].wall;
					}
					else
					{
						Main.tile[num9, j].wall = (ushort)num4;
					}
					if ((!Main.wallDungeon[Main.tile[num9, num5 - 2].wall] && !Main.tileDungeon[Main.tile[num9, num5 - 2].type]) || (!Main.wallDungeon[Main.tile[num9, num6 + 2].wall] && !Main.tileDungeon[Main.tile[num9, num6 + 3].type]))
					{
						Main.tile[num9, j].wall = 0;
					}
				}
			}
			if (flag)
			{
				num4 = -1;
			}
			for (int k = num5; k < Main.maxTilesY - 50; k++)
			{
				if (!Main.wallDungeon[Main.tile[num9, k].wall] && Main.tile[num9, k].liquid > 0)
				{
					Main.tile[num9, k].lava(lava: true);
				}
				if (Main.tile[num9, k].type == 161)
				{
					Main.tile[num9, k].type = 1;
				}
				if (Main.tile[num9, k].type == 147)
				{
					Main.tile[num9, k].type = 0;
				}
			}
		}
		for (int l = 10; l < Main.maxTilesX - 10; l++)
		{
			for (int m = num7 - num3 - 10; m < num7 + num3 + 10; m++)
			{
				if (!Main.wallDungeon[Main.tile[l, m].wall])
				{
					continue;
				}
				int num10 = l + 20;
				for (int n = l + 1; n <= num10; n++)
				{
					if (Main.wallDungeon[Main.tile[n, m].wall])
					{
						num10 = n;
						break;
					}
				}
				if (!Main.wallDungeon[Main.tile[num10, m].wall])
				{
					continue;
				}
				for (int num11 = l; num11 <= num10; num11++)
				{
					if (!Main.wallDungeon[Main.tile[num11, m].wall])
					{
						Main.tile[num11, m].wall = Main.tile[l, m].wall;
					}
				}
			}
		}
	}

	private static void GrowWeb(int i, int j)
	{
		if (genRand.Next(10) != 0)
		{
			return;
		}
		int num = genRand.Next(2, 4);
		int num2 = i - num;
		int num3 = i + num;
		int num4 = j - num;
		int num5 = j + num;
		bool flag = false;
		for (int k = num2; k <= num3; k++)
		{
			for (int l = num4; l <= num5; l++)
			{
				if (SolidTile(k, l))
				{
					flag = true;
					break;
				}
				if (Main.notTheBeesWorld && Main.getGoodWorld && !Main.tenthAnniversaryWorld && Main.tile[k, l].wall != 62)
				{
					flag = true;
					break;
				}
			}
		}
		if (flag && !Main.tile[i, j].active())
		{
			PlaceTile(i, j, 51, mute: true);
			TileFrame(i, j, resetFrame: true);
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, i, j, 1);
			}
		}
	}

	public static bool GeneratePlanteraBulbOnAllMechsDefeated()
	{
		bool num = (double)Main.dungeonX > (double)Main.maxTilesX * 0.5;
		int num2 = (int)(num ? ((double)Main.maxTilesX * 0.15) : ((double)Main.maxTilesX * 0.65));
		int num3 = (int)(num ? ((double)Main.maxTilesX * 0.35) : ((double)Main.maxTilesX * 0.85));
		int num4 = (int)Main.worldSurface;
		int underworldLayer = Main.UnderworldLayer;
		int width = num3 - num2;
		int height = underworldLayer - num4;
		Rectangle rectangle = new Rectangle(num2, num4, width, height);
		int num5 = 2500;
		while (num5 > 0)
		{
			bool flag = num5 < 500;
			bool flag2 = num5 < 200;
			num5--;
			Point point = new Point(rectangle.X + genRand.Next(rectangle.Width), rectangle.Y + genRand.Next(rectangle.Height));
			Tile tile = Main.tile[point.X, point.Y];
			int num6 = 500;
			bool flag3 = false;
			while (!flag3)
			{
				num6--;
				if (num6 <= 0)
				{
					flag3 = true;
				}
				point.Y--;
				if (point.Y < rectangle.Y)
				{
					break;
				}
				tile = Main.tile[point.X, point.Y];
				if (tile != null && (flag2 || tile.active()))
				{
					if (tile.type == 60)
					{
						flag3 = true;
					}
					else if (flag && tile.type == 59)
					{
						flag3 = true;
					}
				}
			}
			if (tile == null)
			{
				continue;
			}
			bool num7 = tile.active() || flag2;
			bool flag4 = tile.type == 60 || (flag && tile.type == 59);
			if (num7 && flag4)
			{
				if (AttemptToGeneratePlanteraBulbAt(point.X, point.Y - 1, flag))
				{
					return true;
				}
				if (AttemptToGeneratePlanteraBulbAt(point.X - 1, point.Y - 1, flag))
				{
					return true;
				}
				if (AttemptToGeneratePlanteraBulbAt(point.X + 1, point.Y - 1, flag))
				{
					return true;
				}
			}
		}
		return false;
	}

	private static bool AttemptToGeneratePlanteraBulbAt(int i, int j, bool forceBulb)
	{
		if (forceBulb)
		{
			int num = 0;
			for (int k = -2; k < 2; k++)
			{
				for (int l = -2; l < 2; l++)
				{
					int num2 = i + k;
					int num3 = j + l;
					Tile tile = Main.tile[num2, num3];
					if (tile.type == 59 || tile.type == 60)
					{
						num++;
					}
					else if (tile.active())
					{
						num--;
					}
					if (IsAContainer(tile) || tile.type == 226 || tile.type == 237 || tile.type == 10 || tile.type == 11 || tile.type == 26 || tile.type == 16 || tile.type == 15 || tile.type == 14 || tile.type == 104 || TileID.Sets.Paintings[tile.type] || tile.type == 158 || tile.type == 105 || tile.type == 531 || tile.type == 349 || tile.type == 137 || tile.type == 443 || tile.type == 12 || tile.type == 314 || (tile.type >= 0 && TileID.Sets.Boulders[tile.type]))
					{
						num = -1;
						break;
					}
				}
				if (num <= -1)
				{
					break;
				}
			}
			if (num < 12)
			{
				return false;
			}
			for (int m = -2; m < 2; m++)
			{
				for (int n = -2; n < 2; n++)
				{
					int num4 = i + m;
					int num5 = j + n;
					bool num6 = m == -2 || m == 1 || n == -2 || n == 1;
					Tile tile2 = Main.tile[num4, num5];
					tile2.ClearTile();
					if (num6)
					{
						tile2.type = 60;
						tile2.active(active: true);
					}
					SquareTileFrame(num4, num5);
				}
			}
			PlaceJunglePlant(i, j, 238, 0, 0, inheritPaint: true);
			if (Main.tile[i, j].type == 238)
			{
				SquareTileFrame(i, j);
				SquareTileFrame(i + 2, j);
				SquareTileFrame(i - 1, j);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, j, 8);
				}
				return true;
			}
		}
		else
		{
			PlaceJunglePlant(i, j, 238, 0, 0, inheritPaint: true);
			if (Main.tile[i, j].type == 238)
			{
				SquareTileFrame(i, j);
				SquareTileFrame(i + 2, j);
				SquareTileFrame(i - 1, j);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, j, 5);
				}
				return true;
			}
		}
		return false;
	}

	private static void UpdateWorld_GrassGrowth(int i, int j, int minI, int maxI, int minJ, int maxJ, bool underground)
	{
		if (!InWorld(i, j, 10))
		{
			return;
		}
		if (underground)
		{
			int type = Main.tile[i, j].type;
			int num = -1;
			int num2 = -1;
			int num3 = -1;
			int maxValue = 1;
			int num4 = type;
			int num5 = -1;
			switch (type)
			{
			case 23:
				num = 0;
				num2 = 59;
				num4 = 23;
				num5 = 661;
				num3 = 24;
				maxValue = 2;
				if (!AllowedToSpreadInfections)
				{
					return;
				}
				break;
			case 199:
				num = 0;
				num2 = 59;
				num4 = 199;
				num5 = 662;
				num3 = 201;
				maxValue = 2;
				if (!AllowedToSpreadInfections)
				{
					return;
				}
				break;
			case 661:
				num = 59;
				num2 = 0;
				num4 = 661;
				num5 = 23;
				num3 = 24;
				maxValue = 2;
				if (!AllowedToSpreadInfections)
				{
					return;
				}
				break;
			case 662:
				num = 59;
				num2 = 0;
				num4 = 662;
				num5 = 199;
				num3 = 201;
				maxValue = 2;
				if (!AllowedToSpreadInfections)
				{
					return;
				}
				break;
			case 60:
				num = 59;
				num3 = 61;
				maxValue = 10;
				break;
			case 70:
				num = 59;
				num3 = 71;
				maxValue = 10;
				break;
			case 633:
				num = 57;
				num3 = 637;
				maxValue = 2;
				break;
			case 226:
				num = -1;
				num3 = 61;
				maxValue = 10;
				break;
			}
			bool flag = false;
			if (num3 != -1 && !Main.tile[i, minJ].active() && genRand.Next(maxValue) == 0)
			{
				bool flag2 = true;
				if (type == 226 && TooManyJunglePlantsNearby(i, minJ))
				{
					flag2 = false;
				}
				if (flag2)
				{
					flag = true;
					PlaceTile(i, minJ, num3, mute: true);
					if (Main.tile[i, minJ].active() && Main.tile[i, minJ].type == num3)
					{
						Main.tile[i, minJ].CopyPaintAndCoating(Main.tile[i, j]);
						if (Main.netMode == 2 && Main.tile[i, minJ].active())
						{
							NetMessage.SendTileSquare(-1, i, minJ);
						}
					}
				}
			}
			if (num != -1)
			{
				bool flag3 = false;
				TileColorCache color = Main.tile[i, j].BlockColorAndCoating();
				for (int k = minI; k < maxI; k++)
				{
					for (int l = minJ; l < maxJ; l++)
					{
						if (!InWorld(k, l, 10) || (i == k && j == l) || !Main.tile[k, l].active())
						{
							continue;
						}
						if (Main.tile[k, l].type == num)
						{
							SpreadGrass(k, l, num, num4, repeat: false, color);
							if (Main.tile[k, l].type == num4)
							{
								SquareTileFrame(k, l);
								flag3 = true;
							}
						}
						else if (num2 > -1 && num5 > -1 && Main.tile[k, l].type == num2)
						{
							SpreadGrass(k, l, num2, num5, repeat: false, color);
							if (Main.tile[k, l].type == num5)
							{
								SquareTileFrame(k, l);
								flag3 = true;
							}
						}
					}
				}
				if (Main.netMode == 2 && flag3)
				{
					NetMessage.SendTileSquare(-1, i, j, 3);
				}
			}
			switch (type)
			{
			case 60:
			{
				if (flag || genRand.Next(25) != 0 || Main.tile[i, minJ].liquid != 0)
				{
					break;
				}
				if (Main.hardMode && NPC.downedMechBoss1 && NPC.downedMechBoss2 && NPC.downedMechBoss3 && genRand.Next(60) == 0)
				{
					bool flag4 = true;
					int num6 = 150;
					for (int m = i - num6; m < i + num6; m += 2)
					{
						for (int n = j - num6; n < j + num6; n += 2)
						{
							if (m > 1 && m < Main.maxTilesX - 2 && n > 1 && n < Main.maxTilesY - 2 && Main.tile[m, n].active() && Main.tile[m, n].type == 238)
							{
								flag4 = false;
								break;
							}
						}
					}
					if (flag4)
					{
						PlaceJunglePlant(i, minJ, 238, 0, 0, inheritPaint: true);
						SquareTileFrame(i, minJ);
						SquareTileFrame(i + 2, minJ);
						SquareTileFrame(i - 1, minJ);
						if (Main.tile[i, minJ].type == 238 && Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, minJ, 5);
						}
					}
				}
				int maxValue2 = (Main.expertMode ? 30 : 40);
				if (Main.hardMode && NPC.downedMechBossAny && genRand.Next(maxValue2) == 0)
				{
					bool flag5 = true;
					int num7 = 60;
					if (Main.expertMode)
					{
						num7 -= 10;
					}
					for (int num8 = i - num7; num8 < i + num7; num8 += 2)
					{
						for (int num9 = j - num7; num9 < j + num7; num9 += 2)
						{
							if (num8 > 1 && num8 < Main.maxTilesX - 2 && num9 > 1 && num9 < Main.maxTilesY - 2 && Main.tile[num8, num9].active() && Main.tile[num8, num9].type == 236)
							{
								flag5 = false;
								break;
							}
						}
					}
					if (flag5)
					{
						PlaceJunglePlant(i, minJ, 236, genRand.Next(3), 0, inheritPaint: true);
						SquareTileFrame(i, minJ);
						SquareTileFrame(i + 1, minJ + 1);
						if (Main.tile[i, minJ].type == 236 && Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, minJ, 4);
						}
					}
					break;
				}
				PlaceJunglePlant(i, minJ, 233, genRand.Next(8), 0, inheritPaint: true);
				if (Main.tile[i, minJ].type == 233)
				{
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, minJ, 4);
					}
					break;
				}
				PlaceJunglePlant(i, minJ, 233, genRand.Next(12), 1, inheritPaint: true);
				if (Main.tile[i, minJ].type == 233 && Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, minJ, 3);
				}
				break;
			}
			case 70:
				if (Main.tile[i, j - 1].liquid > 0)
				{
					PlaceCatTail(i, j - 1);
				}
				if (genRand.Next(250) == 0 && TryGrowingTreeByType(5, i, j) && PlayerLOS(i, j))
				{
					TreeGrowFXCheck(i, j - 1);
				}
				break;
			}
			return;
		}
		int num10 = Main.tile[i, j].type;
		switch (num10)
		{
		case 2:
		case 23:
		case 32:
		case 109:
		case 199:
		case 352:
		case 477:
		case 492:
		case 661:
		case 662:
		{
			if (Main.halloween && genRand.Next(75) == 0 && (num10 == 2 || num10 == 109))
			{
				int num13 = 100;
				int num14 = 0;
				for (int num15 = i - num13; num15 < i + num13; num15 += 2)
				{
					for (int num16 = j - num13; num16 < j + num13; num16 += 2)
					{
						if (num15 > 1 && num15 < Main.maxTilesX - 2 && num16 > 1 && num16 < Main.maxTilesY - 2 && Main.tile[num15, num16].active() && Main.tile[num15, num16].type == 254)
						{
							num14++;
						}
					}
				}
				if (num14 < 6)
				{
					PlacePumpkin(i, minJ);
					if (Main.netMode == 2 && Main.tile[i, minJ].type == 254)
					{
						NetMessage.SendTileSquare(-1, i - 1, minJ - 1, 2, 2);
					}
				}
			}
			if (!Main.tile[i, minJ].active() && Main.tile[i, minJ].liquid == 0)
			{
				int num17 = -1;
				if (num10 == 2 && genRand.Next(12) == 0)
				{
					num17 = 3;
				}
				else if (num10 == 23 && genRand.Next(10) == 0)
				{
					num17 = 24;
				}
				else if (num10 == 199 && genRand.Next(10) == 0)
				{
					num17 = 201;
				}
				else if (num10 == 661 && genRand.Next(10) == 0)
				{
					num17 = 24;
				}
				else if (num10 == 662 && genRand.Next(10) == 0)
				{
					num17 = 201;
				}
				else if (num10 == 109 && genRand.Next(10) == 0)
				{
					num17 = 110;
				}
				else if (num10 == 633 && genRand.Next(10) == 0)
				{
					num17 = 637;
				}
				if (num17 != -1)
				{
					PlaceTile(i, minJ, num17, mute: true);
					if (Main.tile[i, minJ].active() && Main.tile[i, minJ].type == num17)
					{
						Main.tile[i, minJ].CopyPaintAndCoating(Main.tile[i, j]);
						if (Main.netMode == 2 && Main.tile[i, minJ].active())
						{
							NetMessage.SendTileSquare(-1, i, minJ);
						}
					}
				}
			}
			bool flag7 = false;
			switch (num10)
			{
			case 32:
				num10 = 23;
				if (!AllowedToSpreadInfections)
				{
					return;
				}
				break;
			case 352:
				num10 = 199;
				if (!AllowedToSpreadInfections)
				{
					return;
				}
				break;
			case 477:
				num10 = 2;
				break;
			case 492:
				num10 = 109;
				break;
			}
			int grass = num10;
			int num18 = -1;
			if (num10 == 23 || num10 == 661)
			{
				grass = 23;
				num18 = 661;
			}
			if (num10 == 199 || num10 == 662)
			{
				grass = 199;
				num18 = 662;
			}
			bool flag8 = AllowedToSpreadInfections && (num10 == 23 || num10 == 199 || num10 == 109 || num10 == 492 || num10 == 661 || num10 == 662) && InWorld(i, j, 10);
			for (int num19 = minI; num19 < maxI; num19++)
			{
				for (int num20 = minJ; num20 < maxJ; num20++)
				{
					if (!InWorld(num19, num20, 10) || (i == num19 && j == num20) || !Main.tile[num19, num20].active())
					{
						continue;
					}
					int type2 = Main.tile[num19, num20].type;
					if (!flag8 && type2 != 0 && (num18 == -1 || type2 != 59))
					{
						continue;
					}
					TileColorCache color3 = Main.tile[i, j].BlockColorAndCoating();
					if (type2 == 0 || (num18 > -1 && type2 == 59) || ((num10 == 23 || num10 == 661 || num10 == 199 || num10 == 662) && (type2 == 2 || type2 == 109 || type2 == 477 || type2 == 492)))
					{
						SpreadGrass(num19, num20, 0, grass, repeat: false, color3);
						if (num18 > -1)
						{
							SpreadGrass(num19, num20, 59, num18, repeat: false, color3);
						}
						if (AllowedToSpreadInfections && (num10 == 23 || num10 == 199 || num10 == 661 || num10 == 662))
						{
							SpreadGrass(num19, num20, 2, grass, repeat: false, color3);
							SpreadGrass(num19, num20, 109, grass, repeat: false, color3);
							SpreadGrass(num19, num20, 477, grass, repeat: false, color3);
							SpreadGrass(num19, num20, 492, grass, repeat: false, color3);
							if (num18 > -1)
							{
								SpreadGrass(num19, num20, 60, num18, repeat: false, color3);
							}
						}
						if (Main.tile[num19, num20].type == num10 || (num18 > -1 && Main.tile[num19, num20].type == num18))
						{
							SquareTileFrame(num19, num20);
							flag7 = true;
						}
					}
					if (type2 == 0 || ((num10 == 109 || num10 == 492) && (type2 == 2 || type2 == 477 || type2 == 23 || type2 == 199)))
					{
						SpreadGrass(num19, num20, 0, grass, repeat: false, color3);
						if (num10 == 109)
						{
							SpreadGrass(num19, num20, 2, grass, repeat: false, color3);
						}
						switch (num10)
						{
						case 492:
							SpreadGrass(num19, num20, 477, grass, repeat: false, color3);
							break;
						case 109:
							SpreadGrass(num19, num20, 477, 492, repeat: false, color3);
							break;
						}
						if ((num10 == 492 || num10 == 109) && AllowedToSpreadInfections)
						{
							SpreadGrass(num19, num20, 23, 109, repeat: false, color3);
						}
						if ((num10 == 492 || num10 == 109) && AllowedToSpreadInfections)
						{
							SpreadGrass(num19, num20, 199, 109, repeat: false, color3);
						}
						if (Main.tile[num19, num20].type == num10)
						{
							SquareTileFrame(num19, num20);
							flag7 = true;
						}
					}
				}
			}
			if (Main.netMode == 2 && flag7)
			{
				NetMessage.SendTileSquare(-1, i, j, 3);
			}
			break;
		}
		case 70:
		{
			if (!Main.tile[i, j].inActive())
			{
				if (!Main.tile[i, minJ].active() && genRand.Next(10) == 0)
				{
					PlaceTile(i, minJ, 71, mute: true);
					if (Main.tile[i, minJ].active())
					{
						Main.tile[i, minJ].CopyPaintAndCoating(Main.tile[i, j]);
					}
					if (Main.netMode == 2 && Main.tile[i, minJ].active())
					{
						NetMessage.SendTileSquare(-1, i, minJ);
					}
				}
				if (genRand.Next(300) == 0)
				{
					bool flag10 = PlayerLOS(i, j);
					if (TryGrowingTreeByType(5, i, j) && flag10)
					{
						TreeGrowFXCheck(i, j - 1);
					}
				}
			}
			bool flag11 = false;
			TileColorCache color5 = Main.tile[i, j].BlockColorAndCoating();
			for (int num23 = minI; num23 < maxI; num23++)
			{
				for (int num24 = minJ; num24 < maxJ; num24++)
				{
					if ((i != num23 || j != num24) && Main.tile[num23, num24].active() && Main.tile[num23, num24].type == 59)
					{
						SpreadGrass(num23, num24, 59, num10, repeat: false, color5);
						if (Main.tile[num23, num24].type == num10)
						{
							SquareTileFrame(num23, num24);
							flag11 = true;
						}
					}
				}
			}
			if (Main.netMode == 2 && flag11)
			{
				NetMessage.SendTileSquare(-1, i, j, 3);
			}
			break;
		}
		case 60:
		{
			if (!Main.tile[i, minJ].active() && genRand.Next(7) == 0)
			{
				PlaceTile(i, minJ, 61, mute: true);
				if (Main.tile[i, minJ].active())
				{
					Main.tile[i, minJ].CopyPaintAndCoating(Main.tile[i, j]);
				}
				if (Main.netMode == 2 && Main.tile[i, minJ].active())
				{
					NetMessage.SendTileSquare(-1, i, minJ);
				}
			}
			else if (genRand.Next(500) == 0 && (!Main.tile[i, minJ].active() || Main.tile[i, minJ].type == 61 || Main.tile[i, minJ].type == 74 || Main.tile[i, minJ].type == 69))
			{
				if (TryGrowingTreeByType(5, i, j) && PlayerLOS(i, j))
				{
					TreeGrowFXCheck(i, j - 1);
				}
			}
			else if (genRand.Next(25) == 0 && Main.tile[i, minJ].liquid == 0)
			{
				PlaceJunglePlant(i, minJ, 233, genRand.Next(8), 0, inheritPaint: true);
				if (Main.tile[i, minJ].type == 233)
				{
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, minJ, 4);
					}
				}
				else
				{
					PlaceJunglePlant(i, minJ, 233, genRand.Next(12), 1, inheritPaint: true);
					if (Main.tile[i, minJ].type == 233 && Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, minJ, 3);
					}
				}
			}
			bool flag9 = false;
			TileColorCache color4 = Main.tile[i, j].BlockColorAndCoating();
			for (int num21 = minI; num21 < maxI; num21++)
			{
				for (int num22 = minJ; num22 < maxJ; num22++)
				{
					if ((i != num21 || j != num22) && Main.tile[num21, num22].active() && Main.tile[num21, num22].type == 59)
					{
						SpreadGrass(num21, num22, 59, num10, repeat: false, color4);
						if (Main.tile[num21, num22].type == num10)
						{
							SquareTileFrame(num21, num22);
							flag9 = true;
						}
					}
				}
			}
			if (Main.netMode == 2 && flag9)
			{
				NetMessage.SendTileSquare(-1, i, j, 3);
			}
			break;
		}
		case 226:
			if (!Main.tile[i, minJ].active() && genRand.Next(7) == 0 && !TooManyJunglePlantsNearby(i, minJ))
			{
				PlaceTile(i, minJ, 61, mute: true);
				if (Main.tile[i, minJ].active())
				{
					Main.tile[i, minJ].CopyPaintAndCoating(Main.tile[i, j]);
				}
				if (Main.netMode == 2 && Main.tile[i, minJ].active())
				{
					NetMessage.SendTileSquare(-1, i, minJ);
				}
			}
			break;
		case 633:
		{
			if (!Main.tile[i, minJ].active() && genRand.Next(10) == 0)
			{
				PlaceTile(i, minJ, 637, mute: true);
				if (Main.tile[i, minJ].active() && Main.tile[i, minJ].type == 637)
				{
					Main.tile[i, minJ].CopyPaintAndCoating(Main.tile[i, j]);
				}
				if (Main.netMode == 2 && Main.tile[i, minJ].active())
				{
					NetMessage.SendTileSquare(-1, i, minJ);
				}
			}
			TileColorCache color2 = Main.tile[i, j].BlockColorAndCoating();
			bool flag6 = false;
			for (int num11 = minI; num11 < maxI; num11++)
			{
				for (int num12 = minJ; num12 < maxJ; num12++)
				{
					if ((i != num11 || j != num12) && Main.tile[num11, num12].active() && Main.tile[num11, num12].type == 57)
					{
						SpreadGrass(num11, num12, 57, num10, repeat: false, color2);
						if (Main.tile[num11, num12].type == num10)
						{
							SquareTileFrame(num11, num12);
							flag6 = true;
						}
					}
				}
			}
			if (Main.netMode == 2 && flag6)
			{
				NetMessage.SendTileSquare(-1, i, j, 3);
			}
			break;
		}
		}
	}

	private static void TrySpawningTownNPC(int x, int y)
	{
		if (Main.invasionType <= 0 && !Main.eclipse && ++npcSpawnDelay >= npcSpawnPeriod)
		{
			npcSpawnDelay = 0;
			if (Main.tile[x, y].wall != 34 || Main.rand.Next(4) == 0)
			{
				bool flag = Main.tileSolid[379];
				Main.tileSolid[379] = true;
				SpawnTownNPC(x, y);
				Main.tileSolid[379] = flag;
			}
		}
	}

	public static void SpreadGrassWalls(int wallDist, int i, int j)
	{
		if (!InWorld(i, j, 10))
		{
			return;
		}
		Tile tile = Main.tile[i, j];
		if (WallID.Sets.SpreadsCrimson[tile.wall] || (tile.active() && tile.type >= 0 && TileID.Sets.SpreadsCrimson[tile.type]))
		{
			int num = i + genRand.Next(-2, 3);
			int num2 = j + genRand.Next(-2, 3);
			if (!InWorld(num, num2, 10) || Main.tile[num, num2].wall < 63 || Main.tile[num, num2].wall > 68)
			{
				return;
			}
			bool flag = false;
			for (int k = i - wallDist; k <= i + wallDist; k++)
			{
				for (int l = j - wallDist; l <= j + wallDist; l++)
				{
					if (Main.tile[k, l].active())
					{
						int type = Main.tile[k, l].type;
						if (type >= 0 && TileID.Sets.SpreadsCrimson[type])
						{
							flag = true;
							break;
						}
					}
				}
			}
			if (flag)
			{
				Convert(num, num2, 4, tiles: false);
			}
		}
		else if (WallID.Sets.SpreadsCorruption[tile.wall] || (tile.active() && tile.type >= 0 && TileID.Sets.SpreadsCorruption[tile.type]))
		{
			int num3 = i + genRand.Next(-2, 3);
			int num4 = j + genRand.Next(-2, 3);
			if (!InWorld(num3, num4, 10) || Main.tile[num3, num4].wall < 63 || Main.tile[num3, num4].wall > 68)
			{
				return;
			}
			bool flag2 = false;
			for (int m = i - wallDist; m <= i + wallDist; m++)
			{
				for (int n = j - wallDist; n <= j + wallDist; n++)
				{
					if (Main.tile[m, n].active())
					{
						int type2 = Main.tile[m, n].type;
						if (type2 >= 0 && TileID.Sets.SpreadsCorruption[type2])
						{
							flag2 = true;
							break;
						}
					}
				}
			}
			if (flag2)
			{
				Convert(num3, num4, 1, tiles: false);
			}
		}
		else
		{
			if (!WallID.Sets.SpreadsHallow[tile.wall] && (!tile.active() || tile.type < 0 || !TileID.Sets.SpreadsHallow[tile.type]))
			{
				return;
			}
			int num5 = i + genRand.Next(-2, 3);
			int num6 = j + genRand.Next(-2, 3);
			if ((!InWorld(num5, num6, 10) || Main.tile[num5, num6].wall != 63) && Main.tile[num5, num6].wall != 65 && Main.tile[num5, num6].wall != 66 && Main.tile[num5, num6].wall != 68)
			{
				return;
			}
			bool flag3 = false;
			for (int num7 = i - wallDist; num7 <= i + wallDist; num7++)
			{
				for (int num8 = j - wallDist; num8 <= j + wallDist; num8++)
				{
					if (Main.tile[num7, num8].active())
					{
						int type3 = Main.tile[num7, num8].type;
						if (type3 >= 0 && TileID.Sets.SpreadsHallow[type3])
						{
							flag3 = true;
							break;
						}
					}
				}
			}
			if (flag3)
			{
				Convert(num5, num6, 2, tiles: false);
			}
		}
	}

	public static void SpreadDesertWalls(int wallDist, int i, int j)
	{
		if (!InWorld(i, j, 10) || (!WallID.Sets.Conversion.Sandstone[Main.tile[i, j].wall] && (!Main.tile[i, j].active() || !TileID.Sets.Conversion.Sandstone[Main.tile[i, j].type]) && !WallID.Sets.Conversion.HardenedSand[Main.tile[i, j].wall]))
		{
			return;
		}
		int num = 0;
		int wall = Main.tile[i, j].wall;
		int type = Main.tile[i, j].type;
		if (WallID.Sets.SpreadsCorruption[wall] || TileID.Sets.SpreadsCorruption[type])
		{
			num = 1;
		}
		if (WallID.Sets.SpreadsHallow[wall] || TileID.Sets.SpreadsHallow[type])
		{
			num = 2;
		}
		if (WallID.Sets.SpreadsCrimson[wall] || TileID.Sets.SpreadsCrimson[type])
		{
			num = 3;
		}
		if (num == 0)
		{
			return;
		}
		int conversionType = 1;
		if (num == 2)
		{
			conversionType = 2;
		}
		if (num == 3)
		{
			conversionType = 4;
		}
		int num2 = i + genRand.Next(-2, 3);
		int num3 = j + genRand.Next(-2, 3);
		bool flag = false;
		if (WallID.Sets.Conversion.PureSand[Main.tile[num2, num3].wall])
		{
			switch (num)
			{
			case 3:
			{
				for (int m = i - wallDist; m <= i + wallDist; m++)
				{
					for (int n = j - wallDist; n <= j + wallDist; n++)
					{
						if (Main.tile[m, n].active() && TileID.Sets.SpreadsCrimson[Main.tile[m, n].type])
						{
							flag = true;
							break;
						}
					}
					if (flag)
					{
						break;
					}
				}
				break;
			}
			case 2:
			{
				for (int num4 = i - wallDist; num4 <= i + wallDist; num4++)
				{
					for (int num5 = j - wallDist; num5 <= j + wallDist; num5++)
					{
						if (Main.tile[num4, num5].active() && TileID.Sets.SpreadsHallow[Main.tile[num4, num5].type])
						{
							flag = true;
							break;
						}
					}
					if (flag)
					{
						break;
					}
				}
				break;
			}
			case 1:
			{
				for (int k = i - wallDist; k <= i + wallDist; k++)
				{
					for (int l = j - wallDist; l <= j + wallDist; l++)
					{
						if (Main.tile[k, l].active() && TileID.Sets.SpreadsCorruption[Main.tile[k, l].type])
						{
							flag = true;
							break;
						}
					}
					if (flag)
					{
						break;
					}
				}
				break;
			}
			}
		}
		if (!flag)
		{
			return;
		}
		ushort? num6 = null;
		if (WallID.Sets.Conversion.Sandstone[Main.tile[num2, num3].wall])
		{
			switch (num)
			{
			case 3:
				num6 = 221;
				break;
			case 2:
				num6 = 222;
				break;
			case 1:
				num6 = 220;
				break;
			}
		}
		if (WallID.Sets.Conversion.HardenedSand[Main.tile[num2, num3].wall])
		{
			switch (num)
			{
			case 3:
				num6 = 218;
				break;
			case 2:
				num6 = 219;
				break;
			case 1:
				num6 = 217;
				break;
			}
		}
		if (num6.HasValue && Main.tile[num2, num3].wall != num6.Value)
		{
			Convert(num2, num3, conversionType, tiles: false);
		}
	}

	public static void PlaceWall(int i, int j, int type, bool mute = false)
	{
		if (i <= 1 || j <= 1 || i >= Main.maxTilesX - 2 || j >= Main.maxTilesY - 2)
		{
			return;
		}
		if (Main.tile[i, j] == null)
		{
			Main.tile[i, j] = new Tile();
		}
		if (Main.tile[i, j].wall == 0)
		{
			Main.tile[i, j].wall = (ushort)type;
			SquareWallFrame(i, j);
			if (!mute)
			{
				SoundEngine.PlaySound(0, i * 16, j * 16);
			}
		}
	}

	public static void SpreadGrass(int i, int j, int dirt = 0, int grass = 2, bool repeat = true, TileColorCache color = default(TileColorCache))
	{
		try
		{
			if (!InWorld(i, j, 10) || !Main.tile[i, j].active() || Main.tile[i, j].type != dirt)
			{
				return;
			}
			if (isGeneratingOrLoadingWorld && (grass == 199 || grass == 23))
			{
				int num = beachDistance;
				if ((!tenthAnniversaryWorldGen && (double)i > (double)Main.maxTilesX * 0.45 && (double)i <= (double)Main.maxTilesX * 0.55) || i < num || i >= Main.maxTilesX - num)
				{
					return;
				}
			}
			else if ((isGeneratingOrLoadingWorld || (grass != 199 && grass != 23 && grass != 661 && grass != 662)) && (Main.tile[i, j].type != dirt || !Main.tile[i, j].active() || ((double)j >= Main.worldSurface && dirt == 0)) && !growGrassUnderground)
			{
				return;
			}
			int num2 = i - 1;
			int num3 = i + 2;
			int num4 = j - 1;
			int num5 = j + 2;
			if (num2 < 0)
			{
				num2 = 0;
			}
			if (num3 > Main.maxTilesX)
			{
				num3 = Main.maxTilesX;
			}
			if (num4 < 0)
			{
				num4 = 0;
			}
			if (num5 > Main.maxTilesY)
			{
				num5 = Main.maxTilesY;
			}
			bool flag = true;
			for (int k = num2; k < num3; k++)
			{
				for (int l = num4; l < num5; l++)
				{
					if (!Main.tile[k, l].active() || !Main.tileSolid[Main.tile[k, l].type])
					{
						flag = false;
					}
					if (Main.tile[k, l].lava() && Main.tile[k, l].liquid > 0)
					{
						flag = true;
						break;
					}
				}
			}
			if (flag || !CanBeClearedDuringGeneration(Main.tile[i, j].type, i, j, skipDualDungeonCheck: true) || ((grass == 23 || grass == 661) && Main.tile[i, j - 1].type == 27) || ((grass == 199 || grass == 662) && Main.tile[i, j - 1].type == 27) || (grass == 109 && Main.tile[i, j - 1].type == 27))
			{
				return;
			}
			bool flag2 = dirt > 0 && TileID.Sets.Conversion.Grass[dirt];
			bool num6 = grass == 23 || grass == 661 || grass == 199 || grass == 662 || grass == 109 || grass == 492;
			if (flag2 && (grass == 23 || grass == 661))
			{
				Convert(i, j, 1, tiles: true, walls: false);
			}
			else if (flag2 && (grass == 199 || grass == 662))
			{
				Convert(i, j, 4, tiles: true, walls: false);
			}
			else if (flag2 && grass == 109)
			{
				Convert(i, j, 2, tiles: true, walls: false);
			}
			else
			{
				TryConvertingOrKillingTreesAboveIfTheyWouldBecomeInvalid(i, j, grass);
				Main.tile[i, j].type = (ushort)grass;
				SquareTileFrame(i, j);
			}
			if (!num6 || !SpecialSeedFeatures.RainbowSandAndBlackSandWalls)
			{
				Main.tile[i, j].UseBlockColors(color);
			}
			NetMessage.SendTileSquare(-1, i, j, 3);
			for (int m = num2; m < num3; m++)
			{
				for (int n = num4; n < num5; n++)
				{
					if (!Main.tile[m, n].active() || Main.tile[m, n].type != dirt)
					{
						continue;
					}
					try
					{
						if (repeat && grassSpread < 1000)
						{
							grassSpread++;
							SpreadGrass(m, n, dirt, grass);
							grassSpread--;
						}
					}
					catch
					{
					}
				}
			}
		}
		catch
		{
		}
	}

	public static void ChasmRunnerSideways(int i, int j, int direction, int steps)
	{
		double num = steps;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(10, 21) * 0.1 * (double)direction;
		vector2D2.Y = (double)genRand.Next(-10, 10) * 0.01;
		double num2 = genRand.Next(5) + 7;
		while (num2 > 0.0)
		{
			if (num > 0.0)
			{
				num2 += (double)genRand.Next(3);
				num2 -= (double)genRand.Next(3);
				if (num2 < 7.0)
				{
					num2 = 7.0;
				}
				if (num2 > 20.0)
				{
					num2 = 20.0;
				}
				if (num == 1.0 && num2 < 10.0)
				{
					num2 = 10.0;
				}
			}
			else
			{
				num2 -= (double)genRand.Next(4);
			}
			if (vector2D.Y > Main.rockLayer && num > 0.0 && !SecretSeed.noSurface.Enabled)
			{
				num = 0.0;
			}
			num -= 1.0;
			int num3 = (int)(vector2D.X - num2 * 0.5);
			int num4 = (int)(vector2D.X + num2 * 0.5);
			int num5 = (int)(vector2D.Y - num2 * 0.5);
			int num6 = (int)(vector2D.Y + num2 * 0.5);
			if (num3 < 0)
			{
				num3 = 0;
			}
			if (num4 > Main.maxTilesX - 1)
			{
				num4 = Main.maxTilesX - 1;
			}
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesY)
			{
				num6 = Main.maxTilesY;
			}
			for (int k = num3; k < num4; k++)
			{
				for (int l = num5; l < num6; l++)
				{
					if (CanEvilReplace(k, l) && Math.Abs((double)k - vector2D.X) + Math.Abs((double)l - vector2D.Y) < num2 * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[k, l].type != 31 && Main.tile[k, l].type != 22 && Main.tile[k, l].type != 204)
					{
						Main.tile[k, l].active(active: false);
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.Y += (double)genRand.Next(-10, 10) * 0.1;
			if (vector2D.Y < (double)(j - 20))
			{
				vector2D2.Y += (double)genRand.Next(20) * 0.01;
			}
			if (vector2D.Y > (double)(j + 20))
			{
				vector2D2.Y -= (double)genRand.Next(20) * 0.01;
			}
			if (vector2D2.Y < -0.5)
			{
				vector2D2.Y = -0.5;
			}
			if (vector2D2.Y > 0.5)
			{
				vector2D2.Y = 0.5;
			}
			vector2D2.X += (double)genRand.Next(-10, 11) * 0.01;
			switch (direction)
			{
			case -1:
				if (vector2D2.X > -0.5)
				{
					vector2D2.X = -0.5;
				}
				if (vector2D2.X < -2.0)
				{
					vector2D2.X = -2.0;
				}
				break;
			case 1:
				if (vector2D2.X < 0.5)
				{
					vector2D2.X = 0.5;
				}
				if (vector2D2.X > 2.0)
				{
					vector2D2.X = 2.0;
				}
				break;
			}
			num3 = (int)(vector2D.X - num2 * 1.1);
			num4 = (int)(vector2D.X + num2 * 1.1);
			num5 = (int)(vector2D.Y - num2 * 1.1);
			num6 = (int)(vector2D.Y + num2 * 1.1);
			if (num3 < 1)
			{
				num3 = 1;
			}
			if (num4 > Main.maxTilesX - 1)
			{
				num4 = Main.maxTilesX - 1;
			}
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesY)
			{
				num6 = Main.maxTilesY;
			}
			for (int m = num3; m < num4; m++)
			{
				for (int n = num5; n < num6; n++)
				{
					if (CanEvilReplace(m, n) && Math.Abs((double)m - vector2D.X) + Math.Abs((double)n - vector2D.Y) < num2 * 1.1 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[m, n].wall != GenVars.ebonStoneWall)
					{
						if (!Main.tile[m, n].active() || (Main.tile[m, n].type != 31 && Main.tile[m, n].type != 22 && Main.tile[m, n].type != 204))
						{
							Main.tile[m, n].type = GenVars.ebonStone;
						}
						Main.tile[m, n].active(active: true);
						if (Main.tile[m, n].wall == 2)
						{
							Main.tile[m, n].wall = 0;
						}
					}
				}
			}
			for (int num7 = num3; num7 < num4; num7++)
			{
				for (int num8 = num5; num8 < num6; num8++)
				{
					if (CanEvilReplace(num7, num8) && Math.Abs((double)num7 - vector2D.X) + Math.Abs((double)num8 - vector2D.Y) < num2 * 1.1 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[num7, num8].wall != GenVars.ebonStoneWall)
					{
						if (!Main.tile[num7, num8].active() || (Main.tile[num7, num8].type != 31 && Main.tile[num7, num8].type != 22 && Main.tile[num7, num8].type != 204))
						{
							Main.tile[num7, num8].type = GenVars.ebonStone;
						}
						Main.tile[num7, num8].active(active: true);
						PlaceWall(num7, num8, GenVars.ebonStoneWall, mute: true);
					}
				}
			}
		}
		if (genRand.Next(3) == 0)
		{
			int num9 = (int)vector2D.X;
			int num10;
			for (num10 = (int)vector2D.Y; !Main.tile[num9, num10].active(); num10++)
			{
			}
			TileRunner(num9, num10, genRand.Next(2, 6), genRand.Next(3, 7), 22);
		}
	}

	public static bool CanEvilReplace(int x, int y)
	{
		Tile tile = Main.tile[x, y];
		int num = (tile.active() ? tile.type : (-1));
		ushort wall = tile.wall;
		if (num >= 0 && (Main.tileDungeon[num] || TileID.Sets.CrackedBricks[num]))
		{
			return false;
		}
		if (wall >= 0 && Main.wallDungeon[wall])
		{
			return false;
		}
		return true;
	}

	public static void CrimStart(int i, int j)
	{
		double num = Main.worldSurface;
		if (SecretSeed.noSurface.Enabled)
		{
			num = Main.rockLayer;
		}
		int crimDir = 1;
		int k = j;
		if ((double)k > num)
		{
			k = (int)num;
		}
		for (; !SolidTile(i, k); k++)
		{
		}
		int num2 = k;
		Vector2D position = new Vector2D(i, k);
		Vector2D vector2D = new Vector2D((double)genRand.Next(-20, 21) * 0.1, (double)genRand.Next(20, 201) * 0.01);
		if (vector2D.X < 0.0)
		{
			crimDir = -1;
		}
		double num3 = genRand.Next(15, 26);
		bool flag = true;
		int num4 = 0;
		while (flag)
		{
			num3 += (double)genRand.Next(-50, 51) * 0.01;
			if (num3 < 15.0)
			{
				num3 = 15.0;
			}
			if (num3 > 25.0)
			{
				num3 = 25.0;
			}
			for (int l = (int)(position.X - num3 / 2.0); (double)l < position.X + num3 / 2.0; l++)
			{
				for (int m = (int)(position.Y - num3 / 2.0); (double)m < position.Y + num3 / 2.0; m++)
				{
					if (!CanEvilReplace(l, m))
					{
						continue;
					}
					if (m > num2)
					{
						if (Math.Abs((double)l - position.X) + Math.Abs((double)m - position.Y) < num3 * 0.3)
						{
							Main.tile[l, m].active(active: false);
							Main.tile[l, m].wall = GenVars.crimStoneWall;
						}
						else if (Math.Abs((double)l - position.X) + Math.Abs((double)m - position.Y) < num3 * 0.8 && Main.tile[l, m].wall != GenVars.crimStoneWall)
						{
							Main.tile[l, m].active(active: true);
							Main.tile[l, m].type = GenVars.crimStone;
							if (Math.Abs((double)l - position.X) + Math.Abs((double)m - position.Y) < num3 * 0.6)
							{
								Main.tile[l, m].wall = GenVars.crimStoneWall;
							}
						}
					}
					else if (Math.Abs((double)l - position.X) + Math.Abs((double)m - position.Y) < num3 * 0.3 && Main.tile[l, m].active())
					{
						Main.tile[l, m].active(active: false);
						Main.tile[l, m].wall = GenVars.crimStoneWall;
					}
				}
			}
			if (position.X > (double)(i + 50))
			{
				num4 = -100;
			}
			if (position.X < (double)(i - 50))
			{
				num4 = 100;
			}
			if (num4 < 0)
			{
				vector2D.X -= (double)genRand.Next(20, 51) * 0.01;
			}
			else if (num4 > 0)
			{
				vector2D.X += (double)genRand.Next(20, 51) * 0.01;
			}
			else
			{
				vector2D.X += (double)genRand.Next(-50, 51) * 0.01;
			}
			vector2D.Y += (double)genRand.Next(-50, 51) * 0.01;
			if (vector2D.Y < 0.25)
			{
				vector2D.Y = 0.25;
			}
			if (vector2D.Y > 2.0)
			{
				vector2D.Y = 2.0;
			}
			if (vector2D.X < -2.0)
			{
				vector2D.X = -2.0;
			}
			if (vector2D.X > 2.0)
			{
				vector2D.X = 2.0;
			}
			position += vector2D;
			if (position.Y > num + 100.0)
			{
				flag = false;
			}
		}
		num3 = genRand.Next(40, 55);
		for (int n = 0; n < 50; n++)
		{
			int num5 = (int)position.X + genRand.Next(-20, 21);
			int num6 = (int)position.Y + genRand.Next(-20, 21);
			for (int num7 = (int)((double)num5 - num3 / 2.0); (double)num7 < (double)num5 + num3 / 2.0; num7++)
			{
				for (int num8 = (int)((double)num6 - num3 / 2.0); (double)num8 < (double)num6 + num3 / 2.0; num8++)
				{
					if (!CanEvilReplace(num7, num8))
					{
						continue;
					}
					double num9 = Math.Abs(num7 - num5);
					double num10 = Math.Abs(num8 - num6);
					double num11 = 1.0 + (double)genRand.Next(-20, 21) * 0.01;
					double num12 = 1.0 + (double)genRand.Next(-20, 21) * 0.01;
					double num13 = num9 * num11;
					num10 *= num12;
					double num14 = Math.Sqrt(num13 * num13 + num10 * num10);
					if (num14 < num3 * 0.25)
					{
						Main.tile[num7, num8].active(active: false);
						Main.tile[num7, num8].wall = GenVars.crimStoneWall;
					}
					else if (num14 < num3 * 0.4 && Main.tile[num7, num8].wall != GenVars.crimStoneWall)
					{
						Main.tile[num7, num8].active(active: true);
						Main.tile[num7, num8].type = GenVars.crimStone;
						if (num14 < num3 * 0.35)
						{
							Main.tile[num7, num8].wall = GenVars.crimStoneWall;
						}
					}
				}
			}
		}
		int num15 = genRand.Next(5, 9);
		Vector2D[] array = new Vector2D[num15];
		for (int num16 = 0; num16 < num15; num16++)
		{
			int num17 = (int)position.X;
			int num18 = (int)position.Y;
			int num19 = 0;
			bool flag2 = true;
			Vector2D vector2D2 = new Vector2D((double)genRand.Next(-20, 21) * 0.15, (double)genRand.Next(0, 21) * 0.15);
			while (flag2)
			{
				vector2D2 = new Vector2D((double)genRand.Next(-20, 21) * 0.15, (double)genRand.Next(0, 21) * 0.15);
				while (Math.Abs(vector2D2.X) + Math.Abs(vector2D2.Y) < 1.5)
				{
					vector2D2 = new Vector2D((double)genRand.Next(-20, 21) * 0.15, (double)genRand.Next(0, 21) * 0.15);
				}
				flag2 = false;
				for (int num20 = 0; num20 < num16; num20++)
				{
					if (vector2D.X > array[num20].X - 0.75 && vector2D.X < array[num20].X + 0.75 && vector2D.Y > array[num20].Y - 0.75 && vector2D.Y < array[num20].Y + 0.75)
					{
						flag2 = true;
						num19++;
						break;
					}
				}
				if (num19 > 10000)
				{
					break;
				}
			}
			array[num16] = vector2D2;
			CrimVein(new Vector2D(num17, num18), vector2D2);
		}
		int num21 = Main.maxTilesX;
		int num22 = 0;
		position.X = i;
		position.Y = num2;
		num3 = genRand.Next(25, 35);
		double num23 = genRand.Next(0, 6);
		for (int num24 = 0; num24 < 50; num24++)
		{
			if (num23 > 0.0)
			{
				double num25 = (double)genRand.Next(10, 30) * 0.01;
				num23 -= num25;
				position.Y -= num25;
			}
			int num26 = (int)position.X + genRand.Next(-2, 3);
			int num27 = (int)position.Y + genRand.Next(-2, 3);
			for (int num28 = (int)((double)num26 - num3 / 2.0); (double)num28 < (double)num26 + num3 / 2.0; num28++)
			{
				for (int num29 = (int)((double)num27 - num3 / 2.0); (double)num29 < (double)num27 + num3 / 2.0; num29++)
				{
					if (!CanEvilReplace(num28, num29))
					{
						continue;
					}
					double num30 = Math.Abs(num28 - num26);
					double num31 = Math.Abs(num29 - num27);
					double num32 = 1.0 + (double)genRand.Next(-20, 21) * 0.005;
					double num33 = 1.0 + (double)genRand.Next(-20, 21) * 0.005;
					double num34 = num30 * num32;
					num31 *= num33;
					double num35 = Math.Sqrt(num34 * num34 + num31 * num31);
					if (num35 < num3 * 0.2 * ((double)genRand.Next(90, 111) * 0.01))
					{
						Main.tile[num28, num29].active(active: false);
						Main.tile[num28, num29].wall = GenVars.crimStoneWall;
					}
					else
					{
						if (!(num35 < num3 * 0.45))
						{
							continue;
						}
						if (num28 < num21)
						{
							num21 = num28;
						}
						if (num28 > num22)
						{
							num22 = num28;
						}
						if (Main.tile[num28, num29].wall != GenVars.crimStoneWall)
						{
							Main.tile[num28, num29].active(active: true);
							Main.tile[num28, num29].type = GenVars.crimStone;
							if (num35 < num3 * 0.35)
							{
								Main.tile[num28, num29].wall = GenVars.crimStoneWall;
							}
						}
					}
				}
			}
		}
		for (int num36 = num21; num36 <= num22; num36++)
		{
			int num37;
			for (num37 = num2; (Main.tile[num36, num37].type == GenVars.crimStone && Main.tile[num36, num37].active()) || Main.tile[num36, num37].wall == GenVars.crimStoneWall; num37++)
			{
			}
			int num38 = genRand.Next(15, 20);
			while (!Main.tile[num36, num37].active() && num38 > 0 && Main.tile[num36, num37].wall != GenVars.crimStoneWall)
			{
				if (CanEvilReplace(num36, num37))
				{
					num38--;
					Main.tile[num36, num37].type = GenVars.crimStone;
					Main.tile[num36, num37].active(active: true);
					num37++;
				}
			}
		}
		CrimEnt(position, crimDir);
	}

	public static void CrimPlaceHearts()
	{
		int num = 16;
		for (int i = 0; i < heartCount; i++)
		{
			num = genRand.Next(16, 21);
			int x = heartPos[i].X;
			int y = heartPos[i].Y;
			for (int j = x - num / 2; j < x + num / 2; j++)
			{
				for (int k = y - num / 2; k < y + num / 2; k++)
				{
					double num2 = Math.Abs(j - x);
					double num3 = Math.Abs(k - y);
					if (Math.Sqrt(num2 * num2 + num3 * num3) < (double)num * 0.4)
					{
						Main.tile[j, k].active(active: true);
						Main.tile[j, k].type = GenVars.crimStone;
						Main.tile[j, k].wall = GenVars.crimStoneWall;
					}
				}
			}
		}
		for (int l = 0; l < heartCount; l++)
		{
			num = genRand.Next(10, 14);
			int x2 = heartPos[l].X;
			int y2 = heartPos[l].Y;
			for (int m = x2 - num / 2; m < x2 + num / 2; m++)
			{
				for (int n = y2 - num / 2; n < y2 + num / 2; n++)
				{
					double num4 = Math.Abs(m - x2);
					double num5 = Math.Abs(n - y2);
					if (Math.Sqrt(num4 * num4 + num5 * num5) < (double)num * 0.3)
					{
						Main.tile[m, n].active(active: false);
						Main.tile[m, n].wall = GenVars.crimStoneWall;
					}
				}
			}
		}
		for (int num6 = 0; num6 < heartCount; num6++)
		{
			AddShadowOrb(heartPos[num6].X, heartPos[num6].Y, crimsonHeart: true);
		}
	}

	public static void CrimEnt(Vector2D position, int crimDir)
	{
		double num = 0.0;
		double num2 = genRand.Next(6, 11);
		bool flag = true;
		Vector2D vector2D = new Vector2D(2.0, (double)genRand.Next(-20, 0) * 0.01);
		vector2D.X *= -crimDir;
		while (flag)
		{
			num += 1.0;
			if (num >= 20.0)
			{
				flag = false;
			}
			num2 += (double)genRand.Next(-10, 11) * 0.02;
			if (num2 < 6.0)
			{
				num2 = 6.0;
			}
			if (num2 > 10.0)
			{
				num2 = 10.0;
			}
			for (int i = (int)(position.X - num2 / 2.0); (double)i < position.X + num2 / 2.0; i++)
			{
				for (int j = (int)(position.Y - num2 / 2.0); (double)j < position.Y + num2 / 2.0; j++)
				{
					if (CanEvilReplace(i, j))
					{
						double num3 = Math.Abs((double)i - position.X);
						double num4 = Math.Abs((double)j - position.Y);
						if (Math.Sqrt(num3 * num3 + num4 * num4) < num2 * 0.5 && Main.tile[i, j].active() && Main.tile[i, j].type == GenVars.crimStone)
						{
							Main.tile[i, j].active(active: false);
							flag = true;
							num = 0.0;
						}
					}
				}
			}
			position += vector2D;
		}
	}

	public static void CrimVein(Vector2D position, Vector2D velocity)
	{
		double num = genRand.Next(15, 26);
		bool flag = true;
		Vector2D vector2D = velocity;
		Vector2D vector2D2 = position;
		int num2 = genRand.Next(100, 150);
		if (velocity.Y < 0.0)
		{
			num2 -= 25;
		}
		while (flag)
		{
			num += (double)genRand.Next(-50, 51) * 0.02;
			if (num < 15.0)
			{
				num = 15.0;
			}
			if (num > 25.0)
			{
				num = 25.0;
			}
			for (int i = (int)(position.X - num / 2.0); (double)i < position.X + num / 2.0; i++)
			{
				for (int j = (int)(position.Y - num / 2.0); (double)j < position.Y + num / 2.0; j++)
				{
					if (!CanEvilReplace(i, j))
					{
						continue;
					}
					double num3 = Math.Abs((double)i - position.X);
					double num4 = Math.Abs((double)j - position.Y);
					double num5 = Math.Sqrt(num3 * num3 + num4 * num4);
					if (num5 < num * 0.2)
					{
						Main.tile[i, j].active(active: false);
						Main.tile[i, j].wall = GenVars.crimStoneWall;
					}
					else if (num5 < num * 0.5 && Main.tile[i, j].wall != GenVars.crimStoneWall)
					{
						Main.tile[i, j].active(active: true);
						Main.tile[i, j].type = GenVars.crimStone;
						if (num5 < num * 0.4)
						{
							Main.tile[i, j].wall = GenVars.crimStoneWall;
						}
					}
				}
			}
			velocity.X += (double)genRand.Next(-50, 51) * 0.05;
			velocity.Y += (double)genRand.Next(-50, 51) * 0.05;
			if (velocity.Y < vector2D.Y - 0.75)
			{
				velocity.Y = vector2D.Y - 0.75;
			}
			if (velocity.Y > vector2D.Y + 0.75)
			{
				velocity.Y = vector2D.Y + 0.75;
			}
			if (velocity.X < vector2D.X - 0.75)
			{
				velocity.X = vector2D.X - 0.75;
			}
			if (velocity.X > vector2D.X + 0.75)
			{
				velocity.X = vector2D.X + 0.75;
			}
			position += velocity;
			if (Math.Abs(position.X - vector2D2.X) + Math.Abs(position.Y - vector2D2.Y) > (double)num2)
			{
				flag = false;
			}
		}
		heartPos[heartCount] = position.ToPoint();
		heartCount++;
	}

	public static void ChasmRunner(int i, int j, int steps, bool makeOrb = false)
	{
		double num = Main.worldSurface;
		if (SecretSeed.noSurface.Enabled)
		{
			num = Main.rockLayer;
		}
		bool flag = false;
		bool flag2 = false;
		bool flag3 = false;
		if (!makeOrb)
		{
			flag2 = true;
		}
		double num2 = steps;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-10, 11) * 0.1;
		vector2D2.Y = (double)genRand.Next(11) * 0.2 + 0.5;
		int num3 = 5;
		double num4 = genRand.Next(5) + 7;
		while (num4 > 0.0)
		{
			if (num2 > 0.0)
			{
				num4 += (double)genRand.Next(3);
				num4 -= (double)genRand.Next(3);
				if (num4 < 7.0)
				{
					num4 = 7.0;
				}
				if (num4 > 20.0)
				{
					num4 = 20.0;
				}
				if (num2 == 1.0 && num4 < 10.0)
				{
					num4 = 10.0;
				}
			}
			else if (vector2D.Y > num + 45.0)
			{
				num4 -= (double)genRand.Next(4);
			}
			if (vector2D.Y > Main.rockLayer && num2 > 0.0)
			{
				num2 = 0.0;
			}
			num2 -= 1.0;
			if (!flag && vector2D.Y > num + 20.0)
			{
				flag = true;
				ChasmRunnerSideways((int)vector2D.X, (int)vector2D.Y, -1, genRand.Next(20, 40));
				ChasmRunnerSideways((int)vector2D.X, (int)vector2D.Y, 1, genRand.Next(20, 40));
			}
			int num5;
			int num6;
			int num7;
			int num8;
			if (num2 > (double)num3)
			{
				num5 = (int)(vector2D.X - num4 * 0.5);
				num6 = (int)(vector2D.X + num4 * 0.5);
				num7 = (int)(vector2D.Y - num4 * 0.5);
				num8 = (int)(vector2D.Y + num4 * 0.5);
				if (num5 < 0)
				{
					num5 = 0;
				}
				if (num6 > Main.maxTilesX - 1)
				{
					num6 = Main.maxTilesX - 1;
				}
				if (num7 < 0)
				{
					num7 = 0;
				}
				if (num8 > Main.maxTilesY)
				{
					num8 = Main.maxTilesY;
				}
				for (int k = num5; k < num6; k++)
				{
					for (int l = num7; l < num8; l++)
					{
						if (Math.Abs((double)k - vector2D.X) + Math.Abs((double)l - vector2D.Y) < num4 * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && CanEvilReplace(k, l) && Main.tile[k, l].type != 31 && Main.tile[k, l].type != 22 && Main.tile[k, l].type != 204)
						{
							Main.tile[k, l].active(active: false);
						}
					}
				}
			}
			if (num2 <= 2.0 && vector2D.Y < num + 45.0)
			{
				num2 = 2.0;
			}
			if (num2 <= 0.0)
			{
				if (!flag2)
				{
					flag2 = true;
					AddShadowOrb((int)vector2D.X, (int)vector2D.Y, crimsonHeart: false);
				}
				else if (!flag3)
				{
					flag3 = false;
					bool flag4 = false;
					int num9 = 0;
					while (!flag4)
					{
						int num10 = genRand.Next((int)vector2D.X - 25, (int)vector2D.X + 25);
						int num11 = genRand.Next((int)vector2D.Y - 50, (int)vector2D.Y);
						if (num10 < 5)
						{
							num10 = 5;
						}
						if (num10 > Main.maxTilesX - 5)
						{
							num10 = Main.maxTilesX - 5;
						}
						if (num11 < 5)
						{
							num11 = 5;
						}
						if (num11 > Main.maxTilesY - 5)
						{
							num11 = Main.maxTilesY - 5;
						}
						if ((double)num11 > num)
						{
							if (!IsTileNearby(num10, num11, 26, 3))
							{
								Place3x2(num10, num11, 26);
							}
							if (Main.tile[num10, num11].type == 26)
							{
								flag4 = true;
								continue;
							}
							num9++;
							if (num9 >= 10000)
							{
								flag4 = true;
							}
						}
						else
						{
							flag4 = true;
						}
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-10, 11) * 0.01;
			if (vector2D2.X > 0.3)
			{
				vector2D2.X = 0.3;
			}
			if (vector2D2.X < -0.3)
			{
				vector2D2.X = -0.3;
			}
			num5 = (int)(vector2D.X - num4 * 1.1);
			num6 = (int)(vector2D.X + num4 * 1.1);
			num7 = (int)(vector2D.Y - num4 * 1.1);
			num8 = (int)(vector2D.Y + num4 * 1.1);
			if (num5 < 1)
			{
				num5 = 1;
			}
			if (num6 > Main.maxTilesX - 1)
			{
				num6 = Main.maxTilesX - 1;
			}
			if (num7 < 0)
			{
				num7 = 0;
			}
			if (num8 > Main.maxTilesY)
			{
				num8 = Main.maxTilesY;
			}
			for (int m = num5; m < num6; m++)
			{
				for (int n = num7; n < num8; n++)
				{
					if (CanEvilReplace(m, n) && Math.Abs((double)m - vector2D.X) + Math.Abs((double)n - vector2D.Y) < num4 * 1.1 * (1.0 + (double)genRand.Next(-10, 11) * 0.015))
					{
						if (Main.tile[m, n].type != GenVars.ebonStone && n > j + genRand.Next(3, 20))
						{
							Main.tile[m, n].active(active: true);
						}
						if (steps <= num3)
						{
							Main.tile[m, n].active(active: true);
						}
						if (Main.tile[m, n].type != 31)
						{
							Main.tile[m, n].type = GenVars.ebonStone;
						}
					}
				}
			}
			for (int num12 = num5; num12 < num6; num12++)
			{
				for (int num13 = num7; num13 < num8; num13++)
				{
					if (CanEvilReplace(num12, num13) && Math.Abs((double)num12 - vector2D.X) + Math.Abs((double)num13 - vector2D.Y) < num4 * 1.1 * (1.0 + (double)genRand.Next(-10, 11) * 0.015))
					{
						if (Main.tile[num12, num13].type != 31)
						{
							Main.tile[num12, num13].type = GenVars.ebonStone;
						}
						if (steps <= num3)
						{
							Main.tile[num12, num13].active(active: true);
						}
						if (num13 > j + genRand.Next(3, 20))
						{
							Main.tile[num12, num13].wall = GenVars.ebonStoneWall;
						}
					}
				}
			}
		}
	}

	public static void SpawnPlanteraThorns(Vector2 position)
	{
		if (Main.netMode == 1)
		{
			return;
		}
		int num = Main.rand.Next(3, 6);
		for (int i = 0; i < num; i++)
		{
			int num2 = Main.rand.Next(15, 31);
			int num3 = (int)(position.X / 16f);
			int num4 = (int)(position.Y / 16f);
			int num5 = 0;
			int num6 = 0;
			if (Main.rand.Next(2) != 0)
			{
				num6 = ((Main.rand.Next(2) == 0) ? 1 : (-1));
			}
			else
			{
				num5 = ((Main.rand.Next(2) == 0) ? 1 : (-1));
			}
			while (num2 > 0)
			{
				num2--;
				if (!Main.tile[num3, num4].active())
				{
					PlaceTile(num3, num4, 655);
					if (Main.tile[num3, num4].active() && Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, num3, num4);
					}
				}
				num3 += num5;
				num4 += num6;
				if (!InWorld(num3, num4))
				{
					return;
				}
				if (Main.rand.Next(5) == 0)
				{
					if (num6 == 0)
					{
						num5 = 0;
						num6 = ((Main.rand.Next(2) == 0) ? 1 : (-1));
					}
					else
					{
						num6 = 0;
						num5 = ((Main.rand.Next(2) == 0) ? 1 : (-1));
					}
				}
			}
		}
	}

	public static void GERunner(int i, int j, double speedX = 0.0, double speedY = 0.0, bool good = true)
	{
		if (Skyblock.lowTiles)
		{
			return;
		}
		int num = 0;
		for (int k = 20; k < Main.maxTilesX - 20; k++)
		{
			for (int l = 20; l < Main.maxTilesY - 20; l++)
			{
				if (Main.tile[k, l].active() && Main.tile[k, l].type == 225)
				{
					num++;
				}
			}
		}
		bool flag = false;
		if (num > 200000)
		{
			flag = true;
		}
		int num2 = genRand.Next(200, 250);
		double num3 = (double)Main.maxTilesX / 4200.0;
		num2 = (int)((double)num2 * num3);
		double num4 = num2;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-10, 11) * 0.1;
		vector2D2.Y = (double)genRand.Next(-10, 11) * 0.1;
		if (speedX != 0.0 || speedY != 0.0)
		{
			vector2D2.X = speedX;
			vector2D2.Y = speedY;
		}
		bool flag2 = true;
		while (flag2)
		{
			int num5 = (int)(vector2D.X - num4 * 0.5);
			int num6 = (int)(vector2D.X + num4 * 0.5);
			int num7 = (int)(vector2D.Y - num4 * 0.5);
			int num8 = (int)(vector2D.Y + num4 * 0.5);
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesX)
			{
				num6 = Main.maxTilesX;
			}
			if (num7 < 0)
			{
				num7 = 0;
			}
			if (num8 > Main.maxTilesY - 5)
			{
				num8 = Main.maxTilesY - 5;
			}
			for (int m = num5; m < num6; m++)
			{
				for (int n = num7; n < num8; n++)
				{
					if (!(Math.Abs((double)m - vector2D.X) + Math.Abs((double)n - vector2D.Y) < (double)num2 * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015)))
					{
						continue;
					}
					if (good)
					{
						if (Main.tile[m, n].wall == 63 || Main.tile[m, n].wall == 65 || Main.tile[m, n].wall == 66 || Main.tile[m, n].wall == 68 || Main.tile[m, n].wall == 69 || Main.tile[m, n].wall == 81)
						{
							Main.tile[m, n].wall = 70;
						}
						else if (Main.tile[m, n].wall == 216)
						{
							Main.tile[m, n].wall = 219;
						}
						else if (Main.tile[m, n].wall == 187)
						{
							Main.tile[m, n].wall = 222;
						}
						else if (Main.tile[m, n].wall == 3 || Main.tile[m, n].wall == 83)
						{
							Main.tile[m, n].wall = 28;
						}
						if (flag && Main.tile[m, n].type == 225)
						{
							Main.tile[m, n].type = 117;
							SquareTileFrame(m, n);
						}
						else if (flag && Main.tile[m, n].type == 230)
						{
							Main.tile[m, n].type = 402;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 2)
						{
							Main.tile[m, n].type = 109;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 1 || Main.tile[m, n].type == 25 || Main.tile[m, n].type == 203)
						{
							Main.tile[m, n].type = 117;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 53 || Main.tile[m, n].type == 123 || Main.tile[m, n].type == 112 || Main.tile[m, n].type == 234)
						{
							Main.tile[m, n].type = 116;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 661 || Main.tile[m, n].type == 662)
						{
							Main.tile[m, n].type = 60;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 23 || Main.tile[m, n].type == 199)
						{
							Main.tile[m, n].type = 109;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 161 || Main.tile[m, n].type == 163 || Main.tile[m, n].type == 200)
						{
							Main.tile[m, n].type = 164;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 396)
						{
							Main.tile[m, n].type = 403;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 397)
						{
							Main.tile[m, n].type = 402;
							SquareTileFrame(m, n);
						}
					}
					else if (crimson)
					{
						if (Main.tile[m, n].wall == 63 || Main.tile[m, n].wall == 65 || Main.tile[m, n].wall == 66 || Main.tile[m, n].wall == 68)
						{
							Main.tile[m, n].wall = 81;
						}
						else if (Main.tile[m, n].wall == 216)
						{
							Main.tile[m, n].wall = 218;
						}
						else if (Main.tile[m, n].wall == 187)
						{
							Main.tile[m, n].wall = 221;
						}
						if (flag && Main.tile[m, n].type == 225)
						{
							Main.tile[m, n].type = 203;
							SquareTileFrame(m, n);
						}
						else if (flag && Main.tile[m, n].type == 230)
						{
							Main.tile[m, n].type = 399;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 60 || Main.tile[m, n].type == 661)
						{
							Main.tile[m, n].type = 662;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 2 || Main.tile[m, n].type == 109)
						{
							Main.tile[m, n].type = 199;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 1 || Main.tile[m, n].type == 117)
						{
							Main.tile[m, n].type = 203;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 53 || Main.tile[m, n].type == 123 || Main.tile[m, n].type == 116)
						{
							Main.tile[m, n].type = 234;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 161 || Main.tile[m, n].type == 164)
						{
							Main.tile[m, n].type = 200;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 396)
						{
							Main.tile[m, n].type = 401;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 397)
						{
							Main.tile[m, n].type = 399;
							SquareTileFrame(m, n);
						}
					}
					else
					{
						if (Main.tile[m, n].wall == 63 || Main.tile[m, n].wall == 65 || Main.tile[m, n].wall == 66 || Main.tile[m, n].wall == 68)
						{
							Main.tile[m, n].wall = 69;
						}
						else if (Main.tile[m, n].wall == 216)
						{
							Main.tile[m, n].wall = 217;
						}
						else if (Main.tile[m, n].wall == 187)
						{
							Main.tile[m, n].wall = 220;
						}
						if (flag && Main.tile[m, n].type == 225)
						{
							Main.tile[m, n].type = 25;
							SquareTileFrame(m, n);
						}
						else if (flag && Main.tile[m, n].type == 230)
						{
							Main.tile[m, n].type = 398;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 60 || Main.tile[m, n].type == 662)
						{
							Main.tile[m, n].type = 661;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 2 || Main.tile[m, n].type == 109)
						{
							Main.tile[m, n].type = 23;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 1 || Main.tile[m, n].type == 117)
						{
							Main.tile[m, n].type = 25;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 53 || Main.tile[m, n].type == 123 || Main.tile[m, n].type == 116)
						{
							Main.tile[m, n].type = 112;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 161 || Main.tile[m, n].type == 164)
						{
							Main.tile[m, n].type = 163;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 396)
						{
							Main.tile[m, n].type = 400;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 397)
						{
							Main.tile[m, n].type = 398;
							SquareTileFrame(m, n);
						}
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
			if (vector2D2.X > speedX + 1.0)
			{
				vector2D2.X = speedX + 1.0;
			}
			if (vector2D2.X < speedX - 1.0)
			{
				vector2D2.X = speedX - 1.0;
			}
			if (vector2D.X < (double)(-num2) || vector2D.Y < (double)(-num2) || vector2D.X > (double)(Main.maxTilesX + num2) || vector2D.Y > (double)(Main.maxTilesY + num2))
			{
				flag2 = false;
			}
		}
	}

	private static bool badOceanCaveTiles(int x, int y)
	{
		if (Main.tile[x, y].wall == 83 || Main.tile[x, y].wall == 3 || Main.wallDungeon[Main.tile[x, y].wall] || Main.tile[x, y].type == 203 || Main.tile[x, y].type == 25 || Main.tileDungeon[Main.tile[x, y].type] || Main.tile[x, y].type == 26 || Main.tile[x, y].type == 31)
		{
			return true;
		}
		return false;
	}

	public static void oceanCave(int i, int j)
	{
		if (GenVars.numOceanCaveTreasure >= GenVars.maxOceanCaveTreasure)
		{
			GenVars.numOceanCaveTreasure = 0;
		}
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		if (i < Main.maxTilesX / 2)
		{
			vector2D2.X = 0.25 + genRand.NextDouble() * 0.25;
		}
		else
		{
			vector2D2.X = -0.35 - genRand.NextDouble() * 0.5;
		}
		vector2D2.Y = 0.4 + genRand.NextDouble() * 0.25;
		ushort num = 264;
		ushort num2 = 53;
		ushort num3 = 397;
		double num4 = genRand.Next(17, 25);
		double num5 = genRand.Next(600, 800);
		double num6 = 4.0;
		bool flag = true;
		bool flag2 = false;
		while (num4 > num6 && num5 > 0.0)
		{
			bool flag3 = true;
			bool flag4 = true;
			bool flag5 = true;
			if (flag2 || (vector2D.X > (double)(beachDistance - 50) && vector2D.X < (double)(Main.maxTilesX - beachDistance + 50)))
			{
				num4 *= 0.96;
				num5 *= 0.96;
			}
			if (num4 < num6 + 2.0 || num5 < 20.0)
			{
				flag5 = false;
			}
			if (flag)
			{
				num4 -= 0.01 + genRand.NextDouble() * 0.01;
				num5 -= 0.5;
			}
			else
			{
				num4 -= 0.02 + genRand.NextDouble() * 0.02;
				num5 -= 1.0;
			}
			if (flag5)
			{
				GenVars.oceanCaveTreasure[GenVars.numOceanCaveTreasure].X = (int)vector2D.X;
				GenVars.oceanCaveTreasure[GenVars.numOceanCaveTreasure].Y = (int)vector2D.Y;
			}
			int num7 = (int)(vector2D.X - num4 * 3.0);
			int num8 = (int)(vector2D.X + num4 * 3.0);
			int num9 = (int)(vector2D.Y - num4 * 3.0);
			int num10 = (int)(vector2D.Y + num4 * 3.0);
			if (num7 < 1)
			{
				num7 = 1;
			}
			if (num8 > Main.maxTilesX - 1)
			{
				num8 = Main.maxTilesX - 1;
			}
			if (num9 < 1)
			{
				num9 = 1;
			}
			if (num10 > Main.maxTilesY - 1)
			{
				num10 = Main.maxTilesY - 1;
			}
			for (int k = num7; k < num8; k++)
			{
				for (int l = num9; l < num10; l++)
				{
					if (!flag2 && SecretSeed.dualDungeons.Enabled && DungeonUtils.InAnyPotentialDungeonBounds(k, l, 5))
					{
						flag2 = true;
					}
					if (badOceanCaveTiles(k, l))
					{
						continue;
					}
					double num11 = new Vector2D(Math.Abs((double)k - vector2D.X), Math.Abs((double)l - vector2D.Y)).Length();
					if (flag5 && num11 < num4 * 0.5 + 1.0)
					{
						Main.tile[k, l].type = num;
						Main.tile[k, l].active(active: false);
					}
					else if (num11 < num4 * 1.5 + 1.0 && Main.tile[k, l].type != num)
					{
						if ((double)l < vector2D.Y)
						{
							if ((vector2D2.X < 0.0 && (double)k < vector2D.X) || (vector2D2.X > 0.0 && (double)k > vector2D.X))
							{
								if (num11 < num4 * 1.1 + 1.0)
								{
									Main.tile[k, l].type = num3;
									if (Main.tile[k, l].liquid == byte.MaxValue)
									{
										Main.tile[k, l].wall = 0;
									}
								}
								else if (Main.tile[k, l].type != num3)
								{
									Main.tile[k, l].type = num2;
								}
							}
						}
						else if ((vector2D2.X < 0.0 && k < i) || (vector2D2.X > 0.0 && k > i))
						{
							if (Main.tile[k, l].liquid == byte.MaxValue)
							{
								Main.tile[k, l].wall = 0;
							}
							Main.tile[k, l].type = num2;
							Main.tile[k, l].active(active: true);
							if (k == (int)vector2D.X && flag3)
							{
								flag3 = false;
								int num12 = 50 + genRand.Next(3);
								int num13 = 43 + genRand.Next(3);
								int num14 = 20 + genRand.Next(3);
								int num15 = k;
								int num16 = k + num14;
								if (vector2D2.X < 0.0)
								{
									num15 = k - num14;
									num16 = k;
								}
								if (num5 < 100.0)
								{
									num12 = (int)((double)num12 * (num5 / 100.0));
									num13 = (int)((double)num13 * (num5 / 100.0));
									num14 = (int)((double)num14 * (num5 / 100.0));
								}
								if (num4 < num6 + 5.0)
								{
									double num17 = (num4 - num6) / 5.0;
									num12 = (int)((double)num12 * num17);
									num13 = (int)((double)num13 * num17);
									num14 = (int)((double)num14 * num17);
								}
								for (int m = num15; m <= num16; m++)
								{
									for (int n = l; n < l + num12 && !badOceanCaveTiles(m, n); n++)
									{
										if (n > l + num13)
										{
											if (SolidTile(m, n) && Main.tile[m, n].type != num2)
											{
												break;
											}
											Main.tile[m, n].type = num3;
										}
										else
										{
											Main.tile[m, n].type = num2;
										}
										Main.tile[m, n].active(active: true);
										if (genRand.Next(3) == 0)
										{
											Main.tile[m - 1, n].type = num2;
											Main.tile[m - 1, n].active(active: true);
										}
										if (genRand.Next(3) == 0)
										{
											Main.tile[m + 1, n].type = num2;
											Main.tile[m + 1, n].active(active: true);
										}
									}
								}
							}
						}
					}
					if (num11 < num4 * 1.3 + 1.0 && l > j - 10)
					{
						Main.tile[k, l].liquid = byte.MaxValue;
						Main.tile[k, l].liquidType(0);
					}
					if (!flag4 || k != (int)vector2D.X || !((double)l > vector2D.Y))
					{
						continue;
					}
					flag4 = false;
					int num18 = 100;
					int num19 = 2;
					for (int num20 = k - num19; num20 <= k + num19; num20++)
					{
						for (int num21 = l; num21 < l + num18; num21++)
						{
							if (!badOceanCaveTiles(num20, num21))
							{
								Main.tile[num20, num21].liquid = byte.MaxValue;
								Main.tile[num20, num21].liquidType(0);
							}
						}
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += genRand.NextDouble() * 0.1 - 0.05;
			vector2D2.Y += genRand.NextDouble() * 0.1 - 0.05;
			if (flag)
			{
				if (vector2D.Y > (Main.worldSurface * 2.0 + Main.rockLayer) / 3.0 && vector2D.Y > (double)(j + 30))
				{
					flag = false;
				}
				vector2D2.Y = Utils.Clamp(vector2D2.Y, 0.35, 1.0);
			}
			else
			{
				if (vector2D.X < (double)(Main.maxTilesX / 2))
				{
					if (vector2D2.X < 0.5)
					{
						vector2D2.X += 0.02;
					}
				}
				else if (vector2D2.X > -0.5)
				{
					vector2D2.X -= 0.02;
				}
				if (!flag5)
				{
					if (vector2D2.Y < 0.0)
					{
						vector2D2.Y *= 0.95;
					}
					vector2D2.Y += 0.04;
				}
				else if (vector2D.Y < (Main.worldSurface * 4.0 + Main.rockLayer) / 5.0)
				{
					if (vector2D2.Y < 0.0)
					{
						vector2D2.Y *= 0.97;
					}
					vector2D2.Y += 0.02;
				}
				else if (vector2D2.Y > -0.1)
				{
					vector2D2.Y *= 0.99;
					vector2D2.Y -= 0.01;
				}
				vector2D2.Y = Utils.Clamp(vector2D2.Y, -1.0, 1.0);
			}
			if (vector2D.X < (double)(Main.maxTilesX / 2))
			{
				vector2D2.X = Utils.Clamp(vector2D2.X, 0.1, 1.0);
			}
			else
			{
				vector2D2.X = Utils.Clamp(vector2D2.X, -1.0, -0.1);
			}
		}
		GenVars.numOceanCaveTreasure++;
	}

	public static void WavyCaverer(int startX, int startY, double waveStrengthScalar, double wavePercentScalar, int steps, int type)
	{
		Vector2D vector2D = new Vector2D(startX, startY);
		bool flag = ((startX > Main.maxTilesX / 2) ? true : false);
		int num = 2 + genRand.Next(2);
		int num2 = 15 + genRand.Next(11);
		int num3 = 1 + genRand.Next(2);
		int num4 = (int)Math.Ceiling((double)num2 / (double)num3);
		double num5 = 1.0;
		double num6 = 1.0;
		int num7 = (int)(-1.0 + genRand.NextDouble() * 3.0);
		int num8 = num;
		int num9 = 0;
		for (int i = 0; i < steps; i++)
		{
			bool flag2 = i < num4;
			bool flag3 = i >= steps - num4;
			vector2D.X += ((!flag) ? 1 : (-1));
			if (!flag2 && !flag3)
			{
				num9++;
				num5 = Math.Min(2.0, Math.Max(0.5, num5 + (-0.5 + genRand.NextDouble()) * 0.25));
				num6 = Math.Min(1.1, Math.Max(0.9, num6 + (-0.5 + genRand.NextDouble()) * 0.02));
			}
			double num10 = Math.Sin((double)num9 * 0.1 * num6 * wavePercentScalar) * num5 * waveStrengthScalar;
			vector2D.Y = (double)startY + num10 + (double)(num9 * num7);
			int num11 = num8;
			if (flag2)
			{
				num8 = Math.Min(num2, num8 + num3);
			}
			else if (flag3)
			{
				num8 = Math.Max(num, num8 - num3);
			}
			vector2D.Y -= (num11 + num8) / 4;
			for (int j = 0; j < num8; j++)
			{
				int num12 = (int)vector2D.X;
				int num13 = (int)vector2D.Y + j;
				if (InWorld(num12, num13, 20))
				{
					if (type >= 0)
					{
						PlaceTile(num12, num13, type, mute: true, forced: true);
					}
					else
					{
						KillTile(num12, num13);
					}
				}
			}
		}
	}

	public static void TileRunner(int i, int j, double strength, int steps, int type, bool addTile = false, double speedX = 0.0, double speedY = 0.0, bool noYChange = false, bool overRide = true, int ignoreTileType = -1)
	{
		if (!GenVars.mudWall)
		{
			if (drunkWorldGen)
			{
				strength *= 1.0 + (double)genRand.Next(-80, 81) * 0.01;
				steps = (int)((double)steps * (1.0 + (double)genRand.Next(-80, 81) * 0.01));
			}
			else if (remixWorldGen)
			{
				strength *= 1.0 + (double)genRand.Next(-50, 51) * 0.01;
			}
			else if (getGoodWorldGen && type != 57)
			{
				strength *= 1.0 + (double)genRand.Next(-80, 81) * 0.015;
				steps += genRand.Next(3);
			}
		}
		double num = strength;
		double num2 = steps;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-10, 11) * 0.1;
		vector2D2.Y = (double)genRand.Next(-10, 11) * 0.1;
		if (speedX != 0.0 || speedY != 0.0)
		{
			vector2D2.X = speedX;
			vector2D2.Y = speedY;
		}
		bool flag = type >= 0 && !TileID.Sets.SaveSlopes[type];
		bool flag2 = type == 368;
		bool flag3 = type == 367;
		short num3 = 0;
		if (notTheBees && dontStarveWorldGen && !remixWorldGen && genRand.Next(3) == 0)
		{
			num3 = 2;
		}
		else if (genRand.Next(4) == 0)
		{
			if (drunkWorldGen && tenthAnniversaryWorldGen && remixWorldGen && !notTheBees)
			{
				num3 = 3;
			}
			else if (getGoodWorldGen)
			{
				num3 = 1;
			}
		}
		while (num > 0.0 && num2 > 0.0)
		{
			if (drunkWorldGen && genRand.Next(30) == 0)
			{
				vector2D.X += (double)genRand.Next(-100, 101) * 0.05;
				vector2D.Y += (double)genRand.Next(-100, 101) * 0.05;
			}
			if (num3 == 1 && tenthAnniversaryWorldGen && vector2D.X > (double)Main.maxTilesX * 0.45 && vector2D.Y < (double)Main.maxTilesX * 0.55 && vector2D.Y < Main.worldSurface)
			{
				num3 = 0;
			}
			if (vector2D.Y < 0.0 && num2 > 0.0 && type == 59)
			{
				num2 = 0.0;
			}
			num = strength * (num2 / (double)steps);
			num2 -= 1.0;
			int num4 = (int)(vector2D.X - num * 0.5);
			int num5 = (int)(vector2D.X + num * 0.5);
			int num6 = (int)(vector2D.Y - num * 0.5);
			int num7 = (int)(vector2D.Y + num * 0.5);
			if (num4 < 1)
			{
				num4 = 1;
			}
			if (num5 > Main.maxTilesX - 1)
			{
				num5 = Main.maxTilesX - 1;
			}
			if (num6 < 1)
			{
				num6 = 1;
			}
			if (num7 > Main.maxTilesY - 1)
			{
				num7 = Main.maxTilesY - 1;
			}
			for (int k = num4; k < num5; k++)
			{
				if (k < beachDistance + 50 || k >= Main.maxTilesX - beachDistance - 50)
				{
					num3 = 0;
				}
				for (int l = num6; l < num7; l++)
				{
					if (drunkWorldGen && l < Main.maxTilesY - 300 && type == 57)
					{
						continue;
					}
					Tile tile = Main.tile[k, l];
					if ((tile.active() && Main.tileFrameImportant[tile.type] && !Main.tileCut[tile.type]) || (ignoreTileType >= 0 && Main.tile[k, l].active() && Main.tile[k, l].type == ignoreTileType) || !(Math.Abs((double)k - vector2D.X) + Math.Abs((double)l - vector2D.Y) < strength * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015)))
					{
						continue;
					}
					if (GenVars.mudWall && (double)l > Main.worldSurface && Main.tile[k, l - 1].wall != 2 && l < Main.maxTilesY - 210 - genRand.Next(3) && Math.Abs((double)k - vector2D.X) + Math.Abs((double)l - vector2D.Y) < strength * 0.45 * (1.0 + (double)genRand.Next(-10, 11) * 0.01))
					{
						if (l > GenVars.lavaLine - genRand.Next(0, 4) - 50)
						{
							if (Main.tile[k, l - 1].wall != 64 && Main.tile[k, l + 1].wall != 64 && Main.tile[k - 1, l].wall != 64 && Main.tile[k + 1, l].wall != 64)
							{
								PlaceWall(k, l, 15, mute: true);
							}
						}
						else if (Main.tile[k, l - 1].wall != 15 && Main.tile[k, l + 1].wall != 15 && Main.tile[k - 1, l].wall != 15 && Main.tile[k + 1, l].wall != 15)
						{
							PlaceWall(k, l, 64, mute: true);
						}
					}
					if (type < 0)
					{
						if (Main.tile[k, l].active() && Main.tile[k, l].type == 53)
						{
							continue;
						}
						if (type == -2 && Main.tile[k, l].active() && (l < GenVars.waterLine || l > GenVars.lavaLine))
						{
							Main.tile[k, l].liquid = byte.MaxValue;
							Main.tile[k, l].liquidType(num3);
							if (remixWorldGen)
							{
								if (l > GenVars.lavaLine && ((double)l < Main.rockLayer - 80.0 || l > Main.maxTilesY - 350) && !oceanDepths(k, l))
								{
									Main.tile[k, l].lava(lava: true);
								}
							}
							else if (l > GenVars.lavaLine)
							{
								Main.tile[k, l].lava(lava: true);
							}
						}
						Main.tile[k, l].active(active: false);
						continue;
					}
					if (flag2 && Math.Abs((double)k - vector2D.X) + Math.Abs((double)l - vector2D.Y) < strength * 0.3 * (1.0 + (double)genRand.Next(-10, 11) * 0.01))
					{
						PlaceWall(k, l, 180, mute: true);
					}
					if (flag3 && Math.Abs((double)k - vector2D.X) + Math.Abs((double)l - vector2D.Y) < strength * 0.3 * (1.0 + (double)genRand.Next(-10, 11) * 0.01))
					{
						PlaceWall(k, l, 178, mute: true);
					}
					bool flag4 = false;
					Tile tile2 = Main.tile[k, l];
					if (overRide && tile2.active())
					{
						flag4 = Main.tileStone[type] && tile2.type != 1;
						if (!CanBeClearedDuringGeneration(tile2.type, k, l))
						{
							flag4 = true;
						}
						switch (tile2.type)
						{
						case 53:
							if (type == 59 && GenVars.UndergroundDesertLocation.Contains(k, l))
							{
								flag4 = true;
							}
							if (type == 40)
							{
								flag4 = true;
							}
							if ((double)l < Main.worldSurface && type != 59)
							{
								flag4 = true;
							}
							break;
						case 45:
						case 147:
						case 189:
						case 190:
						case 196:
						case 460:
						case 717:
						case 718:
						case 719:
							flag4 = true;
							break;
						case 396:
						case 397:
							flag4 = !TileID.Sets.Ore[type];
							break;
						case 1:
							if (type == 59 && (double)l < Main.worldSurface + (double)genRand.Next(-50, 50))
							{
								flag4 = true;
							}
							break;
						case 367:
						case 368:
							if (type == 59)
							{
								flag4 = true;
							}
							break;
						}
					}
					if (!flag4)
					{
						tile2.type = (ushort)type;
						if (flag)
						{
							tile2.ClearSlope();
						}
					}
					if (addTile)
					{
						tile2.active(active: true);
						tile2.liquid = 0;
						tile2.lava(lava: false);
					}
					if (noYChange && (double)l < Main.worldSurface && type != 59)
					{
						tile2.wall = 2;
					}
					if (type == 59 && l > GenVars.waterLine && tile2.liquid > 0)
					{
						tile2.lava(lava: false);
						tile2.liquid = 0;
					}
				}
			}
			vector2D += vector2D2;
			if ((!drunkWorldGen || genRand.Next(3) != 0) && num > 50.0)
			{
				vector2D += vector2D2;
				num2 -= 1.0;
				vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
				vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
				if (num > 100.0)
				{
					vector2D += vector2D2;
					num2 -= 1.0;
					vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
					vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
					if (num > 150.0)
					{
						vector2D += vector2D2;
						num2 -= 1.0;
						vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
						vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
						if (num > 200.0)
						{
							vector2D += vector2D2;
							num2 -= 1.0;
							vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
							vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
							if (num > 250.0)
							{
								vector2D += vector2D2;
								num2 -= 1.0;
								vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
								vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
								if (num > 300.0)
								{
									vector2D += vector2D2;
									num2 -= 1.0;
									vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
									vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
									if (num > 400.0)
									{
										vector2D += vector2D2;
										num2 -= 1.0;
										vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
										vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
										if (num > 500.0)
										{
											vector2D += vector2D2;
											num2 -= 1.0;
											vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
											vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
											if (num > 600.0)
											{
												vector2D += vector2D2;
												num2 -= 1.0;
												vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
												vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
												if (num > 700.0)
												{
													vector2D += vector2D2;
													num2 -= 1.0;
													vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
													vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
													if (num > 800.0)
													{
														vector2D += vector2D2;
														num2 -= 1.0;
														vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
														vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
														if (num > 900.0)
														{
															vector2D += vector2D2;
															num2 -= 1.0;
															vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
															vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
			if (drunkWorldGen)
			{
				vector2D2.X += (double)genRand.Next(-10, 11) * 0.25;
			}
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			if (!noYChange)
			{
				vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
				if (vector2D2.Y > 1.0)
				{
					vector2D2.Y = 1.0;
				}
				if (vector2D2.Y < -1.0)
				{
					vector2D2.Y = -1.0;
				}
			}
			else if (type != 59 && num < 3.0)
			{
				if (vector2D2.Y > 1.0)
				{
					vector2D2.Y = 1.0;
				}
				if (vector2D2.Y < -1.0)
				{
					vector2D2.Y = -1.0;
				}
			}
			if (type == 59 && !noYChange)
			{
				if (vector2D2.Y > 0.5)
				{
					vector2D2.Y = 0.5;
				}
				if (vector2D2.Y < -0.5)
				{
					vector2D2.Y = -0.5;
				}
				if (vector2D.Y < Main.rockLayer + 100.0)
				{
					vector2D2.Y = 1.0;
				}
				if (vector2D.Y > (double)(Main.maxTilesY - 300))
				{
					vector2D2.Y = -1.0;
				}
			}
		}
	}

	public static void DirtyRockRunner(int i, int j)
	{
		double num = genRand.Next(2, 6);
		double num2 = genRand.Next(5, 50);
		double num3 = num2;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-10, 11) * 0.1;
		vector2D2.Y = (double)genRand.Next(-10, 11) * 0.1;
		while (num > 0.0 && num3 > 0.0)
		{
			double num4 = num * (num3 / num2);
			num3 -= 1.0;
			int num5 = (int)(vector2D.X - num4 * 0.5);
			int num6 = (int)(vector2D.X + num4 * 0.5);
			int num7 = (int)(vector2D.Y - num4 * 0.5);
			int num8 = (int)(vector2D.Y + num4 * 0.5);
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesX)
			{
				num6 = Main.maxTilesX;
			}
			if (num7 < 0)
			{
				num7 = 0;
			}
			if (num8 > Main.maxTilesY)
			{
				num8 = Main.maxTilesY;
			}
			for (int k = num5; k < num6; k++)
			{
				for (int l = num7; l < num8; l++)
				{
					if (Math.Abs((double)k - vector2D.X) + Math.Abs((double)l - vector2D.Y) < num * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[k, l].wall == 2)
					{
						Main.tile[k, l].wall = 59;
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
			if (vector2D2.Y > 1.0)
			{
				vector2D2.Y = 1.0;
			}
			if (vector2D2.Y < -1.0)
			{
				vector2D2.Y = -1.0;
			}
		}
	}

	public static void MudWallRunner(int i, int j)
	{
		double num = genRand.Next(8, 21);
		double num2 = genRand.Next(8, 33);
		double num3 = num2;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-10, 11) * 0.1;
		vector2D2.Y = (double)genRand.Next(-10, 11) * 0.1;
		while (num > 0.0 && num3 > 0.0)
		{
			double num4 = num * (num3 / num2);
			num3 -= 1.0;
			int num5 = (int)(vector2D.X - num4 * 0.5);
			int num6 = (int)(vector2D.X + num4 * 0.5);
			int num7 = (int)(vector2D.Y - num4 * 0.5);
			int num8 = (int)(vector2D.Y + num4 * 0.5);
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesX)
			{
				num6 = Main.maxTilesX;
			}
			if (num7 < 0)
			{
				num7 = 0;
			}
			if (num8 > Main.maxTilesY)
			{
				num8 = Main.maxTilesY;
			}
			for (int k = num5; k < num6; k++)
			{
				for (int l = num7; l < num8; l++)
				{
					if (Math.Abs((double)k - vector2D.X) + Math.Abs((double)l - vector2D.Y) < num * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && (double)l > Main.worldSurface)
					{
						Main.tile[k, l].wall = 0;
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
			if (vector2D2.Y > 1.0)
			{
				vector2D2.Y = 1.0;
			}
			if (vector2D2.Y < -1.0)
			{
				vector2D2.Y = -1.0;
			}
		}
	}

	public static void SpiderWallRemover(int i, int j)
	{
		double num = genRand.Next(8, 21);
		double num2 = genRand.Next(8, 33);
		double num3 = num2;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-10, 11) * 0.1;
		vector2D2.Y = (double)genRand.Next(-10, 11) * 0.1;
		while (num > 0.0 && num3 > 0.0)
		{
			double num4 = num * (num3 / num2);
			num3 -= 1.0;
			int num5 = (int)(vector2D.X - num4 * 0.5);
			int num6 = (int)(vector2D.X + num4 * 0.5);
			int num7 = (int)(vector2D.Y - num4 * 0.5);
			int num8 = (int)(vector2D.Y + num4 * 0.5);
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesX)
			{
				num6 = Main.maxTilesX;
			}
			if (num7 < 0)
			{
				num7 = 0;
			}
			if (num8 > Main.maxTilesY)
			{
				num8 = Main.maxTilesY;
			}
			for (int k = num5; k < num6; k++)
			{
				for (int l = num7; l < num8; l++)
				{
					if (Math.Abs((double)k - vector2D.X) + Math.Abs((double)l - vector2D.Y) < num * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[k, l].wall == 62)
					{
						Main.tile[k, l].wall = 0;
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
			if (vector2D2.Y > 1.0)
			{
				vector2D2.Y = 1.0;
			}
			if (vector2D2.Y < -1.0)
			{
				vector2D2.Y = -1.0;
			}
		}
	}

	public static void SnowCloudIsland(int i, int j)
	{
		double num = genRand.Next(100, 150);
		double num2 = num;
		double num3 = genRand.Next(20, 30);
		int num4 = i;
		int num5 = i;
		int num6 = j;
		int num7 = j;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
		{
			vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		}
		vector2D2.Y = (double)genRand.Next(-20, -10) * 0.02;
		while (num > 0.0 && num3 > 0.0)
		{
			num -= (double)genRand.Next(4);
			num3 -= 1.0;
			int num8 = (int)(vector2D.X - num * 0.5);
			int num9 = (int)(vector2D.X + num * 0.5);
			int num10 = (int)(vector2D.Y - num * 0.5);
			int num11 = (int)(vector2D.Y + num * 0.5);
			if (num8 < 0)
			{
				num8 = 0;
			}
			if (num9 > Main.maxTilesX)
			{
				num9 = Main.maxTilesX;
			}
			if (num10 < 0)
			{
				num10 = 0;
			}
			if (num11 > Main.maxTilesY)
			{
				num11 = Main.maxTilesY;
			}
			num2 = num * (double)genRand.Next(80, 120) * 0.01;
			double num12 = vector2D.Y + 1.0;
			for (int k = num8; k < num9; k++)
			{
				if (genRand.Next(2) == 0)
				{
					num12 += (double)genRand.Next(-1, 2);
				}
				if (num12 < vector2D.Y)
				{
					num12 = vector2D.Y;
				}
				if (num12 > vector2D.Y + 2.0)
				{
					num12 = vector2D.Y + 2.0;
				}
				if (SecretSeed.surfaceIsInSpace.Enabled && !SecretSeed.errorWorld.Enabled)
				{
					double num13 = num12;
					if (num13 < (double)num10)
					{
						num13 = num10;
					}
					if (num13 > (double)num11)
					{
						num13 = num11;
					}
					for (int l = 0; (double)l <= num13; l++)
					{
						if (TileID.Sets.Clouds[Main.tile[k, l].type])
						{
							Main.tile[k, l].active(active: false);
						}
					}
				}
				for (int m = num10; m < num11; m++)
				{
					if (!((double)m > num12))
					{
						continue;
					}
					double num14 = Math.Abs((double)k - vector2D.X);
					double num15 = Math.Abs((double)m - vector2D.Y) * 3.0;
					if (Math.Sqrt(num14 * num14 + num15 * num15) < num2 * 0.4)
					{
						if (k < num4)
						{
							num4 = k;
						}
						if (k > num5)
						{
							num5 = k;
						}
						if (m < num6)
						{
							num6 = m;
						}
						if (m > num7)
						{
							num7 = m;
						}
						Main.tile[k, m].active(active: true);
						Main.tile[k, m].type = 189;
						SquareTileFrame(k, m);
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-20, 21) * 0.05;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			if (vector2D2.Y > 0.2)
			{
				vector2D2.Y = -0.2;
			}
			if (vector2D2.Y < -0.2)
			{
				vector2D2.Y = -0.2;
			}
		}
		int num16 = num4;
		int num18;
		for (num16 += genRand.Next(5); num16 < num5; num16 += genRand.Next(num18, (int)((double)num18 * 1.5)))
		{
			int num17 = num7;
			while (InWorld(num16, num17, 15) && !Main.tile[num16, num17].active())
			{
				num17--;
			}
			num17 += genRand.Next(-3, 4);
			num18 = genRand.Next(4, 8);
			int num19 = 189;
			if (genRand.Next(4) == 0)
			{
				num19 = 460;
			}
			for (int n = num16 - num18; n <= num16 + num18; n++)
			{
				for (int num20 = num17 - num18; num20 <= num17 + num18; num20++)
				{
					if (num20 > num6)
					{
						double num21 = Math.Abs(n - num16);
						double num22 = Math.Abs(num20 - num17) * 2;
						if (Math.Sqrt(num21 * num21 + num22 * num22) < (double)(num18 + genRand.Next(2)))
						{
							Main.tile[n, num20].active(active: true);
							Main.tile[n, num20].type = (ushort)num19;
							SquareTileFrame(n, num20);
						}
					}
				}
			}
		}
		num = genRand.Next(80, 95);
		num2 = num;
		num3 = genRand.Next(10, 15);
		vector2D.X = i;
		vector2D.Y = num6;
		vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
		{
			vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		}
		vector2D2.Y = (double)genRand.Next(-20, -10) * 0.02;
		while (num > 0.0 && num3 > 0.0)
		{
			num -= (double)genRand.Next(4);
			num3 -= 1.0;
			int num8 = (int)(vector2D.X - num * 0.5);
			int num9 = (int)(vector2D.X + num * 0.5);
			int num10 = num6 - 1;
			int num11 = (int)(vector2D.Y + num * 0.5);
			if (num8 < 0)
			{
				num8 = 0;
			}
			if (num9 > Main.maxTilesX)
			{
				num9 = Main.maxTilesX;
			}
			if (num10 < 0)
			{
				num10 = 0;
			}
			if (num11 > Main.maxTilesY)
			{
				num11 = Main.maxTilesY;
			}
			num2 = num * (double)genRand.Next(80, 120) * 0.01;
			double num23 = vector2D.Y + 1.0;
			for (int num24 = num8; num24 < num9; num24++)
			{
				if (genRand.Next(2) == 0)
				{
					num23 += (double)genRand.Next(-1, 2);
				}
				if (num23 < vector2D.Y)
				{
					num23 = vector2D.Y;
				}
				if (num23 > vector2D.Y + 2.0)
				{
					num23 = vector2D.Y + 2.0;
				}
				for (int num25 = num10; num25 < num11; num25++)
				{
					if ((double)num25 > num23)
					{
						double num26 = Math.Abs((double)num24 - vector2D.X);
						double num27 = Math.Abs((double)num25 - vector2D.Y) * 3.0;
						if (Math.Sqrt(num26 * num26 + num27 * num27) < num2 * 0.4 && Main.tile[num24, num25].type == 189)
						{
							Main.tile[num24, num25].type = 147;
							SquareTileFrame(num24, num25);
						}
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-20, 21) * 0.05;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			if (vector2D2.Y > 0.2)
			{
				vector2D2.Y = -0.2;
			}
			if (vector2D2.Y < -0.2)
			{
				vector2D2.Y = -0.2;
			}
		}
		int num28 = num4;
		num28 += genRand.Next(5);
		while (num28 < num5)
		{
			int num29 = num7;
			while ((!Main.tile[num28, num29].active() || Main.tile[num28, num29].type != 147) && num28 < num5)
			{
				num29--;
				if (num29 < num6)
				{
					num29 = num7;
					num28 += genRand.Next(1, 4);
				}
			}
			if (num28 >= num5)
			{
				continue;
			}
			num29 += genRand.Next(0, 4);
			int num30 = genRand.Next(2, 5);
			int num31 = 189;
			for (int num32 = num28 - num30; num32 <= num28 + num30; num32++)
			{
				for (int num33 = num29 - num30; num33 <= num29 + num30; num33++)
				{
					if (num33 > num6)
					{
						double num34 = Math.Abs(num32 - num28);
						double num35 = Math.Abs(num33 - num29) * 2;
						if (Math.Sqrt(num34 * num34 + num35 * num35) < (double)num30)
						{
							Main.tile[num32, num33].type = (ushort)num31;
							SquareTileFrame(num32, num33);
						}
					}
				}
			}
			num28 += genRand.Next(num30, (int)((double)num30 * 1.5));
		}
		for (int num36 = num4 - 20; num36 <= num5 + 20; num36++)
		{
			for (int num37 = num6 - 20; num37 <= num7 + 20; num37++)
			{
				bool flag = true;
				for (int num38 = num36 - 1; num38 <= num36 + 1; num38++)
				{
					for (int num39 = num37 - 1; num39 <= num37 + 1; num39++)
					{
						if (!Main.tile[num38, num39].active() || (Main.tile[num38, num39].wall > 0 && Main.tile[num38, num39].wall != 73))
						{
							flag = false;
						}
					}
				}
				if (flag)
				{
					Main.tile[num36, num37].wall = 73;
					SquareWallFrame(num36, num37);
				}
			}
		}
		for (int num40 = num4; num40 <= num5; num40++)
		{
			int num41;
			for (num41 = num6 - 10; !Main.tile[num40, num41 + 1].active(); num41++)
			{
			}
			if (num41 >= num7 || Main.tile[num40, num41 + 1].type != 189)
			{
				continue;
			}
			if (genRand.Next(10) == 0)
			{
				int num42 = genRand.Next(1, 3);
				for (int num43 = num40 - num42; num43 <= num40 + num42; num43++)
				{
					if (Main.tile[num43, num41].type == 189 && WillWaterPlacedHereStayPut(num43, num41))
					{
						Main.tile[num43, num41].active(active: false);
						Main.tile[num43, num41].liquid = byte.MaxValue;
						Main.tile[num43, num41].liquidType(0);
						SquareTileFrame(num40, num41);
					}
					if (Main.tile[num43, num41 + 1].type == 189 && WillWaterPlacedHereStayPut(num43, num41 + 1))
					{
						Main.tile[num43, num41 + 1].active(active: false);
						Main.tile[num43, num41 + 1].liquid = byte.MaxValue;
						Main.tile[num43, num41 + 1].liquidType(0);
						SquareTileFrame(num40, num41 + 1);
					}
					if (num43 > num40 - num42 && num43 < num40 + 2 && Main.tile[num43, num41 + 2].type == 189 && WillWaterPlacedHereStayPut(num43, num41 + 2))
					{
						Main.tile[num43, num41 + 2].active(active: false);
						Main.tile[num43, num41 + 2].liquid = byte.MaxValue;
						Main.tile[num43, num41 + 2].liquidType(0);
						SquareTileFrame(num40, num41 + 2);
					}
				}
			}
			if (genRand.Next(5) == 0 && WillWaterPlacedHereStayPut(num40, num41))
			{
				Main.tile[num40, num41].liquid = byte.MaxValue;
			}
			Main.tile[num40, num41].liquidType(0);
			SquareTileFrame(num40, num41);
		}
		int num44 = genRand.Next(4);
		for (int num45 = 0; num45 <= num44; num45++)
		{
			int num46 = genRand.Next(num4 - 5, num5 + 5);
			int num47 = num6 - genRand.Next(20, 40);
			int num48 = genRand.Next(4, 8);
			int num49 = 189;
			if (genRand.Next(2) == 0)
			{
				num49 = 460;
			}
			for (int num50 = num46 - num48; num50 <= num46 + num48; num50++)
			{
				for (int num51 = num47 - num48; num51 <= num47 + num48; num51++)
				{
					double num52 = Math.Abs(num50 - num46);
					double num53 = Math.Abs(num51 - num47) * 2;
					if (Math.Sqrt(num52 * num52 + num53 * num53) < (double)(num48 + genRand.Next(-1, 2)))
					{
						Main.tile[num50, num51].active(active: true);
						Main.tile[num50, num51].type = (ushort)num49;
						SquareTileFrame(num50, num51);
					}
				}
			}
			for (int num54 = num46 - num48 + 2; num54 <= num46 + num48 - 2; num54++)
			{
				int num55;
				for (num55 = num47 - num48; !Main.tile[num54, num55].active(); num55++)
				{
				}
				if (WillWaterPlacedHereStayPut(num54, num55))
				{
					Main.tile[num54, num55].active(active: false);
					Main.tile[num54, num55].liquid = byte.MaxValue;
					Main.tile[num54, num55].liquidType(0);
					SquareTileFrame(num54, num55);
				}
			}
		}
	}

	public static void DesertCloudIsland(int i, int j)
	{
		double num = genRand.Next(100, 150);
		double num2 = num;
		double num3 = genRand.Next(20, 30);
		int num4 = i;
		int num5 = i;
		int num6 = j;
		int num7 = j;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
		{
			vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		}
		vector2D2.Y = (double)genRand.Next(-20, -10) * 0.02;
		while (num > 0.0 && num3 > 0.0)
		{
			num -= (double)genRand.Next(4);
			num3 -= 1.0;
			int num8 = (int)(vector2D.X - num * 0.5);
			int num9 = (int)(vector2D.X + num * 0.5);
			int num10 = (int)(vector2D.Y - num * 0.5);
			int num11 = (int)(vector2D.Y + num * 0.5);
			if (num8 < 0)
			{
				num8 = 0;
			}
			if (num9 > Main.maxTilesX)
			{
				num9 = Main.maxTilesX;
			}
			if (num10 < 0)
			{
				num10 = 0;
			}
			if (num11 > Main.maxTilesY)
			{
				num11 = Main.maxTilesY;
			}
			num2 = num * (double)genRand.Next(80, 120) * 0.01;
			double num12 = vector2D.Y + 1.0;
			for (int k = num8; k < num9; k++)
			{
				if (genRand.Next(2) == 0)
				{
					num12 += (double)genRand.Next(-1, 2);
				}
				if (num12 < vector2D.Y)
				{
					num12 = vector2D.Y;
				}
				if (num12 > vector2D.Y + 2.0)
				{
					num12 = vector2D.Y + 2.0;
				}
				if (SecretSeed.surfaceIsInSpace.Enabled && !SecretSeed.errorWorld.Enabled)
				{
					double num13 = num12;
					if (num13 < (double)num10)
					{
						num13 = num10;
					}
					if (num13 > (double)num11)
					{
						num13 = num11;
					}
					for (int l = 0; (double)l <= num13; l++)
					{
						if (TileID.Sets.Clouds[Main.tile[k, l].type])
						{
							Main.tile[k, l].active(active: false);
						}
					}
				}
				for (int m = num10; m < num11; m++)
				{
					if (!((double)m > num12))
					{
						continue;
					}
					double num14 = Math.Abs((double)k - vector2D.X);
					double num15 = Math.Abs((double)m - vector2D.Y) * 3.0;
					if (Math.Sqrt(num14 * num14 + num15 * num15) < num2 * 0.4)
					{
						if (k < num4)
						{
							num4 = k;
						}
						if (k > num5)
						{
							num5 = k;
						}
						if (m < num6)
						{
							num6 = m;
						}
						if (m > num7)
						{
							num7 = m;
						}
						Main.tile[k, m].active(active: true);
						Main.tile[k, m].type = 189;
						SquareTileFrame(k, m);
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-20, 21) * 0.05;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			if (vector2D2.Y > 0.2)
			{
				vector2D2.Y = -0.2;
			}
			if (vector2D2.Y < -0.2)
			{
				vector2D2.Y = -0.2;
			}
		}
		int num16 = num4;
		int num18;
		for (num16 += genRand.Next(5); num16 < num5; num16 += genRand.Next(num18, (int)((double)num18 * 1.5)))
		{
			int num17 = num7;
			while (InWorld(num16, num17, 15) && !Main.tile[num16, num17].active())
			{
				num17--;
			}
			num17 += genRand.Next(-3, 4);
			num18 = genRand.Next(4, 8);
			int num19 = 189;
			if (genRand.Next(4) == 0)
			{
				num19 = 196;
			}
			for (int n = num16 - num18; n <= num16 + num18; n++)
			{
				for (int num20 = num17 - num18; num20 <= num17 + num18; num20++)
				{
					if (num20 > num6)
					{
						double num21 = Math.Abs(n - num16);
						double num22 = Math.Abs(num20 - num17) * 2;
						if (Math.Sqrt(num21 * num21 + num22 * num22) < (double)(num18 + genRand.Next(2)))
						{
							Main.tile[n, num20].active(active: true);
							Main.tile[n, num20].type = (ushort)num19;
							SquareTileFrame(n, num20);
						}
					}
				}
			}
		}
		num = genRand.Next(80, 95);
		num2 = num;
		num3 = genRand.Next(10, 15);
		vector2D.X = i;
		vector2D.Y = num6;
		vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
		{
			vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		}
		vector2D2.Y = (double)genRand.Next(-20, -10) * 0.02;
		while (num > 0.0 && num3 > 0.0)
		{
			num -= (double)genRand.Next(4);
			num3 -= 1.0;
			int num8 = (int)(vector2D.X - num * 0.5);
			int num9 = (int)(vector2D.X + num * 0.5);
			int num10 = num6 - 1;
			int num11 = (int)(vector2D.Y + num * 0.5);
			if (num8 < 0)
			{
				num8 = 0;
			}
			if (num9 > Main.maxTilesX)
			{
				num9 = Main.maxTilesX;
			}
			if (num10 < 0)
			{
				num10 = 0;
			}
			if (num11 > Main.maxTilesY)
			{
				num11 = Main.maxTilesY;
			}
			num2 = num * (double)genRand.Next(80, 120) * 0.01;
			double num23 = vector2D.Y + 1.0;
			for (int num24 = num8; num24 < num9; num24++)
			{
				if (genRand.Next(2) == 0)
				{
					num23 += (double)genRand.Next(-1, 2);
				}
				if (num23 < vector2D.Y)
				{
					num23 = vector2D.Y;
				}
				if (num23 > vector2D.Y + 2.0)
				{
					num23 = vector2D.Y + 2.0;
				}
				for (int num25 = num10; num25 < num11; num25++)
				{
					if ((double)num25 > num23)
					{
						double num26 = Math.Abs((double)num24 - vector2D.X);
						double num27 = Math.Abs((double)num25 - vector2D.Y) * 3.0;
						if (Math.Sqrt(num26 * num26 + num27 * num27) < num2 * 0.4 && Main.tile[num24, num25].type == 189)
						{
							Main.tile[num24, num25].type = 53;
							SquareTileFrame(num24, num25);
						}
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-20, 21) * 0.05;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			if (vector2D2.Y > 0.2)
			{
				vector2D2.Y = -0.2;
			}
			if (vector2D2.Y < -0.2)
			{
				vector2D2.Y = -0.2;
			}
		}
		int num28 = num4;
		num28 += genRand.Next(5);
		while (num28 < num5)
		{
			int num29 = num7;
			while ((!Main.tile[num28, num29].active() || Main.tile[num28, num29].type != 53) && num28 < num5)
			{
				num29--;
				if (num29 < num6)
				{
					num29 = num7;
					num28 += genRand.Next(1, 4);
				}
			}
			if (num28 >= num5)
			{
				continue;
			}
			num29 += genRand.Next(0, 4);
			int num30 = genRand.Next(2, 5);
			int num31 = 189;
			for (int num32 = num28 - num30; num32 <= num28 + num30; num32++)
			{
				for (int num33 = num29 - num30; num33 <= num29 + num30; num33++)
				{
					if (num33 > num6)
					{
						double num34 = Math.Abs(num32 - num28);
						double num35 = Math.Abs(num33 - num29) * 2;
						if (Math.Sqrt(num34 * num34 + num35 * num35) < (double)num30)
						{
							Main.tile[num32, num33].type = (ushort)num31;
							SquareTileFrame(num32, num33);
						}
					}
				}
			}
			num28 += genRand.Next(num30, (int)((double)num30 * 1.5));
		}
		for (int num36 = num4 - 20; num36 <= num5 + 20; num36++)
		{
			for (int num37 = num6 - 20; num37 <= num7 + 20; num37++)
			{
				bool flag = true;
				for (int num38 = num36 - 1; num38 <= num36 + 1; num38++)
				{
					for (int num39 = num37 - 1; num39 <= num37 + 1; num39++)
					{
						if (!Main.tile[num38, num39].active() || (Main.tile[num38, num39].wall > 0 && Main.tile[num38, num39].wall != 73))
						{
							flag = false;
						}
					}
				}
				if (flag)
				{
					Main.tile[num36, num37].wall = 73;
					SquareWallFrame(num36, num37);
				}
			}
		}
		for (int num40 = num4; num40 <= num5; num40++)
		{
			int num41;
			for (num41 = num6 - 10; !Main.tile[num40, num41 + 1].active(); num41++)
			{
			}
			if (num41 >= num7 || Main.tile[num40, num41 + 1].type != 189)
			{
				continue;
			}
			if (genRand.Next(10) == 0)
			{
				int num42 = genRand.Next(1, 3);
				for (int num43 = num40 - num42; num43 <= num40 + num42; num43++)
				{
					if (Main.tile[num43, num41].type == 189 && WillWaterPlacedHereStayPut(num43, num41))
					{
						Main.tile[num43, num41].active(active: false);
						Main.tile[num43, num41].liquid = byte.MaxValue;
						Main.tile[num43, num41].liquidType(0);
						SquareTileFrame(num40, num41);
					}
					if (Main.tile[num43, num41 + 1].type == 189 && WillWaterPlacedHereStayPut(num43, num41 + 1))
					{
						Main.tile[num43, num41 + 1].active(active: false);
						Main.tile[num43, num41 + 1].liquid = byte.MaxValue;
						Main.tile[num43, num41 + 1].liquidType(0);
						SquareTileFrame(num40, num41 + 1);
					}
					if (num43 > num40 - num42 && num43 < num40 + 2 && Main.tile[num43, num41 + 2].type == 189 && WillWaterPlacedHereStayPut(num43, num41 + 2))
					{
						Main.tile[num43, num41 + 2].active(active: false);
						Main.tile[num43, num41 + 2].liquid = byte.MaxValue;
						Main.tile[num43, num41 + 2].liquidType(0);
						SquareTileFrame(num40, num41 + 2);
					}
				}
			}
			if (genRand.Next(5) == 0 && WillWaterPlacedHereStayPut(num40, num41))
			{
				Main.tile[num40, num41].liquid = byte.MaxValue;
			}
			Main.tile[num40, num41].liquidType(0);
			SquareTileFrame(num40, num41);
		}
		int num44 = genRand.Next(4);
		for (int num45 = 0; num45 <= num44; num45++)
		{
			int num46 = genRand.Next(num4 - 5, num5 + 5);
			int num47 = num6 - genRand.Next(20, 40);
			int num48 = genRand.Next(4, 8);
			int num49 = 189;
			if (genRand.Next(2) == 0)
			{
				num49 = 196;
			}
			for (int num50 = num46 - num48; num50 <= num46 + num48; num50++)
			{
				for (int num51 = num47 - num48; num51 <= num47 + num48; num51++)
				{
					double num52 = Math.Abs(num50 - num46);
					double num53 = Math.Abs(num51 - num47) * 2;
					if (Math.Sqrt(num52 * num52 + num53 * num53) < (double)(num48 + genRand.Next(-1, 2)))
					{
						Main.tile[num50, num51].active(active: true);
						Main.tile[num50, num51].type = (ushort)num49;
						SquareTileFrame(num50, num51);
					}
				}
			}
			for (int num54 = num46 - num48 + 2; num54 <= num46 + num48 - 2; num54++)
			{
				int num55;
				for (num55 = num47 - num48; !Main.tile[num54, num55].active(); num55++)
				{
				}
				if (WillWaterPlacedHereStayPut(num54, num55))
				{
					Main.tile[num54, num55].active(active: false);
					Main.tile[num54, num55].liquid = byte.MaxValue;
					Main.tile[num54, num55].liquidType(0);
					SquareTileFrame(num54, num55);
				}
			}
		}
	}

	public static void CloudIsland(int i, int j)
	{
		double num = genRand.Next(100, 150);
		double num2 = num;
		double num3 = genRand.Next(20, 30);
		int num4 = i;
		int num5 = i;
		int num6 = j;
		int num7 = j;
		ushort num8 = 189;
		if (SecretSeed.extraFloatingIslands.Enabled && genRand.Next(3) == 0)
		{
			num8 = 718;
		}
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
		{
			vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		}
		vector2D2.Y = (double)genRand.Next(-20, -10) * 0.02;
		while (num > 0.0 && num3 > 0.0)
		{
			num -= (double)genRand.Next(4);
			num3 -= 1.0;
			int num9 = (int)(vector2D.X - num * 0.5);
			int num10 = (int)(vector2D.X + num * 0.5);
			int num11 = (int)(vector2D.Y - num * 0.5);
			int num12 = (int)(vector2D.Y + num * 0.5);
			if (num9 < 0)
			{
				num9 = 0;
			}
			if (num10 > Main.maxTilesX)
			{
				num10 = Main.maxTilesX;
			}
			if (num11 < 0)
			{
				num11 = 0;
			}
			if (num12 > Main.maxTilesY)
			{
				num12 = Main.maxTilesY;
			}
			num2 = num * (double)genRand.Next(80, 120) * 0.01;
			double num13 = vector2D.Y + 1.0;
			for (int k = num9; k < num10; k++)
			{
				if (genRand.Next(2) == 0)
				{
					num13 += (double)genRand.Next(-1, 2);
				}
				if (num13 < vector2D.Y)
				{
					num13 = vector2D.Y;
				}
				if (num13 > vector2D.Y + 2.0)
				{
					num13 = vector2D.Y + 2.0;
				}
				if (SecretSeed.surfaceIsInSpace.Enabled && !SecretSeed.errorWorld.Enabled)
				{
					double num14 = num13;
					if (num14 < (double)num11)
					{
						num14 = num11;
					}
					if (num14 > (double)num12)
					{
						num14 = num12;
					}
					for (int l = 0; (double)l <= num14; l++)
					{
						if (TileID.Sets.Clouds[Main.tile[k, l].type])
						{
							Main.tile[k, l].active(active: false);
						}
					}
				}
				for (int m = num11; m < num12; m++)
				{
					if (!((double)m > num13))
					{
						continue;
					}
					double num15 = Math.Abs((double)k - vector2D.X);
					double num16 = Math.Abs((double)m - vector2D.Y) * 3.0;
					if (Math.Sqrt(num15 * num15 + num16 * num16) < num2 * 0.4)
					{
						if (k < num4)
						{
							num4 = k;
						}
						if (k > num5)
						{
							num5 = k;
						}
						if (m < num6)
						{
							num6 = m;
						}
						if (m > num7)
						{
							num7 = m;
						}
						Main.tile[k, m].active(active: true);
						Main.tile[k, m].type = num8;
						SquareTileFrame(k, m);
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-20, 21) * 0.05;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			if (vector2D2.Y > 0.2)
			{
				vector2D2.Y = -0.2;
			}
			if (vector2D2.Y < -0.2)
			{
				vector2D2.Y = -0.2;
			}
		}
		int num17 = num4;
		int num19;
		for (num17 += genRand.Next(5); num17 < num5; num17 += genRand.Next(num19, (int)((double)num19 * 1.5)))
		{
			int num18 = num7;
			while (InWorld(num17, num18, 15) && !Main.tile[num17, num18].active())
			{
				num18--;
			}
			num18 += genRand.Next(-3, 4);
			num19 = genRand.Next(4, 8);
			int num20 = num8;
			if (genRand.Next(4) == 0)
			{
				num20 = 196;
			}
			for (int n = num17 - num19; n <= num17 + num19; n++)
			{
				for (int num21 = num18 - num19; num21 <= num18 + num19; num21++)
				{
					if (num21 > num6)
					{
						double num22 = Math.Abs(n - num17);
						double num23 = Math.Abs(num21 - num18) * 2;
						if (Math.Sqrt(num22 * num22 + num23 * num23) < (double)(num19 + genRand.Next(2)))
						{
							Main.tile[n, num21].active(active: true);
							Main.tile[n, num21].type = (ushort)num20;
							SquareTileFrame(n, num21);
						}
					}
				}
			}
		}
		num = genRand.Next(80, 95);
		num2 = num;
		num3 = genRand.Next(10, 15);
		vector2D.X = i;
		vector2D.Y = num6;
		vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
		{
			vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		}
		vector2D2.Y = (double)genRand.Next(-20, -10) * 0.02;
		while (num > 0.0 && num3 > 0.0)
		{
			num -= (double)genRand.Next(4);
			num3 -= 1.0;
			int num9 = (int)(vector2D.X - num * 0.5);
			int num10 = (int)(vector2D.X + num * 0.5);
			int num11 = num6 - 1;
			int num12 = (int)(vector2D.Y + num * 0.5);
			if (num9 < 0)
			{
				num9 = 0;
			}
			if (num10 > Main.maxTilesX)
			{
				num10 = Main.maxTilesX;
			}
			if (num11 < 0)
			{
				num11 = 0;
			}
			if (num12 > Main.maxTilesY)
			{
				num12 = Main.maxTilesY;
			}
			num2 = num * (double)genRand.Next(80, 120) * 0.01;
			double num24 = vector2D.Y + 1.0;
			for (int num25 = num9; num25 < num10; num25++)
			{
				if (genRand.Next(2) == 0)
				{
					num24 += (double)genRand.Next(-1, 2);
				}
				if (num24 < vector2D.Y)
				{
					num24 = vector2D.Y;
				}
				if (num24 > vector2D.Y + 2.0)
				{
					num24 = vector2D.Y + 2.0;
				}
				for (int num26 = num11; num26 < num12; num26++)
				{
					if ((double)num26 > num24)
					{
						double num27 = Math.Abs((double)num25 - vector2D.X);
						double num28 = Math.Abs((double)num26 - vector2D.Y) * 3.0;
						if (Math.Sqrt(num27 * num27 + num28 * num28) < num2 * 0.4 && Main.tile[num25, num26].type == num8)
						{
							Main.tile[num25, num26].type = 0;
							SquareTileFrame(num25, num26);
						}
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-20, 21) * 0.05;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			if (vector2D2.Y > 0.2)
			{
				vector2D2.Y = -0.2;
			}
			if (vector2D2.Y < -0.2)
			{
				vector2D2.Y = -0.2;
			}
		}
		int num29 = num4;
		num29 += genRand.Next(5);
		while (num29 < num5)
		{
			int num30 = num7;
			while ((!Main.tile[num29, num30].active() || Main.tile[num29, num30].type != 0) && num29 < num5)
			{
				num30--;
				if (num30 < num6)
				{
					num30 = num7;
					num29 += genRand.Next(1, 4);
				}
			}
			if (num29 >= num5)
			{
				continue;
			}
			num30 += genRand.Next(0, 4);
			int num31 = genRand.Next(2, 5);
			int num32 = num8;
			for (int num33 = num29 - num31; num33 <= num29 + num31; num33++)
			{
				for (int num34 = num30 - num31; num34 <= num30 + num31; num34++)
				{
					if (num34 > num6)
					{
						double num35 = Math.Abs(num33 - num29);
						double num36 = Math.Abs(num34 - num30) * 2;
						if (Math.Sqrt(num35 * num35 + num36 * num36) < (double)num31)
						{
							Main.tile[num33, num34].type = (ushort)num32;
							SquareTileFrame(num33, num34);
						}
					}
				}
			}
			num29 += genRand.Next(num31, (int)((double)num31 * 1.5));
		}
		for (int num37 = num4 - 20; num37 <= num5 + 20; num37++)
		{
			for (int num38 = num6 - 20; num38 <= num7 + 20; num38++)
			{
				bool flag = true;
				for (int num39 = num37 - 1; num39 <= num37 + 1; num39++)
				{
					for (int num40 = num38 - 1; num40 <= num38 + 1; num40++)
					{
						if (!Main.tile[num39, num40].active() || (Main.tile[num39, num40].wall > 0 && Main.tile[num39, num40].wall != 73))
						{
							flag = false;
						}
					}
				}
				if (flag)
				{
					Main.tile[num37, num38].wall = 73;
					SquareWallFrame(num37, num38);
				}
			}
		}
		for (int num41 = num4; num41 <= num5; num41++)
		{
			int num42;
			for (num42 = num6 - 10; !Main.tile[num41, num42 + 1].active(); num42++)
			{
			}
			if (num42 >= num7 || Main.tile[num41, num42 + 1].type != num8)
			{
				continue;
			}
			if (genRand.Next(10) == 0)
			{
				int num43 = genRand.Next(1, 3);
				for (int num44 = num41 - num43; num44 <= num41 + num43; num44++)
				{
					if (Main.tile[num44, num42].type == num8 && WillWaterPlacedHereStayPut(num44, num42))
					{
						Main.tile[num44, num42].active(active: false);
						Main.tile[num44, num42].liquid = byte.MaxValue;
						Main.tile[num44, num42].liquidType(0);
						SquareTileFrame(num41, num42);
					}
					if (Main.tile[num44, num42 + 1].type == num8 && WillWaterPlacedHereStayPut(num44, num42 + 1))
					{
						Main.tile[num44, num42 + 1].active(active: false);
						Main.tile[num44, num42 + 1].liquid = byte.MaxValue;
						Main.tile[num44, num42 + 1].liquidType(0);
						SquareTileFrame(num41, num42 + 1);
					}
					if (num44 > num41 - num43 && num44 < num41 + 2 && Main.tile[num44, num42 + 2].type == num8 && WillWaterPlacedHereStayPut(num44, num42 + 2))
					{
						Main.tile[num44, num42 + 2].active(active: false);
						Main.tile[num44, num42 + 2].liquid = byte.MaxValue;
						Main.tile[num44, num42 + 2].liquidType(0);
						SquareTileFrame(num41, num42 + 2);
					}
				}
			}
			if (genRand.Next(5) == 0 && WillWaterPlacedHereStayPut(num41, num42))
			{
				Main.tile[num41, num42].liquid = byte.MaxValue;
			}
			Main.tile[num41, num42].liquidType(0);
			SquareTileFrame(num41, num42);
		}
		int num45 = genRand.Next(4);
		for (int num46 = 0; num46 <= num45; num46++)
		{
			int num47 = genRand.Next(num4 - 5, num5 + 5);
			int num48 = num6 - genRand.Next(20, 40);
			int num49 = genRand.Next(4, 8);
			int num50 = num8;
			if (genRand.Next(2) == 0)
			{
				num50 = 196;
			}
			for (int num51 = num47 - num49; num51 <= num47 + num49; num51++)
			{
				for (int num52 = num48 - num49; num52 <= num48 + num49; num52++)
				{
					double num53 = Math.Abs(num51 - num47);
					double num54 = Math.Abs(num52 - num48) * 2;
					if (Math.Sqrt(num53 * num53 + num54 * num54) < (double)(num49 + genRand.Next(-1, 2)))
					{
						Main.tile[num51, num52].active(active: true);
						Main.tile[num51, num52].type = (ushort)num50;
						SquareTileFrame(num51, num52);
					}
				}
			}
			for (int num55 = num47 - num49 + 2; num55 <= num47 + num49 - 2; num55++)
			{
				int num56;
				for (num56 = num48 - num49; !Main.tile[num55, num56].active(); num56++)
				{
				}
				if (WillWaterPlacedHereStayPut(num55, num56))
				{
					Main.tile[num55, num56].active(active: false);
					Main.tile[num55, num56].liquid = byte.MaxValue;
					Main.tile[num55, num56].liquidType(0);
					SquareTileFrame(num55, num56);
				}
			}
		}
	}

	public static bool WillWaterPlacedHereStayPut(int x, int y)
	{
		if (((Main.tile[x, y + 1].active() && Main.tileSolid[Main.tile[x, y + 1].type] && !Main.tileSolidTop[Main.tile[x, y + 1].type]) || Main.tile[x, y + 1].liquid == byte.MaxValue) && ((Main.tile[x - 1, y].active() && Main.tileSolid[Main.tile[x - 1, y].type] && !Main.tileSolidTop[Main.tile[x - 1, y].type]) || Main.tile[x - 1, y].liquid == byte.MaxValue) && ((Main.tile[x + 1, y].active() && Main.tileSolid[Main.tile[x + 1, y].type] && !Main.tileSolidTop[Main.tile[x + 1, y].type]) || Main.tile[x + 1, y].liquid == byte.MaxValue))
		{
			return true;
		}
		return false;
	}

	public static void CloudLake(int i, int j)
	{
		double num = genRand.Next(100, 150);
		double num2 = num;
		double num3 = genRand.Next(20, 30);
		int num4 = i;
		int num5 = i;
		int num6 = j;
		int num7 = j;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
		{
			vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		}
		vector2D2.Y = (double)genRand.Next(-20, -10) * 0.02;
		ushort num8 = 189;
		if (SecretSeed.extraFloatingIslands.Enabled && genRand.Next(3) == 0)
		{
			num8 = 718;
		}
		while (num > 0.0 && num3 > 0.0)
		{
			num -= (double)genRand.Next(4);
			num3 -= 1.0;
			int num9 = (int)(vector2D.X - num * 0.5);
			int num10 = (int)(vector2D.X + num * 0.5);
			int num11 = (int)(vector2D.Y - num * 0.5);
			int num12 = (int)(vector2D.Y + num * 0.5);
			if (num9 < 0)
			{
				num9 = 0;
			}
			if (num10 > Main.maxTilesX)
			{
				num10 = Main.maxTilesX;
			}
			if (num11 < 0)
			{
				num11 = 0;
			}
			if (num12 > Main.maxTilesY)
			{
				num12 = Main.maxTilesY;
			}
			num2 = num * (double)genRand.Next(80, 120) * 0.01;
			double num13 = vector2D.Y + 1.0;
			for (int k = num9; k < num10; k++)
			{
				if (genRand.Next(2) == 0)
				{
					num13 += (double)genRand.Next(-1, 2);
				}
				if (num13 < vector2D.Y)
				{
					num13 = vector2D.Y;
				}
				if (num13 > vector2D.Y + 2.0)
				{
					num13 = vector2D.Y + 2.0;
				}
				if (SecretSeed.surfaceIsInSpace.Enabled && !SecretSeed.errorWorld.Enabled)
				{
					double num14 = num13;
					if (num14 < (double)num11)
					{
						num14 = num11;
					}
					if (num14 > (double)num12)
					{
						num14 = num12;
					}
					for (int l = 0; (double)l <= num14; l++)
					{
						if (TileID.Sets.Clouds[Main.tile[k, l].type])
						{
							Main.tile[k, l].active(active: false);
						}
					}
				}
				for (int m = num11; m < num12; m++)
				{
					if (!((double)m > num13))
					{
						continue;
					}
					double num15 = Math.Abs((double)k - vector2D.X);
					double num16 = Math.Abs((double)m - vector2D.Y) * 3.0;
					if (Math.Sqrt(num15 * num15 + num16 * num16) < num2 * 0.4)
					{
						if (k < num4)
						{
							num4 = k;
						}
						if (k > num5)
						{
							num5 = k;
						}
						if (m < num6)
						{
							num6 = m;
						}
						if (m > num7)
						{
							num7 = m;
						}
						Main.tile[k, m].active(active: true);
						Main.tile[k, m].type = num8;
						SquareTileFrame(k, m);
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-20, 21) * 0.05;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			if (vector2D2.Y > 0.2)
			{
				vector2D2.Y = -0.2;
			}
			if (vector2D2.Y < -0.2)
			{
				vector2D2.Y = -0.2;
			}
		}
		int num17 = num4;
		int num19;
		for (num17 += genRand.Next(5); num17 < num5; num17 += genRand.Next(num19, (int)((double)num19 * 1.5)))
		{
			int num18 = num7;
			while (!Main.tile[num17, num18].active())
			{
				num18--;
			}
			num18 += genRand.Next(-3, 4);
			num19 = genRand.Next(4, 8);
			int num20 = num8;
			if (genRand.Next(4) == 0)
			{
				num20 = 196;
			}
			for (int n = num17 - num19; n <= num17 + num19; n++)
			{
				for (int num21 = num18 - num19; num21 <= num18 + num19; num21++)
				{
					if (num21 > num6)
					{
						double num22 = Math.Abs(n - num17);
						double num23 = Math.Abs(num21 - num18) * 2;
						if (Math.Sqrt(num22 * num22 + num23 * num23) < (double)(num19 + genRand.Next(2)))
						{
							Main.tile[n, num21].active(active: true);
							Main.tile[n, num21].type = (ushort)num20;
							SquareTileFrame(n, num21);
						}
					}
				}
			}
		}
		num = genRand.Next(80, 95);
		num2 = num;
		num3 = genRand.Next(10, 15);
		vector2D.X = i;
		vector2D.Y = num6;
		vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
		{
			vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		}
		vector2D2.Y = (double)genRand.Next(-20, -10) * 0.02;
		while (num > 0.0 && num3 > 0.0)
		{
			num -= (double)genRand.Next(4);
			num3 -= 1.0;
			int num9 = (int)(vector2D.X - num * 0.5);
			int num10 = (int)(vector2D.X + num * 0.5);
			int num11 = num6 - 1;
			int num12 = (int)(vector2D.Y + num * 0.5);
			if (num9 < 0)
			{
				num9 = 0;
			}
			if (num10 > Main.maxTilesX)
			{
				num10 = Main.maxTilesX;
			}
			if (num11 < 0)
			{
				num11 = 0;
			}
			if (num12 > Main.maxTilesY)
			{
				num12 = Main.maxTilesY;
			}
			num2 = num * (double)genRand.Next(80, 120) * 0.01;
			double num24 = vector2D.Y + 1.0;
			for (int num25 = num9; num25 < num10; num25++)
			{
				if (genRand.Next(2) == 0)
				{
					num24 += (double)genRand.Next(-1, 2);
				}
				if (num24 < vector2D.Y)
				{
					num24 = vector2D.Y;
				}
				if (num24 > vector2D.Y + 2.0)
				{
					num24 = vector2D.Y + 2.0;
				}
				for (int num26 = num11; num26 < num12; num26++)
				{
					if (!((double)num26 > num24 - 2.0))
					{
						continue;
					}
					double num27 = Math.Abs((double)num25 - vector2D.X);
					double num28 = Math.Abs((double)num26 - vector2D.Y) * 3.0;
					if (!(Math.Sqrt(num27 * num27 + num28 * num28) < num2 * 0.4) || Main.tile[num25, num26].type != num8)
					{
						continue;
					}
					Main.tile[num25, num26].active(active: false);
					Main.tile[num25, num26].wall = 0;
					Main.tile[num25 - 1, num26].wall = 0;
					Main.tile[num25 + 1, num26].wall = 0;
					Main.tile[num25, num26 - 1].wall = 0;
					Main.tile[num25 - 1, num26 - 1].wall = 0;
					Main.tile[num25 + 1, num26 - 1].wall = 0;
					if ((double)num26 > num24 + 1.0)
					{
						if (WillWaterPlacedHereStayPut(num25, num26))
						{
							Main.tile[num25, num26].liquid = byte.MaxValue;
						}
						Main.tile[num25, num26].liquidType(0);
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-20, 21) * 0.05;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			if (vector2D2.Y > 0.2)
			{
				vector2D2.Y = -0.2;
			}
			if (vector2D2.Y < 0.0)
			{
				vector2D2.Y = 0.0;
			}
		}
		for (int num29 = num4 - 20; num29 <= num5 + 20; num29++)
		{
			for (int num30 = num6 - 20; num30 <= num7 + 20; num30++)
			{
				bool flag = true;
				for (int num31 = num29 - 1; num31 <= num29 + 1; num31++)
				{
					for (int num32 = num30 - 1; num32 <= num30 + 1; num32++)
					{
						if (!Main.tile[num31, num32].active() || (Main.tile[num31, num32].wall > 0 && Main.tile[num31, num32].wall != 73))
						{
							flag = false;
						}
					}
				}
				if (flag)
				{
					Main.tile[num29, num30].wall = 73;
				}
			}
		}
		for (int num33 = num4; num33 <= num5; num33++)
		{
			int num34;
			for (num34 = num6 - 10; !Main.tile[num33, num34 + 1].active(); num34++)
			{
			}
			if (num34 >= num7 || Main.tile[num33, num34 + 1].type != num8)
			{
				continue;
			}
			if (genRand.Next(10) == 0)
			{
				int num35 = genRand.Next(1, 3);
				for (int num36 = num33 - num35; num36 <= num33 + num35; num36++)
				{
					if (Main.tile[num36, num34].type == num8 && WillWaterPlacedHereStayPut(num36, num34))
					{
						Main.tile[num36, num34].active(active: false);
						Main.tile[num36, num34].liquid = byte.MaxValue;
						Main.tile[num36, num34].liquidType(0);
						SquareTileFrame(num33, num34);
					}
					if (Main.tile[num36, num34 + 1].type == num8 && WillWaterPlacedHereStayPut(num36, num34 + 1))
					{
						Main.tile[num36, num34 + 1].active(active: false);
						Main.tile[num36, num34 + 1].liquid = byte.MaxValue;
						Main.tile[num36, num34 + 1].liquidType(0);
						SquareTileFrame(num33, num34 + 1);
					}
					if (num36 > num33 - num35 && num36 < num33 + 2 && Main.tile[num36, num34 + 2].type == num8 && WillWaterPlacedHereStayPut(num36, num34 + 2))
					{
						Main.tile[num36, num34 + 2].active(active: false);
						Main.tile[num36, num34 + 2].liquid = byte.MaxValue;
						Main.tile[num36, num34 + 2].liquidType(0);
						SquareTileFrame(num33, num34 + 2);
					}
				}
			}
			if (genRand.Next(5) == 0 && WillWaterPlacedHereStayPut(num33, num34))
			{
				Main.tile[num33, num34].liquid = byte.MaxValue;
			}
			Main.tile[num33, num34].liquidType(0);
			SquareTileFrame(num33, num34);
		}
		int num37 = genRand.Next(1, 4);
		for (int num38 = 0; num38 <= num37; num38++)
		{
			int num39 = genRand.Next(num4 - 5, num5 + 5);
			int num40 = num6 - genRand.Next(20, 40);
			int num41 = genRand.Next(4, 8);
			int num42 = num8;
			if (genRand.Next(4) != 0)
			{
				num42 = 196;
			}
			for (int num43 = num39 - num41; num43 <= num39 + num41; num43++)
			{
				for (int num44 = num40 - num41; num44 <= num40 + num41; num44++)
				{
					double num45 = Math.Abs(num43 - num39);
					double num46 = Math.Abs(num44 - num40) * 2;
					if (Math.Sqrt(num45 * num45 + num46 * num46) < (double)(num41 + genRand.Next(-1, 2)))
					{
						Main.tile[num43, num44].active(active: true);
						Main.tile[num43, num44].type = (ushort)num42;
						SquareTileFrame(num43, num44);
					}
				}
			}
			for (int num47 = num39 - num41 + 2; num47 <= num39 + num41 - 2; num47++)
			{
				int num48;
				for (num48 = num40 - num41; !Main.tile[num47, num48].active(); num48++)
				{
				}
				if (WillWaterPlacedHereStayPut(num47, num48))
				{
					Main.tile[num47, num48].active(active: false);
					Main.tile[num47, num48].liquid = byte.MaxValue;
					Main.tile[num47, num48].liquidType(0);
					SquareTileFrame(num47, num48);
				}
			}
		}
	}

	public static void FloatingIsland(int i, int j)
	{
		double num = genRand.Next(80, 120);
		double num2 = num;
		double num3 = genRand.Next(20, 25);
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
		{
			vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		}
		vector2D2.Y = (double)genRand.Next(-20, -10) * 0.02;
		while (num > 0.0 && num3 > 0.0)
		{
			num -= (double)genRand.Next(4);
			num3 -= 1.0;
			int num4 = (int)(vector2D.X - num * 0.5);
			int num5 = (int)(vector2D.X + num * 0.5);
			int num6 = (int)(vector2D.Y - num * 0.5);
			int num7 = (int)(vector2D.Y + num * 0.5);
			if (num4 < 0)
			{
				num4 = 0;
			}
			if (num5 > Main.maxTilesX)
			{
				num5 = Main.maxTilesX;
			}
			if (num6 < 0)
			{
				num6 = 0;
			}
			if (num7 > Main.maxTilesY)
			{
				num7 = Main.maxTilesY;
			}
			num2 = num * (double)genRand.Next(80, 120) * 0.01;
			double num8 = vector2D.Y + 1.0;
			for (int k = num4; k < num5; k++)
			{
				if (genRand.Next(2) == 0)
				{
					num8 += (double)genRand.Next(-1, 2);
				}
				if (num8 < vector2D.Y)
				{
					num8 = vector2D.Y;
				}
				if (num8 > vector2D.Y + 2.0)
				{
					num8 = vector2D.Y + 2.0;
				}
				for (int l = num6; l < num7; l++)
				{
					if (!((double)l > num8))
					{
						continue;
					}
					double num9 = Math.Abs((double)k - vector2D.X);
					double num10 = Math.Abs((double)l - vector2D.Y) * 2.0;
					if (Math.Sqrt(num9 * num9 + num10 * num10) < num2 * 0.4)
					{
						Main.tile[k, l].active(active: true);
						if (Main.tile[k, l].type == 59)
						{
							Main.tile[k, l].type = 0;
						}
					}
				}
			}
			num4 = (int)(vector2D.X - num * 0.4);
			num5 = (int)(vector2D.X + num * 0.4);
			num6 = (int)(vector2D.Y - num * 0.4);
			num7 = (int)(vector2D.Y + num * 0.4);
			if (num4 < 0)
			{
				num4 = 0;
			}
			if (num5 > Main.maxTilesX)
			{
				num5 = Main.maxTilesX;
			}
			if (num6 < 0)
			{
				num6 = 0;
			}
			if (num7 > Main.maxTilesY)
			{
				num7 = Main.maxTilesY;
			}
			num2 = num * (double)genRand.Next(80, 120) * 0.01;
			for (int m = num4; m < num5; m++)
			{
				for (int n = num6; n < num7; n++)
				{
					if ((double)n > vector2D.Y + 2.0)
					{
						double num11 = Math.Abs((double)m - vector2D.X);
						double num12 = Math.Abs((double)n - vector2D.Y) * 2.0;
						if (Math.Sqrt(num11 * num11 + num12 * num12) < num2 * 0.4)
						{
							Main.tile[m, n].wall = 2;
						}
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			if (vector2D2.Y > 0.2)
			{
				vector2D2.Y = -0.2;
			}
			if (vector2D2.Y < -0.2)
			{
				vector2D2.Y = -0.2;
			}
		}
	}

	public static void Caverer(int X, int Y)
	{
		switch (genRand.Next(2))
		{
		case 0:
		{
			int num4 = genRand.Next(7, 9);
			double num5 = (double)genRand.Next(100) * 0.01;
			double num6 = 1.0 - num5;
			if (genRand.Next(2) == 0)
			{
				num5 = 0.0 - num5;
			}
			if (genRand.Next(2) == 0)
			{
				num6 = 0.0 - num6;
			}
			Vector2D vector2D2 = new Vector2D(X, Y);
			for (int j = 0; j < num4; j++)
			{
				vector2D2 = digTunnel(vector2D2.X, vector2D2.Y, num5, num6, genRand.Next(6, 20), genRand.Next(4, 9));
				num5 += (double)genRand.Next(-20, 21) * 0.1;
				num6 += (double)genRand.Next(-20, 21) * 0.1;
				if (num5 < -1.5)
				{
					num5 = -1.5;
				}
				if (num5 > 1.5)
				{
					num5 = 1.5;
				}
				if (num6 < -1.5)
				{
					num6 = -1.5;
				}
				if (num6 > 1.5)
				{
					num6 = 1.5;
				}
				double num7 = (double)genRand.Next(100) * 0.01;
				double num8 = 1.0 - num7;
				if (genRand.Next(2) == 0)
				{
					num7 = 0.0 - num7;
				}
				if (genRand.Next(2) == 0)
				{
					num8 = 0.0 - num8;
				}
				Vector2D vector2D3 = digTunnel(vector2D2.X, vector2D2.Y, num7, num8, genRand.Next(30, 50), genRand.Next(3, 6));
				TileRunner((int)vector2D3.X, (int)vector2D3.Y, genRand.Next(10, 20), genRand.Next(5, 10), -1);
			}
			break;
		}
		case 1:
		{
			int num = genRand.Next(15, 30);
			double num2 = (double)genRand.Next(100) * 0.01;
			double num3 = 1.0 - num2;
			if (genRand.Next(2) == 0)
			{
				num2 = 0.0 - num2;
			}
			if (genRand.Next(2) == 0)
			{
				num3 = 0.0 - num3;
			}
			Vector2D vector2D = new Vector2D(X, Y);
			for (int i = 0; i < num; i++)
			{
				vector2D = digTunnel(vector2D.X, vector2D.Y, num2, num3, genRand.Next(5, 15), genRand.Next(2, 6), Wet: true);
				num2 += (double)genRand.Next(-20, 21) * 0.1;
				num3 += (double)genRand.Next(-20, 21) * 0.1;
				if (num2 < -1.5)
				{
					num2 = -1.5;
				}
				if (num2 > 1.5)
				{
					num2 = 1.5;
				}
				if (num3 < -1.5)
				{
					num3 = -1.5;
				}
				if (num3 > 1.5)
				{
					num3 = 1.5;
				}
			}
			break;
		}
		}
	}

	public static Vector2D digTunnel(double X, double Y, double xDir, double yDir, int Steps, int Size, bool Wet = false)
	{
		double num = X;
		double num2 = Y;
		try
		{
			double num3 = 0.0;
			double num4 = 0.0;
			double num5 = Size;
			num = Utils.Clamp(num, num5 + 1.0, (double)Main.maxTilesX - num5 - 1.0);
			num2 = Utils.Clamp(num2, num5 + 1.0, (double)Main.maxTilesY - num5 - 1.0);
			for (int i = 0; i < Steps; i++)
			{
				for (int j = (int)(num - num5); (double)j <= num + num5; j++)
				{
					for (int k = (int)(num2 - num5); (double)k <= num2 + num5; k++)
					{
						if (Math.Abs((double)j - num) + Math.Abs((double)k - num2) < num5 * (1.0 + (double)genRand.Next(-10, 11) * 0.005) && j >= 0 && j < Main.maxTilesX && k >= 0 && k < Main.maxTilesY)
						{
							Main.tile[j, k].active(active: false);
							if (Wet)
							{
								Main.tile[j, k].liquid = byte.MaxValue;
								Main.tile[j, k].liquidType(0);
							}
						}
					}
				}
				num5 += (double)genRand.Next(-50, 51) * 0.03;
				if (num5 < (double)Size * 0.6)
				{
					num5 = (double)Size * 0.6;
				}
				if (num5 > (double)(Size * 2))
				{
					num5 = Size * 2;
				}
				num3 += (double)genRand.Next(-20, 21) * 0.01;
				num4 += (double)genRand.Next(-20, 21) * 0.01;
				if (num3 < -1.0)
				{
					num3 = -1.0;
				}
				if (num3 > 1.0)
				{
					num3 = 1.0;
				}
				if (num4 < -1.0)
				{
					num4 = -1.0;
				}
				if (num4 > 1.0)
				{
					num4 = 1.0;
				}
				num += (xDir + num3) * 0.6;
				num2 += (yDir + num4) * 0.6;
			}
		}
		catch
		{
		}
		return new Vector2D(num, num2);
	}

	public static void IslandHouse(int i, int j, int islandStyle)
	{
		bool flag = crimson;
		int num = 30;
		for (int k = i - num; k <= i + num; k++)
		{
			for (int l = j - num; l <= j + num; l++)
			{
				if (InWorld(k, l) && (Main.wallDungeon[Main.tile[k, l].wall] || Main.tile[k, l].wall == 87 || Main.tile[k, l].wall == 3 || Main.tile[k, l].wall == 83))
				{
					return;
				}
			}
		}
		if (drunkWorldGen)
		{
			flag = (GenVars.crimsonLeft && i < Main.maxTilesX / 2) || ((!GenVars.crimsonLeft && i > Main.maxTilesX / 2) ? true : false);
		}
		ushort type = 202;
		ushort wall = 82;
		Vector2D vector2D = new Vector2D(i, j);
		int num2 = 1;
		if (genRand.Next(2) == 0)
		{
			num2 = -1;
		}
		int num3 = genRand.Next(7, 12);
		int num4 = genRand.Next(5, 7);
		vector2D.X = i + (num3 + 2) * num2;
		if ((double)j > Main.worldSurface)
		{
			vector2D.Y = j - 5;
		}
		else
		{
			for (int m = j - 15; m < j + 30; m++)
			{
				Tile tile = Main.tile[(int)vector2D.X, m];
				if (tile.wall > 0 && tile.active() && SolidTile((int)vector2D.X, m) && tile.type != 192 && tile.type != 191 && tile.type != 384 && tile.type != 384)
				{
					vector2D.Y = m - 1;
					break;
				}
			}
		}
		vector2D.X = i;
		int num5 = (int)(vector2D.X - (double)num3 - 1.0);
		int num6 = (int)(vector2D.X + (double)num3 + 1.0);
		int num7 = (int)(vector2D.Y - (double)num4 - 1.0);
		int num8 = (int)(vector2D.Y + 2.0);
		if (num5 < 0)
		{
			num5 = 0;
		}
		if (num6 > Main.maxTilesX)
		{
			num6 = Main.maxTilesX;
		}
		if (num7 < 0)
		{
			num7 = 0;
		}
		if (num8 > Main.maxTilesY)
		{
			num8 = Main.maxTilesY;
		}
		for (int n = num5; n <= num6; n++)
		{
			for (int num9 = num7 - 1; num9 < num8 + 1; num9++)
			{
				if (num9 != num7 - 1 || (n != num5 && n != num6))
				{
					Main.tile[n, num9].active(active: true);
					Main.tile[n, num9].liquid = 0;
					Main.tile[n, num9].type = type;
					Main.tile[n, num9].wall = 0;
					Main.tile[n, num9].halfBrick(halfBrick: false);
					Main.tile[n, num9].slope(0);
				}
			}
		}
		num5 = (int)(vector2D.X - (double)num3);
		num6 = (int)(vector2D.X + (double)num3);
		num7 = (int)(vector2D.Y - (double)num4);
		num8 = (int)(vector2D.Y + 1.0);
		if (num5 < 0)
		{
			num5 = 0;
		}
		if (num6 > Main.maxTilesX)
		{
			num6 = Main.maxTilesX;
		}
		if (num7 < 0)
		{
			num7 = 0;
		}
		if (num8 > Main.maxTilesY)
		{
			num8 = Main.maxTilesY;
		}
		for (int num10 = num5; num10 <= num6; num10++)
		{
			for (int num11 = num7; num11 < num8; num11++)
			{
				if ((num11 != num7 || (num10 != num5 && num10 != num6)) && Main.tile[num10, num11].wall == 0)
				{
					Main.tile[num10, num11].active(active: false);
					Main.tile[num10, num11].wall = wall;
				}
			}
		}
		int num12 = i + (num3 + 1) * num2;
		int num13 = (int)vector2D.Y;
		for (int num14 = num12 - 2; num14 <= num12 + 2; num14++)
		{
			Main.tile[num14, num13].active(active: false);
			Main.tile[num14, num13 - 1].active(active: false);
			Main.tile[num14, num13 - 2].active(active: false);
		}
		if (remixWorldGen && (!tenthAnniversaryWorldGen || getGoodWorldGen))
		{
			if (flag)
			{
				PlaceTile(num12, num13, 10, mute: true, forced: false, -1, 5);
			}
			else
			{
				PlaceTile(num12, num13, 10, mute: true, forced: false, -1, 38);
			}
		}
		else
		{
			PlaceTile(num12, num13, 10, mute: true, forced: false, -1, 9);
		}
		num12 = i + (num3 + 1) * -num2 - num2;
		for (int num15 = num7; num15 <= num8 + 1; num15++)
		{
			Main.tile[num12, num15].active(active: true);
			Main.tile[num12, num15].liquid = 0;
			Main.tile[num12, num15].type = type;
			Main.tile[num12, num15].wall = 0;
			Main.tile[num12, num15].halfBrick(halfBrick: false);
			Main.tile[num12, num15].slope(0);
		}
		int mainItemInChest = 0;
		int num16 = GenVars.skyIslandHouseCount;
		if (num16 > 3)
		{
			num16 = genRand.Next(4);
		}
		switch (num16)
		{
		case 0:
			mainItemInChest = 159;
			break;
		case 1:
			mainItemInChest = 65;
			break;
		case 2:
			mainItemInChest = 158;
			break;
		case 3:
			mainItemInChest = 2219;
			break;
		}
		if (getGoodWorldGen)
		{
			AddBuriedChest(i, num13 - 3, mainItemInChest, notNearOtherChests: false, 2, trySlope: false, 0);
		}
		else
		{
			AddBuriedChest(i, num13 - 3, mainItemInChest, notNearOtherChests: false, 13, trySlope: false, 0);
		}
		if (islandStyle > 0)
		{
			for (int num17 = 0; num17 < 100000; num17++)
			{
				int num18 = i + genRand.Next(-50, 51);
				int num19 = num13 + genRand.Next(21);
				if ((num17 >= 50000 || Main.tile[num18, num19].type != 202) && !Main.tile[num18, num19].active())
				{
					Place2xX(num18, num19, 207, islandStyle);
					if (Main.tile[num18, num19].active())
					{
						SwitchFountain(num18, num19);
						break;
					}
				}
			}
		}
		GenVars.skyIslandHouseCount++;
		if (!remixWorldGen || (tenthAnniversaryWorldGen && !getGoodWorldGen))
		{
			int num20 = i - num3 / 2 + 1;
			int num21 = i + num3 / 2 - 1;
			int num22 = 1;
			if (num3 > 10)
			{
				num22 = 2;
			}
			int num23 = (num7 + num8) / 2 - 1;
			for (int num24 = num20 - num22; num24 <= num20 + num22; num24++)
			{
				for (int num25 = num23 - 1; num25 <= num23 + 1; num25++)
				{
					Main.tile[num24, num25].wall = 21;
				}
			}
			for (int num26 = num21 - num22; num26 <= num21 + num22; num26++)
			{
				for (int num27 = num23 - 1; num27 <= num23 + 1; num27++)
				{
					Main.tile[num26, num27].wall = 21;
				}
			}
		}
		int num28 = i + (num3 / 2 + 1) * -num2;
		if (remixWorldGen && (!tenthAnniversaryWorldGen || getGoodWorldGen))
		{
			if (flag)
			{
				PlaceTile(num28, num8 - 1, 14, mute: true, forced: false, -1, 5);
				PlaceTile(num28 - 2, num8 - 1, 15, mute: true, forced: false, 0, 8);
				PlaceTile(num28 + 2, num8 - 1, 15, mute: true, forced: false, 0, 8);
			}
			else
			{
				PlaceTile(num28, num8 - 1, 469, mute: true, forced: false, -1, 2);
				PlaceTile(num28 - 2, num8 - 1, 15, mute: true, forced: false, 0, 38);
				PlaceTile(num28 + 2, num8 - 1, 15, mute: true, forced: false, 0, 38);
			}
		}
		else
		{
			PlaceTile(num28, num8 - 1, 14, mute: true, forced: false, -1, 7);
			PlaceTile(num28 - 2, num8 - 1, 15, mute: true, forced: false, 0, 10);
			PlaceTile(num28 + 2, num8 - 1, 15, mute: true, forced: false, 0, 10);
		}
		Main.tile[num28 - 2, num8 - 1].frameX += 18;
		Main.tile[num28 - 2, num8 - 2].frameX += 18;
		if (!remixWorldGen || (tenthAnniversaryWorldGen && !getGoodWorldGen))
		{
			int i2 = num5 + 1;
			int j2 = num7;
			PlaceTile(i2, j2, 91, mute: true, forced: false, -1, genRand.Next(7, 10));
			i2 = num6 - 1;
			j2 = num7;
			PlaceTile(i2, j2, 91, mute: true, forced: false, -1, genRand.Next(7, 10));
			if (num2 > 0)
			{
				i2 = num5;
				j2 = num7 + 1;
			}
			else
			{
				i2 = num6;
				j2 = num7 + 1;
			}
			PlaceTile(i2, j2, 91, mute: true, forced: false, -1, genRand.Next(7, 10));
		}
		if (islandStyle != 1)
		{
			return;
		}
		int num29 = genRand.Next(3, 6);
		for (int num30 = 0; num30 < 100000; num30++)
		{
			int num31 = i + genRand.Next(-50, 51);
			int num32 = num13 + genRand.Next(-10, 21);
			if (!Main.tile[num31, num32].active())
			{
				TryGrowingTreeByType(323, num31, num32 + 1);
				if (Main.tile[num31, num32].active())
				{
					num29--;
				}
			}
			if (num29 <= 0)
			{
				break;
			}
		}
	}

	public static void Mountinater(int i, int j)
	{
		double num = genRand.Next(80, 120);
		double num2 = num;
		double num3 = genRand.Next(40, 55);
		if (remixWorldGen)
		{
			num2 *= 1.5;
			num3 *= 1.5;
		}
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = (double)j + num3 / 2.0;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-10, 11) * 0.1;
		vector2D2.Y = (double)genRand.Next(-20, -10) * 0.1;
		while (num > 0.0 && num3 > 0.0)
		{
			num -= (double)genRand.Next(4);
			num3 -= 1.0;
			int num4 = (int)(vector2D.X - num * 0.5);
			int num5 = (int)(vector2D.X + num * 0.5);
			int num6 = (int)(vector2D.Y - num * 0.5);
			int num7 = (int)(vector2D.Y + num * 0.5);
			if (num4 < 0)
			{
				num4 = 0;
			}
			if (num5 > Main.maxTilesX)
			{
				num5 = Main.maxTilesX;
			}
			if (num6 < 0)
			{
				num6 = 0;
			}
			if (num7 > Main.maxTilesY)
			{
				num7 = Main.maxTilesY;
			}
			num2 = num * (double)genRand.Next(80, 120) * 0.01;
			for (int k = num4; k < num5; k++)
			{
				for (int l = num6; l < num7; l++)
				{
					double num8 = Math.Abs((double)k - vector2D.X);
					double num9 = Math.Abs((double)l - vector2D.Y);
					if (Math.Sqrt(num8 * num8 + num9 * num9) < num2 * 0.4 && !Main.tile[k, l].active())
					{
						Main.tile[k, l].active(active: true);
						Main.tile[k, l].type = 0;
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
			vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
			if (vector2D2.X > 0.5)
			{
				vector2D2.X = 0.5;
			}
			if (vector2D2.X < -0.5)
			{
				vector2D2.X = -0.5;
			}
			if (vector2D2.Y > -0.5)
			{
				vector2D2.Y = -0.5;
			}
			if (vector2D2.Y < -1.5)
			{
				vector2D2.Y = -1.5;
			}
		}
	}

	public static void MakeWateryIceThing(int i, int j)
	{
		if (!InWorld(i, j, 1) || Main.tile[i, j].liquid <= 0 || Main.tile[i, j].active() || (Main.tile[i, j].lava() && !Main.remixWorld))
		{
			return;
		}
		int num = j;
		while (!Main.tile[i, num].active() && Main.tile[i, num].liquid > 0)
		{
			num++;
			if (num > Main.maxTilesY - 50)
			{
				return;
			}
		}
		if (!Main.tile[i, num].active() || (!TileID.Sets.Snow[Main.tile[i, num].type] && !TileID.Sets.Ices[Main.tile[i, num].type]))
		{
			return;
		}
		num--;
		while (Main.tile[i, num].liquid > 0)
		{
			num--;
			if (num < 10)
			{
				return;
			}
		}
		if (Main.tile[i, num].active())
		{
			return;
		}
		num++;
		if (!Main.tile[i, num].active())
		{
			int num2 = i;
			while (InWorld(num2, num, 1) && !Main.tile[num2, num].active() && Main.tile[num2, num].liquid > 0 && Main.tile[num2, num - 1].liquid == 0 && !Main.tile[num2, num - 1].active() && !Main.tile[num2 - 1, num].halfBrick())
			{
				PlaceTile(num2, num, 162, mute: true);
				num2--;
			}
			for (num2 = i + 1; InWorld(num2, num, 1) && !Main.tile[num2, num].active() && Main.tile[num2, num].liquid > 0 && Main.tile[num2, num - 1].liquid == 0 && !Main.tile[num2, num - 1].active() && !Main.tile[num2 + 1, num].halfBrick(); num2++)
			{
				PlaceTile(num2, num, 162, mute: true);
			}
		}
	}

	public static void Lakinater(int i, int j, double strengthMultiplier = 1.0)
	{
		double num = (double)genRand.Next(25, 50) * strengthMultiplier;
		double num2 = num;
		double num3 = genRand.Next(30, 80);
		if (genRand.Next(5) == 0)
		{
			num *= 1.5;
			num2 *= 1.5;
			num3 *= 1.2;
		}
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = (double)j - num3 * 0.3;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-10, 11) * 0.1;
		vector2D2.Y = (double)genRand.Next(-20, -10) * 0.1;
		while (num > 0.0 && num3 > 0.0)
		{
			if (vector2D.Y + num2 * 0.5 > Main.worldSurface)
			{
				num3 = 0.0;
			}
			num -= (double)genRand.Next(3);
			num3 -= 1.0;
			int num4 = (int)(vector2D.X - num * 0.5);
			int num5 = (int)(vector2D.X + num * 0.5);
			int num6 = (int)(vector2D.Y - num * 0.5);
			int num7 = (int)(vector2D.Y + num * 0.5);
			if (num4 < 0)
			{
				num4 = 0;
			}
			if (num5 > Main.maxTilesX)
			{
				num5 = Main.maxTilesX;
			}
			if (num6 < 0)
			{
				num6 = 0;
			}
			if (num7 > Main.maxTilesY)
			{
				num7 = Main.maxTilesY;
			}
			num2 = num * (double)genRand.Next(80, 120) * 0.01;
			for (int k = num4; k < num5; k++)
			{
				for (int l = num6; l < num7; l++)
				{
					double num8 = Math.Abs((double)k - vector2D.X);
					double num9 = Math.Abs((double)l - vector2D.Y);
					if (Math.Sqrt(num8 * num8 + num9 * num9) < num2 * 0.4)
					{
						if (Main.tile[k, l].active())
						{
							Main.tile[k, l].liquid = byte.MaxValue;
							Main.tile[k, l].liquidType(0);
						}
						Main.tile[k, l].active(active: false);
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
			vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
			if (vector2D2.X > 0.5)
			{
				vector2D2.X = 0.5;
			}
			if (vector2D2.X < -0.5)
			{
				vector2D2.X = -0.5;
			}
			if (vector2D2.Y > 1.5)
			{
				vector2D2.Y = 1.5;
			}
			if (vector2D2.Y < 0.5)
			{
				vector2D2.Y = 0.5;
			}
		}
	}

	public static void SonOfLakinater(int i, int j, double strengthMultiplier = 1.0)
	{
		short liquidType = 0;
		if (genRand.Next(3) == 0)
		{
			if (drunkWorldGen && tenthAnniversaryWorldGen && remixWorldGen && !notTheBees)
			{
				liquidType = 3;
			}
			else if (getGoodWorldGen && ((double)i < (double)Main.maxTilesX * 0.45 || (double)i > (double)Main.maxTilesX * 0.55))
			{
				liquidType = 1;
			}
		}
		double num = (double)genRand.Next(15, 31) * strengthMultiplier;
		double num2 = genRand.Next(30, 61);
		if (genRand.Next(5) == 0)
		{
			num *= 1.3;
			num2 *= 1.3;
		}
		if (drunkWorldGen)
		{
			num *= 1.3;
			num2 *= 1.3;
		}
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		double num3 = genRand.NextDouble() * 0.002;
		Vector2D vector2D2 = default(Vector2D);
		if (genRand.Next(4) != 0)
		{
			vector2D2.X = (double)genRand.Next(-15, 16) * 0.01;
		}
		else
		{
			vector2D2.X = (double)genRand.Next(-50, 51) * 0.01;
			num3 = genRand.NextDouble() * 0.004 + 0.001;
		}
		vector2D2.Y = (double)genRand.Next(101) * 0.01;
		double num4 = num;
		double num5 = num2;
		while (num > 3.0 && num2 > 0.0)
		{
			num -= (double)genRand.Next(11) * 0.1;
			num2 -= 1.0;
			int num6 = (int)(vector2D.X - num * 4.0);
			int num7 = (int)(vector2D.X + num * 4.0);
			int num8 = (int)(vector2D.Y - num * 3.0);
			int num9 = (int)(vector2D.Y + num * 2.0);
			if (num6 < 0)
			{
				num6 = 0;
			}
			if (num7 > Main.maxTilesX)
			{
				num7 = Main.maxTilesX;
			}
			if (num8 < 0)
			{
				num8 = 0;
			}
			if (num9 > Main.maxTilesY)
			{
				num9 = Main.maxTilesY;
			}
			num4 = num;
			for (int k = num6; k < num7; k++)
			{
				for (int l = num8; l < num9; l++)
				{
					double value = Math.Abs((double)k - vector2D.X) * 0.6;
					double value2 = Math.Abs((double)l - vector2D.Y) * 1.4;
					double value3 = Math.Abs((double)k - vector2D.X) * 0.3;
					double value4 = Math.Abs((double)l - vector2D.Y) * 5.0;
					value = Utils.Lerp(value, value3, num2 / num5);
					value2 = Utils.Lerp(value2, value4, num2 / num5);
					double num10 = Math.Sqrt(value * value + value2 * value2);
					int num11 = j + 5;
					if (num10 < num4 * 0.4)
					{
						if (l >= j)
						{
							if (l <= j + 1)
							{
								if (WillWaterPlacedHereStayPut(k, l))
								{
									Main.tile[k, l].liquid = byte.MaxValue;
									Main.tile[k, l].liquidType(liquidType);
								}
							}
							else
							{
								Main.tile[k, l].liquid = byte.MaxValue;
								Main.tile[k, l].liquidType(liquidType);
							}
						}
						Main.tile[k, l].active(active: false);
						if (!isGeneratingOrLoadingWorld)
						{
							SquareTileFrame(k, l);
						}
						if (Main.tile[k, l].type == 59 || Main.tile[k, l].type == 60)
						{
							SpreadGrass(k - 1, l, 59, 60);
							SpreadGrass(k + 1, l, 59, 60);
							SpreadGrass(k, l + 1, 59, 60);
						}
					}
					else if (l > j + 1 && num10 < num4 && Main.tile[k, l].liquid == 0)
					{
						if (Math.Abs((double)k - vector2D.X) * 0.8 < num4 && !Main.tile[k, l].active() && Main.tile[k, l].wall > 0 && Main.tile[k - 1, l].wall > 0 && Main.tile[k + 1, l].wall > 0 && Main.tile[k, l + 1].wall > 0)
						{
							Main.tile[k, l].type = WallID.Sets.WallTypeToTerrainTileType[Main.tile[k, l].wall];
							Main.tile[k, l].active(active: true);
						}
					}
					else
					{
						if (l >= j || num2 != num5 - 1.0 || !((double)l > GenVars.worldSurfaceLow - 20.0) || !Main.tile[k, l].active() || TileID.Sets.Clouds[Main.tile[k, l].type])
						{
							continue;
						}
						value = (double)Math.Abs(k - i) * 0.7;
						value2 = (double)Math.Abs(l - num11) * 1.35;
						num10 = Math.Sqrt(value * value + value2 * value2);
						double num12 = num4 * 0.4;
						double num13 = (double)Math.Abs(k - i) / (double)(num7 - i);
						num13 = 1.0 - num13;
						num13 *= 2.3;
						num13 *= num13;
						num13 *= num13;
						if (l < num11 && value < num12 + (double)Math.Abs(l - num11) * 0.5 * num13)
						{
							Main.tile[k, l].active(active: false);
							if (Main.tile[k, l].type == 59 || Main.tile[k, l].type == 60)
							{
								SpreadGrass(k - 1, l, 59, 60);
								SpreadGrass(k + 1, l, 59, 60);
								SpreadGrass(k, l + 1, 59, 60);
							}
						}
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-100, 101) * num3;
			vector2D2.Y += (double)genRand.Next(-100, 101) * 0.01;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			if (vector2D2.Y > 1.0)
			{
				vector2D2.Y = 1.0;
			}
			double num14 = 0.5 * (1.0 - num2 / num5);
			if (vector2D2.Y < num14)
			{
				vector2D2.Y = num14;
			}
		}
	}

	public static void ShroomPatch(int i, int j)
	{
		double num = genRand.Next(80, 100);
		double num2 = genRand.Next(20, 26);
		double num3 = (double)Main.maxTilesX / 4200.0;
		if (getGoodWorldGen && !Main.remixWorld)
		{
			num3 *= 1.5;
		}
		num *= num3;
		num2 *= num3;
		double num4 = num2 - 1.0;
		double num5 = num;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = (double)j - num2 * 0.3;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-100, 101) * 0.005;
		vector2D2.Y = (double)genRand.Next(-200, -100) * 0.005;
		while (num > 0.0 && num2 > 0.0)
		{
			num -= (double)genRand.Next(3);
			num2 -= 1.0;
			int num6 = (int)(vector2D.X - num * 0.5);
			int num7 = (int)(vector2D.X + num * 0.5);
			int num8 = (int)(vector2D.Y - num * 0.5);
			int num9 = (int)(vector2D.Y + num * 0.5);
			if (num6 < 0)
			{
				num6 = 0;
			}
			if (num7 > Main.maxTilesX)
			{
				num7 = Main.maxTilesX;
			}
			if (num8 < 0)
			{
				num8 = 0;
			}
			if (num9 > Main.maxTilesY)
			{
				num9 = Main.maxTilesY;
			}
			num5 = num * (double)genRand.Next(80, 120) * 0.01;
			for (int k = num6; k < num7; k++)
			{
				for (int l = num8; l < num9; l++)
				{
					double num10 = Math.Abs((double)k - vector2D.X);
					double num11 = Math.Abs(((double)l - vector2D.Y) * 2.3);
					double num12 = Math.Sqrt(num10 * num10 + num11 * num11);
					if (num12 < num5 * 0.8 && Main.tile[k, l].lava())
					{
						Main.tile[k, l].liquid = 0;
					}
					if (num12 < num5 * 0.2 && (double)l < vector2D.Y)
					{
						Main.tile[k, l].active(active: false);
						if (Main.tile[k, l].wall > 0)
						{
							Main.tile[k, l].wall = 80;
						}
					}
					else if (num12 < num5 * 0.4 * (0.95 + genRand.NextDouble() * 0.1))
					{
						Main.tile[k, l].type = 59;
						if (num2 == num4 && (double)l > vector2D.Y)
						{
							Main.tile[k, l].active(active: true);
						}
						if (Main.tile[k, l].wall > 0)
						{
							Main.tile[k, l].wall = 80;
						}
					}
				}
			}
			vector2D += vector2D2;
			vector2D.X += vector2D2.X;
			vector2D2.X += (double)genRand.Next(-100, 110) * 0.005;
			vector2D2.Y -= (double)genRand.Next(110) * 0.005;
			if (vector2D2.X > -0.5 && vector2D2.X < 0.5)
			{
				if (vector2D2.X < 0.0)
				{
					vector2D2.X = -0.5;
				}
				else
				{
					vector2D2.X = 0.5;
				}
			}
			if (vector2D2.X > 0.5)
			{
				vector2D2.X = 0.5;
			}
			if (vector2D2.X < -0.5)
			{
				vector2D2.X = -0.5;
			}
			if (vector2D2.Y > 0.5)
			{
				vector2D2.Y = 0.5;
			}
			if (vector2D2.Y < -0.5)
			{
				vector2D2.Y = -0.5;
			}
			for (int m = 0; m < 2; m++)
			{
				int num13 = (int)vector2D.X + genRand.Next(-20, 20);
				int num14 = (int)vector2D.Y + genRand.Next(0, 20);
				while (!Main.tile[num13, num14].active() && Main.tile[num13, num14].type != 59)
				{
					num13 = (int)vector2D.X + genRand.Next(-20, 20);
					num14 = (int)vector2D.Y + genRand.Next(0, 20);
				}
				int num15 = genRand.Next(10, 20);
				int steps = genRand.Next(10, 20);
				TileRunner(num13, num14, num15, steps, 59, addTile: false, 0.0, 2.0, noYChange: true);
			}
		}
	}

	public static void Cavinator(int i, int j, int steps)
	{
		double num = genRand.Next(7, 15);
		double num2 = num;
		int num3 = 1;
		if (genRand.Next(2) == 0)
		{
			num3 = -1;
		}
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		int num4 = genRand.Next(20, 40);
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.Y = (double)genRand.Next(10, 20) * 0.01;
		vector2D2.X = num3;
		while (num4 > 0)
		{
			num4--;
			int num5 = (int)(vector2D.X - num * 0.5);
			int num6 = (int)(vector2D.X + num * 0.5);
			int num7 = (int)(vector2D.Y - num * 0.5);
			int num8 = (int)(vector2D.Y + num * 0.5);
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesX)
			{
				num6 = Main.maxTilesX;
			}
			if (num7 < 0)
			{
				num7 = 0;
			}
			if (num8 > Main.maxTilesY)
			{
				num8 = Main.maxTilesY;
			}
			num2 = num * (double)genRand.Next(80, 120) * 0.01;
			for (int k = num5; k < num6; k++)
			{
				for (int l = num7; l < num8; l++)
				{
					double num9 = Math.Abs((double)k - vector2D.X);
					double num10 = Math.Abs((double)l - vector2D.Y);
					if (Math.Sqrt(num9 * num9 + num10 * num10) < num2 * 0.4)
					{
						Tile tile = Main.tile[k, l];
						if (SecretSeed.dualDungeons.Enabled && ((tile.active() && DungeonUtils.IsConsideredDungeonTile(tile.type, allDungeons: true)) || DungeonUtils.IsConsideredDungeonWall(tile.wall, allDungeons: true)))
						{
							num4 = 0;
							break;
						}
						if ((tile.active() && Main.tileDungeon[tile.type]) || Main.wallDungeon[tile.wall])
						{
							num4 = 0;
							break;
						}
						if (tile.active() && (!CanBeClearedDuringGeneration(tile.type, k, l) || tile.type == 53))
						{
							continue;
						}
						Main.tile[k, l].active(active: false);
					}
					if (num4 <= 0)
					{
						break;
					}
				}
				if (num4 <= 0)
				{
					break;
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
			vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
			if (vector2D2.X > (double)num3 + 0.5)
			{
				vector2D2.X = (double)num3 + 0.5;
			}
			if (vector2D2.X < (double)num3 - 0.5)
			{
				vector2D2.X = (double)num3 - 0.5;
			}
			if (vector2D2.Y > 2.0)
			{
				vector2D2.Y = 2.0;
			}
			if (vector2D2.Y < 0.0)
			{
				vector2D2.Y = 0.0;
			}
		}
		if (steps > 0 && (double)(int)vector2D.Y < Main.rockLayer + 50.0)
		{
			Cavinator((int)vector2D.X, (int)vector2D.Y, steps - 1);
		}
	}

	public static void CaveOpenater(int i, int j)
	{
		double num = genRand.Next(7, 12);
		double num2 = num;
		int num3 = 1;
		if (genRand.Next(2) == 0)
		{
			num3 = -1;
		}
		if (genRand.Next(10) != 0)
		{
			num3 = ((i < Main.maxTilesX / 2) ? 1 : (-1));
		}
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		int num4 = 100;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.Y = 0.0;
		vector2D2.X = num3;
		while (num4 > 0)
		{
			Tile tile = Main.tile[(int)vector2D.X, (int)vector2D.Y];
			if (tile.wall == 0 || (tile.active() && !CanBeClearedDuringGeneration(tile.type, (int)vector2D.X, (int)vector2D.Y)))
			{
				num4 = 0;
			}
			num4--;
			int num5 = (int)(vector2D.X - num * 0.5);
			int num6 = (int)(vector2D.X + num * 0.5);
			int num7 = (int)(vector2D.Y - num * 0.5);
			int num8 = (int)(vector2D.Y + num * 0.5);
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesX)
			{
				num6 = Main.maxTilesX;
			}
			if (num7 < 0)
			{
				num7 = 0;
			}
			if (num8 > Main.maxTilesY)
			{
				num8 = Main.maxTilesY;
			}
			num2 = num * (double)genRand.Next(80, 120) * 0.01;
			for (int k = num5; k < num6; k++)
			{
				for (int l = num7; l < num8; l++)
				{
					double num9 = Math.Abs((double)k - vector2D.X);
					double num10 = Math.Abs((double)l - vector2D.Y);
					if (Math.Sqrt(num9 * num9 + num10 * num10) < num2 * 0.4 && CanBeClearedDuringGeneration(Main.tile[k, l].type, k, l))
					{
						Main.tile[k, l].active(active: false);
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
			vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
			if (vector2D2.X > (double)num3 + 0.5)
			{
				vector2D2.X = (double)num3 + 0.5;
			}
			if (vector2D2.X < (double)num3 - 0.5)
			{
				vector2D2.X = (double)num3 - 0.5;
			}
			if (vector2D2.Y > 0.0)
			{
				vector2D2.Y = 0.0;
			}
			if (vector2D2.Y < -0.5)
			{
				vector2D2.Y = -0.5;
			}
		}
	}

	public static bool CanBeClearedDuringGeneration(int tileType, int x, int y, bool skipDualDungeonCheck = false)
	{
		if (isGeneratingOrLoadingWorld && !skipDualDungeonCheck && SecretSeed.dualDungeons.Enabled && DungeonUtils.InAnyPotentialDungeonBounds(x, y) && DungeonUtils.IsConsideredDungeonTile(tileType, allDungeons: true))
		{
			return false;
		}
		return TileID.Sets.CanBeClearedDuringGeneration[tileType];
	}

	public static void DiamondTileFrame(int i, int j)
	{
		TileFrame(i - 1, j);
		TileFrame(i, j - 1);
		TileFrame(i, j + 1);
		TileFrame(i + 1, j);
	}

	public static void SquareTileFrame(int i, int j, bool resetFrame = true)
	{
		TileFrame(i - 1, j - 1);
		TileFrame(i - 1, j);
		TileFrame(i - 1, j + 1);
		TileFrame(i, j - 1);
		TileFrame(i, j, resetFrame);
		TileFrame(i, j + 1);
		TileFrame(i + 1, j - 1);
		TileFrame(i + 1, j);
		TileFrame(i + 1, j + 1);
	}

	public static void SquareWallFrame(int i, int j, bool resetFrame = true)
	{
		Framing.WallFrame(i - 1, j - 1);
		Framing.WallFrame(i - 1, j);
		Framing.WallFrame(i - 1, j + 1);
		Framing.WallFrame(i, j - 1);
		Framing.WallFrame(i, j, resetFrame);
		Framing.WallFrame(i, j + 1);
		Framing.WallFrame(i + 1, j - 1);
		Framing.WallFrame(i + 1, j);
		Framing.WallFrame(i + 1, j + 1);
	}

	public static void SectionTileFrameWithCheck(int startX, int startY, int endX, int endY)
	{
		int sectionX = Netplay.GetSectionX(startX);
		int sectionY = Netplay.GetSectionY(startY);
		int sectionX2 = Netplay.GetSectionX(endX);
		int sectionY2 = Netplay.GetSectionY(endY);
		for (int i = sectionX; i <= sectionX2; i++)
		{
			for (int j = sectionY; j <= sectionY2; j++)
			{
				if (Main.sectionManager.SectionLoaded(i, j) && !Main.sectionManager.SectionFramed(i, j))
				{
					SectionTileFrame(i, j, i, j);
					if (!Main.sectionManager.AnyUnfinishedSections)
					{
						return;
					}
				}
			}
		}
	}

	public static void RefreshSections(int startX, int startY, int endX, int endY)
	{
		int sectionX = Netplay.GetSectionX(startX);
		int sectionY = Netplay.GetSectionY(startY);
		int sectionX2 = Netplay.GetSectionX(endX);
		int sectionY2 = Netplay.GetSectionY(endY);
		for (int i = sectionX; i <= sectionX2; i++)
		{
			for (int j = sectionY; j <= sectionY2; j++)
			{
				if (Main.sectionManager.SectionNeedsRefresh(i, j))
				{
					RefreshSection(i, j);
				}
			}
		}
	}

	public static void RefreshSection(int sectionX, int sectionY)
	{
		GetSectionBounds(sectionX, sectionY, sectionX, sectionY, out var tileStartX, out var tileEndX, out var tileStartY, out var tileEndY);
		if (generatingWorld)
		{
			for (int i = tileStartX; i < tileEndX; i++)
			{
				for (int j = tileStartY; j < tileEndY; j++)
				{
					Reframe(i, j);
				}
			}
		}
		else
		{
			int totalEcho = 0;
			int totalFramed = 0;
			for (int k = tileStartY; k < tileEndY; k += 50)
			{
				for (int l = tileStartX; l < tileEndX; l += 200)
				{
					RefreshStrip(l, k, Math.Min(l + 200, tileEndX), Math.Min(k + 50, tileEndY), ref totalEcho, ref totalFramed);
				}
			}
		}
		Main.sectionManager.SetSectionAsRefreshed(sectionX, sectionY);
	}

	public static void RefreshStrip(int xStart, int yStart, int xEnd, int yEnd, ref int totalEcho, ref int totalFramed)
	{
		int num = xStart - 1;
		int num2 = yStart - 1;
		int num3 = xEnd - xStart;
		int num4 = yEnd - yStart;
		if (num4 > 50 || num3 > 200)
		{
			throw new IndexOutOfRangeException();
		}
		int num5 = 0;
		Vertical64BitStrips vertical64BitStrips = bitStrip;
		for (int i = 1; i <= num3; i++)
		{
			Bits64 value = default(Bits64);
			for (int j = 1; j <= num4; j++)
			{
				Tile tile = Main.tile[num + i, num2 + j];
				if (tile != null && (tile.invisibleBlock() || tile.invisibleWall()))
				{
					num5++;
					value[j] = true;
				}
			}
			vertical64BitStrips[i] = value;
		}
		if (num5 == 0)
		{
			return;
		}
		vertical64BitStrips.Expand3x3();
		for (int k = 0; k < num3 + 2; k++)
		{
			Bits64 bits = vertical64BitStrips[k];
			if (bits.IsEmpty)
			{
				continue;
			}
			for (int l = 0; l < num4 + 2; l++)
			{
				if (bits[l])
				{
					totalFramed++;
					Reframe(num + k, num2 + l);
				}
			}
		}
		vertical64BitStrips.Clear();
		totalEcho += num5;
	}

	public static void Reframe(int x, int y, bool resetFrame = false)
	{
		if (generatingWorld)
		{
			TileFrameCosmetic(x, y, Main.tile[x, y], resetFrame);
		}
		else
		{
			TileFrame(x, y, resetFrame, noBreak: true);
		}
		Framing.WallFrame(x, y, resetFrame);
	}

	public static void SectionTileFrame(int sectionStartX, int sectionStartY, int sectionEndXInclusive, int sectionEndYInclusive)
	{
		Main.mapTime = Main.mapTimeMax + 10;
		GetSectionBounds(sectionStartX, sectionStartY, sectionEndXInclusive, sectionEndYInclusive, out var tileStartX, out var tileEndX, out var tileStartY, out var tileEndY);
		MapUpdateQueue.Add(new Rectangle(tileStartX - 2, tileStartY - 2, tileEndX - tileStartX + 4, tileEndY - tileStartY + 4));
		for (int i = tileStartX - 1; i < tileEndX + 1; i++)
		{
			for (int j = tileStartY - 1; j < tileEndY + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = new Tile();
				}
				Reframe(i, j, resetFrame: true);
			}
		}
		for (int k = sectionStartX; k <= sectionEndXInclusive; k++)
		{
			for (int l = sectionStartY; l <= sectionEndYInclusive; l++)
			{
				Main.sectionManager.SetSectionFramed(k, l);
			}
		}
	}

	public static void GetSectionBounds(int sectionStartX, int sectionStartY, int sectionEndXInclusive, int sectionEndYInclusive, out int tileStartX, out int tileEndX, out int tileStartY, out int tileEndY)
	{
		tileStartX = sectionStartX * 200;
		tileEndX = (sectionEndXInclusive + 1) * 200;
		tileStartY = sectionStartY * 150;
		tileEndY = (sectionEndYInclusive + 1) * 150;
		if (tileStartX < 1)
		{
			tileStartX = 1;
		}
		if (tileStartY < 1)
		{
			tileStartY = 1;
		}
		if (tileStartX > Main.maxTilesX - 2)
		{
			tileStartX = Main.maxTilesX - 2;
		}
		if (tileStartY > Main.maxTilesY - 2)
		{
			tileStartY = Main.maxTilesY - 2;
		}
		if (tileEndX > Main.maxTilesX - 2)
		{
			tileEndX = Main.maxTilesX - 2;
		}
		if (tileEndY > Main.maxTilesY - 2)
		{
			tileEndY = Main.maxTilesY - 2;
		}
	}

	public static void RangeFrame(int startX, int startY, int endX, int endY)
	{
		MapUpdateQueue.Add(new Rectangle(startX - 2, startY - 2, startX - endX + 4, startY - endY + 4));
		int num = endX + 1;
		int num2 = endY + 1;
		for (int i = startX - 1; i < num + 1; i++)
		{
			for (int j = startY - 1; j < num2 + 1; j++)
			{
				TileFrame(i, j);
				Framing.WallFrame(i, j);
			}
		}
	}

	public static void WaterCheck()
	{
		Liquid.tilesIgnoreWater(ignoreSolids: true);
		Liquid.numLiquid = 0;
		LiquidBuffer.numLiquidBuffer = 0;
		for (int i = 1; i < Main.maxTilesX - 1; i++)
		{
			for (int num = Main.maxTilesY - 2; num > 0; num--)
			{
				Tile tile = Main.tile[i, num];
				tile.checkingLiquid(checkingLiquid: false);
				if (tile.liquid > 0 && tile.nactive() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type])
				{
					if (tile.type != 379)
					{
						tile.liquid = 0;
					}
				}
				else if (tile.liquid > 0)
				{
					if (tile.active())
					{
						if (tile.lava())
						{
							if (TileObjectData.CheckLavaDeath(tile))
							{
								KillTile(i, num);
							}
						}
						else if (TileObjectData.CheckWaterDeath(tile))
						{
							KillTile(i, num);
						}
					}
					Tile tile2 = Main.tile[i, num + 1];
					if ((!tile2.nactive() || !Main.tileSolid[tile2.type] || Main.tileSolidTop[tile2.type]) && tile2.liquid < byte.MaxValue)
					{
						if (tile2.liquid > 250)
						{
							tile2.liquid = byte.MaxValue;
						}
						else
						{
							Liquid.AddWater(i, num);
						}
					}
					Tile tile3 = Main.tile[i - 1, num];
					Tile tile4 = Main.tile[i + 1, num];
					if ((!tile3.nactive() || !Main.tileSolid[tile3.type] || Main.tileSolidTop[tile3.type]) && tile3.liquid != tile.liquid)
					{
						Liquid.AddWater(i, num);
					}
					else if ((!tile4.nactive() || !Main.tileSolid[tile4.type] || Main.tileSolidTop[tile4.type]) && tile4.liquid != tile.liquid)
					{
						Liquid.AddWater(i, num);
					}
					if (tile.lava())
					{
						if (tile3.liquid > 0 && !tile3.lava())
						{
							Liquid.AddWater(i, num);
						}
						else if (tile4.liquid > 0 && !tile4.lava())
						{
							Liquid.AddWater(i, num);
						}
						else if (Main.tile[i, num - 1].liquid > 0 && !Main.tile[i, num - 1].lava())
						{
							Liquid.AddWater(i, num);
						}
						else if (tile2.liquid > 0 && !tile2.lava())
						{
							Liquid.AddWater(i, num);
						}
					}
				}
			}
		}
		Liquid.tilesIgnoreWater(ignoreSolids: false);
	}

	public static void ClearPendingLiquid()
	{
		if (Liquid.numLiquid != 0 || LiquidBuffer.numLiquidBuffer != 0)
		{
			for (int i = 0; i < Liquid.numLiquid; i++)
			{
				Liquid liquid = Main.liquid[i];
				Main.tile[liquid.x, liquid.y].checkingLiquid(checkingLiquid: false);
			}
			for (int j = 0; j < LiquidBuffer.numLiquidBuffer; j++)
			{
				LiquidBuffer liquidBuffer = Main.liquidBuffer[j];
				Main.tile[liquidBuffer.x, liquidBuffer.y].checkingLiquid(checkingLiquid: false);
			}
			Liquid.numLiquid = 0;
			LiquidBuffer.numLiquidBuffer = 0;
		}
	}

	public static void PlantCheck(int x, int y)
	{
		if (destroyObject)
		{
			return;
		}
		x = Utils.Clamp(x, 1, Main.maxTilesX - 2);
		y = Utils.Clamp(y, 1, Main.maxTilesY - 2);
		for (int i = x - 1; i <= x + 1; i++)
		{
			for (int j = y - 1; j <= y + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					return;
				}
			}
		}
		int num = -1;
		int num2 = Main.tile[x, y].type;
		_ = x - 1;
		_ = 0;
		_ = x + 1;
		_ = Main.maxTilesX;
		_ = y - 1;
		_ = 0;
		if (y + 1 >= Main.maxTilesY)
		{
			num = num2;
		}
		if (x - 1 >= 0 && Main.tile[x - 1, y] != null && Main.tile[x - 1, y].nactive())
		{
			_ = Main.tile[x - 1, y].type;
		}
		if (x + 1 < Main.maxTilesX && Main.tile[x + 1, y] != null && Main.tile[x + 1, y].nactive())
		{
			_ = Main.tile[x + 1, y].type;
		}
		if (y - 1 >= 0 && Main.tile[x, y - 1] != null && Main.tile[x, y - 1].nactive())
		{
			_ = Main.tile[x, y - 1].type;
		}
		if (y + 1 < Main.maxTilesY && Main.tile[x, y + 1] != null && Main.tile[x, y + 1].nactive() && !Main.tile[x, y + 1].halfBrick() && Main.tile[x, y + 1].slope() == 0)
		{
			num = Main.tile[x, y + 1].type;
		}
		if (x - 1 >= 0 && y - 1 >= 0 && Main.tile[x - 1, y - 1] != null && Main.tile[x - 1, y - 1].nactive())
		{
			_ = Main.tile[x - 1, y - 1].type;
		}
		if (x + 1 < Main.maxTilesX && y - 1 >= 0 && Main.tile[x + 1, y - 1] != null && Main.tile[x + 1, y - 1].nactive())
		{
			_ = Main.tile[x + 1, y - 1].type;
		}
		if (x - 1 >= 0 && y + 1 < Main.maxTilesY && Main.tile[x - 1, y + 1] != null && Main.tile[x - 1, y + 1].nactive())
		{
			_ = Main.tile[x - 1, y + 1].type;
		}
		if (x + 1 < Main.maxTilesX && y + 1 < Main.maxTilesY && Main.tile[x + 1, y + 1] != null && Main.tile[x + 1, y + 1].nactive())
		{
			_ = Main.tile[x + 1, y + 1].type;
		}
		if (num2 == 703)
		{
			if (!SolidTileAllowBottomSlope(x, y + 1))
			{
				destroyObject = true;
				KillTile(x, y);
				destroyObject = false;
			}
		}
		else
		{
			if ((num2 != 3 || num == 2 || num == 477 || num == 78 || num == 380 || num == 579) && (num2 != 73 || num == 2 || num == 477 || num == 78 || num == 380 || num == 579) && (num2 != 24 || num == 23 || num == 661) && (num2 != 61 || num == 60 || num == 226) && (num2 != 74 || num == 60 || num == 226) && (num2 != 71 || num == 70) && (num2 != 110 || num == 109 || num == 492) && (num2 != 113 || num == 109 || num == 492) && (num2 != 201 || num == 199 || num == 662) && (num2 != 637 || num == 633))
			{
				return;
			}
			bool flag = false;
			if (num2 == 3 || num2 == 110 || num2 == 24)
			{
				flag = Main.tile[x, y].frameX == 144;
			}
			if (num2 == 201)
			{
				flag = Main.tile[x, y].frameX == 270;
			}
			if ((num2 == 3 || num2 == 73) && num != 2 && num != 477 && Main.tile[x, y].frameX >= 162)
			{
				Main.tile[x, y].frameX = 126;
			}
			if (num2 == 74 && num != 60 && num != 226 && Main.tile[x, y].frameX >= 162)
			{
				Main.tile[x, y].frameX = 126;
			}
			switch (num)
			{
			case 23:
			case 661:
				num2 = 24;
				if (Main.tile[x, y].frameX >= 162)
				{
					Main.tile[x, y].frameX = 126;
				}
				break;
			case 2:
			case 477:
				num2 = ((num2 != 113) ? 3 : 73);
				break;
			case 109:
			case 492:
				num2 = ((num2 != 73) ? 110 : 113);
				break;
			case 199:
			case 662:
				num2 = 201;
				break;
			case 60:
			case 226:
				num2 = 61;
				while (Main.tile[x, y].frameX > 126)
				{
					Main.tile[x, y].frameX -= 126;
				}
				break;
			case 70:
				num2 = 71;
				while (Main.tile[x, y].frameX > 72)
				{
					Main.tile[x, y].frameX -= 72;
				}
				break;
			}
			if (num2 != Main.tile[x, y].type)
			{
				Main.tile[x, y].type = (ushort)num2;
				if (flag)
				{
					Main.tile[x, y].frameX = 144;
					if (num2 == 201)
					{
						Main.tile[x, y].frameX = 270;
					}
				}
			}
			else
			{
				destroyObject = true;
				KillTile(x, y);
				destroyObject = false;
			}
		}
	}

	public static bool CanPoundTile(int x, int y)
	{
		if (Main.tile[x, y] == null)
		{
			Main.tile[x, y] = new Tile();
		}
		if (Main.tile[x, y - 1] == null)
		{
			Main.tile[x, y - 1] = new Tile();
		}
		if (Main.tile[x, y + 1] == null)
		{
			Main.tile[x, y + 1] = new Tile();
		}
		switch (Main.tile[x, y].type)
		{
		case 10:
		case 48:
		case 137:
		case 232:
		case 380:
		case 387:
		case 388:
		case 476:
		case 484:
			return false;
		default:
			if (Main.tile[x, y].type >= 0 && TileID.Sets.Boulders[Main.tile[x, y].type])
			{
				return false;
			}
			if (isGeneratingOrLoadingWorld)
			{
				if (Main.tile[x, y].type == 190)
				{
					return false;
				}
				if (Main.tile[x, y].type == 30)
				{
					return false;
				}
			}
			if (Main.tile[x, y - 1].active())
			{
				switch (Main.tile[x, y - 1].type)
				{
				case 21:
				case 26:
				case 77:
				case 88:
				case 235:
				case 237:
				case 441:
				case 467:
				case 468:
				case 470:
				case 475:
				case 488:
				case 597:
					return false;
				}
			}
			return CanKillTile(x, y);
		}
	}

	public static bool SlopeTile(int i, int j, int slope = 0, bool noEffects = false, bool quiet = true)
	{
		if (!CanPoundTile(i, j))
		{
			return false;
		}
		Main.tile[i, j].halfBrick(halfBrick: false);
		Main.tile[i, j].slope((byte)slope);
		if (!isGeneratingOrLoadingWorld)
		{
			if (!noEffects)
			{
				KillTile(i, j, fail: true, effectOnly: true);
			}
			SoundEngine.PlaySound(0, i * 16, j * 16);
			SquareTileFrame(i, j);
			slope = Main.tile[i, j].slope();
			if (slope == 0)
			{
				Rectangle rectangle = new Rectangle(i * 16, j * 16, 16, 16);
				for (int k = 0; k < 255; k++)
				{
					if (Main.player[k].active && !Main.player[k].dead && rectangle.Intersects(new Rectangle((int)Main.player[k].position.X, (int)Main.player[k].position.Y, Main.player[k].width, Main.player[k].height)))
					{
						Main.player[k].gfxOffY += Main.player[k].position.Y + (float)Main.player[k].height - (float)rectangle.Y;
						Main.player[k].position.Y = rectangle.Y - Main.player[k].height;
					}
				}
			}
		}
		if (!quiet)
		{
			NetMessage.SendData(17, -1, -1, null, 14, i, j, slope);
		}
		return true;
	}

	public static bool PoundTile(int i, int j)
	{
		if (!CanPoundTile(i, j))
		{
			return false;
		}
		if (!Main.tile[i, j].halfBrick())
		{
			Main.tile[i, j].halfBrick(halfBrick: true);
		}
		else
		{
			Main.tile[i, j].halfBrick(halfBrick: false);
		}
		if (!isGeneratingOrLoadingWorld)
		{
			KillTile(i, j, fail: true, effectOnly: true);
			SoundEngine.PlaySound(0, i * 16, j * 16);
			SquareTileFrame(i, j);
			if (!Main.tile[i, j].halfBrick())
			{
				Rectangle rectangle = new Rectangle(i * 16, j * 16, 16, 16);
				for (int k = 0; k < 255; k++)
				{
					if (Main.player[k].active && !Main.player[k].dead && rectangle.Intersects(new Rectangle((int)Main.player[k].position.X, (int)Main.player[k].position.Y, Main.player[k].width, Main.player[k].height)))
					{
						Main.player[k].gfxOffY += Main.player[k].position.Y + (float)Main.player[k].height - (float)rectangle.Y;
						Main.player[k].position.Y = rectangle.Y - Main.player[k].height;
					}
				}
			}
		}
		return true;
	}

	public static void PoundPlatform(int x, int y)
	{
		if (Main.tile[x, y].halfBrick())
		{
			PoundTile(x, y);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 7, x, y, 1f);
			}
			return;
		}
		int num = 1;
		int slope = 2;
		if (TileID.Sets.Platforms[Main.tile[x + 1, y - 1].type] || TileID.Sets.Platforms[Main.tile[x - 1, y + 1].type] || (SolidTile(x + 1, y) && !SolidTile(x - 1, y)))
		{
			num = 2;
			slope = 1;
		}
		if (Main.tile[x, y].slope() == 0)
		{
			SlopeTile(x, y, num);
			int num2 = Main.tile[x, y].slope();
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 14, x, y, num2);
			}
			return;
		}
		if (Main.tile[x, y].slope() == num)
		{
			SlopeTile(x, y, slope);
			int num3 = Main.tile[x, y].slope();
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 14, x, y, num3);
			}
			return;
		}
		SlopeTile(x, y);
		int num4 = Main.tile[x, y].slope();
		if (Main.netMode == 1)
		{
			NetMessage.SendData(17, -1, -1, null, 14, x, y, num4);
		}
		PoundTile(x, y);
		if (Main.netMode == 1)
		{
			NetMessage.SendData(17, -1, -1, null, 7, x, y, 1f);
		}
	}

	public static void TileMergeAttemptFrametest(int i, int j, int myType, int lookfor, ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight)
	{
		if (up == lookfor)
		{
			TileFrame(i, j - 1);
			if (mergeDown)
			{
				up = myType;
			}
		}
		if (down == lookfor)
		{
			TileFrame(i, j + 1);
			if (mergeUp)
			{
				down = myType;
			}
		}
		if (left == lookfor)
		{
			TileFrame(i - 1, j);
			if (mergeRight)
			{
				left = myType;
			}
		}
		if (right == lookfor)
		{
			TileFrame(i + 1, j);
			if (mergeLeft)
			{
				right = myType;
			}
		}
		if (upLeft == lookfor)
		{
			upLeft = myType;
		}
		if (upRight == lookfor)
		{
			upRight = myType;
		}
		if (downLeft == lookfor)
		{
			downLeft = myType;
		}
		if (downRight == lookfor)
		{
			downRight = myType;
		}
	}

	public static void TileMergeAttemptFrametest(int i, int j, int myType, bool[] lookfor, ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight)
	{
		if (up > -1 && lookfor[up])
		{
			TileFrame(i, j - 1);
			if (mergeDown)
			{
				up = myType;
			}
		}
		if (down > -1 && lookfor[down])
		{
			TileFrame(i, j + 1);
			if (mergeUp)
			{
				down = myType;
			}
		}
		if (left > -1 && lookfor[left])
		{
			TileFrame(i - 1, j);
			if (mergeRight)
			{
				left = myType;
			}
		}
		if (right > -1 && lookfor[right])
		{
			TileFrame(i + 1, j);
			if (mergeLeft)
			{
				right = myType;
			}
		}
		if (upLeft > -1 && lookfor[upLeft])
		{
			upLeft = myType;
		}
		if (upRight > -1 && lookfor[upRight])
		{
			upRight = myType;
		}
		if (downLeft > -1 && lookfor[downLeft])
		{
			downLeft = myType;
		}
		if (downRight > -1 && lookfor[downRight])
		{
			downRight = myType;
		}
	}

	public static void TileMergeAttempt(int myType, int lookfor, ref int up, ref int down, ref int left, ref int right)
	{
		if (lookfor == up)
		{
			up = myType;
		}
		if (lookfor == down)
		{
			down = myType;
		}
		if (lookfor == left)
		{
			left = myType;
		}
		if (lookfor == right)
		{
			right = myType;
		}
	}

	public static void TileMergeAttempt(int myType, bool[] lookfor, ref int up, ref int down, ref int left, ref int right)
	{
		if (up > -1 && lookfor[up])
		{
			up = myType;
		}
		if (down > -1 && lookfor[down])
		{
			down = myType;
		}
		if (left > -1 && lookfor[left])
		{
			left = myType;
		}
		if (right > -1 && lookfor[right])
		{
			right = myType;
		}
	}

	public static void TileMergeAttempt(int myType, int lookfor, ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight)
	{
		if (lookfor == up)
		{
			up = myType;
		}
		if (lookfor == down)
		{
			down = myType;
		}
		if (lookfor == left)
		{
			left = myType;
		}
		if (lookfor == right)
		{
			right = myType;
		}
		if (lookfor == upLeft)
		{
			upLeft = myType;
		}
		if (lookfor == upRight)
		{
			upRight = myType;
		}
		if (lookfor == downLeft)
		{
			downLeft = myType;
		}
		if (lookfor == downRight)
		{
			downRight = myType;
		}
	}

	public static void TileMergeAttempt(int myType, bool[] lookfor, ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight)
	{
		if (up > -1 && lookfor[up])
		{
			up = myType;
		}
		if (down > -1 && lookfor[down])
		{
			down = myType;
		}
		if (left > -1 && lookfor[left])
		{
			left = myType;
		}
		if (right > -1 && lookfor[right])
		{
			right = myType;
		}
		if (upLeft > -1 && lookfor[upLeft])
		{
			upLeft = myType;
		}
		if (upRight > -1 && lookfor[upRight])
		{
			upRight = myType;
		}
		if (downLeft > -1 && lookfor[downLeft])
		{
			downLeft = myType;
		}
		if (downRight > -1 && lookfor[downRight])
		{
			downRight = myType;
		}
	}

	public static void TileMergeAttempt(int myType, bool[] lookfor, int exclude, ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight)
	{
		if (up > -1 && up != exclude && lookfor[up])
		{
			up = myType;
		}
		if (down > -1 && down != exclude && lookfor[down])
		{
			down = myType;
		}
		if (left > -1 && left != exclude && lookfor[left])
		{
			left = myType;
		}
		if (right > -1 && right != exclude && lookfor[right])
		{
			right = myType;
		}
		if (upLeft > -1 && upLeft != exclude && lookfor[upLeft])
		{
			upLeft = myType;
		}
		if (upRight > -1 && upRight != exclude && lookfor[upRight])
		{
			upRight = myType;
		}
		if (downLeft > -1 && downLeft != exclude && lookfor[downLeft])
		{
			downLeft = myType;
		}
		if (downRight > -1 && downRight != exclude && lookfor[downRight])
		{
			downRight = myType;
		}
	}

	public static void TileMergeAttempt(int myType, bool[] lookfor, bool[] exclude, ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight)
	{
		if (up > -1 && !exclude[up] && lookfor[up])
		{
			up = myType;
		}
		if (down > -1 && !exclude[down] && lookfor[down])
		{
			down = myType;
		}
		if (left > -1 && !exclude[left] && lookfor[left])
		{
			left = myType;
		}
		if (right > -1 && !exclude[right] && lookfor[right])
		{
			right = myType;
		}
		if (upLeft > -1 && !exclude[upLeft] && lookfor[upLeft])
		{
			upLeft = myType;
		}
		if (upRight > -1 && !exclude[upRight] && lookfor[upRight])
		{
			upRight = myType;
		}
		if (downLeft > -1 && !exclude[downLeft] && lookfor[downLeft])
		{
			downLeft = myType;
		}
		if (downRight > -1 && !exclude[downRight] && lookfor[downRight])
		{
			downRight = myType;
		}
	}

	public static void TileMergeAttemptWeird(int myType, int changeTo, bool[] exclude, ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight)
	{
		if (up > -1 && !exclude[up] && up != myType)
		{
			up = changeTo;
		}
		if (down > -1 && !exclude[down] && down != myType)
		{
			down = changeTo;
		}
		if (left > -1 && !exclude[left] && left != myType)
		{
			left = changeTo;
		}
		if (right > -1 && !exclude[right] && right != myType)
		{
			right = changeTo;
		}
		if (upLeft > -1 && !exclude[upLeft] && upLeft != myType)
		{
			upLeft = changeTo;
		}
		if (upRight > -1 && !exclude[upRight] && upRight != myType)
		{
			upRight = changeTo;
		}
		if (downLeft > -1 && !exclude[downLeft] && downLeft != myType)
		{
			downLeft = changeTo;
		}
		if (downRight > -1 && !exclude[downRight] && downRight != myType)
		{
			downRight = changeTo;
		}
	}

	public static int GetTileMossColor(int tileType)
	{
		switch (tileType)
		{
		default:
			return -1;
		case 179:
		case 512:
			return 0;
		case 180:
		case 513:
			return 1;
		case 181:
		case 514:
			return 2;
		case 182:
		case 515:
			return 3;
		case 183:
		case 516:
			return 4;
		case 381:
		case 517:
			return 5;
		case 534:
		case 535:
			return 6;
		case 536:
		case 537:
			return 7;
		case 539:
		case 540:
			return 8;
		case 625:
		case 626:
			return 9;
		case 627:
		case 628:
			return 10;
		}
	}

	public static void CheckFoodPlatter(int x, int y, int type)
	{
		if (Main.tile[x, y] == null || destroyObject || SolidTileAllowBottomSlope(x, y + 1))
		{
			return;
		}
		if (type == 520 && TileEntity.TryGetAt<TEFoodPlatter>(x, y, out var result) && result.item.stack > 0)
		{
			result.DropItem();
			if (Main.netMode != 2)
			{
				Main.LocalPlayer.InterruptItemUsageIfOverTile(520);
			}
		}
		destroyObject = true;
		if (Main.tile[x, y].type == type)
		{
			KillTile(x, y);
		}
		if (type == 520)
		{
			TileEntityType<TEFoodPlatter>.Kill(x, y);
		}
		destroyObject = false;
	}

	public static void HandleRopeEndFraming(int i, int j)
	{
		HandleRopeEndFraming_Inner(i, j);
		_preventInfiniteRopeFraming = false;
	}

	private static void HandleRopeEndFraming_Inner(int i, int j)
	{
		if (_preventInfiniteRopeFraming)
		{
			return;
		}
		_preventInfiniteRopeFraming = true;
		if (!InWorld(i, j, 1))
		{
			return;
		}
		Tile tile = Main.tile[i, j - 1];
		Tile tile2 = Main.tile[i, j + 1];
		if (tile == null || tile2 == null)
		{
			return;
		}
		bool num = tile.active() && tile.type >= 0 && (tile2.type == 314 || TileID.Sets.Platforms[tile.type] || tile.type == 380 || Main.tileRope[tile.type]);
		bool flag = false;
		if (!num)
		{
			flag = tile2.active() && tile2.type >= 0 && (tile2.type == 314 || TileID.Sets.Platforms[tile2.type] || tile2.type == 380 || Main.tileRope[tile2.type]);
		}
		if (num || flag)
		{
			int topRopeY = -1;
			int bottomRopeY = -1;
			GetRopeEnds(i, j, out topRopeY, out bottomRopeY, treatEmptyAsTheRopeEnd: true);
			if (topRopeY != -1 && topRopeY != j)
			{
				TileFrame(i, topRopeY);
			}
			if (bottomRopeY != -1 && bottomRopeY != j)
			{
				TileFrame(i, bottomRopeY);
			}
		}
	}

	public static void TileFrame(int i, int j, bool resetFrame = false, bool noBreak = false)
	{
		if (i <= 5 || j <= 5 || i >= Main.maxTilesX - 5 || j >= Main.maxTilesY - 5 || Main.tile[i, j] == null)
		{
			return;
		}
		MapUpdateQueue.Add(i, j);
		try
		{
			Tile tile = Main.tile[i, j];
			if (!tile.active())
			{
				tile.halfBrick(halfBrick: false);
				tile.ClearBlockPaintAndCoating();
				tile.slope(0);
			}
			if (tile.liquid > 0 && Main.netMode != 1 && !generatingWorld)
			{
				Liquid.AddWater(i, j);
			}
			if (!tile.active())
			{
				return;
			}
			int type = tile.type;
			if (Main.tileFrameImportant[type])
			{
				if (!noBreak || TileID.Sets.Torches[type] || TileID.Sets.FrameImportantEchoCulling[type])
				{
					TileFrameImportant(i, j, type, tile, resetFrame);
				}
				return;
			}
			if (!Main.tileSolid[type])
			{
				switch (type)
				{
				case 49:
					CheckOnTable1x1(i, j, (byte)type);
					return;
				case 80:
					if (CheckCactus(i, j))
					{
						return;
					}
					break;
				}
				if (TileID.Sets.IsVine[type] && !CheckVines(i, j, type, tile))
				{
					return;
				}
			}
			if (!generatingWorld && (!TileID.Sets.Falling[type] || !SpawnFallingBlockProjectile(i, j, type, tile)))
			{
				TileFrameCosmetic(i, j, tile, resetFrame);
			}
		}
		catch
		{
		}
	}

	public static void TileFrameCosmetic(int i, int j, Tile tileCache, bool resetFrame = false)
	{
		if (tileCache == null || !tileCache.active() || i <= 0 || j <= 0 || i >= Main.maxTilesX - 1 || j >= Main.maxTilesY - 1)
		{
			return;
		}
		int num = tileCache.type;
		if (Main.tileFrameImportant[num])
		{
			return;
		}
		switch (num)
		{
		case 80:
			CactusFrame(i, j);
			break;
		default:
			switch (num)
			{
			case 385:
			case 446:
			case 447:
			case 448:
				break;
			default:
			{
				if (Main.tileStone[num])
				{
					num = 1;
				}
				int frameX = tileCache.frameX;
				int frameY = tileCache.frameY;
				Rectangle rectangle = new Rectangle(-1, -1, 0, 0);
				Tile tile = Main.tile[i, j - 1];
				Tile tile2 = Main.tile[i, j + 1];
				Tile tile3 = Main.tile[i - 1, j];
				Tile tile4 = Main.tile[i + 1, j];
				Tile tile5 = Main.tile[i - 1, j + 1];
				Tile tile6 = Main.tile[i + 1, j + 1];
				Tile tile7 = Main.tile[i - 1, j - 1];
				Tile tile8 = Main.tile[i + 1, j - 1];
				TileMergeCullCache tileMergeCulling = GetTileMergeCulling(tileCache, tile, tile2, tile3, tile4, tile5, tile6, tile7, tile8);
				int upLeft = -1;
				int up = -1;
				int upRight = -1;
				int left = -1;
				int right = -1;
				int downLeft = -1;
				int down = -1;
				int downRight = -1;
				if (tile3 != null && tile3.active())
				{
					left = (Main.tileStone[tile3.type] ? 1 : tile3.type);
					if (tile3.slope() == 1 || tile3.slope() == 3)
					{
						left = -1;
					}
				}
				if (tile4 != null && tile4.active())
				{
					right = (Main.tileStone[tile4.type] ? 1 : tile4.type);
					if (tile4.slope() == 2 || tile4.slope() == 4)
					{
						right = -1;
					}
				}
				if (tile != null && tile.active())
				{
					up = (Main.tileStone[tile.type] ? 1 : tile.type);
					if (tile.slope() == 3 || tile.slope() == 4)
					{
						up = -1;
					}
				}
				if (tile2 != null && tile2.active())
				{
					down = (Main.tileStone[tile2.type] ? 1 : tile2.type);
					if (tile2.slope() == 1 || tile2.slope() == 2)
					{
						down = -1;
					}
				}
				if (tile7 != null && tile7.active())
				{
					upLeft = (Main.tileStone[tile7.type] ? 1 : tile7.type);
				}
				if (tile8 != null && tile8.active())
				{
					upRight = (Main.tileStone[tile8.type] ? 1 : tile8.type);
				}
				if (tile5 != null && tile5.active())
				{
					downLeft = (Main.tileStone[tile5.type] ? 1 : tile5.type);
				}
				if (tile6 != null && tile6.active())
				{
					downRight = (Main.tileStone[tile6.type] ? 1 : tile6.type);
				}
				if (tileCache.slope() == 2)
				{
					up = -1;
					left = -1;
				}
				if (tileCache.slope() == 1)
				{
					up = -1;
					right = -1;
				}
				if (tileCache.slope() == 4)
				{
					down = -1;
					left = -1;
				}
				if (tileCache.slope() == 3)
				{
					down = -1;
					right = -1;
				}
				if (num == 668)
				{
					num = 0;
				}
				if (num == 697)
				{
					num = 51;
				}
				TileMergeAttempt(0, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
				switch (num)
				{
				case 147:
					TileMergeAttempt(num, Main.tileBrick, TileID.Sets.DontMergeWithSnow, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					break;
				case 161:
				case 163:
				case 164:
				case 200:
					TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Snow, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					break;
				case 162:
					TileMergeAttempt(num, Main.tileBrick, TileID.Sets.IcesSnow, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					break;
				case 738:
					TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Snow, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					break;
				case 747:
					TileMergeAttempt(num, Main.tileBrick, 53, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					break;
				default:
					if (Main.tileBrick[num])
					{
						switch (num)
						{
						case 60:
						case 70:
						case 661:
						case 662:
							TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
							break;
						case 633:
							TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Ash, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
							break;
						default:
							TileMergeAttempt(num, Main.tileBrick, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
							break;
						}
					}
					else if (Main.tilePile[num])
					{
						TileMergeAttempt(num, Main.tilePile, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					}
					break;
				}
				int num2 = tile2?.frameY ?? (-1);
				int num3 = tile?.frameY ?? (-1);
				bool flag = false;
				switch (num)
				{
				default:
					flag = false;
					break;
				case 1:
				case 25:
				case 117:
				case 147:
				case 161:
				case 163:
				case 164:
				case 200:
				case 203:
				case 225:
					flag = true;
					break;
				}
				if (Main.tileMoss[num])
				{
					flag = true;
				}
				bool flag2 = num2 == 0 || num2 == 72;
				bool flag3 = num3 == 54 || num3 == 90;
				if (down == 165 && flag && flag2)
				{
					down = num;
				}
				if (up == 165 && flag && flag3)
				{
					up = num;
				}
				int num4 = tile2?.frameY ?? (-1);
				int num5 = tile?.frameY ?? (-1);
				bool flag4 = false;
				switch (num)
				{
				default:
					flag4 = false;
					break;
				case 1:
				case 25:
				case 117:
				case 147:
				case 161:
				case 163:
				case 164:
				case 200:
				case 203:
				case 225:
					flag4 = true;
					break;
				}
				if (Main.tileMoss[num])
				{
					flag4 = true;
				}
				bool flag5 = num4 == 0;
				bool flag6 = ((up == 693) ? (num5 >= 18) : (num5 >= 36));
				if ((down == 693 || down == 694) && flag4 && flag5)
				{
					down = num;
				}
				if ((up == 693 || up == 694) && flag4 && flag6)
				{
					up = num;
				}
				if ((tileCache.slope() == 1 || tileCache.slope() == 2) && down > -1 && !TileID.Sets.Platforms[down])
				{
					down = num;
				}
				if (up > -1 && tile != null && (tile.slope() == 1 || tile.slope() == 2) && !TileID.Sets.Platforms[up])
				{
					up = num;
				}
				if ((tileCache.slope() == 3 || tileCache.slope() == 4) && up > -1 && !TileID.Sets.Platforms[up])
				{
					up = num;
				}
				if (down > -1 && tile2 != null && (tile2.slope() == 3 || tile2.slope() == 4) && !TileID.Sets.Platforms[down])
				{
					down = num;
				}
				if (num == 124)
				{
					if (up > -1 && Main.tileSolid[up] && !TileID.Sets.Platforms[up])
					{
						up = num;
					}
					if (down > -1 && Main.tileSolid[down] && !TileID.Sets.Platforms[down])
					{
						down = num;
					}
				}
				if (up > -1 && tile != null && tile.halfBrick() && !TileID.Sets.Platforms[up])
				{
					up = num;
				}
				if (left > -1 && tile3 != null && tile3.halfBrick())
				{
					if (tileCache.halfBrick())
					{
						left = num;
					}
					else if (tile3.type != num)
					{
						left = -1;
					}
				}
				if (right > -1 && tile4 != null && tile4.halfBrick())
				{
					if (tileCache.halfBrick())
					{
						right = num;
					}
					else if (tile4.type != num)
					{
						right = -1;
					}
				}
				if (tileCache.halfBrick())
				{
					if (left != num)
					{
						left = -1;
					}
					if (right != num)
					{
						right = -1;
					}
					up = -1;
				}
				if (tile2 != null && tile2.halfBrick())
				{
					down = -1;
				}
				mergeUp = false;
				mergeDown = false;
				mergeLeft = false;
				mergeRight = false;
				int num6 = 0;
				if (resetFrame)
				{
					num6 = genRand.Next(0, 3);
					tileCache.frameNumber((byte)num6);
				}
				else
				{
					num6 = tileCache.frameNumber();
				}
				if (Main.tileLargeFrames[num] == 1)
				{
					int num7 = j % 4;
					int num8 = i % 3;
					num6 = (new int[4, 3]
					{
						{ 2, 4, 2 },
						{ 1, 3, 1 },
						{ 2, 2, 4 },
						{ 1, 1, 3 }
					})[num7, num8] - 1;
				}
				if (Main.tileLargeFrames[num] == 2)
				{
					int num9 = i % 2;
					int num10 = j % 2;
					num6 = num9 + num10 * 2;
				}
				if (!Main.tileRope[num] && TileID.Sets.BlockMergesWithMergeAllBlock[num])
				{
					TileMergeAttempt(num, Main.tileBlendAll, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
				}
				if (Main.tileBlendAll[num])
				{
					TileMergeAttempt(num, TileID.Sets.BlockMergesWithMergeAllBlock, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
				}
				if (TileID.Sets.ForcedDirtMerging[num])
				{
					TileMergeAttempt(num, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
				}
				if (TileID.Sets.Dirt[num])
				{
					if (up > -1 && Main.tileMergeDirt[up])
					{
						TileFrame(i, j - 1);
						if (mergeDown)
						{
							up = num;
						}
					}
					else if (up == 147)
					{
						TileFrame(i, j - 1);
						if (mergeDown)
						{
							up = num;
						}
					}
					if (down > -1 && Main.tileMergeDirt[down])
					{
						TileFrame(i, j + 1);
						if (mergeUp)
						{
							down = num;
						}
					}
					else if (down == 147)
					{
						TileFrame(i, j + 1);
						if (mergeUp)
						{
							down = num;
						}
					}
					if (left > -1 && Main.tileMergeDirt[left])
					{
						TileFrame(i - 1, j);
						if (mergeRight)
						{
							left = num;
						}
					}
					else if (left == 147)
					{
						TileFrame(i - 1, j);
						if (mergeRight)
						{
							left = num;
						}
					}
					if (right > -1 && Main.tileMergeDirt[right])
					{
						TileFrame(i + 1, j);
						if (mergeLeft)
						{
							right = num;
						}
					}
					else if (right == 147)
					{
						TileFrame(i + 1, j);
						if (mergeLeft)
						{
							right = num;
						}
					}
					bool[] mergesWithDirtInASpecialWay = TileID.Sets.Conversion.MergesWithDirtInASpecialWay;
					if (up > -1 && mergesWithDirtInASpecialWay[up])
					{
						up = num;
					}
					if (down > -1 && mergesWithDirtInASpecialWay[down])
					{
						down = num;
					}
					if (left > -1 && mergesWithDirtInASpecialWay[left])
					{
						left = num;
					}
					if (right > -1 && mergesWithDirtInASpecialWay[right])
					{
						right = num;
					}
					if (upLeft > -1 && Main.tileMergeDirt[upLeft])
					{
						upLeft = num;
					}
					else if (upLeft > -1 && mergesWithDirtInASpecialWay[upLeft])
					{
						upLeft = num;
					}
					if (upRight > -1 && Main.tileMergeDirt[upRight])
					{
						upRight = num;
					}
					else if (upRight > -1 && mergesWithDirtInASpecialWay[upRight])
					{
						upRight = num;
					}
					if (downLeft > -1 && Main.tileMergeDirt[downLeft])
					{
						downLeft = num;
					}
					else if (downLeft > -1 && mergesWithDirtInASpecialWay[downLeft])
					{
						downLeft = num;
					}
					if (downRight > -1 && Main.tileMergeDirt[downRight])
					{
						downRight = num;
					}
					else if (downRight > -1 && mergesWithDirtInASpecialWay[downRight])
					{
						downRight = num;
					}
					TileMergeAttempt(0, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					TileMergeAttempt(-2, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					TileMergeAttempt(0, 191, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					if (up > -1 && TileID.Sets.ForcedDirtMerging[up])
					{
						up = num;
					}
					if (down > -1 && TileID.Sets.ForcedDirtMerging[down])
					{
						down = num;
					}
					if (left > -1 && TileID.Sets.ForcedDirtMerging[left])
					{
						left = num;
					}
					if (right > -1 && TileID.Sets.ForcedDirtMerging[right])
					{
						right = num;
					}
					if (upLeft > -1 && TileID.Sets.ForcedDirtMerging[upLeft])
					{
						upLeft = num;
					}
					if (upRight > -1 && TileID.Sets.ForcedDirtMerging[upRight])
					{
						upRight = num;
					}
					if (downLeft > -1 && TileID.Sets.ForcedDirtMerging[downLeft])
					{
						downLeft = num;
					}
					if (downRight > -1 && TileID.Sets.ForcedDirtMerging[downRight])
					{
						downRight = num;
					}
				}
				else if (Main.tileRope[num])
				{
					if (num != 504 && up != num && IsRope(i, j - 1))
					{
						up = num;
					}
					if (down != num && (IsRope(i, j + 1) || down == 698))
					{
						down = num;
					}
					if (num != 504 && up > -1 && Main.tileSolid[up] && !Main.tileSolidTop[up])
					{
						up = num;
					}
					if (down > -1 && Main.tileSolid[down])
					{
						down = num;
					}
					if (num != 504 && up != num)
					{
						if (left > -1 && Main.tileSolid[left])
						{
							left = num;
						}
						if (right > -1 && Main.tileSolid[right])
						{
							right = num;
						}
					}
					if (up == -1)
					{
						TileFrame(i, j - 1);
					}
					if (down == -1)
					{
						TileFrame(i, j + 1);
					}
				}
				else
				{
					switch (num)
					{
					case 53:
						TileMergeAttemptFrametest(i, j, num, 397, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttemptFrametest(i, j, num, 396, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 234:
						TileMergeAttemptFrametest(i, j, num, 399, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttemptFrametest(i, j, num, 401, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 112:
						TileMergeAttemptFrametest(i, j, num, 398, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttemptFrametest(i, j, num, 400, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 116:
						TileMergeAttemptFrametest(i, j, num, 402, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttemptFrametest(i, j, num, 403, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					}
				}
				if (Main.tileMergeDirt[num])
				{
					TileMergeAttempt(-2, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					if (num == 1)
					{
						if ((double)j > Main.rockLayer)
						{
							TileMergeAttemptFrametest(i, j, num, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						}
						TileMergeAttemptFrametest(i, j, num, TileID.Sets.Ash, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					}
				}
				else
				{
					switch (num)
					{
					case 58:
					case 75:
					case 76:
						TileMergeAttempt(-2, TileID.Sets.Ash, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 57:
						TileMergeAttempt(-2, 1, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttempt(num, 633, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttemptFrametest(i, j, num, TileID.Sets.HellSpecial, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 59:
						if ((double)j > Main.rockLayer)
						{
							TileMergeAttempt(-2, 1, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						}
						TileMergeAttempt(num, TileID.Sets.GrassSpecial, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttemptFrametest(i, j, num, TileID.Sets.JungleSpecial, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						if ((double)j < Main.rockLayer)
						{
							TileMergeAttemptFrametest(i, j, num, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						}
						else
						{
							TileMergeAttempt(num, TileID.Sets.Dirt, ref up, ref down, ref left, ref right);
						}
						break;
					case 211:
						TileMergeAttempt(59, 60, ref up, ref down, ref left, ref right);
						TileMergeAttempt(-2, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 225:
					case 226:
						TileMergeAttempt(-2, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 60:
						TileMergeAttempt(59, 211, ref up, ref down, ref left, ref right);
						break;
					case 189:
						TileMergeAttemptFrametest(i, j, num, TileID.Sets.MergesWithClouds, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 196:
						TileMergeAttempt(-2, 189, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttempt(num, 460, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 460:
						TileMergeAttempt(-2, 189, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttempt(num, 196, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 717:
						TileMergeAttempt(-2, 189, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttempt(num, 717, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 718:
						TileMergeAttempt(-2, 189, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttempt(num, 718, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 719:
						TileMergeAttempt(-2, 189, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttempt(num, 719, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 147:
						TileMergeAttemptFrametest(i, j, num, TileID.Sets.IcesSlush, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 161:
					case 163:
					case 164:
					case 200:
					case 224:
						TileMergeAttempt(-2, 147, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 162:
						TileMergeAttempt(-2, TileID.Sets.IcesSnow, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 32:
						if (down == 23)
						{
							down = num;
						}
						break;
					case 352:
						if (down == 199)
						{
							down = num;
						}
						break;
					case 69:
						if (down == 60)
						{
							down = num;
						}
						break;
					case 655:
						if (down == 60)
						{
							down = num;
						}
						break;
					case 51:
						TileMergeAttempt(num, TileID.Sets.AllTiles, Main.tileNoAttach, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 192:
						TileMergeAttemptFrametest(i, j, num, 191, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 191:
						TileMergeAttempt(-2, 192, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttempt(num, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 384:
						TileMergeAttemptFrametest(i, j, num, 383, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 383:
						TileMergeAttempt(-2, 384, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttempt(num, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 407:
						TileMergeAttempt(-2, 404, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 404:
						TileMergeAttempt(-2, 396, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttemptFrametest(i, j, num, 407, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 397:
						TileMergeAttempt(-2, 53, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttemptFrametest(i, j, num, 396, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 396:
						TileMergeAttempt(-2, 397, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttempt(-2, 53, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttemptFrametest(i, j, num, 404, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 398:
						TileMergeAttempt(-2, 112, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttemptFrametest(i, j, num, 400, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 400:
						TileMergeAttempt(-2, 398, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttempt(-2, 112, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 399:
						TileMergeAttempt(-2, 234, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttemptFrametest(i, j, num, 401, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 401:
						TileMergeAttempt(-2, 399, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttempt(-2, 234, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 402:
						TileMergeAttempt(-2, 116, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttemptFrametest(i, j, num, 403, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					case 403:
						TileMergeAttempt(-2, 402, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttempt(-2, 116, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						break;
					}
				}
				if (num == 0)
				{
					TileMergeAttempt(num, Main.tileMoss, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					TileMergeAttempt(num, TileID.Sets.tileMossBrick, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
				}
				else if (Main.tileMoss[num] || TileID.Sets.tileMossBrick[num])
				{
					TileMergeAttempt(num, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
				}
				else if (Main.tileStone[num] || num == 1)
				{
					TileMergeAttempt(num, Main.tileMoss, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
				}
				else if (num == 38)
				{
					TileMergeAttempt(num, TileID.Sets.tileMossBrick, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
				}
				if (TileID.Sets.Conversion.Grass[num])
				{
					TileMergeAttempt(num, TileID.Sets.Ore, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
				}
				else if (TileID.Sets.Ore[num])
				{
					TileMergeAttempt(num, TileID.Sets.Conversion.Grass, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
				}
				switch (num)
				{
				case 53:
					TileMergeAttemptFrametest(i, j, num, 747, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					break;
				case 747:
					TileMergeAttempt(-2, 53, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					break;
				}
				if (TileID.Sets.Snow[num])
				{
					TileMergeAttemptFrametest(i, j, num, 170, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
				}
				else if (num == 170)
				{
					TileMergeAttempt(-2, TileID.Sets.Snow, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
				}
				if (TileID.Sets.Snow[num])
				{
					TileMergeAttemptFrametest(i, j, num, 738, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
				}
				else if (num == 738)
				{
					TileMergeAttempt(-2, TileID.Sets.Snow, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
				}
				if (num >= 0 && num < TileID.Count && TileID.Sets.Mud[num])
				{
					TileMergeAttempt(num, TileID.Sets.OreMergesWithMud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
				}
				else if (TileID.Sets.OreMergesWithMud[num])
				{
					TileMergeAttempt(num, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
				}
				bool flag7 = false;
				if (num == 2 || num == 23 || num == 661 || num == 662 || num == 60 || num == 477 || num == 492 || num == 70 || num == 109 || num == 199 || Main.tileMoss[num] || TileID.Sets.NeedsGrassFraming[num] || TileID.Sets.tileMossBrick[num])
				{
					flag7 = true;
					TileMergeAttemptWeird(num, -1, Main.tileSolid, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					int num11 = TileID.Sets.NeedsGrassFramingDirt[num];
					if (num == 60 || num == 70 || num == 661 || num == 662)
					{
						num11 = 59;
					}
					else if (Main.tileMoss[num])
					{
						num11 = 1;
					}
					else if (TileID.Sets.tileMossBrick[num])
					{
						num11 = 38;
					}
					else
					{
						switch (num)
						{
						case 2:
						case 477:
							TileMergeAttempt(num11, 23, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
							break;
						case 23:
							TileMergeAttempt(num11, 2, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
							break;
						}
					}
					tileMergeCulling.Cull(ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					if (up != num && up != num11 && (down == num || down == num11))
					{
						if (left == num11 && right == num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 0;
								rectangle.Y = 198;
								break;
							case 1:
								rectangle.X = 18;
								rectangle.Y = 198;
								break;
							default:
								rectangle.X = 36;
								rectangle.Y = 198;
								break;
							}
						}
						else if (left == num && right == num11)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 54;
								rectangle.Y = 198;
								break;
							case 1:
								rectangle.X = 72;
								rectangle.Y = 198;
								break;
							default:
								rectangle.X = 90;
								rectangle.Y = 198;
								break;
							}
						}
					}
					else if (down != num && down != num11 && (up == num || up == num11))
					{
						if (left == num11 && right == num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 0;
								rectangle.Y = 216;
								break;
							case 1:
								rectangle.X = 18;
								rectangle.Y = 216;
								break;
							default:
								rectangle.X = 36;
								rectangle.Y = 216;
								break;
							}
						}
						else if (left == num && right == num11)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 54;
								rectangle.Y = 216;
								break;
							case 1:
								rectangle.X = 72;
								rectangle.Y = 216;
								break;
							default:
								rectangle.X = 90;
								rectangle.Y = 216;
								break;
							}
						}
					}
					else if (left != num && left != num11 && (right == num || right == num11))
					{
						if (up == num11 && down == num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 72;
								rectangle.Y = 144;
								break;
							case 1:
								rectangle.X = 72;
								rectangle.Y = 162;
								break;
							default:
								rectangle.X = 72;
								rectangle.Y = 180;
								break;
							}
						}
						else if (down == num && up == num11)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 72;
								rectangle.Y = 90;
								break;
							case 1:
								rectangle.X = 72;
								rectangle.Y = 108;
								break;
							default:
								rectangle.X = 72;
								rectangle.Y = 126;
								break;
							}
						}
					}
					else if (right != num && right != num11 && (left == num || left == num11))
					{
						if (up == num11 && down == num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 90;
								rectangle.Y = 144;
								break;
							case 1:
								rectangle.X = 90;
								rectangle.Y = 162;
								break;
							default:
								rectangle.X = 90;
								rectangle.Y = 180;
								break;
							}
						}
						else if (down == num && right == up)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 90;
								rectangle.Y = 90;
								break;
							case 1:
								rectangle.X = 90;
								rectangle.Y = 108;
								break;
							default:
								rectangle.X = 90;
								rectangle.Y = 126;
								break;
							}
						}
					}
					else if (up == num && down == num && left == num && right == num)
					{
						if (upLeft != num && upRight != num && downLeft != num && downRight != num)
						{
							if (downRight == num11)
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 108;
									rectangle.Y = 324;
									break;
								case 1:
									rectangle.X = 126;
									rectangle.Y = 324;
									break;
								default:
									rectangle.X = 144;
									rectangle.Y = 324;
									break;
								}
							}
							else if (upRight == num11)
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 108;
									rectangle.Y = 342;
									break;
								case 1:
									rectangle.X = 126;
									rectangle.Y = 342;
									break;
								default:
									rectangle.X = 144;
									rectangle.Y = 342;
									break;
								}
							}
							else if (downLeft == num11)
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 108;
									rectangle.Y = 360;
									break;
								case 1:
									rectangle.X = 126;
									rectangle.Y = 360;
									break;
								default:
									rectangle.X = 144;
									rectangle.Y = 360;
									break;
								}
							}
							else if (upLeft == num11)
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 108;
									rectangle.Y = 378;
									break;
								case 1:
									rectangle.X = 126;
									rectangle.Y = 378;
									break;
								default:
									rectangle.X = 144;
									rectangle.Y = 378;
									break;
								}
							}
							else
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 144;
									rectangle.Y = 234;
									break;
								case 1:
									rectangle.X = 198;
									rectangle.Y = 234;
									break;
								default:
									rectangle.X = 252;
									rectangle.Y = 234;
									break;
								}
							}
						}
						else if (upLeft != num && downRight != num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 36;
								rectangle.Y = 306;
								break;
							case 1:
								rectangle.X = 54;
								rectangle.Y = 306;
								break;
							default:
								rectangle.X = 72;
								rectangle.Y = 306;
								break;
							}
						}
						else if (upRight != num && downLeft != num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 90;
								rectangle.Y = 306;
								break;
							case 1:
								rectangle.X = 108;
								rectangle.Y = 306;
								break;
							default:
								rectangle.X = 126;
								rectangle.Y = 306;
								break;
							}
						}
						else if (upLeft != num && upRight == num && downLeft == num && downRight == num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 54;
								rectangle.Y = 108;
								break;
							case 1:
								rectangle.X = 54;
								rectangle.Y = 144;
								break;
							default:
								rectangle.X = 54;
								rectangle.Y = 180;
								break;
							}
						}
						else if (upLeft == num && upRight != num && downLeft == num && downRight == num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 36;
								rectangle.Y = 108;
								break;
							case 1:
								rectangle.X = 36;
								rectangle.Y = 144;
								break;
							default:
								rectangle.X = 36;
								rectangle.Y = 180;
								break;
							}
						}
						else if (upLeft == num && upRight == num && downLeft != num && downRight == num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 54;
								rectangle.Y = 90;
								break;
							case 1:
								rectangle.X = 54;
								rectangle.Y = 126;
								break;
							default:
								rectangle.X = 54;
								rectangle.Y = 162;
								break;
							}
						}
						else if (upLeft == num && upRight == num && downLeft == num && downRight != num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 36;
								rectangle.Y = 90;
								break;
							case 1:
								rectangle.X = 36;
								rectangle.Y = 126;
								break;
							default:
								rectangle.X = 36;
								rectangle.Y = 162;
								break;
							}
						}
					}
					else if (up == num && down == num11 && left == num && right == num && upLeft == -1 && upRight == -1)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 108;
							rectangle.Y = 18;
							break;
						case 1:
							rectangle.X = 126;
							rectangle.Y = 18;
							break;
						default:
							rectangle.X = 144;
							rectangle.Y = 18;
							break;
						}
					}
					else if (up == num11 && down == num && left == num && right == num && downLeft == -1 && downRight == -1)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 108;
							rectangle.Y = 36;
							break;
						case 1:
							rectangle.X = 126;
							rectangle.Y = 36;
							break;
						default:
							rectangle.X = 144;
							rectangle.Y = 36;
							break;
						}
					}
					else if (up == num && down == num && left == num11 && right == num && upRight == -1 && downRight == -1)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 198;
							rectangle.Y = 0;
							break;
						case 1:
							rectangle.X = 198;
							rectangle.Y = 18;
							break;
						default:
							rectangle.X = 198;
							rectangle.Y = 36;
							break;
						}
					}
					else if (up == num && down == num && left == num && right == num11 && upLeft == -1 && downLeft == -1)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 180;
							rectangle.Y = 0;
							break;
						case 1:
							rectangle.X = 180;
							rectangle.Y = 18;
							break;
						default:
							rectangle.X = 180;
							rectangle.Y = 36;
							break;
						}
					}
					else if (up == num && down == num11 && left == num && right == num)
					{
						if (upRight != -1)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 54;
								rectangle.Y = 108;
								break;
							case 1:
								rectangle.X = 54;
								rectangle.Y = 144;
								break;
							default:
								rectangle.X = 54;
								rectangle.Y = 180;
								break;
							}
						}
						else if (upLeft != -1)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 36;
								rectangle.Y = 108;
								break;
							case 1:
								rectangle.X = 36;
								rectangle.Y = 144;
								break;
							default:
								rectangle.X = 36;
								rectangle.Y = 180;
								break;
							}
						}
					}
					else if (up == num11 && down == num && left == num && right == num)
					{
						if (downRight != -1)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 54;
								rectangle.Y = 90;
								break;
							case 1:
								rectangle.X = 54;
								rectangle.Y = 126;
								break;
							default:
								rectangle.X = 54;
								rectangle.Y = 162;
								break;
							}
						}
						else if (downLeft != -1)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 36;
								rectangle.Y = 90;
								break;
							case 1:
								rectangle.X = 36;
								rectangle.Y = 126;
								break;
							default:
								rectangle.X = 36;
								rectangle.Y = 162;
								break;
							}
						}
					}
					else if (up == num && down == num && left == num && right == num11)
					{
						if (upLeft != -1)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 54;
								rectangle.Y = 90;
								break;
							case 1:
								rectangle.X = 54;
								rectangle.Y = 126;
								break;
							default:
								rectangle.X = 54;
								rectangle.Y = 162;
								break;
							}
						}
						else if (downLeft != -1)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 54;
								rectangle.Y = 108;
								break;
							case 1:
								rectangle.X = 54;
								rectangle.Y = 144;
								break;
							default:
								rectangle.X = 54;
								rectangle.Y = 180;
								break;
							}
						}
					}
					else if (up == num && down == num && left == num11 && right == num)
					{
						if (upRight != -1)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 36;
								rectangle.Y = 90;
								break;
							case 1:
								rectangle.X = 36;
								rectangle.Y = 126;
								break;
							default:
								rectangle.X = 36;
								rectangle.Y = 162;
								break;
							}
						}
						else if (downRight != -1)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 36;
								rectangle.Y = 108;
								break;
							case 1:
								rectangle.X = 36;
								rectangle.Y = 144;
								break;
							default:
								rectangle.X = 36;
								rectangle.Y = 180;
								break;
							}
						}
					}
					else if ((up == num11 && down == num && left == num && right == num) || (up == num && down == num11 && left == num && right == num) || (up == num && down == num && left == num11 && right == num) || (up == num && down == num && left == num && right == num11))
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 18;
							rectangle.Y = 18;
							break;
						case 1:
							rectangle.X = 36;
							rectangle.Y = 18;
							break;
						default:
							rectangle.X = 54;
							rectangle.Y = 18;
							break;
						}
					}
					if ((up == num || up == num11) && (down == num || down == num11) && (left == num || left == num11) && (right == num || right == num11))
					{
						if (upLeft != num && upLeft != num11 && (upRight == num || upRight == num11) && (downLeft == num || downLeft == num11) && (downRight == num || downRight == num11))
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 54;
								rectangle.Y = 108;
								break;
							case 1:
								rectangle.X = 54;
								rectangle.Y = 144;
								break;
							default:
								rectangle.X = 54;
								rectangle.Y = 180;
								break;
							}
						}
						else if (upRight != num && upRight != num11 && (upLeft == num || upLeft == num11) && (downLeft == num || downLeft == num11) && (downRight == num || downRight == num11))
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 36;
								rectangle.Y = 108;
								break;
							case 1:
								rectangle.X = 36;
								rectangle.Y = 144;
								break;
							default:
								rectangle.X = 36;
								rectangle.Y = 180;
								break;
							}
						}
						else if (downLeft != num && downLeft != num11 && (upLeft == num || upLeft == num11) && (upRight == num || upRight == num11) && (downRight == num || downRight == num11))
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 54;
								rectangle.Y = 90;
								break;
							case 1:
								rectangle.X = 54;
								rectangle.Y = 126;
								break;
							default:
								rectangle.X = 54;
								rectangle.Y = 162;
								break;
							}
						}
						else if (downRight != num && downRight != num11 && (upLeft == num || upLeft == num11) && (downLeft == num || downLeft == num11) && (upRight == num || upRight == num11))
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 36;
								rectangle.Y = 90;
								break;
							case 1:
								rectangle.X = 36;
								rectangle.Y = 126;
								break;
							default:
								rectangle.X = 36;
								rectangle.Y = 162;
								break;
							}
						}
					}
					if (up != num11 && up != num && down == num && left != num11 && left != num && right == num && downRight != num11 && downRight != num)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 90;
							rectangle.Y = 270;
							break;
						case 1:
							rectangle.X = 108;
							rectangle.Y = 270;
							break;
						default:
							rectangle.X = 126;
							rectangle.Y = 270;
							break;
						}
					}
					else if (up != num11 && up != num && down == num && left == num && right != num11 && right != num && downLeft != num11 && downLeft != num)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 144;
							rectangle.Y = 270;
							break;
						case 1:
							rectangle.X = 162;
							rectangle.Y = 270;
							break;
						default:
							rectangle.X = 180;
							rectangle.Y = 270;
							break;
						}
					}
					else if (down != num11 && down != num && up == num && left != num11 && left != num && right == num && upRight != num11 && upRight != num)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 90;
							rectangle.Y = 288;
							break;
						case 1:
							rectangle.X = 108;
							rectangle.Y = 288;
							break;
						default:
							rectangle.X = 126;
							rectangle.Y = 288;
							break;
						}
					}
					else if (down != num11 && down != num && up == num && left == num && right != num11 && right != num && upLeft != num11 && upLeft != num)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 144;
							rectangle.Y = 288;
							break;
						case 1:
							rectangle.X = 162;
							rectangle.Y = 288;
							break;
						default:
							rectangle.X = 180;
							rectangle.Y = 288;
							break;
						}
					}
					else if (up != num && up != num11 && down == num && left == num && right == num && downLeft != num && downLeft != num11 && downRight != num && downRight != num11)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 144;
							rectangle.Y = 216;
							break;
						case 1:
							rectangle.X = 198;
							rectangle.Y = 216;
							break;
						default:
							rectangle.X = 252;
							rectangle.Y = 216;
							break;
						}
					}
					else if (down != num && down != num11 && up == num && left == num && right == num && upLeft != num && upLeft != num11 && upRight != num && upRight != num11)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 144;
							rectangle.Y = 252;
							break;
						case 1:
							rectangle.X = 198;
							rectangle.Y = 252;
							break;
						default:
							rectangle.X = 252;
							rectangle.Y = 252;
							break;
						}
					}
					else if (left != num && left != num11 && down == num && up == num && right == num && upRight != num && upRight != num11 && downRight != num && downRight != num11)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 126;
							rectangle.Y = 234;
							break;
						case 1:
							rectangle.X = 180;
							rectangle.Y = 234;
							break;
						default:
							rectangle.X = 234;
							rectangle.Y = 234;
							break;
						}
					}
					else if (right != num && right != num11 && down == num && up == num && left == num && upLeft != num && upLeft != num11 && downLeft != num && downLeft != num11)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 162;
							rectangle.Y = 234;
							break;
						case 1:
							rectangle.X = 216;
							rectangle.Y = 234;
							break;
						default:
							rectangle.X = 270;
							rectangle.Y = 234;
							break;
						}
					}
					else if (up != num11 && up != num && (down == num11 || down == num) && left == num11 && right == num11)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 36;
							rectangle.Y = 270;
							break;
						case 1:
							rectangle.X = 54;
							rectangle.Y = 270;
							break;
						default:
							rectangle.X = 72;
							rectangle.Y = 270;
							break;
						}
					}
					else if (down != num11 && down != num && (up == num11 || up == num) && left == num11 && right == num11)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 36;
							rectangle.Y = 288;
							break;
						case 1:
							rectangle.X = 54;
							rectangle.Y = 288;
							break;
						default:
							rectangle.X = 72;
							rectangle.Y = 288;
							break;
						}
					}
					else if (left != num11 && left != num && (right == num11 || right == num) && up == num11 && down == num11)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 0;
							rectangle.Y = 270;
							break;
						case 1:
							rectangle.X = 0;
							rectangle.Y = 288;
							break;
						default:
							rectangle.X = 0;
							rectangle.Y = 306;
							break;
						}
					}
					else if (right != num11 && right != num && (left == num11 || left == num) && up == num11 && down == num11)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 18;
							rectangle.Y = 270;
							break;
						case 1:
							rectangle.X = 18;
							rectangle.Y = 288;
							break;
						default:
							rectangle.X = 18;
							rectangle.Y = 306;
							break;
						}
					}
					else if (up == num && down == num11 && left == num11 && right == num11)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 198;
							rectangle.Y = 288;
							break;
						case 1:
							rectangle.X = 216;
							rectangle.Y = 288;
							break;
						default:
							rectangle.X = 234;
							rectangle.Y = 288;
							break;
						}
					}
					else if (up == num11 && down == num && left == num11 && right == num11)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 198;
							rectangle.Y = 270;
							break;
						case 1:
							rectangle.X = 216;
							rectangle.Y = 270;
							break;
						default:
							rectangle.X = 234;
							rectangle.Y = 270;
							break;
						}
					}
					else if (up == num11 && down == num11 && left == num && right == num11)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 198;
							rectangle.Y = 306;
							break;
						case 1:
							rectangle.X = 216;
							rectangle.Y = 306;
							break;
						default:
							rectangle.X = 234;
							rectangle.Y = 306;
							break;
						}
					}
					else if (up == num11 && down == num11 && left == num11 && right == num)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 144;
							rectangle.Y = 306;
							break;
						case 1:
							rectangle.X = 162;
							rectangle.Y = 306;
							break;
						default:
							rectangle.X = 180;
							rectangle.Y = 306;
							break;
						}
					}
					if (up != num && up != num11 && down == num && left == num && right == num)
					{
						if ((downLeft == num11 || downLeft == num) && downRight != num11 && downRight != num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 0;
								rectangle.Y = 324;
								break;
							case 1:
								rectangle.X = 18;
								rectangle.Y = 324;
								break;
							default:
								rectangle.X = 36;
								rectangle.Y = 324;
								break;
							}
						}
						else if ((downRight == num11 || downRight == num) && downLeft != num11 && downLeft != num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 54;
								rectangle.Y = 324;
								break;
							case 1:
								rectangle.X = 72;
								rectangle.Y = 324;
								break;
							default:
								rectangle.X = 90;
								rectangle.Y = 324;
								break;
							}
						}
					}
					else if (down != num && down != num11 && up == num && left == num && right == num)
					{
						if ((upLeft == num11 || upLeft == num) && upRight != num11 && upRight != num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 0;
								rectangle.Y = 342;
								break;
							case 1:
								rectangle.X = 18;
								rectangle.Y = 342;
								break;
							default:
								rectangle.X = 36;
								rectangle.Y = 342;
								break;
							}
						}
						else if ((upRight == num11 || upRight == num) && upLeft != num11 && upLeft != num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 54;
								rectangle.Y = 342;
								break;
							case 1:
								rectangle.X = 72;
								rectangle.Y = 342;
								break;
							default:
								rectangle.X = 90;
								rectangle.Y = 342;
								break;
							}
						}
					}
					else if (left != num && left != num11 && up == num && down == num && right == num)
					{
						if ((upRight == num11 || upRight == num) && downRight != num11 && downRight != num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 54;
								rectangle.Y = 360;
								break;
							case 1:
								rectangle.X = 72;
								rectangle.Y = 360;
								break;
							default:
								rectangle.X = 90;
								rectangle.Y = 360;
								break;
							}
						}
						else if ((downRight == num11 || downRight == num) && upRight != num11 && upRight != num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 0;
								rectangle.Y = 360;
								break;
							case 1:
								rectangle.X = 18;
								rectangle.Y = 360;
								break;
							default:
								rectangle.X = 36;
								rectangle.Y = 360;
								break;
							}
						}
					}
					else if (right != num && right != num11 && up == num && down == num && left == num)
					{
						if ((upLeft == num11 || upLeft == num) && downLeft != num11 && downLeft != num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 0;
								rectangle.Y = 378;
								break;
							case 1:
								rectangle.X = 18;
								rectangle.Y = 378;
								break;
							default:
								rectangle.X = 36;
								rectangle.Y = 378;
								break;
							}
						}
						else if ((downLeft == num11 || downLeft == num) && upLeft != num11 && upLeft != num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 54;
								rectangle.Y = 378;
								break;
							case 1:
								rectangle.X = 72;
								rectangle.Y = 378;
								break;
							default:
								rectangle.X = 90;
								rectangle.Y = 378;
								break;
							}
						}
					}
					if ((up == num || up == num11) && (down == num || down == num11) && (left == num || left == num11) && (right == num || right == num11) && upLeft != -1 && upRight != -1 && downLeft != -1 && downRight != -1)
					{
						if ((i + j) % 2 == 1)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 108;
								rectangle.Y = 198;
								break;
							case 1:
								rectangle.X = 126;
								rectangle.Y = 198;
								break;
							default:
								rectangle.X = 144;
								rectangle.Y = 198;
								break;
							}
						}
						else
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 18;
								rectangle.Y = 18;
								break;
							case 1:
								rectangle.X = 36;
								rectangle.Y = 18;
								break;
							default:
								rectangle.X = 54;
								rectangle.Y = 18;
								break;
							}
						}
					}
					if (num11 >= 0 && num11 < TileID.Count && TileID.Sets.Dirt[num11])
					{
						TileMergeAttempt(-2, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					}
					else if (num11 >= 0 && num11 < TileID.Count && TileID.Sets.Mud[num11])
					{
						TileMergeAttempt(-2, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					}
					else
					{
						TileMergeAttempt(-2, num11, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					}
					tileMergeCulling.Cull(ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
				}
				TileMergeAttempt(num, Main.tileMerge[num], ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
				if (rectangle.X == -1 && rectangle.Y == -1 && (Main.tileMergeDirt[num] || (num > -1 && TileID.Sets.ChecksForMerge[num])))
				{
					if (!flag7)
					{
						flag7 = true;
						TileMergeAttemptWeird(num, -1, Main.tileSolid, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					}
					if (up > -1 && up != num)
					{
						up = -1;
					}
					if (down > -1 && down != num)
					{
						down = -1;
					}
					if (left > -1 && left != num)
					{
						left = -1;
					}
					if (right > -1 && right != num)
					{
						right = -1;
					}
					tileMergeCulling.Cull(ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					if (up != -1 && down != -1 && left != -1 && right != -1)
					{
						if (up == -2 && down == num && left == num && right == num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 144;
								rectangle.Y = 108;
								break;
							case 1:
								rectangle.X = 162;
								rectangle.Y = 108;
								break;
							default:
								rectangle.X = 180;
								rectangle.Y = 108;
								break;
							}
							mergeUp = true;
						}
						else if (up == num && down == -2 && left == num && right == num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 144;
								rectangle.Y = 90;
								break;
							case 1:
								rectangle.X = 162;
								rectangle.Y = 90;
								break;
							default:
								rectangle.X = 180;
								rectangle.Y = 90;
								break;
							}
							mergeDown = true;
						}
						else if (up == num && down == num && left == -2 && right == num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 162;
								rectangle.Y = 126;
								break;
							case 1:
								rectangle.X = 162;
								rectangle.Y = 144;
								break;
							default:
								rectangle.X = 162;
								rectangle.Y = 162;
								break;
							}
							mergeLeft = true;
						}
						else if (up == num && down == num && left == num && right == -2)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 144;
								rectangle.Y = 126;
								break;
							case 1:
								rectangle.X = 144;
								rectangle.Y = 144;
								break;
							default:
								rectangle.X = 144;
								rectangle.Y = 162;
								break;
							}
							mergeRight = true;
						}
						else if (up == -2 && down == num && left == -2 && right == num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 36;
								rectangle.Y = 90;
								break;
							case 1:
								rectangle.X = 36;
								rectangle.Y = 126;
								break;
							default:
								rectangle.X = 36;
								rectangle.Y = 162;
								break;
							}
							mergeUp = true;
							mergeLeft = true;
						}
						else if (up == -2 && down == num && left == num && right == -2)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 54;
								rectangle.Y = 90;
								break;
							case 1:
								rectangle.X = 54;
								rectangle.Y = 126;
								break;
							default:
								rectangle.X = 54;
								rectangle.Y = 162;
								break;
							}
							mergeUp = true;
							mergeRight = true;
						}
						else if (up == num && down == -2 && left == -2 && right == num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 36;
								rectangle.Y = 108;
								break;
							case 1:
								rectangle.X = 36;
								rectangle.Y = 144;
								break;
							default:
								rectangle.X = 36;
								rectangle.Y = 180;
								break;
							}
							mergeDown = true;
							mergeLeft = true;
						}
						else if (up == num && down == -2 && left == num && right == -2)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 54;
								rectangle.Y = 108;
								break;
							case 1:
								rectangle.X = 54;
								rectangle.Y = 144;
								break;
							default:
								rectangle.X = 54;
								rectangle.Y = 180;
								break;
							}
							mergeDown = true;
							mergeRight = true;
						}
						else if (up == num && down == num && left == -2 && right == -2)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 180;
								rectangle.Y = 126;
								break;
							case 1:
								rectangle.X = 180;
								rectangle.Y = 144;
								break;
							default:
								rectangle.X = 180;
								rectangle.Y = 162;
								break;
							}
							mergeLeft = true;
							mergeRight = true;
						}
						else if (up == -2 && down == -2 && left == num && right == num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 144;
								rectangle.Y = 180;
								break;
							case 1:
								rectangle.X = 162;
								rectangle.Y = 180;
								break;
							default:
								rectangle.X = 180;
								rectangle.Y = 180;
								break;
							}
							mergeUp = true;
							mergeDown = true;
						}
						else if (up == -2 && down == num && left == -2 && right == -2)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 198;
								rectangle.Y = 90;
								break;
							case 1:
								rectangle.X = 198;
								rectangle.Y = 108;
								break;
							default:
								rectangle.X = 198;
								rectangle.Y = 126;
								break;
							}
							mergeUp = true;
							mergeLeft = true;
							mergeRight = true;
						}
						else if (up == num && down == -2 && left == -2 && right == -2)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 198;
								rectangle.Y = 144;
								break;
							case 1:
								rectangle.X = 198;
								rectangle.Y = 162;
								break;
							default:
								rectangle.X = 198;
								rectangle.Y = 180;
								break;
							}
							mergeDown = true;
							mergeLeft = true;
							mergeRight = true;
						}
						else if (up == -2 && down == -2 && left == num && right == -2)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 216;
								rectangle.Y = 144;
								break;
							case 1:
								rectangle.X = 216;
								rectangle.Y = 162;
								break;
							default:
								rectangle.X = 216;
								rectangle.Y = 180;
								break;
							}
							mergeUp = true;
							mergeDown = true;
							mergeRight = true;
						}
						else if (up == -2 && down == -2 && left == -2 && right == num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 216;
								rectangle.Y = 90;
								break;
							case 1:
								rectangle.X = 216;
								rectangle.Y = 108;
								break;
							default:
								rectangle.X = 216;
								rectangle.Y = 126;
								break;
							}
							mergeUp = true;
							mergeDown = true;
							mergeLeft = true;
						}
						else if (up == -2 && down == -2 && left == -2 && right == -2)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 108;
								rectangle.Y = 198;
								break;
							case 1:
								rectangle.X = 126;
								rectangle.Y = 198;
								break;
							default:
								rectangle.X = 144;
								rectangle.Y = 198;
								break;
							}
							mergeUp = true;
							mergeDown = true;
							mergeLeft = true;
							mergeRight = true;
						}
						else if (up == num && down == num && left == num && right == num)
						{
							if (upLeft == -2)
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 18;
									rectangle.Y = 108;
									break;
								case 1:
									rectangle.X = 18;
									rectangle.Y = 144;
									break;
								default:
									rectangle.X = 18;
									rectangle.Y = 180;
									break;
								}
							}
							if (upRight == -2)
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 0;
									rectangle.Y = 108;
									break;
								case 1:
									rectangle.X = 0;
									rectangle.Y = 144;
									break;
								default:
									rectangle.X = 0;
									rectangle.Y = 180;
									break;
								}
							}
							if (downLeft == -2)
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 18;
									rectangle.Y = 90;
									break;
								case 1:
									rectangle.X = 18;
									rectangle.Y = 126;
									break;
								default:
									rectangle.X = 18;
									rectangle.Y = 162;
									break;
								}
							}
							if (downRight == -2)
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 0;
									rectangle.Y = 90;
									break;
								case 1:
									rectangle.X = 0;
									rectangle.Y = 126;
									break;
								default:
									rectangle.X = 0;
									rectangle.Y = 162;
									break;
								}
							}
						}
					}
					else
					{
						if (num != 2 && num != 23 && num != 60 && num != 70 && num != 109 && num != 199 && num != 477 && num != 492 && num != 633 && num != 661 && num != 662)
						{
							if (up == -1 && down == -2 && left == num && right == num)
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 234;
									rectangle.Y = 0;
									break;
								case 1:
									rectangle.X = 252;
									rectangle.Y = 0;
									break;
								default:
									rectangle.X = 270;
									rectangle.Y = 0;
									break;
								}
								mergeDown = true;
							}
							else if (up == -2 && down == -1 && left == num && right == num)
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 234;
									rectangle.Y = 18;
									break;
								case 1:
									rectangle.X = 252;
									rectangle.Y = 18;
									break;
								default:
									rectangle.X = 270;
									rectangle.Y = 18;
									break;
								}
								mergeUp = true;
							}
							else if (up == num && down == num && left == -1 && right == -2)
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 234;
									rectangle.Y = 36;
									break;
								case 1:
									rectangle.X = 252;
									rectangle.Y = 36;
									break;
								default:
									rectangle.X = 270;
									rectangle.Y = 36;
									break;
								}
								mergeRight = true;
							}
							else if (up == num && down == num && left == -2 && right == -1)
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 234;
									rectangle.Y = 54;
									break;
								case 1:
									rectangle.X = 252;
									rectangle.Y = 54;
									break;
								default:
									rectangle.X = 270;
									rectangle.Y = 54;
									break;
								}
								mergeLeft = true;
							}
						}
						if (up != -1 && down != -1 && left == -1 && right == num)
						{
							if (up == -2 && down == num)
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 72;
									rectangle.Y = 144;
									break;
								case 1:
									rectangle.X = 72;
									rectangle.Y = 162;
									break;
								default:
									rectangle.X = 72;
									rectangle.Y = 180;
									break;
								}
								mergeUp = true;
							}
							else if (down == -2 && up == num)
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 72;
									rectangle.Y = 90;
									break;
								case 1:
									rectangle.X = 72;
									rectangle.Y = 108;
									break;
								default:
									rectangle.X = 72;
									rectangle.Y = 126;
									break;
								}
								mergeDown = true;
							}
						}
						else if (up != -1 && down != -1 && left == num && right == -1)
						{
							if (up == -2 && down == num)
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 90;
									rectangle.Y = 144;
									break;
								case 1:
									rectangle.X = 90;
									rectangle.Y = 162;
									break;
								default:
									rectangle.X = 90;
									rectangle.Y = 180;
									break;
								}
								mergeUp = true;
							}
							else if (down == -2 && up == num)
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 90;
									rectangle.Y = 90;
									break;
								case 1:
									rectangle.X = 90;
									rectangle.Y = 108;
									break;
								default:
									rectangle.X = 90;
									rectangle.Y = 126;
									break;
								}
								mergeDown = true;
							}
						}
						else if (up == -1 && down == num && left != -1 && right != -1)
						{
							if (left == -2 && right == num)
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 0;
									rectangle.Y = 198;
									break;
								case 1:
									rectangle.X = 18;
									rectangle.Y = 198;
									break;
								default:
									rectangle.X = 36;
									rectangle.Y = 198;
									break;
								}
								mergeLeft = true;
							}
							else if (right == -2 && left == num)
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 54;
									rectangle.Y = 198;
									break;
								case 1:
									rectangle.X = 72;
									rectangle.Y = 198;
									break;
								default:
									rectangle.X = 90;
									rectangle.Y = 198;
									break;
								}
								mergeRight = true;
							}
						}
						else if (up == num && down == -1 && left != -1 && right != -1)
						{
							if (left == -2 && right == num)
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 0;
									rectangle.Y = 216;
									break;
								case 1:
									rectangle.X = 18;
									rectangle.Y = 216;
									break;
								default:
									rectangle.X = 36;
									rectangle.Y = 216;
									break;
								}
								mergeLeft = true;
							}
							else if (right == -2 && left == num)
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 54;
									rectangle.Y = 216;
									break;
								case 1:
									rectangle.X = 72;
									rectangle.Y = 216;
									break;
								default:
									rectangle.X = 90;
									rectangle.Y = 216;
									break;
								}
								mergeRight = true;
							}
						}
						else if (up != -1 && down != -1 && left == -1 && right == -1)
						{
							if (up == -2 && down == -2)
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 108;
									rectangle.Y = 216;
									break;
								case 1:
									rectangle.X = 108;
									rectangle.Y = 234;
									break;
								default:
									rectangle.X = 108;
									rectangle.Y = 252;
									break;
								}
								mergeUp = true;
								mergeDown = true;
							}
							else if (up == -2)
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 126;
									rectangle.Y = 144;
									break;
								case 1:
									rectangle.X = 126;
									rectangle.Y = 162;
									break;
								default:
									rectangle.X = 126;
									rectangle.Y = 180;
									break;
								}
								mergeUp = true;
							}
							else if (down == -2)
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 126;
									rectangle.Y = 90;
									break;
								case 1:
									rectangle.X = 126;
									rectangle.Y = 108;
									break;
								default:
									rectangle.X = 126;
									rectangle.Y = 126;
									break;
								}
								mergeDown = true;
							}
						}
						else if (up == -1 && down == -1 && left != -1 && right != -1)
						{
							if (left == -2 && right == -2)
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 162;
									rectangle.Y = 198;
									break;
								case 1:
									rectangle.X = 180;
									rectangle.Y = 198;
									break;
								default:
									rectangle.X = 198;
									rectangle.Y = 198;
									break;
								}
								mergeLeft = true;
								mergeRight = true;
							}
							else if (left == -2)
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 0;
									rectangle.Y = 252;
									break;
								case 1:
									rectangle.X = 18;
									rectangle.Y = 252;
									break;
								default:
									rectangle.X = 36;
									rectangle.Y = 252;
									break;
								}
								mergeLeft = true;
							}
							else if (right == -2)
							{
								switch (num6)
								{
								case 0:
									rectangle.X = 54;
									rectangle.Y = 252;
									break;
								case 1:
									rectangle.X = 72;
									rectangle.Y = 252;
									break;
								default:
									rectangle.X = 90;
									rectangle.Y = 252;
									break;
								}
								mergeRight = true;
							}
						}
						else if (up == -2 && down == -1 && left == -1 && right == -1)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 108;
								rectangle.Y = 144;
								break;
							case 1:
								rectangle.X = 108;
								rectangle.Y = 162;
								break;
							default:
								rectangle.X = 108;
								rectangle.Y = 180;
								break;
							}
							mergeUp = true;
						}
						else if (up == -1 && down == -2 && left == -1 && right == -1)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 108;
								rectangle.Y = 90;
								break;
							case 1:
								rectangle.X = 108;
								rectangle.Y = 108;
								break;
							default:
								rectangle.X = 108;
								rectangle.Y = 126;
								break;
							}
							mergeDown = true;
						}
						else if (up == -1 && down == -1 && left == -2 && right == -1)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 0;
								rectangle.Y = 234;
								break;
							case 1:
								rectangle.X = 18;
								rectangle.Y = 234;
								break;
							default:
								rectangle.X = 36;
								rectangle.Y = 234;
								break;
							}
							mergeLeft = true;
						}
						else if (up == -1 && down == -1 && left == -1 && right == -2)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 54;
								rectangle.Y = 234;
								break;
							case 1:
								rectangle.X = 72;
								rectangle.Y = 234;
								break;
							default:
								rectangle.X = 90;
								rectangle.Y = 234;
								break;
							}
							mergeRight = true;
						}
					}
				}
				int num12 = tileCache.blockType();
				if (TileID.Sets.HasSlopeFrames[num])
				{
					if (num12 == 0)
					{
						bool flag8 = num == up && tile != null && tile.topSlope();
						bool flag9 = num == left && tile3 != null && tile3.leftSlope();
						bool flag10 = num == right && tile4 != null && tile4.rightSlope();
						bool flag11 = num == down && tile2 != null && tile2.bottomSlope();
						int num13 = 0;
						int num14 = 0;
						if (flag8.ToInt() + flag9.ToInt() + flag10.ToInt() + flag11.ToInt() > 2)
						{
							int num15 = (tile != null && tile.slope() == 1).ToInt() + (tile4 != null && tile4.slope() == 1).ToInt() + (tile2 != null && tile2.slope() == 4).ToInt() + (tile3 != null && tile3.slope() == 4).ToInt();
							int num16 = (tile != null && tile.slope() == 2).ToInt() + (tile4 != null && tile4.slope() == 3).ToInt() + (tile2 != null && tile2.slope() == 3).ToInt() + (tile3 != null && tile3.slope() == 2).ToInt();
							if (num15 == num16)
							{
								num13 = 2;
								num14 = 4;
							}
							else if (num15 > num16)
							{
								bool num17 = num == upLeft && tile7 != null && tile7.slope() == 0;
								bool flag12 = num == downRight && tile6 != null && tile6.slope() == 0;
								if (num17 && flag12)
								{
									num14 = 4;
								}
								else if (flag12)
								{
									num13 = 6;
								}
								else
								{
									num13 = 7;
									num14 = 1;
								}
							}
							else
							{
								bool num18 = num == upRight && tile8 != null && tile8.slope() == 0;
								bool flag13 = num == downLeft && tile5 != null && tile5.slope() == 0;
								if (num18 && flag13)
								{
									num14 = 4;
									num13 = 1;
								}
								else if (flag13)
								{
									num13 = 7;
								}
								else
								{
									num13 = 6;
									num14 = 1;
								}
							}
							rectangle.X = (18 + num13) * 18;
							rectangle.Y = num14 * 18;
						}
						else
						{
							if (flag8 && flag9 && num == down && num == right)
							{
								num14 = 2;
							}
							else if (flag8 && flag10 && num == down && num == left)
							{
								num13 = 1;
								num14 = 2;
							}
							else if (flag10 && flag11 && num == up && num == left)
							{
								num13 = 1;
								num14 = 3;
							}
							else if (flag11 && flag9 && num == up && num == right)
							{
								num14 = 3;
							}
							if (num13 != 0 || num14 != 0)
							{
								rectangle.X = (18 + num13) * 18;
								rectangle.Y = num14 * 18;
							}
						}
					}
					if (num12 >= 2 && (rectangle.X < 0 || rectangle.Y < 0))
					{
						int num19 = -1;
						int num20 = -1;
						int num21 = -1;
						int num22 = 0;
						int num23 = 0;
						switch (num12)
						{
						case 2:
							num19 = left;
							num20 = down;
							num21 = downLeft;
							num22++;
							break;
						case 3:
							num19 = right;
							num20 = down;
							num21 = downRight;
							break;
						case 4:
							num19 = left;
							num20 = up;
							num21 = upLeft;
							num22++;
							num23++;
							break;
						case 5:
							num19 = right;
							num20 = up;
							num21 = upRight;
							num23++;
							break;
						}
						if (num != num19 || num != num20 || num != num21)
						{
							if (num == num19 && num == num20)
							{
								num22 += 2;
							}
							else if (num == num19)
							{
								num22 += 4;
							}
							else if (num == num20)
							{
								num22 += 4;
								num23 += 2;
							}
							else
							{
								num22 += 2;
								num23 += 2;
							}
						}
						rectangle.X = (18 + num22) * 18;
						rectangle.Y = num23 * 18;
					}
				}
				if (rectangle.X < 0 || rectangle.Y < 0)
				{
					if (!flag7)
					{
						flag7 = true;
						TileMergeAttemptWeird(num, -1, Main.tileSolid, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						tileMergeCulling.Cull(ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					}
					if (num == 2 || num == 23 || num == 60 || num == 70 || num == 109 || num == 199 || num == 477 || num == 492 || num == 633 || num == 661 || num == 662 || Main.tileMoss[num] || TileID.Sets.tileMossBrick[num])
					{
						TileMergeAttempt(num, -2, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						tileMergeCulling.Cull(ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					}
					if (up == num && down == num && left == num && right == num)
					{
						if (upLeft != num && upRight != num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 108;
								rectangle.Y = 18;
								break;
							case 1:
								rectangle.X = 126;
								rectangle.Y = 18;
								break;
							default:
								rectangle.X = 144;
								rectangle.Y = 18;
								break;
							}
						}
						else if (downLeft != num && downRight != num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 108;
								rectangle.Y = 36;
								break;
							case 1:
								rectangle.X = 126;
								rectangle.Y = 36;
								break;
							default:
								rectangle.X = 144;
								rectangle.Y = 36;
								break;
							}
						}
						else if (upLeft != num && downLeft != num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 180;
								rectangle.Y = 0;
								break;
							case 1:
								rectangle.X = 180;
								rectangle.Y = 18;
								break;
							default:
								rectangle.X = 180;
								rectangle.Y = 36;
								break;
							}
						}
						else if (upRight != num && downRight != num)
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 198;
								rectangle.Y = 0;
								break;
							case 1:
								rectangle.X = 198;
								rectangle.Y = 18;
								break;
							default:
								rectangle.X = 198;
								rectangle.Y = 36;
								break;
							}
						}
						else
						{
							switch (num6)
							{
							case 0:
								rectangle.X = 18;
								rectangle.Y = 18;
								break;
							case 1:
								rectangle.X = 36;
								rectangle.Y = 18;
								break;
							default:
								rectangle.X = 54;
								rectangle.Y = 18;
								break;
							}
						}
					}
					else if (up != num && down == num && left == num && right == num)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 18;
							rectangle.Y = 0;
							break;
						case 1:
							rectangle.X = 36;
							rectangle.Y = 0;
							break;
						default:
							rectangle.X = 54;
							rectangle.Y = 0;
							break;
						}
					}
					else if (up == num && down != num && left == num && right == num)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 18;
							rectangle.Y = 36;
							break;
						case 1:
							rectangle.X = 36;
							rectangle.Y = 36;
							break;
						default:
							rectangle.X = 54;
							rectangle.Y = 36;
							break;
						}
					}
					else if (up == num && down == num && left != num && right == num)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 0;
							rectangle.Y = 0;
							break;
						case 1:
							rectangle.X = 0;
							rectangle.Y = 18;
							break;
						default:
							rectangle.X = 0;
							rectangle.Y = 36;
							break;
						}
					}
					else if (up == num && down == num && left == num && right != num)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 72;
							rectangle.Y = 0;
							break;
						case 1:
							rectangle.X = 72;
							rectangle.Y = 18;
							break;
						default:
							rectangle.X = 72;
							rectangle.Y = 36;
							break;
						}
					}
					else if (up != num && down == num && left != num && right == num)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 0;
							rectangle.Y = 54;
							break;
						case 1:
							rectangle.X = 36;
							rectangle.Y = 54;
							break;
						default:
							rectangle.X = 72;
							rectangle.Y = 54;
							break;
						}
					}
					else if (up != num && down == num && left == num && right != num)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 18;
							rectangle.Y = 54;
							break;
						case 1:
							rectangle.X = 54;
							rectangle.Y = 54;
							break;
						default:
							rectangle.X = 90;
							rectangle.Y = 54;
							break;
						}
					}
					else if (up == num && down != num && left != num && right == num)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 0;
							rectangle.Y = 72;
							break;
						case 1:
							rectangle.X = 36;
							rectangle.Y = 72;
							break;
						default:
							rectangle.X = 72;
							rectangle.Y = 72;
							break;
						}
					}
					else if (up == num && down != num && left == num && right != num)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 18;
							rectangle.Y = 72;
							break;
						case 1:
							rectangle.X = 54;
							rectangle.Y = 72;
							break;
						default:
							rectangle.X = 90;
							rectangle.Y = 72;
							break;
						}
					}
					else if (up == num && down == num && left != num && right != num)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 90;
							rectangle.Y = 0;
							break;
						case 1:
							rectangle.X = 90;
							rectangle.Y = 18;
							break;
						default:
							rectangle.X = 90;
							rectangle.Y = 36;
							break;
						}
					}
					else if (up != num && down != num && left == num && right == num)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 108;
							rectangle.Y = 72;
							break;
						case 1:
							rectangle.X = 126;
							rectangle.Y = 72;
							break;
						default:
							rectangle.X = 144;
							rectangle.Y = 72;
							break;
						}
					}
					else if (up != num && down == num && left != num && right != num)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 108;
							rectangle.Y = 0;
							break;
						case 1:
							rectangle.X = 126;
							rectangle.Y = 0;
							break;
						default:
							rectangle.X = 144;
							rectangle.Y = 0;
							break;
						}
					}
					else if (up == num && down != num && left != num && right != num)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 108;
							rectangle.Y = 54;
							break;
						case 1:
							rectangle.X = 126;
							rectangle.Y = 54;
							break;
						default:
							rectangle.X = 144;
							rectangle.Y = 54;
							break;
						}
					}
					else if (up != num && down != num && left != num && right == num)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 162;
							rectangle.Y = 0;
							break;
						case 1:
							rectangle.X = 162;
							rectangle.Y = 18;
							break;
						default:
							rectangle.X = 162;
							rectangle.Y = 36;
							break;
						}
					}
					else if (up != num && down != num && left == num && right != num)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 216;
							rectangle.Y = 0;
							break;
						case 1:
							rectangle.X = 216;
							rectangle.Y = 18;
							break;
						default:
							rectangle.X = 216;
							rectangle.Y = 36;
							break;
						}
					}
					else if (up != num && down != num && left != num && right != num)
					{
						switch (num6)
						{
						case 0:
							rectangle.X = 162;
							rectangle.Y = 54;
							break;
						case 1:
							rectangle.X = 180;
							rectangle.Y = 54;
							break;
						default:
							rectangle.X = 198;
							rectangle.Y = 54;
							break;
						}
					}
				}
				if (rectangle.X <= -1 || rectangle.Y <= -1)
				{
					if (num6 <= 0)
					{
						rectangle.X = 18;
						rectangle.Y = 18;
					}
					else if (num6 == 1)
					{
						rectangle.X = 36;
						rectangle.Y = 18;
					}
					if (num6 >= 2)
					{
						rectangle.X = 54;
						rectangle.Y = 18;
					}
				}
				if (Main.tileLargeFrames[num] == 1 && num6 == 3)
				{
					rectangle.Y += 90;
				}
				if (Main.tileLargeFrames[num] == 2 && num6 == 3)
				{
					rectangle.Y += 90;
				}
				tileCache.frameX = (short)rectangle.X;
				tileCache.frameY = (short)rectangle.Y;
				if (rectangle.X != frameX && rectangle.Y != frameY && frameX >= 0 && frameY >= 0)
				{
					tileReframeCount++;
					if (tileReframeCount < 25)
					{
						bool num24 = mergeUp;
						bool flag14 = mergeDown;
						bool flag15 = mergeLeft;
						bool flag16 = mergeRight;
						TileFrameCosmetic(i - 1, j, tile3);
						TileFrameCosmetic(i + 1, j, tile4);
						TileFrameCosmetic(i, j - 1, tile);
						TileFrameCosmetic(i, j + 1, tile2);
						mergeUp = num24;
						mergeDown = flag14;
						mergeLeft = flag15;
						mergeRight = flag16;
					}
					tileReframeCount--;
				}
				return;
			}
			}
			goto case 255;
		case 255:
		case 256:
		case 257:
		case 258:
		case 259:
		case 260:
		case 261:
		case 262:
		case 263:
		case 264:
		case 265:
		case 266:
		case 267:
		case 268:
			Framing.SelfFrame8Way(i, j, tileCache, resetFrame);
			break;
		}
	}

	public static TileMergeCullCache GetTileMergeCulling(Tile tileCache, Tile tileTopCache, Tile tileBottomCache, Tile tileLeftCache, Tile tileRightCache, Tile tileBottomLeftCache, Tile tileBottomRightCache, Tile tileTopLeftCache, Tile tileTopRightCache)
	{
		if (Main.ShouldShowInvisibleBlocksAndWalls())
		{
			return default(TileMergeCullCache);
		}
		bool flag = tileCache.invisibleBlock();
		return new TileMergeCullCache
		{
			CullTop = (tileTopCache != null && tileTopCache.invisibleBlock() != flag),
			CullBottom = (tileBottomCache != null && tileBottomCache.invisibleBlock() != flag),
			CullLeft = (tileLeftCache != null && tileLeftCache.invisibleBlock() != flag),
			CullRight = (tileRightCache != null && tileRightCache.invisibleBlock() != flag),
			CullTopLeft = (tileTopLeftCache != null && tileTopLeftCache.invisibleBlock() != flag),
			CullTopRight = (tileTopRightCache != null && tileTopRightCache.invisibleBlock() != flag),
			CullBottomLeft = (tileBottomLeftCache != null && tileBottomLeftCache.invisibleBlock() != flag),
			CullBottomRight = (tileBottomRightCache != null && tileBottomRightCache.invisibleBlock() != flag)
		};
	}

	private static bool CheckVines(int i, int j, int type, Tile tileCache)
	{
		Tile tile = Main.tile[i, j - 1];
		if (tile == null)
		{
			return true;
		}
		int num = -1;
		if (tile.nactive() && !tile.bottomSlope())
		{
			num = tile.type;
		}
		if (type == num)
		{
			return true;
		}
		bool num2 = num == 60 || num == 226 || num == 62;
		bool num3 = num == 109 || num == 115 || num == 492;
		bool flag = num == 23 || num == 636 || num == 661;
		bool flag2 = num == 199 || num == 205 || num == 662;
		bool flag3 = num == 2 || num == 52 || num == 477;
		bool flag4 = num == 382;
		bool num4 = num == 70 || num == 528;
		bool num5 = num == 633 || num == 638;
		ushort num6 = 0;
		if (num5)
		{
			num6 = 638;
		}
		if (num4)
		{
			num6 = 528;
		}
		if (num3)
		{
			num6 = 115;
		}
		if (num2)
		{
			num6 = 62;
		}
		if (flag)
		{
			num6 = 636;
		}
		if (flag2)
		{
			num6 = 205;
		}
		if (flag3 && type != 382)
		{
			num6 = 52;
		}
		if (flag4)
		{
			num6 = 382;
		}
		if (num6 != 0 && num6 != type)
		{
			tileCache.type = num6;
			SquareTileFrame(i, j);
			return false;
		}
		bool flag5 = false;
		if (num == -1)
		{
			flag5 = true;
		}
		if ((type == 52 || type == 382) && num != 2 && num != 477 && num != 192)
		{
			flag5 = true;
		}
		if (type == 62 && num != 60 && num != 384 && num != 226)
		{
			flag5 = true;
		}
		if (type == 115 && num != 109 && num != 492)
		{
			flag5 = true;
		}
		if (type == 528 && num != 70)
		{
			flag5 = true;
		}
		if (type == 636 && num != 23 && num != 661)
		{
			flag5 = true;
		}
		if (type == 205 && num != 199 && num != 662)
		{
			flag5 = true;
		}
		if (type == 638 && num != 633)
		{
			flag5 = true;
		}
		if (flag5)
		{
			KillTile(i, j);
			return false;
		}
		return true;
	}

	private static void TileFrameImportant(int i, int j, int type, Tile tileCache, bool resetFrame)
	{
		switch (type)
		{
		case 518:
			CheckLilyPad(i, j);
			return;
		case 519:
			CheckCatTail(i, j);
			return;
		case 549:
			CheckUnderwaterPlant(549, i, j);
			return;
		case 571:
			CheckBamboo(i, j);
			return;
		}
		if (TileID.Sets.Torches[type])
		{
			CheckTorch(i, j);
			return;
		}
		switch (type)
		{
		case 442:
			CheckProjectilePressurePad(i, j);
			return;
		case 136:
		{
			Tile tile = Main.tile[i, j - 1];
			Tile tile2 = Main.tile[i, j + 1];
			Tile tile3 = Main.tile[i - 1, j];
			Tile tile4 = Main.tile[i + 1, j];
			Tile tile5 = Main.tile[i - 1, j + 1];
			Tile tile6 = Main.tile[i + 1, j + 1];
			Tile tile7 = Main.tile[i - 1, j - 1];
			Tile tile8 = Main.tile[i + 1, j - 1];
			int num = -1;
			int num2 = -1;
			int num3 = -1;
			int tree = -1;
			int tree2 = -1;
			int tree3 = -1;
			int tree4 = -1;
			if (tile != null && tile.nactive())
			{
				_ = tile.type;
			}
			if (tile2 != null && tile2.nactive() && !tile2.halfBrick() && !tile2.topSlope())
			{
				num = tile2.type;
			}
			if (tile3 != null && tile3.nactive())
			{
				num2 = tile3.type;
			}
			if (tile4 != null && tile4.nactive())
			{
				num3 = tile4.type;
			}
			if (tile5 != null && tile5.nactive())
			{
				tree = tile5.type;
			}
			if (tile6 != null && tile6.nactive())
			{
				tree2 = tile6.type;
			}
			if (tile7 != null && tile7.nactive())
			{
				tree3 = tile7.type;
			}
			if (tile8 != null && tile8.nactive())
			{
				tree4 = tile8.type;
			}
			if (num >= 0 && Main.tileSolid[num] && !Main.tileNoAttach[num] && tile2 != null && !tile2.halfBrick() && (tile2.slope() == 0 || tile2.bottomSlope()))
			{
				tileCache.frameX = 0;
			}
			else if ((num2 >= 0 && Main.tileSolid[num2] && !Main.tileNoAttach[num2] && tile3 != null && (tile3.leftSlope() || tile3.slope() == 0) && !tile3.halfBrick()) || (num2 >= 0 && TileID.Sets.IsBeam[num2]) || (IsTreeType(num2) && IsTreeType(tree3) && IsTreeType(tree)))
			{
				tileCache.frameX = 18;
			}
			else if ((num3 >= 0 && Main.tileSolid[num3] && !Main.tileNoAttach[num3] && tile4 != null && (tile4.rightSlope() || tile4.slope() == 0) && !tile4.halfBrick()) || (num3 >= 0 && TileID.Sets.IsBeam[num3]) || (IsTreeType(num3) && IsTreeType(tree4) && IsTreeType(tree2)))
			{
				tileCache.frameX = 36;
			}
			else if (tileCache.wall > 0)
			{
				tileCache.frameX = 54;
			}
			else
			{
				KillTile(i, j);
			}
			return;
		}
		case 129:
		case 149:
		{
			int frameY = tileCache.frameY;
			int newFrameDirection = 0;
			if (CheckAndAdjustMultiDirectionalTile(i, j, type, out newFrameDirection))
			{
				int num4 = frameY;
				switch (newFrameDirection)
				{
				case 0:
					num4 = 0;
					break;
				case 1:
					num4 = 18;
					break;
				case 2:
					num4 = 54;
					break;
				case 3:
					num4 = 36;
					break;
				}
				tileCache.frameY = (short)num4;
			}
			else
			{
				KillTile(i, j);
			}
			return;
		}
		}
		if (TileID.Sets.IsADripTile[type])
		{
			Tile tile9 = Main.tile[i, j - 1];
			if (tile9 == null || !tile9.active() || tile9.bottomSlope() || !Main.tileSolid[tile9.type] || Main.tileSolidTop[tile9.type])
			{
				KillTile(i, j);
			}
			return;
		}
		switch (type)
		{
		case 178:
		{
			int frameY2 = tileCache.frameY;
			int newFrameDirection2 = 0;
			if (CheckAndAdjustMultiDirectionalTile(i, j, type, out newFrameDirection2))
			{
				int num16 = ((!resetFrame) ? (tileCache.frameY % 54) : (genRand.Next(3) * 18));
				int num17 = -1;
				switch (newFrameDirection2)
				{
				case 0:
					if (frameY2 < 0 || frameY2 > 36)
					{
						num17 = 0;
					}
					break;
				case 1:
					if (frameY2 < 54 || frameY2 > 90)
					{
						num17 = 54;
					}
					break;
				case 2:
					if (frameY2 < 108 || frameY2 > 144)
					{
						num17 = 108;
					}
					break;
				case 3:
					if (frameY2 < 162 || frameY2 > 198)
					{
						num17 = 162;
					}
					break;
				}
				if (num17 > -1)
				{
					tileCache.frameY = (short)(num17 + num16);
				}
			}
			else
			{
				KillTile(i, j);
			}
			break;
		}
		case 184:
		{
			Tile tile31 = Main.tile[i, j - 1];
			Tile tile32 = Main.tile[i, j + 1];
			Tile tile33 = Main.tile[i - 1, j];
			Tile tile34 = Main.tile[i + 1, j];
			int num18 = -1;
			int num19 = -1;
			int num20 = -1;
			int num21 = -1;
			if (tile31 != null && tile31.active() && !tile31.bottomSlope())
			{
				num19 = tile31.type;
			}
			if (tile32 != null && tile32.active() && !tile32.halfBrick() && !tile32.topSlope())
			{
				num18 = tile32.type;
			}
			if (tile33 != null && tile33.active())
			{
				num20 = tile33.type;
			}
			if (tile34 != null && tile34.active())
			{
				num21 = tile34.type;
			}
			short num22 = (short)(genRand.Next(3) * 18);
			if (num18 >= 0 && GetTileMossColor(num18) != -1)
			{
				tileCache.frameX = (short)(22 * GetTileMossColor(num18));
				if (tileCache.frameY < 0 || tileCache.frameY > 36)
				{
					tileCache.frameY = num22;
				}
			}
			else if (num19 >= 0 && GetTileMossColor(num19) != -1)
			{
				tileCache.frameX = (short)(22 * GetTileMossColor(num19));
				if (tileCache.frameY < 54 || tileCache.frameY > 90)
				{
					tileCache.frameY = (short)(54 + num22);
				}
			}
			else if (num20 >= 0 && GetTileMossColor(num20) != -1)
			{
				tileCache.frameX = (short)(22 * GetTileMossColor(num20));
				if (tileCache.frameY < 108 || tileCache.frameY > 144)
				{
					tileCache.frameY = (short)(108 + num22);
				}
			}
			else if (num21 >= 0 && GetTileMossColor(num21) != -1)
			{
				tileCache.frameX = (short)(22 * GetTileMossColor(num21));
				if (tileCache.frameY < 162 || tileCache.frameY > 198)
				{
					tileCache.frameY = (short)(162 + num22);
				}
			}
			else
			{
				KillTile(i, j);
			}
			break;
		}
		case 529:
		{
			if (!SolidTileAllowBottomSlope(i, j + 1))
			{
				KillTile(i, j);
				break;
			}
			Tile tile30 = Main.tile[i, j + 1];
			_ = Main.tile[i, j].frameY / 34;
			if (tile30 == null || !tile30.active() || (tile30.type >= 0 && tile30.type < TileID.Count && !TileID.Sets.Conversion.Sand[tile30.type]))
			{
				KillTile(i, j);
			}
			break;
		}
		case 3:
		case 24:
		case 61:
		case 71:
		case 73:
		case 74:
		case 110:
		case 113:
		case 201:
		case 637:
		case 703:
			PlantCheck(i, j);
			break;
		case 227:
			CheckDye(i, j);
			break;
		case 579:
			CheckRockGolemHead(i, j);
			break;
		case 12:
		case 31:
		case 639:
		case 696:
			CheckOrb(i, j, type);
			break;
		case 165:
			CheckStalactite(i, j);
			break;
		case 693:
		case 694:
			CheckStalactiteEcho(i, j);
			break;
		case 324:
			if (!SolidTileAllowBottomSlope(i, j + 1))
			{
				KillTile(i, j);
			}
			if (InvalidTileForPilesOrSpeleothems(i, j + 1))
			{
				KillTile(i, j);
			}
			break;
		case 235:
			Check3x1(i, j, type);
			break;
		case 185:
			CheckPile(i, j);
			break;
		default:
			if (type != 296 && type != 297 && type != 309 && type != 358 && type != 359 && type != 413 && type != 414 && type != 542 && type != 550 && type != 551 && type != 553 && type != 554 && type != 558 && type != 559 && type != 599 && type != 600 && type != 601 && type != 602 && type != 603 && type != 604 && type != 605 && type != 606 && type != 607 && type != 608 && type != 609 && type != 610 && type != 611 && type != 612 && type != 632 && type != 640 && type != 643 && type != 644 && type != 645 && type != 710)
			{
				if (type == 10)
				{
					CheckDoorClosed(i, j, tileCache, type);
					break;
				}
				if (type == 11)
				{
					CheckDoorOpen(i, j, tileCache);
					break;
				}
				if (type == 314)
				{
					Minecart.FrameTrack(i, j, pound: false);
					HandleRopeEndFraming(i, j);
					break;
				}
				if (type == 380)
				{
					Tile tile10 = Main.tile[i, j - 1];
					if (tile10 == null)
					{
						break;
					}
					Tile tile11 = Main.tile[i, j + 1];
					if (tile11 == null)
					{
						break;
					}
					Tile tile12 = Main.tile[i - 1, j];
					if (tile12 == null)
					{
						break;
					}
					Tile tile13 = Main.tile[i + 1, j];
					if (tile13 == null)
					{
						break;
					}
					Tile tile14 = Main.tile[i - 1, j + 1];
					if (tile14 == null)
					{
						break;
					}
					Tile tile15 = Main.tile[i + 1, j + 1];
					if (tile15 == null)
					{
						break;
					}
					Tile tile16 = Main.tile[i - 1, j - 1];
					if (tile16 == null)
					{
						break;
					}
					Tile tile17 = Main.tile[i + 1, j - 1];
					if (tile17 != null)
					{
						TileMergeCullCache tileMergeCulling = GetTileMergeCulling(tileCache, tile10, tile11, tile12, tile13, tile14, tile15, tile16, tile17);
						int num5 = -1;
						int num6 = -1;
						if (tile12 != null && tile12.active())
						{
							num6 = (Main.tileStone[tile12.type] ? 1 : tile12.type);
						}
						if (tile13 != null && tile13.active())
						{
							num5 = (Main.tileStone[tile13.type] ? 1 : tile13.type);
						}
						if (num5 >= 0 && tileMergeCulling.CullRight)
						{
							num5 = -1;
						}
						if (num6 >= 0 && tileMergeCulling.CullLeft)
						{
							num6 = -1;
						}
						if (num5 >= 0 && !Main.tileSolid[num5])
						{
							num5 = -1;
						}
						if (num6 >= 0 && !Main.tileSolid[num6])
						{
							num6 = -1;
						}
						int num7 = ((num6 == type && num5 == type) ? 18 : ((num6 == type && num5 != type) ? 36 : ((num6 == type || num5 != type) ? 54 : 0)));
						tileCache.frameX = (short)num7;
						HandleRopeEndFraming(i, j);
					}
					break;
				}
				if (type >= 0 && TileID.Sets.Platforms[type])
				{
					Tile tile18 = Main.tile[i, j - 1];
					if (tile18 == null)
					{
						break;
					}
					Tile tile19 = Main.tile[i, j + 1];
					if (tile19 == null)
					{
						break;
					}
					Tile tile20 = Main.tile[i - 1, j];
					if (tile20 == null)
					{
						break;
					}
					Tile tile21 = Main.tile[i + 1, j];
					if (tile21 == null)
					{
						break;
					}
					Tile tile22 = Main.tile[i - 1, j + 1];
					if (tile22 == null)
					{
						break;
					}
					Tile tile23 = Main.tile[i + 1, j + 1];
					if (tile23 == null)
					{
						break;
					}
					Tile tile24 = Main.tile[i - 1, j - 1];
					if (tile24 == null)
					{
						break;
					}
					Tile tile25 = Main.tile[i + 1, j - 1];
					if (tile25 != null)
					{
						TileMergeCullCache tileMergeCulling2 = GetTileMergeCulling(tileCache, tile18, tile19, tile20, tile21, tile22, tile23, tile24, tile25);
						int num8 = -1;
						int num9 = -1;
						if (tile20 != null && tile20.active())
						{
							num9 = (Main.tileStone[tile20.type] ? 1 : ((!TileID.Sets.Platforms[tile20.type]) ? tile20.type : type));
						}
						if (tile21 != null && tile21.active())
						{
							num8 = (Main.tileStone[tile21.type] ? 1 : ((!TileID.Sets.Platforms[tile21.type]) ? tile21.type : type));
						}
						if (num8 >= 0 && tileMergeCulling2.CullRight)
						{
							num8 = -1;
						}
						if (num9 >= 0 && tileMergeCulling2.CullLeft)
						{
							num9 = -1;
						}
						if (num8 >= 0 && !Main.tileSolid[num8])
						{
							num8 = -1;
						}
						if (num9 >= 0 && !Main.tileSolid[num9])
						{
							num9 = -1;
						}
						if (num9 == type && tile20.halfBrick() != tileCache.halfBrick())
						{
							num9 = -1;
						}
						if (num8 == type && tile21.halfBrick() != tileCache.halfBrick())
						{
							num8 = -1;
						}
						if (num9 != -1 && num9 != type && tileCache.halfBrick())
						{
							num9 = -1;
						}
						if (num8 != -1 && num8 != type && tileCache.halfBrick())
						{
							num8 = -1;
						}
						if (num9 == -1 && tile24.active() && tile24.type == type && tile24.slope() == 1 && !tileMergeCulling2.CullTopLeft)
						{
							num9 = type;
						}
						if (num8 == -1 && tile25.active() && tile25.type == type && tile25.slope() == 2 && !tileMergeCulling2.CullTopRight)
						{
							num8 = type;
						}
						if (num9 == type && tile20.slope() == 2 && num8 != type)
						{
							num8 = -1;
						}
						if (num8 == type && tile21.slope() == 1 && num9 != type)
						{
							num9 = -1;
						}
						int num10 = ((tileCache.slope() == 1) ? ((TileID.Sets.Platforms[tile21.type] && tile21.slope() == 0 && !tile21.halfBrick() && !tileMergeCulling2.CullRight) ? 468 : (((!tile23.active() || tileMergeCulling2.CullBottomRight) && (!TileID.Sets.Platforms[tile23.type] || tile23.slope() == 2 || tileMergeCulling2.CullBottomRight)) ? (((tile20.active() && !tileMergeCulling2.CullLeft) || (TileID.Sets.Platforms[tile24.type] && tile24.slope() == 1 && !tileMergeCulling2.CullTopLeft)) ? 360 : 432) : (((tile20.active() && !tileMergeCulling2.CullLeft) || (TileID.Sets.Platforms[tile24.type] && tile24.slope() == 1 && !tileMergeCulling2.CullTopLeft)) ? 180 : 396))) : ((tileCache.slope() == 2) ? ((TileID.Sets.Platforms[tile20.type] && tile20.slope() == 0 && !tile20.halfBrick() && !tileMergeCulling2.CullLeft) ? 450 : (((!tile22.active() || tileMergeCulling2.CullBottomLeft) && (!TileID.Sets.Platforms[tile22.type] || tile22.slope() == 1 || tileMergeCulling2.CullBottomLeft)) ? (((tile21.active() && !tileMergeCulling2.CullRight) || (TileID.Sets.Platforms[tile25.type] && tile25.slope() == 2 && !tileMergeCulling2.CullTopRight)) ? 342 : 414) : (((tile21.active() && !tileMergeCulling2.CullRight) || (TileID.Sets.Platforms[tile25.type] && tile25.slope() == 2 && !tileMergeCulling2.CullTopRight)) ? 144 : 378))) : ((num9 == type && num8 == type) ? ((tile20.slope() == 2 && tile21.slope() == 1) ? 252 : ((tile20.slope() == 2) ? 216 : ((tile21.slope() == 1) ? 234 : 0))) : ((num9 == type && num8 == -1) ? ((tile20.slope() != 2) ? 18 : 270) : ((num9 == -1 && num8 == type) ? ((tile21.slope() != 1) ? 36 : 288) : ((num9 != type && num8 == type) ? 54 : ((num9 == type && num8 != type) ? 72 : ((num9 != type && num9 != -1 && num8 == -1) ? 108 : ((num9 != -1 || num8 == type || num8 == -1) ? 90 : 126)))))))));
						tileCache.frameX = (short)num10;
						HandleRopeEndFraming(i, j);
					}
					break;
				}
				switch (type)
				{
				case 233:
				case 236:
				case 238:
				case 702:
					CheckJunglePlant(i, j, type);
					break;
				case 530:
					CheckOasisPlant(i, j, type);
					break;
				case 240:
				case 440:
					Check3x3Wall(i, j);
					break;
				case 245:
					Check2x3Wall(i, j);
					break;
				case 246:
					Check3x2Wall(i, j);
					break;
				case 241:
					Check4x3Wall(i, j);
					break;
				case 242:
					Check6x4Wall(i, j);
					break;
				case 464:
				case 466:
					Check5x4(i, j, type);
					break;
				case 334:
					CheckWeaponsRack(i, j);
					break;
				case 471:
					TEWeaponsRack.Framing_CheckTile(i, j);
					break;
				case 34:
				case 454:
					CheckChand(i, j, type);
					break;
				case 547:
				case 623:
					Check2x5(i, j, type);
					break;
				case 548:
				case 614:
					Check3x6(i, j, type);
					break;
				case 613:
					Check3x5(i, j, type);
					break;
				default:
					if (type != 354 && type != 406 && type != 412 && type != 355 && type != 452 && type != 455 && type != 491 && type != 499 && type != 642 && type != 733)
					{
						switch (type)
						{
						case 15:
						case 20:
						case 216:
						case 338:
						case 390:
						case 493:
						case 497:
						case 590:
						case 595:
						case 615:
							Check1x2(i, j, (ushort)type);
							break;
						default:
							if (type < 391 || type > 394)
							{
								switch (type)
								{
								case 405:
								case 486:
								case 488:
								case 532:
								case 533:
								case 544:
								case 552:
								case 555:
								case 556:
								case 582:
								case 619:
								case 629:
								case 647:
								case 648:
								case 651:
								case 695:
								case 704:
								case 705:
								case 706:
									break;
								case 36:
								case 135:
								case 141:
								case 210:
								case 239:
								case 428:
								case 593:
								case 624:
								case 650:
								case 656:
								case 700:
								case 701:
									Check1x1(i, j, type);
									return;
								case 476:
									CheckGolf1x1(i, j, type);
									return;
								case 494:
									CheckGolf1x1(i, j, type);
									return;
								case 419:
								case 420:
								case 423:
								case 424:
								case 429:
								case 445:
									CheckLogicTiles(i, j, type);
									return;
								case 16:
								case 18:
								case 29:
								case 103:
								case 134:
								case 462:
								case 649:
									Check2x1(i, j, (ushort)type);
									return;
								case 13:
								case 33:
								case 49:
								case 50:
								case 78:
								case 174:
								case 372:
								case 646:
								case 707:
									CheckOnTable1x1(i, j, type);
									return;
								default:
									if (TileID.Sets.BasicChest[type])
									{
										CheckChest(i, j, type);
										return;
									}
									switch (type)
									{
									case 128:
										CheckMan(i, j);
										break;
									case 269:
										CheckWoman(i, j);
										break;
									case 470:
										TEDisplayDoll.Framing_CheckTile(i, j);
										break;
									case 475:
										TEHatRack.Framing_CheckTile(i, j);
										break;
									case 597:
										TETeleportationPylon.Framing_CheckTile(i, j);
										break;
									case 27:
										CheckSunflower(i, j);
										break;
									case 28:
									case 653:
										CheckPot(i, j, type);
										break;
									case 171:
										CheckXmasTree(i, j);
										break;
									default:
										if (!TileID.Sets.BasicChestFake[type] && type != 457)
										{
											switch (type)
											{
											case 335:
											case 411:
											case 490:
											case 564:
											case 565:
											case 594:
												Check2x2(i, j, type);
												break;
											default:
												if (type < 316 || type > 318)
												{
													switch (type)
													{
													case 172:
													case 360:
													case 505:
													case 521:
													case 522:
													case 523:
													case 524:
													case 525:
													case 526:
													case 527:
													case 543:
													case 568:
													case 569:
													case 570:
													case 580:
													case 598:
													case 620:
													case 652:
													case 654:
													case 713:
													case 714:
													case 715:
													case 716:
													case 751:
													case 752:
														break;
													case 376:
													case 443:
													case 444:
													case 485:
														CheckSuper(i, j, type);
														return;
													case 91:
														CheckBanner(i, j, (byte)type);
														return;
													case 35:
													case 139:
														CheckMB(i, j, (byte)type);
														return;
													case 386:
													case 387:
														CheckTrapDoor(i, j, type);
														return;
													case 388:
													case 389:
														CheckTallGate(i, j, type);
														return;
													case 92:
													case 93:
													case 453:
														Check1xX(i, j, (short)type);
														return;
													case 104:
													case 105:
													case 207:
													case 320:
													case 337:
													case 349:
													case 356:
													case 378:
													case 410:
													case 456:
													case 465:
													case 480:
													case 489:
													case 506:
													case 509:
													case 531:
													case 545:
													case 560:
													case 591:
													case 592:
													case 657:
													case 658:
													case 663:
													case 720:
													case 721:
													case 725:
														Check2xX(i, j, (ushort)type);
														return;
													case 101:
													case 102:
													case 463:
													case 617:
														Check3x4(i, j, type);
														return;
													case 42:
													case 270:
													case 271:
													case 572:
													case 581:
													case 660:
													case 698:
														Check1x2Top(i, j, (ushort)type);
														return;
													case 55:
													case 85:
													case 395:
													case 425:
													case 510:
													case 511:
													case 573:
														CheckSign(i, j, (ushort)type);
														return;
													case 520:
														CheckFoodPlatter(i, j, (ushort)type);
														return;
													case 209:
														CheckCannon(i, j, type);
														return;
													case 79:
													case 90:
													case 487:
														Check4x2(i, j, type);
														return;
													case 699:
														Check4x4(i, j, (ushort)type);
														return;
													case 94:
													case 95:
													case 97:
													case 98:
													case 99:
													case 100:
													case 125:
													case 126:
													case 173:
													case 282:
													case 287:
													case 319:
													case 621:
													case 622:
														Check2x2(i, j, type);
														return;
													case 96:
														Check2x2Style(i, j, type);
														return;
													case 81:
													{
														Tile tile28 = Main.tile[i, j - 1];
														Tile tile29 = Main.tile[i, j + 1];
														_ = Main.tile[i - 1, j];
														_ = Main.tile[i + 1, j];
														int num14 = -1;
														int num15 = -1;
														if (tile28 != null && tile28.active())
														{
															num15 = tile28.type;
														}
														if (tile29 != null && tile29.active())
														{
															num14 = tile29.type;
														}
														if (num15 != -1)
														{
															KillTile(i, j);
														}
														else if (num14 < 0 || !Main.tileSolid[num14] || (tile29 != null && (tile29.halfBrick() || tile29.topSlope())))
														{
															KillTile(i, j);
														}
														return;
													}
													default:
														if (Main.tileAlch[type])
														{
															CheckAlch(i, j);
															return;
														}
														switch (type)
														{
														case 72:
														{
															Tile tile26 = Main.tile[i, j - 1];
															Tile tile27 = Main.tile[i, j + 1];
															int num11 = -1;
															int num12 = -1;
															if (tile26 != null && tile26.active())
															{
																num12 = tile26.type;
															}
															if (tile27 != null && tile27.active())
															{
																num11 = tile27.type;
															}
															if (num11 != type && num11 != 70)
															{
																KillTile(i, j);
															}
															else if (num12 != type && tileCache.frameX == 0)
															{
																int num13 = genRand.Next(3);
																if (num13 == 0)
																{
																	tileCache.frameX = 18;
																	tileCache.frameY = 0;
																}
																if (num13 == 1)
																{
																	tileCache.frameX = 18;
																	tileCache.frameY = 18;
																}
																if (num13 == 2)
																{
																	tileCache.frameX = 18;
																	tileCache.frameY = 36;
																}
															}
															break;
														}
														case 5:
															CheckTree(i, j);
															break;
														case 583:
														case 584:
														case 585:
														case 586:
														case 587:
														case 588:
														case 589:
															CheckTreeWithSettings(i, j, new CheckTreeSettings
															{
																IsGroundValid = GemTreeGroundTest
															});
															break;
														case 596:
															CheckTreeWithSettings(i, j, new CheckTreeSettings
															{
																IsGroundValid = VanityTreeGroundTest
															});
															break;
														case 616:
															CheckTreeWithSettings(i, j, new CheckTreeSettings
															{
																IsGroundValid = VanityTreeGroundTest
															});
															break;
														case 634:
															CheckTreeWithSettings(i, j, new CheckTreeSettings
															{
																IsGroundValid = AshTreeGroundTest
															});
															break;
														case 323:
															CheckPalmTree(i, j);
															break;
														case 567:
															CheckGnome(i, j);
															break;
														case 630:
														case 631:
															CheckStinkbugBlocker(i, j);
															break;
														case 723:
															CheckKiteAnchor(i, j);
															break;
														}
														return;
													}
												}
												goto case 132;
											case 132:
											case 138:
											case 142:
											case 143:
											case 288:
											case 289:
											case 290:
											case 291:
											case 292:
											case 293:
											case 294:
											case 295:
											case 484:
											case 664:
											case 665:
											case 711:
											case 712:
												Check2x2(i, j, type);
												break;
											}
											break;
										}
										goto case 254;
									case 254:
										Check2x2Style(i, j, type);
										break;
									}
									return;
								}
							}
							goto case 14;
						case 14:
						case 17:
						case 26:
						case 77:
						case 86:
						case 87:
						case 88:
						case 89:
						case 114:
						case 133:
						case 186:
						case 187:
						case 215:
						case 217:
						case 218:
						case 237:
						case 244:
						case 285:
						case 286:
						case 298:
						case 299:
						case 310:
						case 339:
						case 361:
						case 362:
						case 363:
						case 364:
						case 377:
						case 469:
						case 538:
							Check3x2(i, j, (ushort)type);
							break;
						}
						break;
					}
					goto case 106;
				case 106:
				case 212:
				case 219:
				case 220:
				case 228:
				case 231:
				case 243:
				case 247:
				case 283:
				case 300:
				case 301:
				case 302:
				case 303:
				case 304:
				case 305:
				case 306:
				case 307:
				case 308:
					Check3x3(i, j, (ushort)type);
					break;
				}
				break;
			}
			goto case 275;
		case 275:
		case 276:
		case 277:
		case 278:
		case 279:
		case 280:
		case 281:
			Check6x3(i, j, type);
			break;
		}
	}

	private static void StopMergingByInvsibility(ref int currentMerge, Tile block, bool wantedInvisibilityState)
	{
		if (currentMerge > -1 && block.invisibleBlock() != wantedInvisibilityState)
		{
			currentMerge = -1;
		}
	}

	private static bool SpawnFallingBlockProjectile(int i, int j, int type, Tile tileCache)
	{
		if (Main.netMode == 1)
		{
			return false;
		}
		Tile tile = Main.tile[i, j - 1];
		Tile tile2 = Main.tile[i, j + 1];
		if (tileCache == null || tile == null || tile2 == null)
		{
			return false;
		}
		if (!BlockBelowMakesSandFall(i, j))
		{
			return false;
		}
		if (!AllowsSandfall(tile))
		{
			return false;
		}
		GetSandfallProjData(type, out var projType, out var dmg);
		tileCache.ClearTile();
		if (Main.netMode == 0)
		{
			int num = Projectile.NewProjectile(GetProjectileSource_TileBreak(i, j), i * 16 + 8, j * 16 + 8, 0f, 0.41f, projType, dmg, 0f, Main.myPlayer);
			Main.projectile[num].ai[0] = 1f;
			SquareTileFrame(i, j);
			ExploitDestroyQueue.Enqueue(new Point(i, j));
			ExploitDestroyQueue.Enqueue(new Point(i, j - 1));
		}
		if (Main.netMode == 2)
		{
			bool flag = false;
			for (int k = 0; k < 1000; k++)
			{
				if (Main.projectile[k].active && Main.projectile[k].owner == Main.myPlayer && Main.projectile[k].type == projType && Math.Abs(Main.projectile[k].timeLeft - 3600) < 60 && Main.projectile[k].Distance(new Vector2(i * 16 + 8, j * 16 + 10)) < 4f)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				int num2 = Projectile.NewProjectile(GetProjectileSource_TileBreak(i, j), i * 16 + 8, j * 16 + 8, 0f, 2.5f, projType, dmg, 0f, Main.myPlayer);
				Main.projectile[num2].velocity.Y = 0.5f;
				Main.projectile[num2].position.Y += 2f;
				Main.projectile[num2].netUpdate = true;
			}
			SquareTileFrame(i, j);
			NetMessage.SendTileSquare(-1, i, j);
			ExploitDestroyQueue.Enqueue(new Point(i, j));
			ExploitDestroyQueue.Enqueue(new Point(i, j - 1));
		}
		return true;
	}

	public static void CheckTorch(int x, int y)
	{
		for (int i = x - 1; i <= x + 1; i++)
		{
			for (int j = y - 1; j <= y + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					return;
				}
			}
		}
		Tile tile = Main.tile[x, y];
		Tile tile2 = Main.tile[x, y - 1];
		Tile tile3 = Main.tile[x, y + 1];
		Tile tile4 = Main.tile[x - 1, y];
		Tile tile5 = Main.tile[x + 1, y];
		Tile tile6 = Main.tile[x - 1, y + 1];
		Tile tile7 = Main.tile[x + 1, y + 1];
		Tile tile8 = Main.tile[x - 1, y - 1];
		Tile tile9 = Main.tile[x + 1, y - 1];
		short num = 0;
		if (tile.frameX >= 66)
		{
			num = 66;
		}
		int num2 = -1;
		int num3 = -1;
		int num4 = -1;
		int tree = -1;
		int tree2 = -1;
		int tree3 = -1;
		int tree4 = -1;
		if (tile2 != null && tile2.active() && !tile2.bottomSlope())
		{
			_ = tile2.type;
		}
		if (tile3 != null && tile3.active() && ((TileID.Sets.Platforms[tile3.type] && TopEdgeCanBeAttachedTo(x, y + 1)) || (!tile3.halfBrick() && !tile3.topSlope())))
		{
			num2 = tile3.type;
		}
		if (tile4 != null && tile4.active() && (tile4.slope() == 0 || tile4.slope() % 2 != 1))
		{
			num3 = tile4.type;
		}
		if (tile5 != null && tile5.active() && (tile5.slope() == 0 || tile5.slope() % 2 != 0))
		{
			num4 = tile5.type;
		}
		if (tile6 != null && tile6.active())
		{
			tree = tile6.type;
		}
		if (tile7 != null && tile7.active())
		{
			tree2 = tile7.type;
		}
		if (tile8 != null && tile8.active())
		{
			tree3 = tile8.type;
		}
		if (tile9 != null && tile9.active())
		{
			tree4 = tile9.type;
		}
		if (num2 >= 0 && Main.tileSolid[num2] && (!Main.tileNoAttach[num2] || TileID.Sets.Platforms[num2]))
		{
			tile.frameX = num;
		}
		else if ((num3 >= 0 && Main.tileSolid[num3] && !Main.tileNoAttach[num3]) || (num3 >= 0 && TileID.Sets.IsBeam[num3]) || (IsTreeType(num3) && IsTreeType(tree3) && IsTreeType(tree)))
		{
			tile.frameX = (short)(22 + num);
		}
		else if ((num4 >= 0 && Main.tileSolid[num4] && !Main.tileNoAttach[num4]) || (num4 >= 0 && TileID.Sets.IsBeam[num4]) || (IsTreeType(num4) && IsTreeType(tree4) && IsTreeType(tree2)))
		{
			tile.frameX = (short)(44 + num);
		}
		else if (tile.wall > 0)
		{
			tile.frameX = num;
		}
		else
		{
			KillTile(x, y);
		}
	}

	public static void CheckProjectilePressurePad(int i, int j)
	{
		CheckProjectilePressurePad_GetPossiblePlacementDirections(i, j, out var canUp, out var canLeft, out var canRight, out var canDown);
		Tile tile = Main.tile[i, j];
		int num = tile.frameX / 22;
		bool flag = false;
		if (num switch
		{
			0 => !canDown, 
			1 => !canUp, 
			2 => !canLeft, 
			3 => !canRight, 
			_ => true, 
		})
		{
			if (canDown)
			{
				tile.frameX = 0;
			}
			else if (canUp)
			{
				tile.frameX = 22;
			}
			else if (canLeft)
			{
				tile.frameX = 44;
			}
			else if (canRight)
			{
				tile.frameX = 66;
			}
			else
			{
				KillTile(i, j);
			}
		}
	}

	private static void CheckProjectilePressurePad_GetPossiblePlacementDirections(int i, int j, out bool canUp, out bool canLeft, out bool canRight, out bool canDown)
	{
		canUp = false;
		canLeft = false;
		canRight = false;
		canDown = false;
		_ = Main.tile[i, j];
		Tile tile = Main.tile[i, j - 1];
		Tile tile2 = Main.tile[i, j + 1];
		Tile tile3 = Main.tile[i - 1, j];
		Tile tile4 = Main.tile[i + 1, j];
		Tile tile5 = Main.tile[i - 1, j + 1];
		Tile tile6 = Main.tile[i + 1, j + 1];
		Tile tile7 = Main.tile[i - 1, j - 1];
		Tile tile8 = Main.tile[i + 1, j - 1];
		int num = -1;
		int num2 = -1;
		int num3 = -1;
		int num4 = -1;
		int tree = -1;
		int tree2 = -1;
		int tree3 = -1;
		int tree4 = -1;
		if (tile != null && tile.nactive() && !tile.bottomSlope())
		{
			num2 = tile.type;
		}
		if (tile2 != null && tile2.nactive() && !tile2.halfBrick() && !tile2.topSlope())
		{
			num = tile2.type;
		}
		if (tile3 != null && tile3.nactive() && (tile3.slope() == 0 || tile3.slope() % 2 != 1))
		{
			num3 = tile3.type;
		}
		if (tile4 != null && tile4.nactive() && (tile4.slope() == 0 || tile4.slope() % 2 != 0))
		{
			num4 = tile4.type;
		}
		if (tile5 != null && tile5.nactive())
		{
			tree = tile5.type;
		}
		if (tile6 != null && tile6.nactive())
		{
			tree2 = tile6.type;
		}
		if (tile7 != null && tile7.nactive())
		{
			tree3 = tile7.type;
		}
		if (tile8 != null && tile8.nactive())
		{
			tree4 = tile8.type;
		}
		if (num >= 0 && Main.tileSolid[num] && (!Main.tileNoAttach[num] || TileID.Sets.Platforms[num]) && (tile2.bottomSlope() || tile2.slope() == 0) && !tile2.halfBrick())
		{
			canDown = true;
		}
		if (num2 >= 0 && Main.tileSolid[num2] && (!Main.tileNoAttach[num2] || (TileID.Sets.Platforms[num2] && tile.halfBrick())) && (tile.topSlope() || tile.slope() == 0 || tile.halfBrick()))
		{
			canUp = true;
		}
		if ((num3 >= 0 && Main.tileSolid[num3] && !Main.tileNoAttach[num3] && (tile3.leftSlope() || tile3.slope() == 0) && !tile3.halfBrick()) || (num3 >= 0 && TileID.Sets.IsBeam[num3]) || (IsTreeType(num3) && IsTreeType(tree3) && IsTreeType(tree)))
		{
			canLeft = true;
		}
		if ((num4 >= 0 && Main.tileSolid[num4] && !Main.tileNoAttach[num4] && (tile4.rightSlope() || tile4.slope() == 0) && !tile4.halfBrick()) || (num4 >= 0 && TileID.Sets.IsBeam[num4]) || (IsTreeType(num4) && IsTreeType(tree4) && IsTreeType(tree2)))
		{
			canRight = true;
		}
	}

	public static bool IsTreeType(int tree)
	{
		if (tree >= 0)
		{
			return TileID.Sets.IsATreeTrunk[tree];
		}
		return false;
	}

	public static int CanPlaceProjectilePressurePad(int x, int y, int type = 442, int style = 0, int direction = 0, int alternate = 0)
	{
		CheckProjectilePressurePad_GetPossiblePlacementDirections(x, y, out var canUp, out var canLeft, out var canRight, out var canDown);
		if (!canUp && !canDown && !canLeft && !canRight)
		{
			return -1;
		}
		switch (alternate)
		{
		case 0:
			if (!canDown)
			{
				return -1;
			}
			break;
		case 1:
			if (!canUp)
			{
				return -1;
			}
			break;
		case 2:
			if (!canLeft)
			{
				return -1;
			}
			break;
		case 3:
			if (!canRight)
			{
				return -1;
			}
			break;
		}
		return style;
	}

	private static void CheckDoorOpen(int i, int j, Tile tileCache)
	{
		if (destroyObject)
		{
			return;
		}
		int num = 0;
		int num2 = i;
		int num3 = j;
		short frameX = tileCache.frameX;
		int frameY = tileCache.frameY;
		int num4 = frameY / 54;
		num4 += tileCache.frameX / 72 * 36;
		num3 = j - frameY % 54 / 18;
		bool flag = false;
		switch (frameX % 72)
		{
		case 0:
			num2 = i;
			num = 1;
			break;
		case 18:
			num2 = i - 1;
			num = 1;
			break;
		case 36:
			num2 = i + 1;
			num = -1;
			break;
		case 54:
			num2 = i;
			num = -1;
			break;
		}
		Tile tile = Main.tile[num2, num3 - 1];
		Tile tile2 = Main.tile[num2, num3 + 3];
		if (tile == null)
		{
			tile = new Tile();
			Main.tile[num2, num3 - 1] = tile;
		}
		if (tile2 == null)
		{
			tile2 = new Tile();
			Main.tile[num2, num3 + 3] = tile2;
		}
		if (!SolidTile(tile) || !SolidTile(tile2))
		{
			flag = true;
		}
		int num5 = num2;
		if (num == -1)
		{
			num5 = num2 - 1;
		}
		if (!flag)
		{
			for (int k = num5; k < num5 + 2; k++)
			{
				for (int l = num3; l < num3 + 3; l++)
				{
					Tile tile3 = Main.tile[k, l];
					if (tile3 != null && (!tile3.active() || tile3.type != 11))
					{
						flag = true;
						break;
					}
				}
				if (flag)
				{
					break;
				}
			}
		}
		if (flag)
		{
			destroyObject = true;
			DropDoorItem(i, j, num4);
			for (int m = num5; m < num5 + 2; m++)
			{
				for (int n = num3; n < num3 + 3; n++)
				{
					Tile tile4 = Main.tile[m, n];
					if (tile4 != null && tile4.active() && tile4.type == 11)
					{
						KillTile(m, n);
					}
				}
			}
		}
		destroyObject = false;
		CheckExploitDestroyQueue();
	}

	private static void CheckDoorClosed(int i, int j, Tile tileCache, int type)
	{
		if (destroyObject)
		{
			return;
		}
		int num = j;
		bool flag = false;
		int frameY = tileCache.frameY;
		int num2 = frameY / 54;
		num2 += tileCache.frameX / 54 * 36;
		num = j - frameY % 54 / 18;
		Tile tile = Main.tile[i, num - 1];
		Tile tile2 = Main.tile[i, num];
		Tile tile3 = Main.tile[i, num + 1];
		Tile tile4 = Main.tile[i, num + 2];
		Tile tile5 = Main.tile[i, num + 3];
		if (tile == null)
		{
			tile = new Tile();
			Main.tile[i, num - 1] = tile;
		}
		if (tile2 == null)
		{
			tile2 = new Tile();
			Main.tile[i, num] = tile2;
		}
		if (tile3 == null)
		{
			tile3 = new Tile();
			Main.tile[i, num + 1] = tile3;
		}
		if (tile4 == null)
		{
			tile4 = new Tile();
			Main.tile[i, num + 2] = tile4;
		}
		if (tile5 == null)
		{
			tile5 = new Tile();
			Main.tile[i, num + 3] = tile5;
		}
		if (!SolidTile(tile))
		{
			flag = true;
		}
		if (!SolidTile(tile5))
		{
			flag = true;
		}
		if (!tile2.active() || tile2.type != type)
		{
			flag = true;
		}
		if (!tile3.active() || tile3.type != type)
		{
			flag = true;
		}
		if (!tile4.active() || tile4.type != type)
		{
			flag = true;
		}
		if (flag)
		{
			destroyObject = true;
			if (tile2.type == 10)
			{
				KillTile(i, num);
			}
			if (tile3.type == 10)
			{
				KillTile(i, num + 1);
			}
			if (tile4.type == 10)
			{
				KillTile(i, num + 2);
			}
			DropDoorItem(i, j, num2);
		}
		destroyObject = false;
		CheckExploitDestroyQueue();
	}

	private static void GetSandfallProjData(int type, out int projType, out int dmg)
	{
		dmg = 10;
		switch (type)
		{
		case 112:
			projType = 56;
			break;
		case 59:
			projType = 39;
			break;
		case 116:
			projType = 67;
			break;
		case 123:
			projType = 71;
			break;
		case 224:
			projType = 179;
			break;
		case 234:
			projType = 241;
			break;
		case 330:
			projType = 411;
			dmg = 0;
			break;
		case 331:
			projType = 412;
			dmg = 0;
			break;
		case 332:
			projType = 413;
			dmg = 0;
			break;
		case 333:
			projType = 414;
			dmg = 0;
			break;
		case 495:
			projType = 812;
			break;
		default:
			projType = 31;
			break;
		}
	}

	public static bool BlockBelowMakesSandConvertIntoHardenedSand(int i, int j)
	{
		bool result = false;
		if (j >= Main.maxTilesY - 1)
		{
			return false;
		}
		Tile tile = Main.tile[i, j + 1];
		if (tile == null)
		{
			return false;
		}
		if (!tile.nactive())
		{
			result = true;
		}
		else if (tile.type >= 0 && tile.type < TileID.Count && !Main.tileSolid[tile.type])
		{
			result = true;
		}
		return result;
	}

	public static bool BlockBelowMakesSandFall(int i, int j)
	{
		bool result = false;
		if (j >= Main.maxTilesY - 1)
		{
			return false;
		}
		Tile tile = Main.tile[i, j + 1];
		if (tile == null)
		{
			return false;
		}
		if (!tile.nactive())
		{
			result = true;
		}
		else if (!Main.tile[i, j + 2].nactive() && (!tile.active() || !Main.tileSolid[tile.type]))
		{
			result = true;
		}
		else if (tile.active() && tile.type == 165)
		{
			result = true;
		}
		return result;
	}

	public static bool AllowsSandfall(Tile tileTopCache)
	{
		if (tileTopCache == null)
		{
			return false;
		}
		bool result = true;
		if (tileTopCache.active() && (TileID.Sets.BasicChest[tileTopCache.type] || TileID.Sets.BasicChestFake[tileTopCache.type] || tileTopCache.type == 323 || tileTopCache.type == 88 || tileTopCache.type == 80 || tileTopCache.type == 77 || tileTopCache.type == 26 || tileTopCache.type == 475 || tileTopCache.type == 470 || tileTopCache.type == 597))
		{
			result = false;
		}
		return result;
	}

	public static void TriggerLunarApocalypse()
	{
		List<int> list = new List<int> { 517, 422, 507, 493 };
		int[] array = new int[4];
		for (int i = 0; i < 4; i++)
		{
			array[i] = list[Main.rand.Next(list.Count)];
			list.Remove(array[i]);
		}
		int num = Main.maxTilesX / 5;
		int num2 = (int)Main.worldSurface;
		for (int j = 0; j < 4; j++)
		{
			int num3 = num * (1 + j);
			bool flag = false;
			for (int k = 0; k < 30; k++)
			{
				int num4 = Main.rand.Next(-100, 101);
				if ((Main.remixWorld && Main.getGoodWorld) || !Main.isThereAWorldSurface)
				{
					int num5 = Main.rand.Next((int)Main.worldSurface, Main.maxTilesY - 350);
					if (!Main.isThereAWorldSurface)
					{
						num5 = Main.rand.Next((int)Main.rockLayer, Main.maxTilesY - 350);
					}
					if (!PlayerLOS(num3 + num4 - 10, num5) && !PlayerLOS(num3 + num4 + 10, num5) && !PlayerLOS(num3 + num4 - 10, num5 - 20) && !PlayerLOS(num3 + num4 + 10, num5 - 20))
					{
						int num6 = NPC.NewNPC(new EntitySource_WorldEvent(), (num3 + num4) * 16, num5 * 16, array[j]);
						if (Main.netMode == 2 && num6 < Main.maxNPCs)
						{
							NetMessage.SendData(23, -1, -1, null, num6);
						}
						flag = true;
						break;
					}
					continue;
				}
				for (int num7 = num2; num7 > 100; num7--)
				{
					if (!Collision.SolidTiles(num3 + num4 - 10, num3 + num4 + 10, num7 - 20, num7 + 15) && !PlayerLOS(num3 + num4 - 10, num7) && !PlayerLOS(num3 + num4 + 10, num7) && !PlayerLOS(num3 + num4 - 10, num7 - 20) && !PlayerLOS(num3 + num4 + 10, num7 - 20))
					{
						int num8 = NPC.NewNPC(new EntitySource_WorldEvent(), (num3 + num4) * 16, num7 * 16, array[j]);
						if (Main.netMode == 2 && num8 < Main.maxNPCs)
						{
							NetMessage.SendData(23, -1, -1, null, num8);
						}
						flag = true;
						break;
					}
				}
				if (flag)
				{
					break;
				}
			}
			if (!flag)
			{
				NPC.NewNPC(new EntitySource_WorldEvent(), num3 * 16, (num2 - 40) * 16, array[j]);
			}
		}
		NPC.TowerActiveVortex = (NPC.TowerActiveNebula = (NPC.TowerActiveSolar = (NPC.TowerActiveStardust = true)));
		NPC.LunarApocalypseIsUp = true;
		NPC.ShieldStrengthTowerSolar = (NPC.ShieldStrengthTowerVortex = (NPC.ShieldStrengthTowerNebula = (NPC.ShieldStrengthTowerStardust = NPC.ShieldStrengthTowerMax)));
		NetMessage.SendData(101);
		MessageLunarApocalypse();
	}

	public static void UpdateLunarApocalypse()
	{
		if (!NPC.LunarApocalypseIsUp)
		{
			return;
		}
		bool flag = false;
		bool flag2 = false;
		bool flag3 = false;
		bool flag4 = false;
		bool flag5 = false;
		for (int i = 0; i < Main.maxNPCs; i++)
		{
			if (Main.npc[i].active)
			{
				switch (Main.npc[i].type)
				{
				case 398:
					flag = true;
					break;
				case 517:
					flag2 = true;
					break;
				case 422:
					flag3 = true;
					break;
				case 507:
					flag4 = true;
					break;
				case 493:
					flag5 = true;
					break;
				}
			}
		}
		if (!flag2)
		{
			NPC.TowerActiveSolar = false;
		}
		if (!flag3)
		{
			NPC.TowerActiveVortex = false;
		}
		if (!flag4)
		{
			NPC.TowerActiveNebula = false;
		}
		if (!flag5)
		{
			NPC.TowerActiveStardust = false;
		}
		if (!NPC.TowerActiveSolar && !NPC.TowerActiveVortex && !NPC.TowerActiveNebula && !NPC.TowerActiveStardust && !flag)
		{
			StartImpendingDoom(3600);
		}
	}

	public static void StartImpendingDoom(int countdownTime)
	{
		NPC.LunarApocalypseIsUp = false;
		NPC.MaxMoonLordCountdown = countdownTime;
		NPC.MoonLordCountdown = NPC.MaxMoonLordCountdown;
		NetMessage.SendData(103);
		BroadcastText(NetworkText.FromKey(Lang.misc[52].Key), 50, 255, 130);
		if (Main.netMode != 1)
		{
			GetRidOfCultists();
		}
	}

	public static void GetRidOfCultists()
	{
		for (int i = 0; i < Main.maxNPCs; i++)
		{
			if (Main.npc[i].active && (Main.npc[i].type == 437 || Main.npc[i].type == 438 || Main.npc[i].type == 379))
			{
				Main.npc[i].active = false;
				if (Main.netMode != 1)
				{
					NetMessage.SendData(23, -1, -1, null, i);
				}
			}
		}
	}

	public static void MessageLunarApocalypse()
	{
		if (NPC.LunarApocalypseIsUp)
		{
			int num = 0;
			if (!NPC.TowerActiveSolar)
			{
				num++;
			}
			if (!NPC.TowerActiveVortex)
			{
				num++;
			}
			if (!NPC.TowerActiveNebula)
			{
				num++;
			}
			if (!NPC.TowerActiveStardust)
			{
				num++;
			}
			BroadcastText(NetworkText.FromKey(Lang.misc[43 + num].Key), 175, 75, 255);
		}
	}

	public static void BroadcastText(NetworkText text, Vector4 color)
	{
		BroadcastText(text, new Color(color));
	}

	public static void BroadcastText(NetworkText text, Vector3 color)
	{
		BroadcastText(text, new Color(color));
	}

	public static void BroadcastText(NetworkText text, int r, int g, int b)
	{
		BroadcastText(text, new Color(r, g, b));
	}

	public static void BroadcastText(NetworkText text, byte r, byte g, byte b)
	{
		BroadcastText(text, new Color(r, g, b));
	}

	public static void BroadcastText(NetworkText text, Color color)
	{
		if (Main.netMode == 0)
		{
			Main.NewText(text.ToString(), color.R, color.G, color.B);
		}
		else if (Main.netMode == 2)
		{
			ChatHelper.BroadcastChatMessage(text, color);
		}
	}

	public static bool CanCutTile(int x, int y, TileCuttingContext context)
	{
		if (Main.tile[x, y + 1] != null && Main.tile[x, y].wall != 350 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 579)
		{
			if (Main.tile[x, y].type == 254)
			{
				return Main.tile[x, y].frameX >= 144;
			}
			return true;
		}
		return false;
	}

	public static bool InAPlaceWithWind(Vector2 position, int width, int height)
	{
		Point point = position.ToTileCoordinates();
		Point point2 = (position + new Vector2(width, height)).ToTileCoordinates();
		return InAPlaceWithWind(point.X, point.Y, 1 + point2.X - point.X, 1 + point2.Y - point.Y);
	}

	public static bool DoesWindBlowAtThisHeight(int tileY)
	{
		bool flag = (double)tileY < Main.worldSurface;
		if (Main.remixWorld)
		{
			flag = !flag;
		}
		return flag;
	}

	public static bool InAPlaceWithWind(int x, int y, int width, int height)
	{
		if (!DoesWindBlowAtThisHeight(y))
		{
			return false;
		}
		for (int i = 0; i < width; i++)
		{
			for (int j = 0; j < height; j++)
			{
				if (InWorld(x + i, y + j))
				{
					Tile tile = Main.tile[x + i, y + j];
					if (tile == null)
					{
						return false;
					}
					if (tile.liquid > 0 || (tile.wall > 0 && !WallID.Sets.AllowsWind[tile.wall]))
					{
						return false;
					}
				}
			}
		}
		return true;
	}

	public static int[] CountTileTypesInWorld(params int[] oreTypes)
	{
		int[] array = new int[oreTypes.Length];
		for (int i = 0; i < Main.maxTilesX; i++)
		{
			for (int j = 0; j < Main.maxTilesY; j++)
			{
				Tile tile = Main.tile[i, j];
				if (!tile.active())
				{
					continue;
				}
				for (int k = 0; k < oreTypes.Length; k++)
				{
					if (oreTypes[k] == tile.type)
					{
						array[k]++;
						break;
					}
				}
			}
		}
		return array;
	}
}
